"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@blocto+sdk@0.5.5";
exports.ids = ["vendor-chunks/@blocto+sdk@0.5.5"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@blocto+sdk@0.5.5/node_modules/@blocto/sdk/dist/blocto-sdk.module.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@blocto+sdk@0.5.5/node_modules/@blocto/sdk/dist/blocto-sdk.module.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BloctoSDK)\n/* harmony export */ });\n/* Version: 0.5.5 - August 14, 2023 10:23:52 */ /******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n// instead invariant from package, since all error will throw on production\nfunction invariant(condition, format) {\n    if (!condition) {\n        throw new Error(format);\n    }\n}\n// local storage version naming rule: [milestone].[patch]\nvar KEY_SESSION;\n(function(KEY_SESSION) {\n    KEY_SESSION[\"prod\"] = \"BLOCTO_SDK\";\n    KEY_SESSION[\"dev\"] = \"BLOCTO_SDK_DEV\";\n    KEY_SESSION[\"staging\"] = \"BLOCTO_SDK_STAGING\";\n})(KEY_SESSION || (KEY_SESSION = {}));\nvar CHAIN;\n(function(CHAIN) {\n    CHAIN[\"ETHEREUM\"] = \"ethereum\";\n    CHAIN[\"SOLANA\"] = \"solana\";\n    CHAIN[\"APTOS\"] = \"aptos\";\n})(CHAIN || (CHAIN = {}));\nclass MemoryStorage {\n    constructor(){\n        this.storage = {};\n    }\n    getItem(key) {\n        return this[key] || null;\n    }\n    setItem(key, value) {\n        this.storage[key] = value;\n    }\n    removeItem(key) {\n        delete this.storage[key];\n    }\n}\nconst memoryStorage =  false ? 0 : new MemoryStorage();\nconst isSupported = ()=>{\n    if (true) {\n        return false;\n    }\n    try {\n        window.sessionStorage.setItem(\"local_storage_supported\", \"1\");\n        const result = window.sessionStorage.getItem(\"local_storage_supported\");\n        window.sessionStorage.removeItem(\"local_storage_supported\");\n        return result === \"1\";\n    } catch (error) {\n        return false;\n    }\n};\nconst storage = isSupported() ? window.sessionStorage : memoryStorage;\nconst getItem = (key, defaultValue = null)=>{\n    const value = storage.getItem(key);\n    try {\n        return value && JSON.parse(value) || defaultValue;\n    } catch (SyntaxError) {\n        return value || defaultValue;\n    }\n};\nconst setItem = (key, value)=>storage.setItem(key, typeof value === \"string\" ? value : JSON.stringify(value));\nconst removeItem = (key)=>{\n    setItem(key, \"\"); // Due to some versions of browser bug can't removeItem correctly.\n    storage.removeItem(key);\n};\n/**\n * @param {keys.KEY_SESSION} key - key to retrieve the data\n * @returns {ProviderSession | null} ProviderSession | null\n * @description\n * Get ProviderSession from storage.\n * If the data is expired, will remove the data and return null\n */ const getAccountStorage = (key)=>{\n    const rawAccountStorage = getItem(key, null);\n    if (!rawAccountStorage) return null;\n    // compare the expiry time of the item with the current time\n    if (new Date().getTime() > rawAccountStorage.expiry || rawAccountStorage.v !== SDK_VERSION) {\n        removeItem(key);\n        return null;\n    }\n    return rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data;\n};\n/**\n  @param {keys.KEY_SESSION} key - key to store the data\n  @param {ProviderSession} data - Only the part of ProviderSession that needs to be updated\n  {\n    connected?: boolean;\n    code?: string | null;\n    accounts: Record<string, string[] | undefined>;\n  }\n  @param {number} expiry - expiry time of the data\n*/ const setAccountStorage = (key, data, expiry)=>{\n    var _a, _b, _c;\n    const rawAccountStorage = getItem(key);\n    const newAccountStorage = {\n        data: {\n            code: (data === null || data === void 0 ? void 0 : data.code) || ((_a = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _a === void 0 ? void 0 : _a.code),\n            connected: !!((data === null || data === void 0 ? void 0 : data.code) || ((_b = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _b === void 0 ? void 0 : _b.code)),\n            accounts: Object.assign(Object.assign({}, (_c = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _c === void 0 ? void 0 : _c.accounts), data === null || data === void 0 ? void 0 : data.accounts)\n        },\n        expiry: expiry || (rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.expiry) || new Date().getTime() + LOGIN_PERSISTING_TIME,\n        v: SDK_VERSION\n    };\n    setItem(key, newAccountStorage);\n    return;\n};\nconst getChainAddress = (key, chain)=>{\n    var _a, _b;\n    if (!((_a = getAccountStorage(key)) === null || _a === void 0 ? void 0 : _a.code)) {\n        removeItem(key);\n        return null;\n    }\n    return ((_b = getAccountStorage(key)) === null || _b === void 0 ? void 0 : _b.accounts[chain]) || null;\n};\nconst setChainAddress = (key, chain, account)=>{\n    setAccountStorage(key, {\n        accounts: {\n            [chain]: account\n        }\n    });\n    return;\n};\nconst removeChainAddress = (key, chain)=>{\n    setAccountStorage(key, {\n        accounts: {\n            [chain]: undefined\n        }\n    });\n    return;\n};\n/* eth series constants begin */ const ETH_RPC_LIST = {\n    // This is the list of public RPC endpoints that we known to be working\n    // Used to help developers did not set up their own RPC endpoints\n    // BSC mainnet\n    56: \"https://bsc-dataseed1.binance.org\",\n    // BSC testnet\n    97: \"https://data-seed-prebsc-1-s1.binance.org:8545\",\n    // Polygon Mainnet\n    137: \"https://rpc-mainnet.maticvigil.com/\",\n    // Polygon Testnet\n    80001: \"https://rpc-mumbai.matic.today/\",\n    // Avalanche Mainnet\n    43114: \"https://api.avax.network/ext/bc/C/rpc\",\n    // Avalanche Fuji Testnet\n    43113: \"https://api.avax-test.network/ext/bc/C/rpc\",\n    // Arbitrum Mainnet\n    42161: \"https://arb1.arbitrum.io/rpc\",\n    // Arbitrum Testnet\n    421613: \"https://endpoints.omniatech.io/v1/arbitrum/goerli/public\",\n    // Optimism Mainnet\n    10: \"https://mainnet.optimism.io\",\n    // Optimism Goerli Testnet\n    420: \"https://goerli.optimism.io\"\n};\nconst ETH_ENV_WALLET_SERVER_MAPPING = {\n    prod: \"https://wallet-v2.blocto.app\",\n    staging: \"https://wallet-v2-staging.blocto.app\",\n    dev: \"https://wallet-v2-dev.blocto.app\"\n};\nconst ETH_SESSION_KEY_MAPPING = {\n    prod: KEY_SESSION.prod,\n    staging: KEY_SESSION.staging,\n    dev: KEY_SESSION.dev\n};\n/* eth series constants end */ /* sol constants begin */ const SOL_NET = {\n    MainnetBeta: \"mainnet-beta\",\n    Testnet: \"testnet\",\n    Devnet: \"devnet\"\n};\nconst SOL_NET_SERVER_MAPPING = {\n    [SOL_NET.MainnetBeta]: \"https://wallet-v2.blocto.app\",\n    [SOL_NET.Devnet]: \"https://wallet-v2-dev.blocto.app\",\n    [SOL_NET.Testnet]: \"https://wallet-v2-dev.blocto.app\"\n};\nconst SOL_SESSION_KEY_MAPPING = {\n    [SOL_NET.MainnetBeta]: KEY_SESSION.prod,\n    [SOL_NET.Devnet]: KEY_SESSION.dev,\n    [SOL_NET.Testnet]: KEY_SESSION.dev\n};\n/* sol constants end */ /* aptos constants begin */ const APT_SESSION_KEY_MAPPING = {\n    1: KEY_SESSION.prod,\n    2: KEY_SESSION.dev,\n    3: KEY_SESSION.dev,\n    4: KEY_SESSION.dev,\n    5: KEY_SESSION.staging\n};\nconst APT_CHAIN_ID_SERVER_MAPPING = {\n    // MAINNET\n    1: \"https://wallet-v2.blocto.app\",\n    // TESTNET\n    2: \"https://wallet-v2-dev.blocto.app\",\n    // DEVNET\n    3: \"https://wallet-v2-dev.blocto.app\",\n    // TESTING\n    4: \"https://wallet-v2-dev.blocto.app\",\n    // PREMAINNET\n    5: \"https://wallet-v2-staging.blocto.app\"\n};\nvar WalletAdapterNetwork;\n(function(WalletAdapterNetwork) {\n    WalletAdapterNetwork[\"Mainnet\"] = \"mainnet\";\n    WalletAdapterNetwork[\"Testnet\"] = \"testnet\";\n    WalletAdapterNetwork[\"Devnet\"] = \"devnet\";\n    WalletAdapterNetwork[\"Testing\"] = \"testing\";\n    WalletAdapterNetwork[\"Premainnet\"] = \"premainnet\";\n})(WalletAdapterNetwork || (WalletAdapterNetwork = {}));\nconst APT_CHAIN_ID_NAME_MAPPING = {\n    1: WalletAdapterNetwork.Mainnet,\n    2: WalletAdapterNetwork.Testnet,\n    3: WalletAdapterNetwork.Devnet,\n    4: WalletAdapterNetwork.Testing,\n    5: WalletAdapterNetwork.Premainnet\n};\nconst APT_CHAIN_ID_RPC_MAPPING = {\n    1: \"https://fullnode.mainnet.aptoslabs.com/v1\",\n    2: \"https://fullnode.testnet.aptoslabs.com/v1\",\n    3: \"https://fullnode.devnet.aptoslabs.com/v1\",\n    4: \"\",\n    5: \"https://premainnet.aptosdev.com/v1\"\n};\n/* aptos constants end */ const EIP1193_EVENTS = [\n    \"connect\",\n    \"disconnect\",\n    \"message\",\n    \"chainChanged\",\n    \"accountsChanged\"\n];\n// Preserve login for 1 day\nconst LOGIN_PERSISTING_TIME = 86400 * 1000;\nconst DEFAULT_APP_ID = \"00000000-0000-0000-0000-000000000000\";\n// Will inject the version of the SDK by rollup versionInjector during build time\nconst SDK_VERSION = \"0.5.5\";\n// The root class for all providers\nclass BloctoProvider {\n    constructor(){\n        this.isBlocto = true;\n        this.isConnecting = false;\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        this.eventListeners = {};\n        // alias removeListener\n        this.off = this.removeListener;\n        // init event listeners\n        EIP1193_EVENTS.forEach((event)=>{\n            this.eventListeners[event] = [];\n        });\n        this.appId = DEFAULT_APP_ID;\n    }\n    // implement by children\n    // eslint-disable-next-line\n    request(payload) {\n        return __awaiter(this, void 0, void 0, function*() {});\n    }\n    on(event, listener) {\n        if (!EIP1193_EVENTS.includes(event)) return;\n        this.eventListeners[event].push(listener);\n    }\n    // @todo: implement it\n    // eslint-disable-next-line\n    once() {}\n    removeListener(event, listener) {\n        const listeners = this.eventListeners[event];\n        const index = listeners.findIndex((item)=>item === listener);\n        if (index !== -1) {\n            this.eventListeners[event].splice(index, 1);\n        }\n    }\n}\nconst IFRAME_STYLE = \"width:100vw;height:100%;position:fixed;top:0;left:0;z-index:2147483646;border:none;box-sizing:border-box;color-scheme:light;inset:0px;display:block;pointer-events:auto;\";\nfunction createFrame(url) {\n    const frame = document.createElement(\"iframe\");\n    frame.setAttribute(\"src\", url);\n    frame.setAttribute(\"style\", IFRAME_STYLE);\n    return frame;\n}\nfunction attachFrame(frame) {\n    document.body.appendChild(frame);\n}\nfunction detatchFrame(frame) {\n    const parentNode = frame && frame.parentNode;\n    if (parentNode && parentNode.removeChild instanceof Function) {\n        parentNode.removeChild(frame);\n    }\n}\nvar addSelfRemovableHandler = (eventType, handler, target = window)=>{\n    function listener(e) {\n        const removeEventListener = ()=>target.removeEventListener(eventType, listener);\n        handler(e, removeEventListener);\n    }\n    target.addEventListener(eventType, listener);\n};\nfunction responseSessionGuard(response, key, disconnectHandler) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (response.status === 403 || response.status === 401) {\n            if (disconnectHandler) {\n                disconnectHandler();\n            }\n            removeItem(key);\n        }\n        if (!response.ok) {\n            const data = yield response.json();\n            const e = new Error((data === null || data === void 0 ? void 0 : data.message) || \"unknown error\");\n            e.error_code = data === null || data === void 0 ? void 0 : data.error_code;\n            throw e;\n        }\n        return response.json();\n    });\n}\nconst isEmail = (value)=>/\\S+@\\S+\\.\\S+/.test(value);\nconst isValidTransaction = (transaction)=>typeof transaction === \"object\" && transaction !== null && \"from\" in transaction;\nconst isValidTransactions = (transactions)=>Array.isArray(transactions) && transactions.every((tx)=>isValidTransaction(tx));\nfunction getEvmSupport() {\n    return __awaiter(this, void 0, void 0, function*() {\n        const { networks } = yield fetch(\"https://api.blocto.app/networks/evm\").then((response)=>response.json());\n        const evmSupportMap = networks.reduce((a, v)=>Object.assign(Object.assign({}, a), {\n                [v.chain_id]: v\n            }), {});\n        return evmSupportMap;\n    });\n}\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar dist = {};\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nfunction _toPrimitive(input, hint) {\n    if (_typeof(input) !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (_typeof(res) !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _assertThisInitialized(self1) {\n    if (self1 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self1;\n}\nfunction _possibleConstructorReturn(self1, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self1);\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _isNativeReflectConstruct$1() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _construct(Parent, args, Class) {\n    if (_isNativeReflectConstruct$1()) {\n        _construct = Reflect.construct.bind();\n    } else {\n        _construct = function _construct(Parent, args, Class) {\n            var a = [\n                null\n            ];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _setPrototypeOf(instance, Class.prototype);\n            return instance;\n        };\n    }\n    return _construct.apply(null, arguments);\n}\nfunction _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n        if (Class === null || !_isNativeFunction(Class)) return Class;\n        if (typeof Class !== \"function\") {\n            throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        if (typeof _cache !== \"undefined\") {\n            if (_cache.has(Class)) return _cache.get(Class);\n            _cache.set(Class, Wrapper);\n        }\n        function Wrapper() {\n            return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n        }\n        Wrapper.prototype = Object.create(Class.prototype, {\n            constructor: {\n                value: Wrapper,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        return _setPrototypeOf(Wrapper, Class);\n    };\n    return _wrapNativeSuper(Class);\n}\nvar classes = {};\nvar fastSafeStringify = stringify;\nstringify[\"default\"] = stringify;\nstringify.stable = deterministicStringify;\nstringify.stableStringify = deterministicStringify;\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = \"[Circular]\";\nvar arr = [];\nvar replacerStack = [];\nfunction defaultOptions() {\n    return {\n        depthLimit: Number.MAX_SAFE_INTEGER,\n        edgesLimit: Number.MAX_SAFE_INTEGER\n    };\n}\n// Regular stringify\nfunction stringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    decirc(obj, \"\", 0, [], undefined, 0, options);\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(obj, replacer, spacer);\n        } else {\n            res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n        }\n    } catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally{\n        while(arr.length !== 0){\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            } else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n        if (propertyDescriptor.configurable) {\n            Object.defineProperty(parent, k, {\n                value: replace\n            });\n            arr.push([\n                parent,\n                k,\n                val,\n                propertyDescriptor\n            ]);\n        } else {\n            replacerStack.push([\n                val,\n                k,\n                replace\n            ]);\n        }\n    } else {\n        parent[k] = replace;\n        arr.push([\n            parent,\n            k,\n            val\n        ]);\n    }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (_typeof(val) === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                decirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            var keys = Object.keys(val);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                decirc(val[key], key, i, stack, val, depth, options);\n            }\n        }\n        stack.pop();\n    }\n}\n// Stable-stringify\nfunction compareFunction(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(tmp, replacer, spacer);\n        } else {\n            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n        }\n    } catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally{\n        // Ensure that we restore the object as it was.\n        while(arr.length !== 0){\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            } else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (_typeof(val) === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        try {\n            if (typeof val.toJSON === \"function\") {\n                return;\n            }\n        } catch (_) {\n            return;\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                deterministicDecirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            // Create a temporary object in the required way\n            var tmp = {};\n            var keys = Object.keys(val).sort(compareFunction);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                deterministicDecirc(val[key], key, i, stack, val, depth, options);\n                tmp[key] = val[key];\n            }\n            if (typeof parent !== \"undefined\") {\n                arr.push([\n                    parent,\n                    k,\n                    val\n                ]);\n                parent[k] = tmp;\n            } else {\n                return tmp;\n            }\n        }\n        stack.pop();\n    }\n}\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n    replacer = typeof replacer !== \"undefined\" ? replacer : function(k, v) {\n        return v;\n    };\n    return function(key, val) {\n        if (replacerStack.length > 0) {\n            for(var i = 0; i < replacerStack.length; i++){\n                var part = replacerStack[i];\n                if (part[1] === key && part[0] === val) {\n                    val = part[2];\n                    replacerStack.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return replacer.call(this, key, val);\n    };\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nObject.defineProperty(classes, \"__esModule\", {\n    value: true\n});\nclasses.EthereumProviderError = classes.EthereumRpcError = void 0;\nvar fast_safe_stringify_1 = fastSafeStringify;\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors\n * per EIP-1474.\n * Permits any integer error code.\n */ var EthereumRpcError = /*#__PURE__*/ function(_Error) {\n    _inherits(EthereumRpcError, _Error);\n    var _super = _createSuper(EthereumRpcError);\n    function EthereumRpcError(code, message, data) {\n        var _this;\n        _classCallCheck(this, EthereumRpcError);\n        if (!Number.isInteger(code)) {\n            throw new Error('\"code\" must be an integer.');\n        }\n        if (!message || typeof message !== \"string\") {\n            throw new Error('\"message\" must be a nonempty string.');\n        }\n        _this = _super.call(this, message);\n        _this.code = code;\n        if (data !== undefined) {\n            _this.data = data;\n        }\n        return _this;\n    }\n    /**\n   * Returns a plain object with all public class properties.\n   */ _createClass(EthereumRpcError, [\n        {\n            key: \"serialize\",\n            value: function serialize() {\n                var serialized = {\n                    code: this.code,\n                    message: this.message\n                };\n                if (this.data !== undefined) {\n                    serialized.data = this.data;\n                }\n                if (this.stack) {\n                    serialized.stack = this.stack;\n                }\n                return serialized;\n            }\n        },\n        {\n            key: \"toString\",\n            value: function toString() {\n                return fast_safe_stringify_1[\"default\"](this.serialize(), stringifyReplacer, 2);\n            }\n        }\n    ]);\n    return EthereumRpcError;\n}(/*#__PURE__*/ _wrapNativeSuper(Error));\nclasses.EthereumRpcError = EthereumRpcError;\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n * Permits integer error codes in the [ 1000 <= 4999 ] range.\n */ var EthereumProviderError = /*#__PURE__*/ function(_EthereumRpcError) {\n    _inherits(EthereumProviderError, _EthereumRpcError);\n    var _super2 = _createSuper(EthereumProviderError);\n    /**\n   * Create an Ethereum Provider JSON-RPC error.\n   * `code` must be an integer in the 1000 <= 4999 range.\n   */ function EthereumProviderError(code, message, data) {\n        _classCallCheck(this, EthereumProviderError);\n        if (!isValidEthProviderCode(code)) {\n            throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n        }\n        return _super2.call(this, code, message, data);\n    }\n    return _createClass(EthereumProviderError);\n}(EthereumRpcError);\nclasses.EthereumProviderError = EthereumProviderError;\n// Internal\nfunction isValidEthProviderCode(code) {\n    return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\nfunction stringifyReplacer(_, value) {\n    if (value === \"[Circular]\") {\n        return undefined;\n    }\n    return value;\n}\nvar utils = {};\nvar errorConstants = {};\nObject.defineProperty(errorConstants, \"__esModule\", {\n    value: true\n});\nerrorConstants.errorValues = errorConstants.errorCodes = void 0;\nerrorConstants.errorCodes = {\n    rpc: {\n        invalidInput: -32000,\n        resourceNotFound: -32001,\n        resourceUnavailable: -32002,\n        transactionRejected: -32003,\n        methodNotSupported: -32004,\n        limitExceeded: -32005,\n        parse: -32700,\n        invalidRequest: -32600,\n        methodNotFound: -32601,\n        invalidParams: -32602,\n        internal: -32603\n    },\n    provider: {\n        userRejectedRequest: 4001,\n        unauthorized: 4100,\n        unsupportedMethod: 4200,\n        disconnected: 4900,\n        chainDisconnected: 4901\n    }\n};\nerrorConstants.errorValues = {\n    \"-32700\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\"\n    },\n    \"-32600\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The JSON sent is not a valid Request object.\"\n    },\n    \"-32601\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The method does not exist / is not available.\"\n    },\n    \"-32602\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid method parameter(s).\"\n    },\n    \"-32603\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Internal JSON-RPC error.\"\n    },\n    \"-32000\": {\n        standard: \"EIP-1474\",\n        message: \"Invalid input.\"\n    },\n    \"-32001\": {\n        standard: \"EIP-1474\",\n        message: \"Resource not found.\"\n    },\n    \"-32002\": {\n        standard: \"EIP-1474\",\n        message: \"Resource unavailable.\"\n    },\n    \"-32003\": {\n        standard: \"EIP-1474\",\n        message: \"Transaction rejected.\"\n    },\n    \"-32004\": {\n        standard: \"EIP-1474\",\n        message: \"Method not supported.\"\n    },\n    \"-32005\": {\n        standard: \"EIP-1474\",\n        message: \"Request limit exceeded.\"\n    },\n    \"4001\": {\n        standard: \"EIP-1193\",\n        message: \"User rejected the request.\"\n    },\n    \"4100\": {\n        standard: \"EIP-1193\",\n        message: \"The requested account and/or method has not been authorized by the user.\"\n    },\n    \"4200\": {\n        standard: \"EIP-1193\",\n        message: \"The requested method is not supported by this Ethereum provider.\"\n    },\n    \"4900\": {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from all chains.\"\n    },\n    \"4901\": {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from the specified chain.\"\n    }\n};\n(function(exports) {\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;\n    var error_constants_1 = errorConstants;\n    var classes_1 = classes;\n    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;\n    var FALLBACK_MESSAGE = \"Unspecified error message. This is a bug, please report it.\";\n    var FALLBACK_ERROR = {\n        code: FALLBACK_ERROR_CODE,\n        message: getMessageFromCode(FALLBACK_ERROR_CODE)\n    };\n    exports.JSON_RPC_SERVER_ERROR_MESSAGE = \"Unspecified server error.\";\n    /**\n   * Gets the message for a given code, or a fallback message if the code has\n   * no corresponding message.\n   */ function getMessageFromCode(code) {\n        var fallbackMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FALLBACK_MESSAGE;\n        if (Number.isInteger(code)) {\n            var codeString = code.toString();\n            if (hasKey(error_constants_1.errorValues, codeString)) {\n                return error_constants_1.errorValues[codeString].message;\n            }\n            if (isJsonRpcServerError(code)) {\n                return exports.JSON_RPC_SERVER_ERROR_MESSAGE;\n            }\n        }\n        return fallbackMessage;\n    }\n    exports.getMessageFromCode = getMessageFromCode;\n    /**\n   * Returns whether the given code is valid.\n   * A code is only valid if it has a message.\n   */ function isValidCode(code) {\n        if (!Number.isInteger(code)) {\n            return false;\n        }\n        var codeString = code.toString();\n        if (error_constants_1.errorValues[codeString]) {\n            return true;\n        }\n        if (isJsonRpcServerError(code)) {\n            return true;\n        }\n        return false;\n    }\n    exports.isValidCode = isValidCode;\n    /**\n   * Serializes the given error to an Ethereum JSON RPC-compatible error object.\n   * Merely copies the given error's values if it is already compatible.\n   * If the given error is not fully compatible, it will be preserved on the\n   * returned object's data.originalError property.\n   */ function serializeError(error) {\n        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$fallbackError = _ref.fallbackError, fallbackError = _ref$fallbackError === void 0 ? FALLBACK_ERROR : _ref$fallbackError, _ref$shouldIncludeSta = _ref.shouldIncludeStack, shouldIncludeStack = _ref$shouldIncludeSta === void 0 ? false : _ref$shouldIncludeSta;\n        var _a, _b;\n        if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== \"string\") {\n            throw new Error(\"Must provide fallback error with integer number code and string message.\");\n        }\n        if (error instanceof classes_1.EthereumRpcError) {\n            return error.serialize();\n        }\n        var serialized = {};\n        if (error && _typeof(error) === \"object\" && !Array.isArray(error) && hasKey(error, \"code\") && isValidCode(error.code)) {\n            var _error = error;\n            serialized.code = _error.code;\n            if (_error.message && typeof _error.message === \"string\") {\n                serialized.message = _error.message;\n                if (hasKey(_error, \"data\")) {\n                    serialized.data = _error.data;\n                }\n            } else {\n                serialized.message = getMessageFromCode(serialized.code);\n                serialized.data = {\n                    originalError: assignOriginalError(error)\n                };\n            }\n        } else {\n            serialized.code = fallbackError.code;\n            var message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;\n            serialized.message = message && typeof message === \"string\" ? message : fallbackError.message;\n            serialized.data = {\n                originalError: assignOriginalError(error)\n            };\n        }\n        var stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;\n        if (shouldIncludeStack && error && stack && typeof stack === \"string\") {\n            serialized.stack = stack;\n        }\n        return serialized;\n    }\n    exports.serializeError = serializeError;\n    // Internal\n    function isJsonRpcServerError(code) {\n        return code >= -32099 && code <= -32000;\n    }\n    function assignOriginalError(error) {\n        if (error && _typeof(error) === \"object\" && !Array.isArray(error)) {\n            return Object.assign({}, error);\n        }\n        return error;\n    }\n    function hasKey(obj, key) {\n        return Object.prototype.hasOwnProperty.call(obj, key);\n    }\n})(utils);\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (null != _i) {\n        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;\n        try {\n            if (_x = (_i = _i.call(arr)).next, 0 === i) {\n                if (Object(_i) !== _i) return;\n                _n = !1;\n            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n        } catch (err) {\n            _d = !0, _e = err;\n        } finally{\n            try {\n                if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n            } finally{\n                if (_d) throw _e;\n            }\n        }\n        return _arr;\n    }\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nvar errors = {};\nObject.defineProperty(errors, \"__esModule\", {\n    value: true\n});\nerrors.ethErrors = void 0;\nvar classes_1 = classes;\nvar utils_1 = utils;\nvar error_constants_1 = errorConstants;\nerrors.ethErrors = {\n    rpc: {\n        /**\n     * Get a JSON RPC 2.0 Parse (-32700) error.\n     */ parse: function parse(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Invalid Request (-32600) error.\n     */ invalidRequest: function invalidRequest(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Invalid Params (-32602) error.\n     */ invalidParams: function invalidParams(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Method Not Found (-32601) error.\n     */ methodNotFound: function methodNotFound(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Internal (-32603) error.\n     */ internal: function internal(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Server error.\n     * Permits integer error codes in the [ -32099 <= -32005 ] range.\n     * Codes -32000 through -32004 are reserved by EIP-1474.\n     */ server: function server(opts) {\n            if (!opts || _typeof(opts) !== \"object\" || Array.isArray(opts)) {\n                throw new Error(\"Ethereum RPC Server errors must provide single object argument.\");\n            }\n            var code = opts.code;\n            if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n                throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\n            }\n            return getEthJsonRpcError(code, opts);\n        },\n        /**\n     * Get an Ethereum JSON RPC Invalid Input (-32000) error.\n     */ invalidInput: function invalidInput(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\n     */ resourceNotFound: function resourceNotFound(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\n     */ resourceUnavailable: function resourceUnavailable(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\n     */ transactionRejected: function transactionRejected(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\n     */ methodNotSupported: function methodNotSupported(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.\n     */ limitExceeded: function limitExceeded(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg);\n        }\n    },\n    provider: {\n        /**\n     * Get an Ethereum Provider User Rejected Request (4001) error.\n     */ userRejectedRequest: function userRejectedRequest(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);\n        },\n        /**\n     * Get an Ethereum Provider Unauthorized (4100) error.\n     */ unauthorized: function unauthorized(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);\n        },\n        /**\n     * Get an Ethereum Provider Unsupported Method (4200) error.\n     */ unsupportedMethod: function unsupportedMethod(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);\n        },\n        /**\n     * Get an Ethereum Provider Not Connected (4900) error.\n     */ disconnected: function disconnected(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);\n        },\n        /**\n     * Get an Ethereum Provider Chain Not Connected (4901) error.\n     */ chainDisconnected: function chainDisconnected(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);\n        },\n        /**\n     * Get a custom Ethereum Provider error.\n     */ custom: function custom(opts) {\n            if (!opts || _typeof(opts) !== \"object\" || Array.isArray(opts)) {\n                throw new Error(\"Ethereum Provider custom errors must provide single object argument.\");\n            }\n            var code = opts.code, message = opts.message, data = opts.data;\n            if (!message || typeof message !== \"string\") {\n                throw new Error('\"message\" must be a nonempty string');\n            }\n            return new classes_1.EthereumProviderError(code, message, data);\n        }\n    }\n};\n// Internal\nfunction getEthJsonRpcError(code, arg) {\n    var _parseOpts = parseOpts(arg), _parseOpts2 = _slicedToArray(_parseOpts, 2), message = _parseOpts2[0], data = _parseOpts2[1];\n    return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);\n}\nfunction getEthProviderError(code, arg) {\n    var _parseOpts3 = parseOpts(arg), _parseOpts4 = _slicedToArray(_parseOpts3, 2), message = _parseOpts4[0], data = _parseOpts4[1];\n    return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);\n}\nfunction parseOpts(arg) {\n    if (arg) {\n        if (typeof arg === \"string\") {\n            return [\n                arg\n            ];\n        } else if (_typeof(arg) === \"object\" && !Array.isArray(arg)) {\n            var message = arg.message, data = arg.data;\n            if (message && typeof message !== \"string\") {\n                throw new Error(\"Must specify string message.\");\n            }\n            return [\n                message || undefined,\n                data\n            ];\n        }\n    }\n    return [];\n}\n(function(exports) {\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;\n    var classes_1 = classes;\n    Object.defineProperty(exports, \"EthereumRpcError\", {\n        enumerable: true,\n        get: function get() {\n            return classes_1.EthereumRpcError;\n        }\n    });\n    Object.defineProperty(exports, \"EthereumProviderError\", {\n        enumerable: true,\n        get: function get() {\n            return classes_1.EthereumProviderError;\n        }\n    });\n    var utils_1 = utils;\n    Object.defineProperty(exports, \"serializeError\", {\n        enumerable: true,\n        get: function get() {\n            return utils_1.serializeError;\n        }\n    });\n    Object.defineProperty(exports, \"getMessageFromCode\", {\n        enumerable: true,\n        get: function get() {\n            return utils_1.getMessageFromCode;\n        }\n    });\n    var errors_1 = errors;\n    Object.defineProperty(exports, \"ethErrors\", {\n        enumerable: true,\n        get: function get() {\n            return errors_1.ethErrors;\n        }\n    });\n    var error_constants_1 = errorConstants;\n    Object.defineProperty(exports, \"errorCodes\", {\n        enumerable: true,\n        get: function get() {\n            return error_constants_1.errorCodes;\n        }\n    });\n})(dist);\nvar global$1 = typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self :  false ? 0 : {};\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\nvar inited = false;\nfunction init() {\n    inited = true;\n    var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for(var i = 0, len = code.length; i < len; ++i){\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n    }\n    revLookup[\"-\".charCodeAt(0)] = 62;\n    revLookup[\"_\".charCodeAt(0)] = 63;\n}\nfunction toByteArray(b64) {\n    if (!inited) {\n        init();\n    }\n    var i, j, l, tmp, placeHolders, arr;\n    var len = b64.length;\n    if (len % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    }\n    // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n    placeHolders = b64[len - 2] === \"=\" ? 2 : b64[len - 1] === \"=\" ? 1 : 0;\n    // base64 is 4/3 + up to two characters of the original data\n    arr = new Arr(len * 3 / 4 - placeHolders);\n    // if there are placeholders, only get up to the last complete 4 chars\n    l = placeHolders > 0 ? len - 4 : len;\n    var L = 0;\n    for(i = 0, j = 0; i < l; i += 4, j += 3){\n        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n        arr[L++] = tmp >> 16 & 0xFF;\n        arr[L++] = tmp >> 8 & 0xFF;\n        arr[L++] = tmp & 0xFF;\n    }\n    if (placeHolders === 2) {\n        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[L++] = tmp & 0xFF;\n    } else if (placeHolders === 1) {\n        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[L++] = tmp >> 8 & 0xFF;\n        arr[L++] = tmp & 0xFF;\n    }\n    return arr;\n}\nfunction tripletToBase64(num) {\n    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\nfunction encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for(var i = start; i < end; i += 3){\n        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n        output.push(tripletToBase64(tmp));\n    }\n    return output.join(\"\");\n}\nfunction fromByteArray(uint8) {\n    if (!inited) {\n        init();\n    }\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n    var output = \"\";\n    var parts = [];\n    var maxChunkLength = 16383; // must be multiple of 3\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength){\n        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    }\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        output += lookup[tmp >> 2];\n        output += lookup[tmp << 4 & 0x3F];\n        output += \"==\";\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        output += lookup[tmp >> 10];\n        output += lookup[tmp >> 4 & 0x3F];\n        output += lookup[tmp << 2 & 0x3F];\n        output += \"=\";\n    }\n    parts.push(output);\n    return parts.join(\"\");\n}\nfunction read(buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? nBytes - 1 : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & (1 << -nBits) - 1;\n    s >>= -nBits;\n    nBits += eLen;\n    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8){}\n    m = e & (1 << -nBits) - 1;\n    e >>= -nBits;\n    nBits += mLen;\n    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8){}\n    if (e === 0) {\n        e = 1 - eBias;\n    } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity;\n    } else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n}\nfunction write(buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    var i = isLE ? 0 : nBytes - 1;\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n    value = Math.abs(value);\n    if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n    } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n        }\n        if (e + eBias >= 1) {\n            value += rt / c;\n        } else {\n            value += rt * Math.pow(2, 1 - eBias);\n        }\n        if (value * c >= 2) {\n            e++;\n            c /= 2;\n        }\n        if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n        } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n        } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n        }\n    }\n    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8){}\n    e = e << mLen | m;\n    eLen += mLen;\n    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8){}\n    buffer[offset + i - d] |= s * 128;\n}\nvar toString = {}.toString;\nvar isArray = Array.isArray || function(arr) {\n    return toString.call(arr) == \"[object Array]\";\n};\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */ var INSPECT_MAX_BYTES = 50;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */ Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;\n/*\n * Export kMaxLength after typed array support is determined.\n */ kMaxLength();\nfunction kMaxLength() {\n    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n}\nfunction createBuffer(that, length) {\n    if (kMaxLength() < length) {\n        throw new RangeError(\"Invalid typed array length\");\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = new Uint8Array(length);\n        that.__proto__ = Buffer.prototype;\n    } else {\n        // Fallback: Return an object instance of the Buffer class\n        if (that === null) {\n            that = new Buffer(length);\n        }\n        that.length = length;\n    }\n    return that;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */ function Buffer(arg, encodingOrOffset, length) {\n    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n        return new Buffer(arg, encodingOrOffset, length);\n    }\n    // Common case.\n    if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") {\n            throw new Error(\"If encoding is specified then the first argument must be a string\");\n        }\n        return allocUnsafe(this, arg);\n    }\n    return from(this, arg, encodingOrOffset, length);\n}\nBuffer.poolSize = 8192; // not used by this implementation\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function(arr) {\n    arr.__proto__ = Buffer.prototype;\n    return arr;\n};\nfunction from(that, value, encodingOrOffset, length) {\n    if (typeof value === \"number\") {\n        throw new TypeError('\"value\" argument must not be a number');\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, encodingOrOffset, length);\n    }\n    if (typeof value === \"string\") {\n        return fromString(that, value, encodingOrOffset);\n    }\n    return fromObject(that, value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/ Buffer.from = function(value, encodingOrOffset, length) {\n    return from(null, value, encodingOrOffset, length);\n};\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n    Buffer.prototype.__proto__ = Uint8Array.prototype;\n    Buffer.__proto__ = Uint8Array;\n    if (typeof Symbol !== \"undefined\" && Symbol.species && Buffer[Symbol.species] === Buffer) ;\n}\nfunction assertSize(size) {\n    if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be a number');\n    } else if (size < 0) {\n        throw new RangeError('\"size\" argument must not be negative');\n    }\n}\nfunction alloc(that, size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n        return createBuffer(that, size);\n    }\n    if (fill !== undefined) {\n        // Only pay attention to encoding if it's a string. This\n        // prevents accidentally sending in a number that would\n        // be interpretted as a start offset.\n        return typeof encoding === \"string\" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n    }\n    return createBuffer(that, size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/ Buffer.alloc = function(size, fill, encoding) {\n    return alloc(null, size, fill, encoding);\n};\nfunction allocUnsafe(that, size) {\n    assertSize(size);\n    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for(var i = 0; i < size; ++i){\n            that[i] = 0;\n        }\n    }\n    return that;\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */ Buffer.allocUnsafe = function(size) {\n    return allocUnsafe(null, size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */ Buffer.allocUnsafeSlow = function(size) {\n    return allocUnsafe(null, size);\n};\nfunction fromString(that, string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n    }\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError('\"encoding\" must be a valid string encoding');\n    }\n    var length = byteLength(string, encoding) | 0;\n    that = createBuffer(that, length);\n    var actual = that.write(string, encoding);\n    if (actual !== length) {\n        // Writing a hex string, for example, that contains invalid characters will\n        // cause everything after the first invalid character to be ignored. (e.g.\n        // 'abxxcd' will be treated as 'ab')\n        that = that.slice(0, actual);\n    }\n    return that;\n}\nfunction fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    that = createBuffer(that, length);\n    for(var i = 0; i < length; i += 1){\n        that[i] = array[i] & 255;\n    }\n    return that;\n}\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n    array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError(\"'offset' is out of bounds\");\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError(\"'length' is out of bounds\");\n    }\n    if (byteOffset === undefined && length === undefined) {\n        array = new Uint8Array(array);\n    } else if (length === undefined) {\n        array = new Uint8Array(array, byteOffset);\n    } else {\n        array = new Uint8Array(array, byteOffset, length);\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = array;\n        that.__proto__ = Buffer.prototype;\n    } else {\n        // Fallback: Return an object instance of the Buffer class\n        that = fromArrayLike(that, array);\n    }\n    return that;\n}\nfunction fromObject(that, obj) {\n    if (internalIsBuffer(obj)) {\n        var len = checked(obj.length) | 0;\n        that = createBuffer(that, len);\n        if (that.length === 0) {\n            return that;\n        }\n        obj.copy(that, 0, 0, len);\n        return that;\n    }\n    if (obj) {\n        if (typeof ArrayBuffer !== \"undefined\" && obj.buffer instanceof ArrayBuffer || \"length\" in obj) {\n            if (typeof obj.length !== \"number\" || isnan(obj.length)) {\n                return createBuffer(that, 0);\n            }\n            return fromArrayLike(that, obj);\n        }\n        if (obj.type === \"Buffer\" && isArray(obj.data)) {\n            return fromArrayLike(that, obj.data);\n        }\n    }\n    throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\");\n}\nfunction checked(length) {\n    // Note: cannot use `length < kMaxLength()` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= kMaxLength()) {\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum \" + \"size: 0x\" + kMaxLength().toString(16) + \" bytes\");\n    }\n    return length | 0;\n}\nBuffer.isBuffer = isBuffer;\nfunction internalIsBuffer(b) {\n    return !!(b != null && b._isBuffer);\n}\nBuffer.compare = function compare(a, b) {\n    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n        throw new TypeError(\"Arguments must be Buffers\");\n    }\n    if (a === b) return 0;\n    var x = a.length;\n    var y = b.length;\n    for(var i = 0, len = Math.min(x, y); i < len; ++i){\n        if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n        }\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\nBuffer.isEncoding = function isEncoding(encoding) {\n    switch(String(encoding).toLowerCase()){\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return true;\n        default:\n            return false;\n    }\n};\nBuffer.concat = function concat(list, length) {\n    if (!isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    if (list.length === 0) {\n        return Buffer.alloc(0);\n    }\n    var i;\n    if (length === undefined) {\n        length = 0;\n        for(i = 0; i < list.length; ++i){\n            length += list[i].length;\n        }\n    }\n    var buffer = Buffer.allocUnsafe(length);\n    var pos = 0;\n    for(i = 0; i < list.length; ++i){\n        var buf = list[i];\n        if (!internalIsBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\nfunction byteLength(string, encoding) {\n    if (internalIsBuffer(string)) {\n        return string.length;\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && typeof ArrayBuffer.isView === \"function\" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n        return string.byteLength;\n    }\n    if (typeof string !== \"string\") {\n        string = \"\" + string;\n    }\n    var len = string.length;\n    if (len === 0) return 0;\n    // Use a for loop to avoid recursion\n    var loweredCase = false;\n    for(;;){\n        switch(encoding){\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n                return len;\n            case \"utf8\":\n            case \"utf-8\":\n            case undefined:\n                return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return len * 2;\n            case \"hex\":\n                return len >>> 1;\n            case \"base64\":\n                return base64ToBytes(string).length;\n            default:\n                if (loweredCase) return utf8ToBytes(string).length // assume utf8\n                ;\n                encoding = (\"\" + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\nBuffer.byteLength = byteLength;\nfunction slowToString(encoding, start, end) {\n    var loweredCase = false;\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) {\n        start = 0;\n    }\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) {\n        return \"\";\n    }\n    if (end === undefined || end > this.length) {\n        end = this.length;\n    }\n    if (end <= 0) {\n        return \"\";\n    }\n    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) {\n        return \"\";\n    }\n    if (!encoding) encoding = \"utf8\";\n    while(true){\n        switch(encoding){\n            case \"hex\":\n                return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n                return utf8Slice(this, start, end);\n            case \"ascii\":\n                return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n                return latin1Slice(this, start, end);\n            case \"base64\":\n                return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return utf16leSlice(this, start, end);\n            default:\n                if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n                encoding = (encoding + \"\").toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\nfunction swap(b, n, m) {\n    var i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n}\nBuffer.prototype.swap16 = function swap16() {\n    var len = this.length;\n    if (len % 2 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    }\n    for(var i = 0; i < len; i += 2){\n        swap(this, i, i + 1);\n    }\n    return this;\n};\nBuffer.prototype.swap32 = function swap32() {\n    var len = this.length;\n    if (len % 4 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    }\n    for(var i = 0; i < len; i += 4){\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n    }\n    return this;\n};\nBuffer.prototype.swap64 = function swap64() {\n    var len = this.length;\n    if (len % 8 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    }\n    for(var i = 0; i < len; i += 8){\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n    }\n    return this;\n};\nBuffer.prototype.toString = function toString() {\n    var length = this.length | 0;\n    if (length === 0) return \"\";\n    if (arguments.length === 0) return utf8Slice(this, 0, length);\n    return slowToString.apply(this, arguments);\n};\nBuffer.prototype.equals = function equals(b) {\n    if (!internalIsBuffer(b)) throw new TypeError(\"Argument must be a Buffer\");\n    if (this === b) return true;\n    return Buffer.compare(this, b) === 0;\n};\nBuffer.prototype.inspect = function inspect() {\n    var str = \"\";\n    var max = INSPECT_MAX_BYTES;\n    if (this.length > 0) {\n        str = this.toString(\"hex\", 0, max).match(/.{2}/g).join(\" \");\n        if (this.length > max) str += \" ... \";\n    }\n    return \"<Buffer \" + str + \">\";\n};\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if (!internalIsBuffer(target)) {\n        throw new TypeError(\"Argument must be a Buffer\");\n    }\n    if (start === undefined) {\n        start = 0;\n    }\n    if (end === undefined) {\n        end = target ? target.length : 0;\n    }\n    if (thisStart === undefined) {\n        thisStart = 0;\n    }\n    if (thisEnd === undefined) {\n        thisEnd = this.length;\n    }\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError(\"out of range index\");\n    }\n    if (thisStart >= thisEnd && start >= end) {\n        return 0;\n    }\n    if (thisStart >= thisEnd) {\n        return -1;\n    }\n    if (start >= end) {\n        return 1;\n    }\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target) return 0;\n    var x = thisEnd - thisStart;\n    var y = end - start;\n    var len = Math.min(x, y);\n    var thisCopy = this.slice(thisStart, thisEnd);\n    var targetCopy = target.slice(start, end);\n    for(var i = 0; i < len; ++i){\n        if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n        }\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1;\n    // Normalize byteOffset\n    if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 0x7fffffff) {\n        byteOffset = 0x7fffffff;\n    } else if (byteOffset < -0x80000000) {\n        byteOffset = -0x80000000;\n    }\n    byteOffset = +byteOffset; // Coerce to Number.\n    if (isNaN(byteOffset)) {\n        // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n        byteOffset = dir ? 0 : buffer.length - 1;\n    }\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1;\n        else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;\n        else return -1;\n    }\n    // Normalize val\n    if (typeof val === \"string\") {\n        val = Buffer.from(val, encoding);\n    }\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if (internalIsBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) {\n            return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n        val = val & 0xFF; // Search for a byte value [0-255]\n        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n        }\n        return arrayIndexOf(buffer, [\n            val\n        ], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n}\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n                return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) {\n            return buf[i];\n        } else {\n            return buf.readUInt16BE(i * indexSize);\n        }\n    }\n    var i;\n    if (dir) {\n        var foundIndex = -1;\n        for(i = byteOffset; i < arrLength; i++){\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1) foundIndex = i;\n                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n            } else {\n                if (foundIndex !== -1) i -= i - foundIndex;\n                foundIndex = -1;\n            }\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for(i = byteOffset; i >= 0; i--){\n            var found = true;\n            for(var j = 0; j < valLength; j++){\n                if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n};\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\nfunction hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n    if (!length) {\n        length = remaining;\n    } else {\n        length = Number(length);\n        if (length > remaining) {\n            length = remaining;\n        }\n    }\n    // must be an even number of digits\n    var strLen = string.length;\n    if (strLen % 2 !== 0) throw new TypeError(\"Invalid hex string\");\n    if (length > strLen / 2) {\n        length = strLen / 2;\n    }\n    for(var i = 0; i < length; ++i){\n        var parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (isNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}\nfunction utf8Write(buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction asciiWrite(buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\nfunction latin1Write(buf, string, offset, length) {\n    return asciiWrite(buf, string, offset, length);\n}\nfunction base64Write(buf, string, offset, length) {\n    return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\nfunction ucs2Write(buf, string, offset, length) {\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n        offset = offset | 0;\n        if (isFinite(length)) {\n            length = length | 0;\n            if (encoding === undefined) encoding = \"utf8\";\n        } else {\n            encoding = length;\n            length = undefined;\n        }\n    // legacy write(string, encoding, offset, length) - remove in v0.13\n    } else {\n        throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    }\n    var remaining = this.length - offset;\n    if (length === undefined || length > remaining) length = remaining;\n    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n    }\n    if (!encoding) encoding = \"utf8\";\n    var loweredCase = false;\n    for(;;){\n        switch(encoding){\n            case \"hex\":\n                return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n                return utf8Write(this, string, offset, length);\n            case \"ascii\":\n                return asciiWrite(this, string, offset, length);\n            case \"latin1\":\n            case \"binary\":\n                return latin1Write(this, string, offset, length);\n            case \"base64\":\n                // Warning: maxLength not taken into account in base64Write\n                return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return ucs2Write(this, string, offset, length);\n            default:\n                if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n                encoding = (\"\" + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n};\nBuffer.prototype.toJSON = function toJSON() {\n    return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n};\nfunction base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) {\n        return fromByteArray(buf);\n    } else {\n        return fromByteArray(buf.slice(start, end));\n    }\n}\nfunction utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    var res = [];\n    var i = start;\n    while(i < end){\n        var firstByte = buf[i];\n        var codePoint = null;\n        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch(bytesPerSequence){\n                case 1:\n                    if (firstByte < 0x80) {\n                        codePoint = firstByte;\n                    }\n                    break;\n                case 2:\n                    secondByte = buf[i + 1];\n                    if ((secondByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                        if (tempCodePoint > 0x7F) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n            }\n        }\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n        } else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n}\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\nfunction decodeCodePointsArray(codePoints) {\n    var len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n        ;\n    }\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    var res = \"\";\n    var i = 0;\n    while(i < len){\n        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n    return res;\n}\nfunction asciiSlice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for(var i = start; i < end; ++i){\n        ret += String.fromCharCode(buf[i] & 0x7F);\n    }\n    return ret;\n}\nfunction latin1Slice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for(var i = start; i < end; ++i){\n        ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n}\nfunction hexSlice(buf, start, end) {\n    var len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    var out = \"\";\n    for(var i = start; i < end; ++i){\n        out += toHex(buf[i]);\n    }\n    return out;\n}\nfunction utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end);\n    var res = \"\";\n    for(var i = 0; i < bytes.length; i += 2){\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n}\nBuffer.prototype.slice = function slice(start, end) {\n    var len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n    } else if (start > len) {\n        start = len;\n    }\n    if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n    } else if (end > len) {\n        end = len;\n    }\n    if (end < start) end = start;\n    var newBuf;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        newBuf = this.subarray(start, end);\n        newBuf.__proto__ = Buffer.prototype;\n    } else {\n        var sliceLen = end - start;\n        newBuf = new Buffer(sliceLen, undefined);\n        for(var i = 0; i < sliceLen; ++i){\n            newBuf[i] = this[i + start];\n        }\n    }\n    return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */ function checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0) throw new RangeError(\"offset is not uint\");\n    if (offset + ext > length) throw new RangeError(\"Trying to access beyond buffer length\");\n}\nBuffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while(++i < byteLength && (mul *= 0x100)){\n        val += this[offset + i] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        checkOffset(offset, byteLength, this.length);\n    }\n    var val = this[offset + --byteLength];\n    var mul = 1;\n    while(byteLength > 0 && (mul *= 0x100)){\n        val += this[offset + --byteLength] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    return this[offset];\n};\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n};\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n};\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while(++i < byteLength && (mul *= 0x100)){\n        val += this[offset + i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var i = byteLength;\n    var mul = 1;\n    var val = this[offset + --i];\n    while(i > 0 && (mul *= 0x100)){\n        val += this[offset + --i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 0x80)) return this[offset];\n    return (0xff - this[offset] + 1) * -1;\n};\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    var val = this[offset] | this[offset + 1] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    var val = this[offset + 1] | this[offset] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return read(this, offset, true, 23, 4);\n};\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return read(this, offset, false, 23, 4);\n};\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return read(this, offset, true, 52, 8);\n};\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return read(this, offset, false, 52, 8);\n};\nfunction checkInt(buf, value, offset, ext, max, min) {\n    if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n}\nBuffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    var mul = 1;\n    var i = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        this[offset + i] = value / mul & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    var i = byteLength - 1;\n    var mul = 1;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        this[offset + i] = value / mul & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffff + value + 1;\n    for(var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i){\n        buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n    }\n}\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n    } else {\n        objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n    } else {\n        objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2;\n};\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffffffff + value + 1;\n    for(var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i){\n        buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n    }\n}\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    var i = 0;\n    var mul = 1;\n    var sub = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    var i = byteLength - 1;\n    var mul = 1;\n    var sub = 0;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n    if (value < 0) value = 0xff + value + 1;\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n    } else {\n        objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n    } else {\n        objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n    } else {\n        objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (value < 0) value = 0xffffffff + value + 1;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4;\n};\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n    if (offset < 0) throw new RangeError(\"Index out of range\");\n}\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4);\n    }\n    write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n}\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, false, noAssert);\n};\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8);\n    }\n    write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n}\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, false, noAssert);\n};\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!start) start = 0;\n    if (!end && end !== 0) end = this.length;\n    if (targetStart >= target.length) targetStart = target.length;\n    if (!targetStart) targetStart = 0;\n    if (end > 0 && end < start) end = start;\n    // Copy 0 bytes; we're done\n    if (end === start) return 0;\n    if (target.length === 0 || this.length === 0) return 0;\n    // Fatal error conditions\n    if (targetStart < 0) {\n        throw new RangeError(\"targetStart out of bounds\");\n    }\n    if (start < 0 || start >= this.length) throw new RangeError(\"sourceStart out of bounds\");\n    if (end < 0) throw new RangeError(\"sourceEnd out of bounds\");\n    // Are we oob?\n    if (end > this.length) end = this.length;\n    if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n    }\n    var len = end - start;\n    var i;\n    if (this === target && start < targetStart && targetStart < end) {\n        // descending copy from end\n        for(i = len - 1; i >= 0; --i){\n            target[i + targetStart] = this[i + start];\n        }\n    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n        // ascending copy from start\n        for(i = 0; i < len; ++i){\n            target[i + targetStart] = this[i + start];\n        }\n    } else {\n        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n    }\n    return len;\n};\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n        } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n        }\n        if (val.length === 1) {\n            var code = val.charCodeAt(0);\n            if (code < 256) {\n                val = code;\n            }\n        }\n        if (encoding !== undefined && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n        }\n        if (typeof encoding === \"string\" && !Buffer.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n    } else if (typeof val === \"number\") {\n        val = val & 255;\n    }\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError(\"Out of range index\");\n    }\n    if (end <= start) {\n        return this;\n    }\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val) val = 0;\n    var i;\n    if (typeof val === \"number\") {\n        for(i = start; i < end; ++i){\n            this[i] = val;\n        }\n    } else {\n        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n        var len = bytes.length;\n        for(i = 0; i < end - start; ++i){\n            this[i + start] = bytes[i % len];\n        }\n    }\n    return this;\n};\n// HELPER FUNCTIONS\n// ================\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\nfunction base64clean(str) {\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = stringtrim(str).replace(INVALID_BASE64_RE, \"\");\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2) return \"\";\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while(str.length % 4 !== 0){\n        str = str + \"=\";\n    }\n    return str;\n}\nfunction stringtrim(str) {\n    if (str.trim) return str.trim();\n    return str.replace(/^\\s+|\\s+$/g, \"\");\n}\nfunction toHex(n) {\n    if (n < 16) return \"0\" + n.toString(16);\n    return n.toString(16);\n}\nfunction utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for(var i = 0; i < length; ++i){\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        } else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else {\n            throw new Error(\"Invalid code point\");\n        }\n    }\n    return bytes;\n}\nfunction asciiToBytes(str) {\n    var byteArray = [];\n    for(var i = 0; i < str.length; ++i){\n        // Node's code seems to be doing this and not & 0x7F..\n        byteArray.push(str.charCodeAt(i) & 0xFF);\n    }\n    return byteArray;\n}\nfunction utf16leToBytes(str, units) {\n    var c, hi, lo;\n    var byteArray = [];\n    for(var i = 0; i < str.length; ++i){\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}\nfunction base64ToBytes(str) {\n    return toByteArray(base64clean(str));\n}\nfunction blitBuffer(src, dst, offset, length) {\n    for(var i = 0; i < length; ++i){\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\nfunction isnan(val) {\n    return val !== val // eslint-disable-line no-self-compare\n    ;\n}\n// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nfunction isBuffer(obj) {\n    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));\n}\nfunction isFastBuffer(obj) {\n    return !!obj.constructor && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n}\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer(obj) {\n    return typeof obj.readFloatLE === \"function\" && typeof obj.slice === \"function\" && isFastBuffer(obj.slice(0, 0));\n}\nconst isHexString = (hex)=>typeof hex === \"string\" && /^0x[0-9A-Fa-f]*$/.test(hex);\nconst utf8ToHex = (str)=>{\n    return Buffer.from(str, \"utf8\").toString(\"hex\");\n};\nvar _EthereumProvider_instances, _EthereumProvider_getBloctoProperties, _EthereumProvider_addToSwitchable, _EthereumProvider_checkNetworkMatched;\nfunction parseChainId(chainId) {\n    if (!chainId) {\n        return 1;\n    }\n    if (typeof chainId === \"number\") {\n        return chainId;\n    } else if (chainId.startsWith(\"0x\")) {\n        return parseInt(chainId, 16);\n    }\n    return parseInt(chainId, 10);\n}\nclass EthereumProvider extends BloctoProvider {\n    constructor({ chainId, rpc, walletServer, appId }){\n        super();\n        _EthereumProvider_instances.add(this);\n        this.networkVersion = \"1\"; // same as chainId but in decimal\n        // setup chainId\n        invariant(chainId, \"'chainId' is required\");\n        this.networkVersion = `${parseChainId(chainId)}`;\n        this.chainId = `0x${parseChainId(chainId).toString(16)}`;\n        // setup rpc\n        this.rpc = rpc || ETH_RPC_LIST[this.networkVersion];\n        invariant(this.rpc, \"'rpc' is required\");\n        // setup injectedWalletServer\n        this.injectedWalletServer = walletServer;\n        // NOTE: _blocto is not fully initialized yet at this point\n        // Any function should call #getBloctoProperties() to get the full _blocto properties\n        this._blocto = {\n            sessionKey: KEY_SESSION.prod,\n            walletServer: this.injectedWalletServer || \"\",\n            blockchainName: \"\",\n            networkType: \"\",\n            supportNetworkList: {},\n            switchableNetwork: {}\n        };\n        this.appId = appId || DEFAULT_APP_ID;\n    }\n    // DEPRECATED API: see https://docs.metamask.io/guide/ethereum-provider.html#ethereum-send-deprecated\n    send(methodOrPayload, paramsOrCallback) {\n        return __awaiter(this, void 0, void 0, function*() {\n            switch(true){\n                // signature type 1: arg1 - JSON-RPC payload, arg2 - callback;\n                // ethereum.send(payload: JsonRpcRequest, callback: JsonRpcCallback): void;\n                // This signature is exactly like ethereum.sendAsync()\n                case paramsOrCallback instanceof Function:\n                    return this.sendAsync(methodOrPayload, paramsOrCallback);\n                // signature type 2: arg1 - JSON-RPC method name, arg2 - params array;\n                // ethereum.send(method: string, params?: Array<unknown>): Promise<JsonRpcResponse>;\n                // This signature is like an async ethereum.sendAsync() with method and params as arguments,\n                // instead of a JSON-RPC payload and callback\n                case typeof methodOrPayload === \"string\" && Array.isArray(paramsOrCallback):\n                    return this.sendAsync({\n                        jsonrpc: \"2.0\",\n                        method: methodOrPayload,\n                        params: paramsOrCallback\n                    });\n                // signature type 3: arg1 - JSON-RPC payload(should be synchronous methods)\n                // ethereum.send(payload: JsonRpcRequest): unknown;\n                // This signature enables you to call some type of RPC methods synchronously\n                default:\n                    return this.sendAsync(methodOrPayload);\n            }\n        });\n    }\n    // DEPRECATED API: see https://docs.metamask.io/guide/ethereum-provider.html#legacy-methods implementation\n    // web3 v1.x BatchRequest still depends on it so we need to implement anyway \\_()_/\n    sendAsync(payload, callback) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const handleRequest = new Promise((resolve)=>{\n                // web3 v1.x concat batched JSON-RPC requests to an array, handle it here\n                if (Array.isArray(payload)) {\n                    // collect transactions and send batch with custom method\n                    const transactions = payload.filter((request)=>request.method === \"eth_sendTransaction\").map((request)=>{\n                        var _a;\n                        return (_a = request.params) === null || _a === void 0 ? void 0 : _a[0];\n                    });\n                    const idBase = Math.floor(Math.random() * 10000);\n                    const batchedRequestPayload = {\n                        method: \"blocto_sendBatchTransaction\",\n                        params: transactions\n                    };\n                    const batchResponsePromise = this.request(batchedRequestPayload);\n                    const requests = payload.map(({ method, params }, index)=>method === \"eth_sendTransaction\" ? batchResponsePromise : this.request({\n                            id: idBase + index + 1,\n                            jsonrpc: \"2.0\",\n                            method,\n                            params\n                        }));\n                    // resolve response when all request are executed\n                    Promise.allSettled(requests).then((responses)=>resolve(responses.map((response, index)=>{\n                            return {\n                                id: String(idBase + index + 1),\n                                jsonrpc: \"2.0\",\n                                method: payload[index].method,\n                                result: response.status === \"fulfilled\" ? response.value : undefined,\n                                error: response.status !== \"fulfilled\" ? response.reason : undefined\n                            };\n                        }))).catch((error)=>{\n                        throw dist.ethErrors.rpc.internal(error === null || error === void 0 ? void 0 : error.message);\n                    });\n                } else {\n                    this.request(Object.assign(Object.assign({}, payload), {\n                        id: Number(payload.id)\n                    })).then(resolve);\n                }\n            });\n            // execute callback or return promise, depdends on callback arg given or not\n            if (callback) {\n                handleRequest.then((data)=>callback(null, data)).catch((error)=>callback(error));\n            } else {\n                return handleRequest;\n            }\n        });\n    }\n    /**\n     * Sending userOperation using Blocto SDK.\n     * @param {IUserOperation} userOp - userOperation object\n     * @remarks No need to include nonce, initCode, and signature as parameters when using BloctoSDK to send userOperation.\n     * These parameters will be ignored.\n     * @returns {Promise<string>} - userOperation hash\n     */ sendUserOperation(userOp) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.request({\n                method: \"eth_sendUserOperation\",\n                params: [\n                    userOp\n                ]\n            });\n        });\n    }\n    request(payload) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!(payload === null || payload === void 0 ? void 0 : payload.method)) throw dist.ethErrors.rpc.invalidRequest();\n            const existedSDK = window.ethereum;\n            if (existedSDK && existedSDK.isBlocto) {\n                if (payload.method === \"wallet_switchEthereumChain\") {\n                    if (!((_b = (_a = payload === null || payload === void 0 ? void 0 : payload.params) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams();\n                    }\n                    return existedSDK.request(payload).then(()=>{\n                        var _a, _b, _c;\n                        this.networkVersion = `${parseChainId((_a = payload === null || payload === void 0 ? void 0 : payload.params) === null || _a === void 0 ? void 0 : _a[0].chainId)}`;\n                        this.chainId = `0x${parseChainId((_b = payload === null || payload === void 0 ? void 0 : payload.params) === null || _b === void 0 ? void 0 : _b[0].chainId).toString(16)}`;\n                        this.rpc = (_c = switchableNetwork === null || switchableNetwork === void 0 ? void 0 : switchableNetwork[this.networkVersion]) === null || _c === void 0 ? void 0 : _c.rpc_url;\n                        return null;\n                    });\n                }\n                return existedSDK.request(payload);\n            }\n            const { blockchainName, switchableNetwork, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            // method that doesn't require user to be connected\n            switch(payload.method){\n                case \"eth_chainId\":\n                    {\n                        return this.chainId;\n                    }\n                case \"net_version\":\n                    {\n                        return this.networkVersion;\n                    }\n                case \"wallet_addEthereumChain\":\n                    {\n                        return this.loadSwitchableNetwork((payload === null || payload === void 0 ? void 0 : payload.params) || []);\n                    }\n                case \"eth_call\":\n                    {\n                        const response = yield this.handleReadRequests(payload);\n                        if (!response || response && !response.result && response.error) {\n                            const errorMessage = ((_c = response === null || response === void 0 ? void 0 : response.error) === null || _c === void 0 ? void 0 : _c.message) ? response.error.message : \"Request failed\";\n                            throw dist.ethErrors.rpc.internal(errorMessage);\n                        }\n                        return response.result;\n                    }\n                case \"wallet_switchEthereumChain\":\n                    {\n                        if (!((_e = (_d = payload === null || payload === void 0 ? void 0 : payload.params) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.chainId)) throw dist.ethErrors.rpc.invalidParams();\n                        const newChainId = payload.params[0].chainId;\n                        if (!getChainAddress(sessionKey, blockchainName)) {\n                            // directly switch network if user is not connected\n                            // TODO: add a confirm switch network dialog\n                            const phasedChainId = parseChainId(newChainId);\n                            if (!switchableNetwork[phasedChainId]) {\n                                throw dist.ethErrors.provider.custom({\n                                    code: 4902,\n                                    message: `Unrecognized chain ID \"${newChainId}\". Try adding the chain using wallet_addEthereumChain first.`\n                                });\n                            }\n                            this.networkVersion = `${phasedChainId}`;\n                            this.chainId = `0x${phasedChainId.toString(16)}`;\n                            this.rpc = switchableNetwork[phasedChainId].rpc_url;\n                            this.eventListeners.chainChanged.forEach((listener)=>listener(this.chainId));\n                            return null;\n                        }\n                        break;\n                    }\n            }\n            // Method that requires user to be connected\n            if (!getChainAddress(sessionKey, blockchainName)) {\n                const email = (_f = payload === null || payload === void 0 ? void 0 : payload.params) === null || _f === void 0 ? void 0 : _f[0];\n                if (payload.method === \"eth_requestAccounts\" && isEmail(email)) {\n                    yield this.enable(email);\n                } else {\n                    yield this.enable();\n                }\n            }\n            try {\n                let response = null;\n                let result = null;\n                switch(payload.method){\n                    case \"eth_requestAccounts\":\n                        yield this.fetchAccounts();\n                    // eslint-disable-next-line\n                    case \"eth_accounts\":\n                        result = getChainAddress(sessionKey, blockchainName);\n                        break;\n                    case \"eth_coinbase\":\n                        {\n                            result = (_g = getChainAddress(sessionKey, blockchainName)) === null || _g === void 0 ? void 0 : _g[0];\n                            break;\n                        }\n                    case \"eth_signTypedData_v3\":\n                    case \"eth_signTypedData\":\n                    case \"eth_signTypedData_v4\":\n                    case \"personal_sign\":\n                    case \"eth_sign\":\n                        {\n                            result = yield this.handleSign(payload);\n                            break;\n                        }\n                    case \"wallet_disconnect\":\n                        {\n                            this.handleDisconnect();\n                            result = null;\n                            break;\n                        }\n                    case \"eth_sendTransaction\":\n                        result = yield this.handleSendTransaction(payload);\n                        break;\n                    case \"blocto_sendBatchTransaction\":\n                        result = yield this.handleSendBatchTransaction(payload);\n                        break;\n                    case \"eth_signTransaction\":\n                    case \"eth_sendRawTransaction\":\n                        {\n                            throw dist.ethErrors.rpc.methodNotSupported(\"Method Not Supported: \" + payload.method);\n                        }\n                    case \"eth_sendUserOperation\":\n                        result = yield this.handleSendUserOperation(payload);\n                        break;\n                    case \"wallet_switchEthereumChain\":\n                        {\n                            if (!((_j = (_h = payload === null || payload === void 0 ? void 0 : payload.params) === null || _h === void 0 ? void 0 : _h[0]) === null || _j === void 0 ? void 0 : _j.chainId)) {\n                                throw dist.ethErrors.rpc.invalidParams();\n                            }\n                            const oldAccount = (_k = getChainAddress(sessionKey, blockchainName)) === null || _k === void 0 ? void 0 : _k[0];\n                            const oldChainId = this.chainId;\n                            const newChainId = payload.params[0].chainId;\n                            if (!switchableNetwork[parseChainId(newChainId)]) {\n                                throw dist.ethErrors.provider.custom({\n                                    code: 4902,\n                                    message: `Unrecognized chain ID \"${parseChainId(payload.params[0].chainId)}\". Try adding the chain using wallet_addEthereumChain first.`\n                                });\n                            }\n                            this.networkVersion = `${parseChainId(newChainId)}`;\n                            this.chainId = `0x${parseChainId(newChainId).toString(16)}`;\n                            this.rpc = switchableNetwork[this.networkVersion].rpc_url;\n                            yield this.enable().then(([newAccount])=>{\n                                var _a;\n                                if (newAccount !== oldAccount) {\n                                    (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.accountsChanged.forEach((listener)=>listener([\n                                            newAccount\n                                        ]));\n                                }\n                                this.eventListeners.chainChanged.forEach((listener)=>listener(this.chainId));\n                                result = null;\n                            }).catch((error)=>{\n                                this.networkVersion = `${parseChainId(oldChainId)}`;\n                                this.chainId = `0x${parseChainId(oldChainId).toString(16)}`;\n                                this.rpc = switchableNetwork[this.networkVersion].rpc_url;\n                                throw error;\n                            });\n                            break;\n                        }\n                    case \"eth_estimateUserOperationGas\":\n                    case \"eth_getUserOperationByHash\":\n                    case \"eth_getUserOperationReceipt\":\n                    case \"eth_supportedEntryPoints\":\n                        result = yield this.handleBundler(payload);\n                        break;\n                    default:\n                        response = yield this.handleReadRequests(payload);\n                }\n                if (response && !response.result && response.error) {\n                    const errorMessage = response.error.message ? response.error.message : \"Request failed\";\n                    throw dist.ethErrors.rpc.internal(errorMessage);\n                }\n                if (response) return response.result;\n                return result;\n            } catch (error) {\n                throw dist.ethErrors.rpc.internal(error === null || error === void 0 ? void 0 : error.message);\n            }\n        });\n    }\n    bloctoApi(url, options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const { walletServer, blockchainName, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const sessionId = ((_a = getAccountStorage(sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            if (!sessionId) {\n                throw dist.ethErrors.provider.unauthorized();\n            }\n            return fetch(`${walletServer}/api/${blockchainName}${url}`, Object.assign({\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Session-Identifier\": sessionId\n                }\n            }, options)).then((response)=>responseSessionGuard(response, sessionKey, ()=>{\n                    var _a;\n                    (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.disconnect.forEach((listener)=>listener(dist.ethErrors.provider.disconnected()));\n                })).catch((e)=>{\n                if ((e === null || e === void 0 ? void 0 : e.error_code) === \"unsupported_method\") {\n                    throw dist.ethErrors.rpc.methodNotSupported(\"Method Not Supported: \" + e.message);\n                } else {\n                    throw dist.ethErrors.rpc.server({\n                        code: -32005,\n                        message: `Blocto server error: ${e.message}`\n                    });\n                }\n            });\n        });\n    }\n    responseListener(frame, objectKey) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { walletServer } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            return new Promise((resolve, reject)=>addSelfRemovableHandler(\"message\", (event, removeEventListener)=>{\n                    const e = event;\n                    if (e.origin === walletServer && e.data.type === \"ETH:FRAME:RESPONSE\") {\n                        if (e.data.status === \"APPROVED\") {\n                            removeEventListener();\n                            detatchFrame(frame);\n                            resolve(e.data[objectKey]);\n                        }\n                        if (e.data.status === \"DECLINED\") {\n                            removeEventListener();\n                            detatchFrame(frame);\n                            if (e.data.errorCode === \"incorrect_session_id\") {\n                                this.handleDisconnect();\n                            }\n                            reject(dist.ethErrors.provider.userRejectedRequest(e.data.errorMessage));\n                        }\n                    }\n                    if (e.data.type === \"ETH:FRAME:CLOSE\") {\n                        removeEventListener();\n                        detatchFrame(frame);\n                        reject(dist.ethErrors.provider.userRejectedRequest(\"User declined the request\"));\n                    }\n                }));\n        });\n    }\n    setIframe(url) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (true) {\n                throw dist.ethErrors.provider.custom({\n                    code: 1001,\n                    message: \"Blocto SDK only works in browser environment\"\n                });\n            }\n            const { walletServer, blockchainName } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const frame = createFrame(`${walletServer}/${this.appId}/${blockchainName}${url}`);\n            attachFrame(frame);\n            return frame;\n        });\n    }\n    // eip-1102 alias\n    // DEPRECATED API: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1102.md\n    enable(email) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { walletServer, blockchainName, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const existedSDK = window.ethereum;\n            if (existedSDK && existedSDK.isBlocto) {\n                if (existedSDK.chainId !== this.chainId) {\n                    yield existedSDK.request({\n                        method: \"wallet_addEthereumChain\",\n                        params: [\n                            {\n                                chainId: this.chainId\n                            }\n                        ]\n                    });\n                    yield existedSDK.request({\n                        method: \"wallet_switchEthereumChain\",\n                        params: [\n                            {\n                                chainId: this.chainId\n                            }\n                        ]\n                    });\n                    setChainAddress(sessionKey, blockchainName, [\n                        existedSDK.address\n                    ]);\n                }\n                return new Promise((resolve, reject)=>// add a small delay to make sure the network has been switched\n                    setTimeout(()=>existedSDK.enable().then(resolve).catch(reject), 10));\n            }\n            const address = getChainAddress(sessionKey, blockchainName);\n            if (address) {\n                return new Promise((resolve)=>{\n                    resolve(address);\n                });\n            }\n            const params = new URLSearchParams();\n            params.set(\"l6n\", window.location.origin);\n            params.set(\"v\", SDK_VERSION);\n            const emailParam = email && isEmail(email) ? `/${email}` : \"\";\n            const loginFrame = yield this.setIframe(`/authn${emailParam}?${params.toString()}`);\n            return new Promise((resolve, reject)=>{\n                addSelfRemovableHandler(\"message\", (event, removeListener)=>{\n                    var _a;\n                    const e = event;\n                    if (e.origin === walletServer) {\n                        if (e.data.type === \"ETH:FRAME:RESPONSE\") {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.connect.forEach((listener)=>listener({\n                                    chainId: this.chainId\n                                }));\n                            setAccountStorage(sessionKey, {\n                                code: e.data.code,\n                                connected: true,\n                                accounts: {\n                                    [blockchainName]: [\n                                        e.data.addr\n                                    ]\n                                }\n                            }, e.data.exp);\n                            resolve([\n                                e.data.addr\n                            ]);\n                        }\n                        if (e.data.type === \"ETH:FRAME:CLOSE\") {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            reject(dist.ethErrors.provider.userRejectedRequest());\n                        }\n                    }\n                });\n            });\n        });\n    }\n    fetchAccounts() {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { blockchainName, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const { accounts } = yield this.bloctoApi(`/accounts`);\n            setChainAddress(sessionKey, blockchainName, accounts);\n            return accounts;\n        });\n    }\n    handleReadRequests(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            return fetch(this.rpc, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(Object.assign({\n                    id: 1,\n                    jsonrpc: \"2.0\"\n                }, payload))\n            }).then((response)=>response.json()).catch((e)=>{\n                throw dist.ethErrors.rpc.internal(e);\n            });\n        });\n    }\n    handleSign({ method, params }) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let message = \"\";\n            if (Array.isArray(params)) {\n                if (method === \"eth_sign\") {\n                    message = isHexString(params[1]) ? params[1].slice(2) : utf8ToHex(params[1]);\n                } else if (method === \"personal_sign\") {\n                    message = isHexString(params[0]) ? params[0].slice(2) : utf8ToHex(params[0]);\n                } else if ([\n                    \"eth_signTypedData\",\n                    \"eth_signTypedData_v3\",\n                    \"eth_signTypedData_v4\"\n                ].includes(method)) {\n                    message = params[1];\n                    const { domain } = JSON.parse(message);\n                    if (isHexString(domain.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams(`Provided chainId \"${domain.chainId}\" must be a number`);\n                    }\n                    if (parseChainId(domain.chainId) !== parseChainId(this.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams(`Provided chainId \"${domain.chainId}\" must match the active chainId \"${parseChainId(this.chainId)}\"`);\n                    }\n                }\n            }\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { signatureId } = yield this.bloctoApi(`/user-signature`, {\n                method: \"POST\",\n                body: JSON.stringify({\n                    method,\n                    message\n                })\n            });\n            const signFrame = yield this.setIframe(`/user-signature/${signatureId}`);\n            return this.responseListener(signFrame, \"signature\");\n        });\n    }\n    handleSendTransaction(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            if (!isValidTransaction((_a = payload.params) === null || _a === void 0 ? void 0 : _a[0])) {\n                throw dist.ethErrors.rpc.invalidParams();\n            }\n            const { authorizationId } = yield this.bloctoApi(`/authz`, {\n                method: \"POST\",\n                body: JSON.stringify(payload.params)\n            });\n            const authzFrame = yield this.setIframe(`/authz/${authorizationId}`);\n            return this.responseListener(authzFrame, \"txHash\");\n        });\n    }\n    handleSendBatchTransaction(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const extractParams = (params)=>params.map((param)=>\"params\" in param ? param.params[0] // handle passing web3.eth.sendTransaction.request(...) as a parameter with params\n                     : param);\n            const formatParams = extractParams(payload.params);\n            const copyPayload = Object.assign(Object.assign({}, payload), {\n                params: formatParams\n            });\n            if (!isValidTransactions(copyPayload.params)) {\n                throw dist.ethErrors.rpc.invalidParams();\n            }\n            return this.handleSendTransaction(copyPayload);\n        });\n    }\n    handleSendUserOperation(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { authorizationId } = yield this.bloctoApi(`/user-operation`, {\n                method: \"POST\",\n                body: JSON.stringify(payload.params)\n            });\n            const userOPFrame = yield this.setIframe(`/user-operation/${authorizationId}`);\n            return this.responseListener(userOPFrame, \"userOpHash\");\n        });\n    }\n    handleBundler(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            return this.bloctoApi(`/rpc/bundler`, {\n                method: \"POST\",\n                body: JSON.stringify(Object.assign({\n                    id: 1,\n                    jsonrpc: \"2.0\"\n                }, payload))\n            });\n        });\n    }\n    handleDisconnect() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.ethereum;\n            if (existedSDK && existedSDK.isBlocto) {\n                return existedSDK.disconnect();\n            }\n            const { sessionKey, blockchainName } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            removeChainAddress(sessionKey, blockchainName);\n            (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.disconnect.forEach((listener)=>listener(dist.ethErrors.provider.disconnected()));\n        });\n    }\n    loadSwitchableNetwork(networkList) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // setup switchable list if user set networkList\n            if (networkList === null || networkList === void 0 ? void 0 : networkList.length) {\n                const listToAdd = networkList.map(({ chainId, rpcUrls })=>{\n                    if (!chainId) throw dist.ethErrors.rpc.invalidParams(\"Empty chainId\");\n                    if (!(rpcUrls === null || rpcUrls === void 0 ? void 0 : rpcUrls.length)) throw dist.ethErrors.rpc.invalidParams(\"Empty rpcUrls\");\n                    return __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_addToSwitchable).call(this, {\n                        chainId: `${parseChainId(chainId)}`,\n                        rpcUrls\n                    });\n                });\n                return Promise.all(listToAdd).then(()=>null);\n            } else {\n                throw dist.ethErrors.rpc.invalidParams(\"Empty networkList\");\n            }\n        });\n    }\n}\n_EthereumProvider_instances = new WeakSet(), _EthereumProvider_getBloctoProperties = function _EthereumProvider_getBloctoProperties() {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (!Object.keys(this._blocto.supportNetworkList).length) {\n            yield getEvmSupport().then((result)=>this._blocto.supportNetworkList = result).catch((e)=>{\n                throw dist.ethErrors.provider.custom({\n                    code: 1001,\n                    message: `Get blocto server failed: ${e.message}`\n                });\n            });\n        }\n        const { chain_id, name, network_type, blocto_service_environment, display_name } = this._blocto.supportNetworkList[this.networkVersion];\n        if (!chain_id) throw dist.ethErrors.provider.unsupportedMethod(`Get support chain failed: ${this.networkVersion} might not be supported yet.`);\n        this._blocto = Object.assign(Object.assign({}, this._blocto), {\n            sessionKey: ETH_SESSION_KEY_MAPPING[blocto_service_environment],\n            walletServer: this.injectedWalletServer || ETH_ENV_WALLET_SERVER_MAPPING[blocto_service_environment],\n            blockchainName: name,\n            networkType: network_type,\n            switchableNetwork: Object.assign(Object.assign({}, this._blocto.switchableNetwork), {\n                [chain_id]: {\n                    name,\n                    display_name,\n                    network_type,\n                    wallet_web_url: this._blocto.walletServer,\n                    rpc_url: this.rpc\n                }\n            })\n        });\n        return this._blocto;\n    });\n}, _EthereumProvider_addToSwitchable = function _EthereumProvider_addToSwitchable({ chainId, rpcUrls }) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const { supportNetworkList } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n        const { chain_id, name, display_name, network_type, blocto_service_environment } = supportNetworkList[chainId];\n        const wallet_web_url = ETH_ENV_WALLET_SERVER_MAPPING[blocto_service_environment];\n        this._blocto.switchableNetwork[chain_id] = {\n            name,\n            display_name,\n            network_type,\n            wallet_web_url,\n            rpc_url: rpcUrls[0]\n        };\n    });\n}, _EthereumProvider_checkNetworkMatched = function _EthereumProvider_checkNetworkMatched() {\n    const existedSDK = window.ethereum;\n    if (existedSDK && existedSDK.isBlocto && parseChainId(existedSDK.chainId) !== parseChainId(this.chainId)) {\n        throw dist.ethErrors.provider.chainDisconnected();\n    }\n};\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base(ALPHABET) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError(\"Alphabet too long\");\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for(var j = 0; j < BASE_MAP.length; j++){\n        BASE_MAP[j] = 255;\n    }\n    for(var i = 0; i < ALPHABET.length; i++){\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + \" is ambiguous\");\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n    function encode(source) {\n        if (source instanceof Uint8Array) ;\n        else if (ArrayBuffer.isView(source)) {\n            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n        } else if (Array.isArray(source)) {\n            source = Uint8Array.from(source);\n        }\n        if (!(source instanceof Uint8Array)) {\n            throw new TypeError(\"Expected Uint8Array\");\n        }\n        if (source.length === 0) {\n            return \"\";\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while(pbegin !== pend && source[pbegin] === 0){\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while(pbegin !== pend){\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){\n                carry += 256 * b58[it1] >>> 0;\n                b58[it1] = carry % BASE >>> 0;\n                carry = carry / BASE >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while(it2 !== size && b58[it2] === 0){\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for(; it2 < size; ++it2){\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    function decodeUnsafe(source) {\n        if (typeof source !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        if (source.length === 0) {\n            return new Uint8Array();\n        }\n        var psz = 0;\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while(source[psz] === LEADER){\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while(source[psz]){\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){\n                carry += BASE * b256[it3] >>> 0;\n                b256[it3] = carry % 256 >>> 0;\n                carry = carry / 256 >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            psz++;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while(it4 !== size && b256[it4] === 0){\n            it4++;\n        }\n        var vch = new Uint8Array(zeroes + (size - it4));\n        var j = zeroes;\n        while(it4 !== size){\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(\"Non-base\" + BASE + \" character\");\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nvar src = base;\nconst basex = src;\nconst ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar bs58 = basex(ALPHABET);\nvar bs58$1 = /*@__PURE__*/ getDefaultExportFromCjs(bs58);\nlet Solana;\ntry {\n    Solana = require(\"@solana/web3.js\");\n} catch (_a) {\n// prevent crash if there is no @solana/web3.js.\n}\nclass SolanaProvider extends BloctoProvider {\n    constructor({ net = \"mainnet-beta\", server, appId, rpc }){\n        super();\n        invariant(net, \"'net' is required\");\n        invariant(Object.values(SOL_NET).includes(net), \"unsupported net\");\n        this.net = net;\n        this.rpc = rpc || (net === \"mainnet-beta\" ? \"https://free.rpcpool.com\" : `https://api.${net}.solana.com`);\n        this.server = server || SOL_NET_SERVER_MAPPING[this.net] || \"\";\n        this.appId = appId || DEFAULT_APP_ID;\n        this.sessionKey = SOL_SESSION_KEY_MAPPING[this.net];\n        if (!Solana) {\n            throw new Error(\"No @solana/web3.js installed. Please install it to interact with Solana.\");\n        }\n    }\n    request(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                return existedSDK.request(payload);\n            }\n            if (!getChainAddress(this.sessionKey, CHAIN.SOLANA)) {\n                yield this.connect();\n            }\n            try {\n                let response = null;\n                let result = null;\n                switch(payload.method){\n                    case \"connect\":\n                        result = yield this.fetchAccounts();\n                        break;\n                    case \"disconnect\":\n                        this.disconnect();\n                        break;\n                    case \"getAccounts\":\n                        result = ((_a = getChainAddress(this.sessionKey, CHAIN.SOLANA)) === null || _a === void 0 ? void 0 : _a.length) ? getChainAddress(this.sessionKey, CHAIN.SOLANA) : yield this.fetchAccounts();\n                        break;\n                    case \"getAccountInfo\":\n                        {\n                            // Format the data as the same format returning from Connection.getAccountInfo from @solana/web3.js\n                            // ref: https://solana-labs.github.io/solana-web3.js/classes/Connection.html#getAccountInfo\n                            const accountInfo = yield this.handleReadRequests(payload);\n                            const [bufferData, encoding] = accountInfo.result.value.data;\n                            result = Object.assign(Object.assign({}, accountInfo.result.value), {\n                                data: Buffer.from(bufferData, encoding),\n                                owner: new Solana.PublicKey(accountInfo.result.value.owner)\n                            });\n                            break;\n                        }\n                    // custom JSON-RPC method\n                    case \"convertToProgramWalletTransaction\":\n                        result = yield this.handleConvertTransaction(payload);\n                        break;\n                    // custom JSON-RPC method\n                    case \"signAndSendTransaction\":\n                        result = yield this.handleSignAndSendTransaction(payload);\n                        break;\n                    // block user from using traditional methods\n                    case \"signTransaction\":\n                    case \"signAllTransactions\":\n                        throw new Error(`Blocto is program wallet, which doesn't support ${payload.method}. Use signAndSendTransaction instead.`);\n                    default:\n                        response = yield this.handleReadRequests(payload);\n                }\n                if (response && !response.result && response.error) {\n                    const errorMessage = response.error.message ? response.error.message : \"Request failed\";\n                    throw new Error(errorMessage);\n                }\n                if (response) return response.result;\n                return result;\n            } catch (error) {\n                console.error(error);\n                throw error;\n            }\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                return new Promise((resolve)=>{\n                    existedSDK.on(\"connect\", ()=>{\n                        setChainAddress(this.sessionKey, CHAIN.SOLANA, [\n                            existedSDK.publicKey.toBase58()\n                        ]);\n                        resolve();\n                    });\n                    existedSDK.connect();\n                });\n            }\n            return new Promise((resolve, reject)=>{\n                if (true) {\n                    return reject(\"Currently only supported in browser\");\n                }\n                if (getChainAddress(this.sessionKey, CHAIN.SOLANA)) {\n                    return resolve();\n                }\n                const location = encodeURIComponent(window.location.origin);\n                const loginFrame = createFrame(`${this.server}/${this.appId}/solana/authn?l6n=${location}&v=${SDK_VERSION}`);\n                attachFrame(loginFrame);\n                addSelfRemovableHandler(\"message\", (event, removeListener)=>{\n                    const e = event;\n                    if (e.origin === this.server) {\n                        if (e.data.type === \"SOL:FRAME:RESPONSE\") {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            this.eventListeners.connect.forEach((listener)=>listener(this.net));\n                            setAccountStorage(this.sessionKey, {\n                                code: e.data.code,\n                                connected: true,\n                                accounts: {\n                                    [CHAIN.SOLANA]: [\n                                        e.data.addr\n                                    ]\n                                }\n                            }, e.data.exp);\n                            resolve();\n                        }\n                        if (e.data.type === \"SOL:FRAME:CLOSE\") {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            reject(new Error(\"User declined the login request\"));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                yield existedSDK.disconnect();\n                return;\n            }\n            this.eventListeners.disconnect.forEach((listener)=>listener(null));\n            removeChainAddress(this.sessionKey, CHAIN.SOLANA);\n        });\n    }\n    fetchAccounts() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            const { accounts } = yield fetch(`${this.server}/api/solana/accounts`, {\n                headers: {\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                }\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            setChainAddress(this.sessionKey, CHAIN.SOLANA, accounts);\n            return accounts;\n        });\n    }\n    handleReadRequests(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return fetch(this.rpc, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(Object.assign({\n                    id: 1,\n                    jsonrpc: \"2.0\"\n                }, payload))\n            }).then((response)=>response.json());\n        });\n    }\n    // solana web3 utility\n    convertToProgramWalletTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                return existedSDK.convertToProgramWalletTransaction(transaction);\n            }\n            const message = yield this.request({\n                method: \"convertToProgramWalletTransaction\",\n                params: {\n                    message: transaction.serializeMessage().toString(\"hex\")\n                }\n            });\n            return this.toTransaction(message, []);\n        });\n    }\n    // solana web3 utility\n    signAndSendTransaction(transaction, connection) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                return existedSDK.signAndSendTransaction(transaction);\n            }\n            const extra = {};\n            if (connection) {\n                if (connection.commitment) extra.commitment = connection.commitment;\n                // if the connection object passed-in has different rpc endpoint, reconnect to it\n                // eslint-disable-next-line no-underscore-dangle\n                const rpc = connection ? connection._rpcEndpoint : null;\n                if (rpc && rpc !== this.rpc) {\n                    this.rpc = rpc;\n                    this.disconnect();\n                    yield this.connect();\n                }\n            }\n            return this.request({\n                method: \"signAndSendTransaction\",\n                params: Object.assign({\n                    signatures: yield this.collectSignatures(transaction),\n                    message: transaction.serializeMessage().toString(\"hex\")\n                }, extra)\n            });\n        });\n    }\n    // solana web3 utility\n    // eslint-disable-next-line class-methods-use-this\n    toTransaction(raw, signatures) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const message = Solana.Message.from(Buffer.from(raw, \"hex\"));\n            const transaction = new Solana.Transaction();\n            transaction.recentBlockhash = message.recentBlockhash;\n            if (message.header.numRequiredSignatures > 0) {\n                transaction.feePayer = message.accountKeys[0];\n            }\n            signatures.forEach((signature, index)=>{\n                const sigPubkeyPair = {\n                    signature: signature === Solana.PublicKey.default.toBase58() ? null : bs58$1.decode(signature),\n                    publicKey: message.accountKeys[index]\n                };\n                transaction.signatures.push(sigPubkeyPair);\n            });\n            message.instructions.forEach((instruction)=>{\n                const keys = instruction.accounts.map((account)=>{\n                    const pubkey = message.accountKeys[account];\n                    return {\n                        pubkey,\n                        isSigner: account < message.header.numRequiredSignatures,\n                        isWritable: message.isAccountWritable(account)\n                    };\n                });\n                transaction.instructions.push(new Solana.TransactionInstruction({\n                    keys,\n                    programId: message.accountKeys[instruction.programIdIndex],\n                    data: bs58$1.decode(instruction.data)\n                }));\n            });\n            return transaction;\n        });\n    }\n    // solana web3 utility\n    // eslint-disable-next-line class-methods-use-this\n    collectSignatures(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return transaction.signatures.reduce((acc, cur)=>{\n                if (cur.signature) {\n                    acc[cur.publicKey.toBase58()] = cur.signature.toString(\"hex\");\n                }\n                return acc;\n            }, {});\n        });\n    }\n    handleConvertTransaction(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            return fetch(`${this.server}/api/solana/convertToWalletTx`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                },\n                body: JSON.stringify(payload.params)\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n        });\n    }\n    handleSignAndSendTransaction(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            const { authorizationId } = yield fetch(`${this.server}/api/solana/authz`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                },\n                body: JSON.stringify(payload.params)\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            if (true) {\n                throw new Error(\"Currently only supported in browser\");\n            }\n            const authzFrame = createFrame(`${this.server}/${this.appId}/solana/authz/${authorizationId}`);\n            attachFrame(authzFrame);\n            return new Promise((resolve, reject)=>addSelfRemovableHandler(\"message\", (event, removeEventListener)=>{\n                    const e = event;\n                    if (e.origin === this.server && e.data.type === \"SOL:FRAME:RESPONSE\") {\n                        if (e.data.status === \"APPROVED\") {\n                            removeEventListener();\n                            detatchFrame(authzFrame);\n                            resolve(e.data.txHash);\n                        }\n                        if (e.data.status === \"DECLINED\") {\n                            removeEventListener();\n                            detatchFrame(authzFrame);\n                            if (e.data.errorCode === \"incorrect_session_id\") {\n                                this.disconnect();\n                            }\n                            reject(new Error(e.data.errorMessage));\n                        }\n                    }\n                }));\n        });\n    }\n}\nconst checkMessagePayloadFormat = (payload)=>{\n    var _a, _b;\n    const formattedPayload = Object.assign({}, payload);\n    const { message, nonce, address, application, chainId } = payload;\n    if (typeof message !== \"string\") {\n        formattedPayload.message = (_a = String(message)) !== null && _a !== void 0 ? _a : \"\";\n    }\n    if (typeof nonce !== \"string\") {\n        formattedPayload.nonce = (_b = String(nonce)) !== null && _b !== void 0 ? _b : \"\";\n    }\n    if (address && typeof address !== \"boolean\") {\n        formattedPayload.address = !!address;\n    }\n    if (application && typeof application !== \"boolean\") {\n        formattedPayload.application = !!application;\n    }\n    if (chainId && typeof chainId !== \"boolean\") {\n        formattedPayload.chainId = !!chainId;\n    }\n    return formattedPayload;\n};\nclass AptosProvider extends BloctoProvider {\n    constructor({ chainId, server, appId }){\n        super();\n        this.publicKey = [];\n        this.authKey = \"\";\n        invariant(chainId, \"'chainId' is required\");\n        invariant(appId, \"It is necessary to interact with Blocto wallet via your app id. Please visit https://developers.blocto.app for more details.\");\n        this.chainId = chainId;\n        this.networkName = APT_CHAIN_ID_NAME_MAPPING[chainId];\n        this.api = APT_CHAIN_ID_RPC_MAPPING[chainId];\n        this.sessionKey = APT_SESSION_KEY_MAPPING[chainId];\n        const defaultServer = APT_CHAIN_ID_SERVER_MAPPING[chainId];\n        this.appId = appId || DEFAULT_APP_ID;\n        this.server = server || defaultServer || \"\";\n    }\n    get publicAccount() {\n        var _a;\n        return {\n            address: ((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a[0]) || null,\n            publicKey: this.publicKey.length ? this.publicKey : null,\n            // @todo: provide authkey\n            authKey: null,\n            minKeysRequired: 2\n        };\n    }\n    network() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return {\n                name: this.networkName,\n                api: this.api,\n                chainId: this.chainId.toString()\n            };\n        });\n    }\n    isConnected() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return !!((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code);\n        });\n    }\n    signTransaction(transaction) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            if (existedSDK) {\n                return existedSDK.signTransaction(transaction);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error(\"Fail to get account\");\n            }\n            throw new Error(\"signTransaction method not supported.\");\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            if (existedSDK) {\n                yield existedSDK.disconnect();\n                return;\n            }\n            removeChainAddress(this.sessionKey, CHAIN.APTOS);\n        });\n    }\n    signAndSubmitTransaction(transaction, txOptions = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            if (existedSDK) {\n                return existedSDK.signAndSubmitTransaction(transaction, txOptions);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error(\"Fail to get account\");\n            }\n            const sessionId = ((_b = getAccountStorage(this.sessionKey)) === null || _b === void 0 ? void 0 : _b.code) || \"\";\n            const { authorizationId } = yield fetch(`${this.server}/api/aptos/authz`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                },\n                body: JSON.stringify(Object.assign(Object.assign({}, transaction), txOptions))\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            if (true) {\n                throw new Error(\"Currently only supported in browser\");\n            }\n            const authzFrame = createFrame(`${this.server}/${this.appId}/aptos/authz/${authorizationId}`);\n            attachFrame(authzFrame);\n            return new Promise((resolve, reject)=>addSelfRemovableHandler(\"message\", (event, removeEventListener)=>{\n                    const e = event;\n                    if (e.origin === this.server && e.data.type === \"APTOS:FRAME:RESPONSE\") {\n                        if (e.data.status === \"APPROVED\") {\n                            removeEventListener();\n                            detatchFrame(authzFrame);\n                            resolve({\n                                hash: e.data.txHash\n                            });\n                        }\n                        if (e.data.status === \"DECLINED\") {\n                            removeEventListener();\n                            detatchFrame(authzFrame);\n                            if (e.data.errorCode === \"incorrect_session_id\") {\n                                this.disconnect();\n                            }\n                            reject(new Error(e.data.errorMessage));\n                        }\n                    }\n                }));\n        });\n    }\n    signMessage(payload) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            const formattedPayload = checkMessagePayloadFormat(payload);\n            if (existedSDK) {\n                return existedSDK.signMessage(formattedPayload);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error(\"Fail to get account\");\n            }\n            if (true) {\n                throw new Error(\"Currently only supported in browser\");\n            }\n            const sessionId = ((_b = getAccountStorage(this.sessionKey)) === null || _b === void 0 ? void 0 : _b.code) || \"\";\n            const { signatureId } = yield fetch(`${this.server}/api/aptos/user-signature`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                },\n                body: JSON.stringify(formattedPayload)\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            const url = `${this.server}/${this.appId}/aptos/user-signature/${signatureId}`;\n            const signFrame = createFrame(url);\n            attachFrame(signFrame);\n            return new Promise((resolve, reject)=>addSelfRemovableHandler(\"message\", (event, removeEventListener)=>{\n                    const e = event;\n                    if (e.origin === this.server && e.data.type === \"APTOS:FRAME:RESPONSE\") {\n                        if (e.data.status === \"APPROVED\") {\n                            removeEventListener();\n                            detatchFrame(signFrame);\n                            resolve(e.data);\n                        }\n                        if (e.data.status === \"DECLINED\") {\n                            removeEventListener();\n                            detatchFrame(signFrame);\n                            if (e.data.errorCode === \"incorrect_session_id\") {\n                                this.disconnect();\n                            }\n                            reject(new Error(e.data.errorMessage));\n                        }\n                    }\n                }));\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            if (existedSDK) {\n                return new Promise((resolve, reject)=>// add a small delay to make sure the network has been switched\n                    setTimeout(()=>existedSDK.connect().then(resolve).catch(reject), 10));\n            }\n            return new Promise((resolve, reject)=>{\n                var _a, _b;\n                if (true) {\n                    return reject(\"Currently only supported in browser\");\n                }\n                if ((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length) {\n                    return resolve({\n                        address: ((_b = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _b === void 0 ? void 0 : _b[0]) || null,\n                        publicKey: this.publicKey,\n                        authKey: null,\n                        minKeysRequired: 2\n                    });\n                }\n                const location = encodeURIComponent(window.location.origin);\n                const loginFrame = createFrame(`${this.server}/${this.appId}/aptos/authn?l6n=${location}&v=${SDK_VERSION}}`);\n                attachFrame(loginFrame);\n                addSelfRemovableHandler(\"message\", (event, removeListener)=>__awaiter(this, void 0, void 0, function*() {\n                        var _c, _d, _e;\n                        const e = event;\n                        if (e.origin === this.server) {\n                            if (e.data.type === \"APTOS:FRAME:RESPONSE\") {\n                                removeListener();\n                                detatchFrame(loginFrame);\n                                setAccountStorage(this.sessionKey, {\n                                    code: e.data.code,\n                                    connected: true,\n                                    accounts: {\n                                        [CHAIN.APTOS]: [\n                                            e.data.addr\n                                        ]\n                                    }\n                                }, e.data.exp);\n                                if ((_c = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _c === void 0 ? void 0 : _c.length) {\n                                    try {\n                                        const { public_keys: publicKeys } = yield fetch(`${this.server}/blocto/aptos/accounts/${(_d = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _d === void 0 ? void 0 : _d[0]}`).then((response)=>response.json());\n                                        this.publicKey = publicKeys || [];\n                                        resolve({\n                                            address: ((_e = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _e === void 0 ? void 0 : _e[0]) || \"\",\n                                            publicKey: this.publicKey,\n                                            authKey: null,\n                                            minKeysRequired: 2\n                                        });\n                                    } catch (err) {\n                                        return reject(e);\n                                    }\n                                } else {\n                                    // @todo: better error\n                                    return reject();\n                                }\n                            }\n                            if (e.data.type === \"APTOS:FRAME:CLOSE\") {\n                                removeListener();\n                                detatchFrame(loginFrame);\n                                reject(new Error(\"User declined the login request\"));\n                            }\n                        }\n                    }));\n            });\n        });\n    }\n    fetchAddress() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            const { accounts } = yield fetch(`${this.server}/api/aptos/accounts`, {\n                headers: {\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                }\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            setChainAddress(this.sessionKey, CHAIN.APTOS, accounts);\n            return (accounts === null || accounts === void 0 ? void 0 : accounts[0]) || \"\";\n        });\n    }\n}\nclass BloctoSDK {\n    constructor({ appId, ethereum, solana, aptos }){\n        if (ethereum) {\n            this.ethereum = new EthereumProvider(Object.assign(Object.assign({}, ethereum), {\n                appId\n            }));\n        }\n        if (solana) {\n            this.solana = new SolanaProvider(Object.assign(Object.assign({}, solana), {\n                appId\n            }));\n        }\n        if (aptos) {\n            this.aptos = new AptosProvider(Object.assign(Object.assign({}, aptos), {\n                appId\n            }));\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGJsb2N0bytzZGtAMC41LjUvbm9kZV9tb2R1bGVzL0BibG9jdG8vc2RrL2Rpc3QvYmxvY3RvLXNkay5tb2R1bGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDZDQUE2QyxHQUM3Qzs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FDOUUsb0RBQW9ELEdBR3BELFNBQVNBLFVBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDaEQsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUVBLFNBQVNPLHVCQUF1QkMsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsQ0FBQztJQUNwRCxJQUFJRCxTQUFT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RUFBRTtnQkFDbEVzVCxTQUFTO29CQUNMLG9EQUFvRDtvQkFDcEQsb0VBQW9FO29CQUNwRSxpQ0FBaUMsSUFBSSxDQUFDdGpCLEtBQUs7b0JBQzNDLDZCQUE2QnFqQjtnQkFDakM7WUFDSixHQUFHbHBCLElBQUksQ0FBQyxDQUFDK0gsV0FBYUQscUJBQXFCQyxVQUFVLElBQUksQ0FBQzJkLFVBQVU7WUFDcEUvaEIsZ0JBQWdCLElBQUksQ0FBQytoQixVQUFVLEVBQUVya0IsTUFBTTB2QixLQUFLLEVBQUUxdEI7WUFDOUMsT0FBTyxDQUFDQSxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUSxDQUFDLEVBQUUsS0FBSztRQUNoRjtJQUNKO0FBQ0o7QUFFQSxNQUFNd3VCO0lBQ0Z0d0IsWUFBWSxFQUFFc0UsS0FBSyxFQUFFK2hCLFFBQVEsRUFBRTRGLE1BQU0sRUFBRXNFLEtBQUssRUFBRSxDQUFFO1FBQzVDLElBQUlsSyxVQUFVO1lBQ1YsSUFBSSxDQUFDQSxRQUFRLEdBQUcsSUFBSXhDLGlCQUFpQjloQixPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdxa0IsV0FBVztnQkFBRS9oQjtZQUFNO1FBQzVGO1FBQ0EsSUFBSTJuQixRQUFRO1lBQ1IsSUFBSSxDQUFDQSxNQUFNLEdBQUcsSUFBSUgsZUFBZS9wQixPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdpcUIsU0FBUztnQkFBRTNuQjtZQUFNO1FBQ3RGO1FBQ0EsSUFBSWlzQixPQUFPO1lBQ1AsSUFBSSxDQUFDQSxLQUFLLEdBQUcsSUFBSXJCLGNBQWNudEIsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHdXVCLFFBQVE7Z0JBQUVqc0I7WUFBTTtRQUNuRjtJQUNKO0FBQ0o7QUFFZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvLnBucG0vQGJsb2N0bytzZGtAMC41LjUvbm9kZV9tb2R1bGVzL0BibG9jdG8vc2RrL2Rpc3QvYmxvY3RvLXNkay5tb2R1bGUuanM/M2UyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBWZXJzaW9uOiAwLjUuNSAtIEF1Z3VzdCAxNCwgMjAyMyAxMDoyMzo1MiAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG4vLyBpbnN0ZWFkIGludmFyaWFudCBmcm9tIHBhY2thZ2UsIHNpbmNlIGFsbCBlcnJvciB3aWxsIHRocm93IG9uIHByb2R1Y3Rpb25cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQpO1xuICAgIH1cbn1cblxuLy8gbG9jYWwgc3RvcmFnZSB2ZXJzaW9uIG5hbWluZyBydWxlOiBbbWlsZXN0b25lXS5bcGF0Y2hdXG52YXIgS0VZX1NFU1NJT047XG4oZnVuY3Rpb24gKEtFWV9TRVNTSU9OKSB7XG4gICAgS0VZX1NFU1NJT05bXCJwcm9kXCJdID0gXCJCTE9DVE9fU0RLXCI7XG4gICAgS0VZX1NFU1NJT05bXCJkZXZcIl0gPSBcIkJMT0NUT19TREtfREVWXCI7XG4gICAgS0VZX1NFU1NJT05bXCJzdGFnaW5nXCJdID0gXCJCTE9DVE9fU0RLX1NUQUdJTkdcIjtcbn0pKEtFWV9TRVNTSU9OIHx8IChLRVlfU0VTU0lPTiA9IHt9KSk7XG52YXIgQ0hBSU47XG4oZnVuY3Rpb24gKENIQUlOKSB7XG4gICAgQ0hBSU5bXCJFVEhFUkVVTVwiXSA9IFwiZXRoZXJldW1cIjtcbiAgICBDSEFJTltcIlNPTEFOQVwiXSA9IFwic29sYW5hXCI7XG4gICAgQ0hBSU5bXCJBUFRPU1wiXSA9IFwiYXB0b3NcIjtcbn0pKENIQUlOIHx8IChDSEFJTiA9IHt9KSk7XG5cbmNsYXNzIE1lbW9yeVN0b3JhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSB7fTtcbiAgICB9XG4gICAgZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba2V5XSB8fCBudWxsO1xuICAgIH1cbiAgICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmVtb3ZlSXRlbShrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RvcmFnZVtrZXldO1xuICAgIH1cbn1cbmNvbnN0IG1lbW9yeVN0b3JhZ2UgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5tZW1vcnlTdG9yYWdlIDogbmV3IE1lbW9yeVN0b3JhZ2UoKTtcblxuY29uc3QgaXNTdXBwb3J0ZWQgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ2xvY2FsX3N0b3JhZ2Vfc3VwcG9ydGVkJywgJzEnKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ2xvY2FsX3N0b3JhZ2Vfc3VwcG9ydGVkJyk7XG4gICAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKCdsb2NhbF9zdG9yYWdlX3N1cHBvcnRlZCcpO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSAnMSc7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmNvbnN0IHN0b3JhZ2UgPSBpc1N1cHBvcnRlZCgpID8gd2luZG93LnNlc3Npb25TdG9yYWdlIDogbWVtb3J5U3RvcmFnZTtcbmNvbnN0IGdldEl0ZW0gPSAoa2V5LCBkZWZhdWx0VmFsdWUgPSBudWxsKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBzdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIEpTT04ucGFyc2UodmFsdWUpKSB8fCBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGNhdGNoIChTeW50YXhFcnJvcikge1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgZGVmYXVsdFZhbHVlO1xuICAgIH1cbn07XG5jb25zdCBzZXRJdGVtID0gKGtleSwgdmFsdWUpID0+IHN0b3JhZ2Uuc2V0SXRlbShrZXksIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG5jb25zdCByZW1vdmVJdGVtID0gKGtleSkgPT4ge1xuICAgIHNldEl0ZW0oa2V5LCAnJyk7IC8vIER1ZSB0byBzb21lIHZlcnNpb25zIG9mIGJyb3dzZXIgYnVnIGNhbid0IHJlbW92ZUl0ZW0gY29ycmVjdGx5LlxuICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xufTtcbi8qKlxuICogQHBhcmFtIHtrZXlzLktFWV9TRVNTSU9OfSBrZXkgLSBrZXkgdG8gcmV0cmlldmUgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtQcm92aWRlclNlc3Npb24gfCBudWxsfSBQcm92aWRlclNlc3Npb24gfCBudWxsXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCBQcm92aWRlclNlc3Npb24gZnJvbSBzdG9yYWdlLlxuICogSWYgdGhlIGRhdGEgaXMgZXhwaXJlZCwgd2lsbCByZW1vdmUgdGhlIGRhdGEgYW5kIHJldHVybiBudWxsXG4gKi9cbmNvbnN0IGdldEFjY291bnRTdG9yYWdlID0gKGtleSkgPT4ge1xuICAgIGNvbnN0IHJhd0FjY291bnRTdG9yYWdlID0gZ2V0SXRlbShrZXksIG51bGwpO1xuICAgIGlmICghcmF3QWNjb3VudFN0b3JhZ2UpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIGNvbXBhcmUgdGhlIGV4cGlyeSB0aW1lIG9mIHRoZSBpdGVtIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSA+IHJhd0FjY291bnRTdG9yYWdlLmV4cGlyeSB8fFxuICAgICAgICByYXdBY2NvdW50U3RvcmFnZS52ICE9PSBTREtfVkVSU0lPTikge1xuICAgICAgICByZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmF3QWNjb3VudFN0b3JhZ2UgPT09IG51bGwgfHwgcmF3QWNjb3VudFN0b3JhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd0FjY291bnRTdG9yYWdlLmRhdGE7XG59O1xuLyoqXG4gIEBwYXJhbSB7a2V5cy5LRVlfU0VTU0lPTn0ga2V5IC0ga2V5IHRvIHN0b3JlIHRoZSBkYXRhXG4gIEBwYXJhbSB7UHJvdmlkZXJTZXNzaW9ufSBkYXRhIC0gT25seSB0aGUgcGFydCBvZiBQcm92aWRlclNlc3Npb24gdGhhdCBuZWVkcyB0byBiZSB1cGRhdGVkXG4gIHtcbiAgICBjb25uZWN0ZWQ/OiBib29sZWFuO1xuICAgIGNvZGU/OiBzdHJpbmcgfCBudWxsO1xuICAgIGFjY291bnRzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXSB8IHVuZGVmaW5lZD47XG4gIH1cbiAgQHBhcmFtIHtudW1iZXJ9IGV4cGlyeSAtIGV4cGlyeSB0aW1lIG9mIHRoZSBkYXRhXG4qL1xuY29uc3Qgc2V0QWNjb3VudFN0b3JhZ2UgPSAoa2V5LCBkYXRhLCBleHBpcnkpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCByYXdBY2NvdW50U3RvcmFnZSA9IGdldEl0ZW0oa2V5KTtcbiAgICBjb25zdCBuZXdBY2NvdW50U3RvcmFnZSA9IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgY29kZTogKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5jb2RlKSB8fCAoKF9hID0gcmF3QWNjb3VudFN0b3JhZ2UgPT09IG51bGwgfHwgcmF3QWNjb3VudFN0b3JhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd0FjY291bnRTdG9yYWdlLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSxcbiAgICAgICAgICAgIGNvbm5lY3RlZDogISEoKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5jb2RlKSB8fCAoKF9iID0gcmF3QWNjb3VudFN0b3JhZ2UgPT09IG51bGwgfHwgcmF3QWNjb3VudFN0b3JhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd0FjY291bnRTdG9yYWdlLmRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb2RlKSksXG4gICAgICAgICAgICBhY2NvdW50czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoX2MgPSByYXdBY2NvdW50U3RvcmFnZSA9PT0gbnVsbCB8fCByYXdBY2NvdW50U3RvcmFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmF3QWNjb3VudFN0b3JhZ2UuZGF0YSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFjY291bnRzKSwgZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmFjY291bnRzKSxcbiAgICAgICAgfSxcbiAgICAgICAgZXhwaXJ5OiBleHBpcnkgfHxcbiAgICAgICAgICAgIChyYXdBY2NvdW50U3RvcmFnZSA9PT0gbnVsbCB8fCByYXdBY2NvdW50U3RvcmFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmF3QWNjb3VudFN0b3JhZ2UuZXhwaXJ5KSB8fFxuICAgICAgICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBMT0dJTl9QRVJTSVNUSU5HX1RJTUUsXG4gICAgICAgIHY6IFNES19WRVJTSU9OLFxuICAgIH07XG4gICAgc2V0SXRlbShrZXksIG5ld0FjY291bnRTdG9yYWdlKTtcbiAgICByZXR1cm47XG59O1xuY29uc3QgZ2V0Q2hhaW5BZGRyZXNzID0gKGtleSwgY2hhaW4pID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghKChfYSA9IGdldEFjY291bnRTdG9yYWdlKGtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSkge1xuICAgICAgICByZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKChfYiA9IGdldEFjY291bnRTdG9yYWdlKGtleSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hY2NvdW50c1tjaGFpbl0pIHx8IG51bGw7XG59O1xuY29uc3Qgc2V0Q2hhaW5BZGRyZXNzID0gKGtleSwgY2hhaW4sIGFjY291bnQpID0+IHtcbiAgICBzZXRBY2NvdW50U3RvcmFnZShrZXksIHsgYWNjb3VudHM6IHsgW2NoYWluXTogYWNjb3VudCB9IH0pO1xuICAgIHJldHVybjtcbn07XG5jb25zdCByZW1vdmVDaGFpbkFkZHJlc3MgPSAoa2V5LCBjaGFpbikgPT4ge1xuICAgIHNldEFjY291bnRTdG9yYWdlKGtleSwgeyBhY2NvdW50czogeyBbY2hhaW5dOiB1bmRlZmluZWQgfSB9KTtcbiAgICByZXR1cm47XG59O1xuXG4vKiBldGggc2VyaWVzIGNvbnN0YW50cyBiZWdpbiAqL1xuY29uc3QgRVRIX1JQQ19MSVNUID0ge1xuICAgIC8vIFRoaXMgaXMgdGhlIGxpc3Qgb2YgcHVibGljIFJQQyBlbmRwb2ludHMgdGhhdCB3ZSBrbm93biB0byBiZSB3b3JraW5nXG4gICAgLy8gVXNlZCB0byBoZWxwIGRldmVsb3BlcnMgZGlkIG5vdCBzZXQgdXAgdGhlaXIgb3duIFJQQyBlbmRwb2ludHNcbiAgICAvLyBCU0MgbWFpbm5ldFxuICAgIDU2OiAnaHR0cHM6Ly9ic2MtZGF0YXNlZWQxLmJpbmFuY2Uub3JnJyxcbiAgICAvLyBCU0MgdGVzdG5ldFxuICAgIDk3OiAnaHR0cHM6Ly9kYXRhLXNlZWQtcHJlYnNjLTEtczEuYmluYW5jZS5vcmc6ODU0NScsXG4gICAgLy8gUG9seWdvbiBNYWlubmV0XG4gICAgMTM3OiAnaHR0cHM6Ly9ycGMtbWFpbm5ldC5tYXRpY3ZpZ2lsLmNvbS8nLFxuICAgIC8vIFBvbHlnb24gVGVzdG5ldFxuICAgIDgwMDAxOiAnaHR0cHM6Ly9ycGMtbXVtYmFpLm1hdGljLnRvZGF5LycsXG4gICAgLy8gQXZhbGFuY2hlIE1haW5uZXRcbiAgICA0MzExNDogJ2h0dHBzOi8vYXBpLmF2YXgubmV0d29yay9leHQvYmMvQy9ycGMnLFxuICAgIC8vIEF2YWxhbmNoZSBGdWppIFRlc3RuZXRcbiAgICA0MzExMzogJ2h0dHBzOi8vYXBpLmF2YXgtdGVzdC5uZXR3b3JrL2V4dC9iYy9DL3JwYycsXG4gICAgLy8gQXJiaXRydW0gTWFpbm5ldFxuICAgIDQyMTYxOiAnaHR0cHM6Ly9hcmIxLmFyYml0cnVtLmlvL3JwYycsXG4gICAgLy8gQXJiaXRydW0gVGVzdG5ldFxuICAgIDQyMTYxMzogJ2h0dHBzOi8vZW5kcG9pbnRzLm9tbmlhdGVjaC5pby92MS9hcmJpdHJ1bS9nb2VybGkvcHVibGljJyxcbiAgICAvLyBPcHRpbWlzbSBNYWlubmV0XG4gICAgMTA6ICdodHRwczovL21haW5uZXQub3B0aW1pc20uaW8nLFxuICAgIC8vIE9wdGltaXNtIEdvZXJsaSBUZXN0bmV0XG4gICAgNDIwOiAnaHR0cHM6Ly9nb2VybGkub3B0aW1pc20uaW8nLFxufTtcbmNvbnN0IEVUSF9FTlZfV0FMTEVUX1NFUlZFUl9NQVBQSU5HID0ge1xuICAgIHByb2Q6ICdodHRwczovL3dhbGxldC12Mi5ibG9jdG8uYXBwJyxcbiAgICBzdGFnaW5nOiAnaHR0cHM6Ly93YWxsZXQtdjItc3RhZ2luZy5ibG9jdG8uYXBwJyxcbiAgICBkZXY6ICdodHRwczovL3dhbGxldC12Mi1kZXYuYmxvY3RvLmFwcCcsXG59O1xuY29uc3QgRVRIX1NFU1NJT05fS0VZX01BUFBJTkcgPSB7XG4gICAgcHJvZDogS0VZX1NFU1NJT04ucHJvZCxcbiAgICBzdGFnaW5nOiBLRVlfU0VTU0lPTi5zdGFnaW5nLFxuICAgIGRldjogS0VZX1NFU1NJT04uZGV2LFxufTtcbi8qIGV0aCBzZXJpZXMgY29uc3RhbnRzIGVuZCAqL1xuLyogc29sIGNvbnN0YW50cyBiZWdpbiAqL1xuY29uc3QgU09MX05FVCA9IHtcbiAgICBNYWlubmV0QmV0YTogJ21haW5uZXQtYmV0YScsXG4gICAgVGVzdG5ldDogJ3Rlc3RuZXQnLFxuICAgIERldm5ldDogJ2Rldm5ldCcsXG59O1xuY29uc3QgU09MX05FVF9TRVJWRVJfTUFQUElORyA9IHtcbiAgICBbU09MX05FVC5NYWlubmV0QmV0YV06ICdodHRwczovL3dhbGxldC12Mi5ibG9jdG8uYXBwJyxcbiAgICBbU09MX05FVC5EZXZuZXRdOiAnaHR0cHM6Ly93YWxsZXQtdjItZGV2LmJsb2N0by5hcHAnLFxuICAgIFtTT0xfTkVULlRlc3RuZXRdOiAnaHR0cHM6Ly93YWxsZXQtdjItZGV2LmJsb2N0by5hcHAnLFxufTtcbmNvbnN0IFNPTF9TRVNTSU9OX0tFWV9NQVBQSU5HID0ge1xuICAgIFtTT0xfTkVULk1haW5uZXRCZXRhXTogS0VZX1NFU1NJT04ucHJvZCxcbiAgICBbU09MX05FVC5EZXZuZXRdOiBLRVlfU0VTU0lPTi5kZXYsXG4gICAgW1NPTF9ORVQuVGVzdG5ldF06IEtFWV9TRVNTSU9OLmRldixcbn07XG4vKiBzb2wgY29uc3RhbnRzIGVuZCAqL1xuLyogYXB0b3MgY29uc3RhbnRzIGJlZ2luICovXG5jb25zdCBBUFRfU0VTU0lPTl9LRVlfTUFQUElORyA9IHtcbiAgICAxOiBLRVlfU0VTU0lPTi5wcm9kLFxuICAgIDI6IEtFWV9TRVNTSU9OLmRldixcbiAgICAzOiBLRVlfU0VTU0lPTi5kZXYsXG4gICAgNDogS0VZX1NFU1NJT04uZGV2LFxuICAgIDU6IEtFWV9TRVNTSU9OLnN0YWdpbmcsXG59O1xuY29uc3QgQVBUX0NIQUlOX0lEX1NFUlZFUl9NQVBQSU5HID0ge1xuICAgIC8vIE1BSU5ORVRcbiAgICAxOiAnaHR0cHM6Ly93YWxsZXQtdjIuYmxvY3RvLmFwcCcsXG4gICAgLy8gVEVTVE5FVFxuICAgIDI6ICdodHRwczovL3dhbGxldC12Mi1kZXYuYmxvY3RvLmFwcCcsXG4gICAgLy8gREVWTkVUXG4gICAgMzogJ2h0dHBzOi8vd2FsbGV0LXYyLWRldi5ibG9jdG8uYXBwJyxcbiAgICAvLyBURVNUSU5HXG4gICAgNDogJ2h0dHBzOi8vd2FsbGV0LXYyLWRldi5ibG9jdG8uYXBwJyxcbiAgICAvLyBQUkVNQUlOTkVUXG4gICAgNTogJ2h0dHBzOi8vd2FsbGV0LXYyLXN0YWdpbmcuYmxvY3RvLmFwcCcsXG59O1xudmFyIFdhbGxldEFkYXB0ZXJOZXR3b3JrO1xuKGZ1bmN0aW9uIChXYWxsZXRBZGFwdGVyTmV0d29yaykge1xuICAgIFdhbGxldEFkYXB0ZXJOZXR3b3JrW1wiTWFpbm5ldFwiXSA9IFwibWFpbm5ldFwiO1xuICAgIFdhbGxldEFkYXB0ZXJOZXR3b3JrW1wiVGVzdG5ldFwiXSA9IFwidGVzdG5ldFwiO1xuICAgIFdhbGxldEFkYXB0ZXJOZXR3b3JrW1wiRGV2bmV0XCJdID0gXCJkZXZuZXRcIjtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIlRlc3RpbmdcIl0gPSBcInRlc3RpbmdcIjtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIlByZW1haW5uZXRcIl0gPSBcInByZW1haW5uZXRcIjtcbn0pKFdhbGxldEFkYXB0ZXJOZXR3b3JrIHx8IChXYWxsZXRBZGFwdGVyTmV0d29yayA9IHt9KSk7XG5jb25zdCBBUFRfQ0hBSU5fSURfTkFNRV9NQVBQSU5HID0ge1xuICAgIDE6IFdhbGxldEFkYXB0ZXJOZXR3b3JrLk1haW5uZXQsXG4gICAgMjogV2FsbGV0QWRhcHRlck5ldHdvcmsuVGVzdG5ldCxcbiAgICAzOiBXYWxsZXRBZGFwdGVyTmV0d29yay5EZXZuZXQsXG4gICAgNDogV2FsbGV0QWRhcHRlck5ldHdvcmsuVGVzdGluZyxcbiAgICA1OiBXYWxsZXRBZGFwdGVyTmV0d29yay5QcmVtYWlubmV0LFxufTtcbmNvbnN0IEFQVF9DSEFJTl9JRF9SUENfTUFQUElORyA9IHtcbiAgICAxOiAnaHR0cHM6Ly9mdWxsbm9kZS5tYWlubmV0LmFwdG9zbGFicy5jb20vdjEnLFxuICAgIDI6ICdodHRwczovL2Z1bGxub2RlLnRlc3RuZXQuYXB0b3NsYWJzLmNvbS92MScsXG4gICAgMzogJ2h0dHBzOi8vZnVsbG5vZGUuZGV2bmV0LmFwdG9zbGFicy5jb20vdjEnLFxuICAgIDQ6ICcnLFxuICAgIDU6ICdodHRwczovL3ByZW1haW5uZXQuYXB0b3NkZXYuY29tL3YxJyxcbn07XG4vKiBhcHRvcyBjb25zdGFudHMgZW5kICovXG5jb25zdCBFSVAxMTkzX0VWRU5UUyA9IFtcbiAgICAnY29ubmVjdCcsXG4gICAgJ2Rpc2Nvbm5lY3QnLFxuICAgICdtZXNzYWdlJyxcbiAgICAnY2hhaW5DaGFuZ2VkJyxcbiAgICAnYWNjb3VudHNDaGFuZ2VkJyxcbl07XG4vLyBQcmVzZXJ2ZSBsb2dpbiBmb3IgMSBkYXlcbmNvbnN0IExPR0lOX1BFUlNJU1RJTkdfVElNRSA9IDg2NDAwICogMTAwMDtcbmNvbnN0IERFRkFVTFRfQVBQX0lEID0gJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7XG4vLyBXaWxsIGluamVjdCB0aGUgdmVyc2lvbiBvZiB0aGUgU0RLIGJ5IHJvbGx1cCB2ZXJzaW9uSW5qZWN0b3IgZHVyaW5nIGJ1aWxkIHRpbWVcbmNvbnN0IFNES19WRVJTSU9OID0gJzAuNS41JztcblxuLy8gVGhlIHJvb3QgY2xhc3MgZm9yIGFsbCBwcm92aWRlcnNcbmNsYXNzIEJsb2N0b1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pc0Jsb2N0byA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IHt9O1xuICAgICAgICAvLyBhbGlhcyByZW1vdmVMaXN0ZW5lclxuICAgICAgICB0aGlzLm9mZiA9IHRoaXMucmVtb3ZlTGlzdGVuZXI7XG4gICAgICAgIC8vIGluaXQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIEVJUDExOTNfRVZFTlRTLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcHBJZCA9IERFRkFVTFRfQVBQX0lEO1xuICAgIH1cbiAgICAvLyBpbXBsZW1lbnQgYnkgY2hpbGRyZW5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICByZXF1ZXN0KHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgfSk7XG4gICAgfVxuICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIUVJUDExOTNfRVZFTlRTLmluY2x1ZGVzKGV2ZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyc1tldmVudF0ucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8vIEB0b2RvOiBpbXBsZW1lbnQgaXRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBvbmNlKCkgeyB9XG4gICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0gPT09IGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyc1tldmVudF0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgSUZSQU1FX1NUWUxFID0gJ3dpZHRoOjEwMHZ3O2hlaWdodDoxMDAlO3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDt6LWluZGV4OjIxNDc0ODM2NDY7Ym9yZGVyOm5vbmU7Ym94LXNpemluZzpib3JkZXItYm94O2NvbG9yLXNjaGVtZTpsaWdodDtpbnNldDowcHg7ZGlzcGxheTpibG9jaztwb2ludGVyLWV2ZW50czphdXRvOyc7XG5mdW5jdGlvbiBjcmVhdGVGcmFtZSh1cmwpIHtcbiAgICBjb25zdCBmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGZyYW1lLnNldEF0dHJpYnV0ZSgnc3JjJywgdXJsKTtcbiAgICBmcmFtZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgSUZSQU1FX1NUWUxFKTtcbiAgICByZXR1cm4gZnJhbWU7XG59XG5mdW5jdGlvbiBhdHRhY2hGcmFtZShmcmFtZSkge1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZnJhbWUpO1xufVxuZnVuY3Rpb24gZGV0YXRjaEZyYW1lKGZyYW1lKSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IGZyYW1lICYmIGZyYW1lLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZnJhbWUpO1xuICAgIH1cbn1cblxudmFyIGFkZFNlbGZSZW1vdmFibGVIYW5kbGVyID0gKGV2ZW50VHlwZSwgaGFuZGxlciwgdGFyZ2V0ID0gd2luZG93KSA9PiB7XG4gICAgZnVuY3Rpb24gbGlzdGVuZXIoZSkge1xuICAgICAgICBjb25zdCByZW1vdmVFdmVudExpc3RlbmVyID0gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGhhbmRsZXIoZSwgcmVtb3ZlRXZlbnRMaXN0ZW5lcik7XG4gICAgfVxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xufTtcblxuZnVuY3Rpb24gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIGtleSwgZGlzY29ubmVjdEhhbmRsZXIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDMgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgIGlmIChkaXNjb25uZWN0SGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3RIYW5kbGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5tZXNzYWdlKSB8fCAndW5rbm93biBlcnJvcicpO1xuICAgICAgICAgICAgZS5lcnJvcl9jb2RlID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmVycm9yX2NvZGU7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfSk7XG59XG5cbmNvbnN0IGlzRW1haWwgPSAodmFsdWUpID0+IC9cXFMrQFxcUytcXC5cXFMrLy50ZXN0KHZhbHVlKTtcbmNvbnN0IGlzVmFsaWRUcmFuc2FjdGlvbiA9ICh0cmFuc2FjdGlvbikgPT4gKHR5cGVvZiB0cmFuc2FjdGlvbiA9PT0gJ29iamVjdCcgJiYgdHJhbnNhY3Rpb24gIT09IG51bGwgJiYgJ2Zyb20nIGluIHRyYW5zYWN0aW9uKTtcbmNvbnN0IGlzVmFsaWRUcmFuc2FjdGlvbnMgPSAodHJhbnNhY3Rpb25zKSA9PiAoQXJyYXkuaXNBcnJheSh0cmFuc2FjdGlvbnMpICYmIHRyYW5zYWN0aW9ucy5ldmVyeSh0eCA9PiBpc1ZhbGlkVHJhbnNhY3Rpb24odHgpKSk7XG5cbmZ1bmN0aW9uIGdldEV2bVN1cHBvcnQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrcyB9ID0geWllbGQgZmV0Y2goJ2h0dHBzOi8vYXBpLmJsb2N0by5hcHAvbmV0d29ya3MvZXZtJykudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSk7XG4gICAgICAgIGNvbnN0IGV2bVN1cHBvcnRNYXAgPSBuZXR3b3Jrcy5yZWR1Y2UoKGEsIHYpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGEpLCB7IFt2LmNoYWluX2lkXTogdiB9KSksIHt9KTtcbiAgICAgICAgcmV0dXJuIGV2bVN1cHBvcnRNYXA7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbnZhciBkaXN0ID0ge307XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9LCBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCkpIHtcbiAgICBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3QuYmluZCgpO1xuICB9IGVsc2Uge1xuICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcbiAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICB9O1xuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbnZhciBjbGFzc2VzID0ge307XG5cbnZhciBmYXN0U2FmZVN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbnN0cmluZ2lmeVtcImRlZmF1bHRcIl0gPSBzdHJpbmdpZnk7XG5zdHJpbmdpZnkuc3RhYmxlID0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeTtcbnN0cmluZ2lmeS5zdGFibGVTdHJpbmdpZnkgPSBkZXRlcm1pbmlzdGljU3RyaW5naWZ5O1xudmFyIExJTUlUX1JFUExBQ0VfTk9ERSA9ICdbLi4uXSc7XG52YXIgQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFID0gJ1tDaXJjdWxhcl0nO1xudmFyIGFyciA9IFtdO1xudmFyIHJlcGxhY2VyU3RhY2sgPSBbXTtcbmZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zKCkge1xuICByZXR1cm4ge1xuICAgIGRlcHRoTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgIGVkZ2VzTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gIH07XG59XG5cbi8vIFJlZ3VsYXIgc3RyaW5naWZ5XG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKTtcbiAgfVxuICBkZWNpcmMob2JqLCAnJywgMCwgW10sIHVuZGVmaW5lZCwgMCwgb3B0aW9ucyk7XG4gIHZhciByZXM7XG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpO1xuICAgIH1cbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSgnW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXScpO1xuICB9IGZpbmFsbHkge1xuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKTtcbiAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHNldFJlcGxhY2UocmVwbGFjZSwgdmFsLCBrLCBwYXJlbnQpIHtcbiAgdmFyIHByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBrKTtcbiAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyZW50LCBrLCB7XG4gICAgICAgIHZhbHVlOiByZXBsYWNlXG4gICAgICB9KTtcbiAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbCwgcHJvcGVydHlEZXNjcmlwdG9yXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGxhY2VyU3RhY2sucHVzaChbdmFsLCBrLCByZXBsYWNlXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcmVudFtrXSA9IHJlcGxhY2U7XG4gICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlY2lyYyh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgZGVwdGggKz0gMTtcbiAgdmFyIGk7XG4gIGlmIChfdHlwZW9mKHZhbCkgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXQpIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSAndW5kZWZpbmVkJyAmJiBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGFjay5wdXNoKHZhbCk7XG4gICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWNpcmModmFsW2ldLCBpLCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBkZWNpcmModmFsW2tleV0sIGtleSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKTtcbiAgfVxufVxuXG4vLyBTdGFibGUtc3RyaW5naWZ5XG5mdW5jdGlvbiBjb21wYXJlRnVuY3Rpb24oYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljU3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKCk7XG4gIH1cbiAgdmFyIHRtcCA9IGRldGVybWluaXN0aWNEZWNpcmMob2JqLCAnJywgMCwgW10sIHVuZGVmaW5lZCwgMCwgb3B0aW9ucykgfHwgb2JqO1xuICB2YXIgcmVzO1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlciwgc3BhY2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlR2V0dGVyVmFsdWVzKHJlcGxhY2VyKSwgc3BhY2VyKTtcbiAgICB9XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJ1t1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV0nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXN0b3JlIHRoZSBvYmplY3QgYXMgaXQgd2FzLlxuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKTtcbiAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNEZWNpcmModmFsLCBrLCBlZGdlSW5kZXgsIHN0YWNrLCBwYXJlbnQsIGRlcHRoLCBvcHRpb25zKSB7XG4gIGRlcHRoICs9IDE7XG4gIHZhciBpO1xuICBpZiAoX3R5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgIHNldFJlcGxhY2UoQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXQpIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSAndW5kZWZpbmVkJyAmJiBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGFjay5wdXNoKHZhbCk7XG4gICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtpXSwgaSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkgb2JqZWN0IGluIHRoZSByZXF1aXJlZCB3YXlcbiAgICAgIHZhciB0bXAgPSB7fTtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKS5zb3J0KGNvbXBhcmVGdW5jdGlvbik7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgIHRtcFtrZXldID0gdmFsW2tleV07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhcmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSk7XG4gICAgICAgIHBhcmVudFtrXSA9IHRtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0bXA7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YWNrLnBvcCgpO1xuICB9XG59XG5cbi8vIHdyYXBzIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB2YWx1ZXMgd2UgY291bGRuJ3QgcmVwbGFjZVxuLy8gYW5kIG1hcmsgdGhlbSBhcyByZXBsYWNlZCB2YWx1ZVxuZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlcikge1xuICByZXBsYWNlciA9IHR5cGVvZiByZXBsYWNlciAhPT0gJ3VuZGVmaW5lZCcgPyByZXBsYWNlciA6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGxhY2VyU3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSByZXBsYWNlclN0YWNrW2ldO1xuICAgICAgICBpZiAocGFydFsxXSA9PT0ga2V5ICYmIHBhcnRbMF0gPT09IHZhbCkge1xuICAgICAgICAgIHZhbCA9IHBhcnRbMl07XG4gICAgICAgICAgcmVwbGFjZXJTdGFjay5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NlcywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuY2xhc3Nlcy5FdGhlcmV1bVByb3ZpZGVyRXJyb3IgPSBjbGFzc2VzLkV0aGVyZXVtUnBjRXJyb3IgPSB2b2lkIDA7XG52YXIgZmFzdF9zYWZlX3N0cmluZ2lmeV8xID0gZmFzdFNhZmVTdHJpbmdpZnk7XG4vKipcbiAqIEVycm9yIHN1YmNsYXNzIGltcGxlbWVudGluZyBKU09OIFJQQyAyLjAgZXJyb3JzIGFuZCBFdGhlcmV1bSBSUEMgZXJyb3JzXG4gKiBwZXIgRUlQLTE0NzQuXG4gKiBQZXJtaXRzIGFueSBpbnRlZ2VyIGVycm9yIGNvZGUuXG4gKi9cbnZhciBFdGhlcmV1bVJwY0Vycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKEV0aGVyZXVtUnBjRXJyb3IsIF9FcnJvcik7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRXRoZXJldW1ScGNFcnJvcik7XG4gIGZ1bmN0aW9uIEV0aGVyZXVtUnBjRXJyb3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXRoZXJldW1ScGNFcnJvcik7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9uZW1wdHkgc3RyaW5nLicpO1xuICAgIH1cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwbGFpbiBvYmplY3Qgd2l0aCBhbGwgcHVibGljIGNsYXNzIHByb3BlcnRpZXMuXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoRXRoZXJldW1ScGNFcnJvciwgW3tcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHZhciBzZXJpYWxpemVkID0ge1xuICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXJpYWxpemVkLmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGFjaykge1xuICAgICAgICBzZXJpYWxpemVkLnN0YWNrID0gdGhpcy5zdGFjaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNlcmlhbGl6ZWQgZXJyb3IsIG9taXR0aW5nXG4gICAgICogYW55IGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gZmFzdF9zYWZlX3N0cmluZ2lmeV8xW1wiZGVmYXVsdFwiXSh0aGlzLnNlcmlhbGl6ZSgpLCBzdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBFdGhlcmV1bVJwY0Vycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcbmNsYXNzZXMuRXRoZXJldW1ScGNFcnJvciA9IEV0aGVyZXVtUnBjRXJyb3I7XG4vKipcbiAqIEVycm9yIHN1YmNsYXNzIGltcGxlbWVudGluZyBFdGhlcmV1bSBQcm92aWRlciBlcnJvcnMgcGVyIEVJUC0xMTkzLlxuICogUGVybWl0cyBpbnRlZ2VyIGVycm9yIGNvZGVzIGluIHRoZSBbIDEwMDAgPD0gNDk5OSBdIHJhbmdlLlxuICovXG52YXIgRXRoZXJldW1Qcm92aWRlckVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXRoZXJldW1ScGNFcnJvcikge1xuICBfaW5oZXJpdHMoRXRoZXJldW1Qcm92aWRlckVycm9yLCBfRXRoZXJldW1ScGNFcnJvcik7XG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKEV0aGVyZXVtUHJvdmlkZXJFcnJvcik7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gRXRoZXJldW0gUHJvdmlkZXIgSlNPTi1SUEMgZXJyb3IuXG4gICAqIGBjb2RlYCBtdXN0IGJlIGFuIGludGVnZXIgaW4gdGhlIDEwMDAgPD0gNDk5OSByYW5nZS5cbiAgICovXG4gIGZ1bmN0aW9uIEV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV0aGVyZXVtUHJvdmlkZXJFcnJvcik7XG4gICAgaWYgKCFpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlciBzdWNoIHRoYXQ6IDEwMDAgPD0gY29kZSA8PSA0OTk5Jyk7XG4gICAgfVxuICAgIHJldHVybiBfc3VwZXIyLmNhbGwodGhpcywgY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFdGhlcmV1bVByb3ZpZGVyRXJyb3IpO1xufShFdGhlcmV1bVJwY0Vycm9yKTtcbmNsYXNzZXMuRXRoZXJldW1Qcm92aWRlckVycm9yID0gRXRoZXJldW1Qcm92aWRlckVycm9yO1xuLy8gSW50ZXJuYWxcbmZ1bmN0aW9uIGlzVmFsaWRFdGhQcm92aWRlckNvZGUoY29kZSkge1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihjb2RlKSAmJiBjb2RlID49IDEwMDAgJiYgY29kZSA8PSA0OTk5O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5UmVwbGFjZXIoXywgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSAnW0NpcmN1bGFyXScpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIHV0aWxzID0ge307XG5cbnZhciBlcnJvckNvbnN0YW50cyA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3JDb25zdGFudHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmVycm9yQ29uc3RhbnRzLmVycm9yVmFsdWVzID0gZXJyb3JDb25zdGFudHMuZXJyb3JDb2RlcyA9IHZvaWQgMDtcbmVycm9yQ29uc3RhbnRzLmVycm9yQ29kZXMgPSB7XG4gIHJwYzoge1xuICAgIGludmFsaWRJbnB1dDogLTMyMDAwLFxuICAgIHJlc291cmNlTm90Rm91bmQ6IC0zMjAwMSxcbiAgICByZXNvdXJjZVVuYXZhaWxhYmxlOiAtMzIwMDIsXG4gICAgdHJhbnNhY3Rpb25SZWplY3RlZDogLTMyMDAzLFxuICAgIG1ldGhvZE5vdFN1cHBvcnRlZDogLTMyMDA0LFxuICAgIGxpbWl0RXhjZWVkZWQ6IC0zMjAwNSxcbiAgICBwYXJzZTogLTMyNzAwLFxuICAgIGludmFsaWRSZXF1ZXN0OiAtMzI2MDAsXG4gICAgbWV0aG9kTm90Rm91bmQ6IC0zMjYwMSxcbiAgICBpbnZhbGlkUGFyYW1zOiAtMzI2MDIsXG4gICAgaW50ZXJuYWw6IC0zMjYwM1xuICB9LFxuICBwcm92aWRlcjoge1xuICAgIHVzZXJSZWplY3RlZFJlcXVlc3Q6IDQwMDEsXG4gICAgdW5hdXRob3JpemVkOiA0MTAwLFxuICAgIHVuc3VwcG9ydGVkTWV0aG9kOiA0MjAwLFxuICAgIGRpc2Nvbm5lY3RlZDogNDkwMCxcbiAgICBjaGFpbkRpc2Nvbm5lY3RlZDogNDkwMVxuICB9XG59O1xuZXJyb3JDb25zdGFudHMuZXJyb3JWYWx1ZXMgPSB7XG4gICctMzI3MDAnOiB7XG4gICAgc3RhbmRhcmQ6ICdKU09OIFJQQyAyLjAnLFxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIEpTT04gd2FzIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXIuIEFuIGVycm9yIG9jY3VycmVkIG9uIHRoZSBzZXJ2ZXIgd2hpbGUgcGFyc2luZyB0aGUgSlNPTiB0ZXh0LidcbiAgfSxcbiAgJy0zMjYwMCc6IHtcbiAgICBzdGFuZGFyZDogJ0pTT04gUlBDIDIuMCcsXG4gICAgbWVzc2FnZTogJ1RoZSBKU09OIHNlbnQgaXMgbm90IGEgdmFsaWQgUmVxdWVzdCBvYmplY3QuJ1xuICB9LFxuICAnLTMyNjAxJzoge1xuICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcbiAgICBtZXNzYWdlOiAnVGhlIG1ldGhvZCBkb2VzIG5vdCBleGlzdCAvIGlzIG5vdCBhdmFpbGFibGUuJ1xuICB9LFxuICAnLTMyNjAyJzoge1xuICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBtZXRob2QgcGFyYW1ldGVyKHMpLidcbiAgfSxcbiAgJy0zMjYwMyc6IHtcbiAgICBzdGFuZGFyZDogJ0pTT04gUlBDIDIuMCcsXG4gICAgbWVzc2FnZTogJ0ludGVybmFsIEpTT04tUlBDIGVycm9yLidcbiAgfSxcbiAgJy0zMjAwMCc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBpbnB1dC4nXG4gIH0sXG4gICctMzIwMDEnOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgbWVzc2FnZTogJ1Jlc291cmNlIG5vdCBmb3VuZC4nXG4gIH0sXG4gICctMzIwMDInOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgbWVzc2FnZTogJ1Jlc291cmNlIHVuYXZhaWxhYmxlLidcbiAgfSxcbiAgJy0zMjAwMyc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICBtZXNzYWdlOiAnVHJhbnNhY3Rpb24gcmVqZWN0ZWQuJ1xuICB9LFxuICAnLTMyMDA0Jzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTE0NzQnLFxuICAgIG1lc3NhZ2U6ICdNZXRob2Qgbm90IHN1cHBvcnRlZC4nXG4gIH0sXG4gICctMzIwMDUnOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgbWVzc2FnZTogJ1JlcXVlc3QgbGltaXQgZXhjZWVkZWQuJ1xuICB9LFxuICAnNDAwMSc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICBtZXNzYWdlOiAnVXNlciByZWplY3RlZCB0aGUgcmVxdWVzdC4nXG4gIH0sXG4gICc0MTAwJzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxuICAgIG1lc3NhZ2U6ICdUaGUgcmVxdWVzdGVkIGFjY291bnQgYW5kL29yIG1ldGhvZCBoYXMgbm90IGJlZW4gYXV0aG9yaXplZCBieSB0aGUgdXNlci4nXG4gIH0sXG4gICc0MjAwJzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxuICAgIG1lc3NhZ2U6ICdUaGUgcmVxdWVzdGVkIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgRXRoZXJldW0gcHJvdmlkZXIuJ1xuICB9LFxuICAnNDkwMCc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICBtZXNzYWdlOiAnVGhlIHByb3ZpZGVyIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIGFsbCBjaGFpbnMuJ1xuICB9LFxuICAnNDkwMSc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICBtZXNzYWdlOiAnVGhlIHByb3ZpZGVyIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBzcGVjaWZpZWQgY2hhaW4uJ1xuICB9XG59O1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0cy5zZXJpYWxpemVFcnJvciA9IGV4cG9ydHMuaXNWYWxpZENvZGUgPSBleHBvcnRzLmdldE1lc3NhZ2VGcm9tQ29kZSA9IGV4cG9ydHMuSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0UgPSB2b2lkIDA7XG4gIHZhciBlcnJvcl9jb25zdGFudHNfMSA9IGVycm9yQ29uc3RhbnRzO1xuICB2YXIgY2xhc3Nlc18xID0gY2xhc3NlcztcbiAgdmFyIEZBTExCQUNLX0VSUk9SX0NPREUgPSBlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5pbnRlcm5hbDtcbiAgdmFyIEZBTExCQUNLX01FU1NBR0UgPSAnVW5zcGVjaWZpZWQgZXJyb3IgbWVzc2FnZS4gVGhpcyBpcyBhIGJ1ZywgcGxlYXNlIHJlcG9ydCBpdC4nO1xuICB2YXIgRkFMTEJBQ0tfRVJST1IgPSB7XG4gICAgY29kZTogRkFMTEJBQ0tfRVJST1JfQ09ERSxcbiAgICBtZXNzYWdlOiBnZXRNZXNzYWdlRnJvbUNvZGUoRkFMTEJBQ0tfRVJST1JfQ09ERSlcbiAgfTtcbiAgZXhwb3J0cy5KU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSA9ICdVbnNwZWNpZmllZCBzZXJ2ZXIgZXJyb3IuJztcbiAgLyoqXG4gICAqIEdldHMgdGhlIG1lc3NhZ2UgZm9yIGEgZ2l2ZW4gY29kZSwgb3IgYSBmYWxsYmFjayBtZXNzYWdlIGlmIHRoZSBjb2RlIGhhc1xuICAgKiBubyBjb3JyZXNwb25kaW5nIG1lc3NhZ2UuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRNZXNzYWdlRnJvbUNvZGUoY29kZSkge1xuICAgIHZhciBmYWxsYmFja01lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IEZBTExCQUNLX01FU1NBR0U7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcbiAgICAgIHZhciBjb2RlU3RyaW5nID0gY29kZS50b1N0cmluZygpO1xuICAgICAgaWYgKGhhc0tleShlcnJvcl9jb25zdGFudHNfMS5lcnJvclZhbHVlcywgY29kZVN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yX2NvbnN0YW50c18xLmVycm9yVmFsdWVzW2NvZGVTdHJpbmddLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNKc29uUnBjU2VydmVyRXJyb3IoY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFja01lc3NhZ2U7XG4gIH1cbiAgZXhwb3J0cy5nZXRNZXNzYWdlRnJvbUNvZGUgPSBnZXRNZXNzYWdlRnJvbUNvZGU7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIGNvZGUgaXMgdmFsaWQuXG4gICAqIEEgY29kZSBpcyBvbmx5IHZhbGlkIGlmIGl0IGhhcyBhIG1lc3NhZ2UuXG4gICAqL1xuICBmdW5jdGlvbiBpc1ZhbGlkQ29kZShjb2RlKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjb2RlU3RyaW5nID0gY29kZS50b1N0cmluZygpO1xuICAgIGlmIChlcnJvcl9jb25zdGFudHNfMS5lcnJvclZhbHVlc1tjb2RlU3RyaW5nXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBleHBvcnRzLmlzVmFsaWRDb2RlID0gaXNWYWxpZENvZGU7XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBlcnJvciB0byBhbiBFdGhlcmV1bSBKU09OIFJQQy1jb21wYXRpYmxlIGVycm9yIG9iamVjdC5cbiAgICogTWVyZWx5IGNvcGllcyB0aGUgZ2l2ZW4gZXJyb3IncyB2YWx1ZXMgaWYgaXQgaXMgYWxyZWFkeSBjb21wYXRpYmxlLlxuICAgKiBJZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgbm90IGZ1bGx5IGNvbXBhdGlibGUsIGl0IHdpbGwgYmUgcHJlc2VydmVkIG9uIHRoZVxuICAgKiByZXR1cm5lZCBvYmplY3QncyBkYXRhLm9yaWdpbmFsRXJyb3IgcHJvcGVydHkuXG4gICAqL1xuICBmdW5jdGlvbiBzZXJpYWxpemVFcnJvcihlcnJvcikge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgIF9yZWYkZmFsbGJhY2tFcnJvciA9IF9yZWYuZmFsbGJhY2tFcnJvcixcbiAgICAgIGZhbGxiYWNrRXJyb3IgPSBfcmVmJGZhbGxiYWNrRXJyb3IgPT09IHZvaWQgMCA/IEZBTExCQUNLX0VSUk9SIDogX3JlZiRmYWxsYmFja0Vycm9yLFxuICAgICAgX3JlZiRzaG91bGRJbmNsdWRlU3RhID0gX3JlZi5zaG91bGRJbmNsdWRlU3RhY2ssXG4gICAgICBzaG91bGRJbmNsdWRlU3RhY2sgPSBfcmVmJHNob3VsZEluY2x1ZGVTdGEgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRzaG91bGRJbmNsdWRlU3RhO1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCFmYWxsYmFja0Vycm9yIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGZhbGxiYWNrRXJyb3IuY29kZSkgfHwgdHlwZW9mIGZhbGxiYWNrRXJyb3IubWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGZhbGxiYWNrIGVycm9yIHdpdGggaW50ZWdlciBudW1iZXIgY29kZSBhbmQgc3RyaW5nIG1lc3NhZ2UuJyk7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGNsYXNzZXNfMS5FdGhlcmV1bVJwY0Vycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3Iuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIHZhciBzZXJpYWxpemVkID0ge307XG4gICAgaWYgKGVycm9yICYmIF90eXBlb2YoZXJyb3IpID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShlcnJvcikgJiYgaGFzS2V5KGVycm9yLCAnY29kZScpICYmIGlzVmFsaWRDb2RlKGVycm9yLmNvZGUpKSB7XG4gICAgICB2YXIgX2Vycm9yID0gZXJyb3I7XG4gICAgICBzZXJpYWxpemVkLmNvZGUgPSBfZXJyb3IuY29kZTtcbiAgICAgIGlmIChfZXJyb3IubWVzc2FnZSAmJiB0eXBlb2YgX2Vycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQubWVzc2FnZSA9IF9lcnJvci5tZXNzYWdlO1xuICAgICAgICBpZiAoaGFzS2V5KF9lcnJvciwgJ2RhdGEnKSkge1xuICAgICAgICAgIHNlcmlhbGl6ZWQuZGF0YSA9IF9lcnJvci5kYXRhO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpYWxpemVkLm1lc3NhZ2UgPSBnZXRNZXNzYWdlRnJvbUNvZGUoc2VyaWFsaXplZC5jb2RlKTtcbiAgICAgICAgc2VyaWFsaXplZC5kYXRhID0ge1xuICAgICAgICAgIG9yaWdpbmFsRXJyb3I6IGFzc2lnbk9yaWdpbmFsRXJyb3IoZXJyb3IpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWQuY29kZSA9IGZhbGxiYWNrRXJyb3IuY29kZTtcbiAgICAgIHZhciBtZXNzYWdlID0gKF9hID0gZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlO1xuICAgICAgc2VyaWFsaXplZC5tZXNzYWdlID0gbWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyBtZXNzYWdlIDogZmFsbGJhY2tFcnJvci5tZXNzYWdlO1xuICAgICAgc2VyaWFsaXplZC5kYXRhID0ge1xuICAgICAgICBvcmlnaW5hbEVycm9yOiBhc3NpZ25PcmlnaW5hbEVycm9yKGVycm9yKVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHN0YWNrID0gKF9iID0gZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGFjaztcbiAgICBpZiAoc2hvdWxkSW5jbHVkZVN0YWNrICYmIGVycm9yICYmIHN0YWNrICYmIHR5cGVvZiBzdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNlcmlhbGl6ZWQuc3RhY2sgPSBzdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgZXhwb3J0cy5zZXJpYWxpemVFcnJvciA9IHNlcmlhbGl6ZUVycm9yO1xuICAvLyBJbnRlcm5hbFxuICBmdW5jdGlvbiBpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gLTMyMDk5ICYmIGNvZGUgPD0gLTMyMDAwO1xuICB9XG4gIGZ1bmN0aW9uIGFzc2lnbk9yaWdpbmFsRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgJiYgX3R5cGVvZihlcnJvcikgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGVycm9yKSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0tleShvYmosIGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9XG59KSh1dGlscyk7XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBudWxsID09IGFyciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gX2kpIHtcbiAgICB2YXIgX3MsXG4gICAgICBfZSxcbiAgICAgIF94LFxuICAgICAgX3IsXG4gICAgICBfYXJyID0gW10sXG4gICAgICBfbiA9ICEwLFxuICAgICAgX2QgPSAhMTtcbiAgICB0cnkge1xuICAgICAgaWYgKF94ID0gKF9pID0gX2kuY2FsbChhcnIpKS5uZXh0LCAwID09PSBpKSB7XG4gICAgICAgIGlmIChPYmplY3QoX2kpICE9PSBfaSkgcmV0dXJuO1xuICAgICAgICBfbiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKF9uID0gKF9zID0gX3guY2FsbChfaSkpLmRvbmUpICYmIChfYXJyLnB1c2goX3MudmFsdWUpLCBfYXJyLmxlbmd0aCAhPT0gaSk7IF9uID0gITApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSAhMCwgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgbnVsbCAhPSBfaVtcInJldHVyblwiXSAmJiAoX3IgPSBfaVtcInJldHVyblwiXSgpLCBPYmplY3QoX3IpICE9PSBfcikpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfYXJyO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG52YXIgZXJyb3JzID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvcnMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmVycm9ycy5ldGhFcnJvcnMgPSB2b2lkIDA7XG52YXIgY2xhc3Nlc18xID0gY2xhc3NlcztcbnZhciB1dGlsc18xID0gdXRpbHM7XG52YXIgZXJyb3JfY29uc3RhbnRzXzEgPSBlcnJvckNvbnN0YW50cztcbmVycm9ycy5ldGhFcnJvcnMgPSB7XG4gIHJwYzoge1xuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBQYXJzZSAoLTMyNzAwKSBlcnJvci5cbiAgICAgKi9cbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLnBhcnNlLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludmFsaWQgUmVxdWVzdCAoLTMyNjAwKSBlcnJvci5cbiAgICAgKi9cbiAgICBpbnZhbGlkUmVxdWVzdDogZnVuY3Rpb24gaW52YWxpZFJlcXVlc3QoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludmFsaWRSZXF1ZXN0LCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludmFsaWQgUGFyYW1zICgtMzI2MDIpIGVycm9yLlxuICAgICAqL1xuICAgIGludmFsaWRQYXJhbXM6IGZ1bmN0aW9uIGludmFsaWRQYXJhbXMoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludmFsaWRQYXJhbXMsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgTWV0aG9kIE5vdCBGb3VuZCAoLTMyNjAxKSBlcnJvci5cbiAgICAgKi9cbiAgICBtZXRob2ROb3RGb3VuZDogZnVuY3Rpb24gbWV0aG9kTm90Rm91bmQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLm1ldGhvZE5vdEZvdW5kLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludGVybmFsICgtMzI2MDMpIGVycm9yLlxuICAgICAqL1xuICAgIGludGVybmFsOiBmdW5jdGlvbiBpbnRlcm5hbChhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMuaW50ZXJuYWwsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgU2VydmVyIGVycm9yLlxuICAgICAqIFBlcm1pdHMgaW50ZWdlciBlcnJvciBjb2RlcyBpbiB0aGUgWyAtMzIwOTkgPD0gLTMyMDA1IF0gcmFuZ2UuXG4gICAgICogQ29kZXMgLTMyMDAwIHRocm91Z2ggLTMyMDA0IGFyZSByZXNlcnZlZCBieSBFSVAtMTQ3NC5cbiAgICAgKi9cbiAgICBzZXJ2ZXI6IGZ1bmN0aW9uIHNlcnZlcihvcHRzKSB7XG4gICAgICBpZiAoIW9wdHMgfHwgX3R5cGVvZihvcHRzKSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V0aGVyZXVtIFJQQyBTZXJ2ZXIgZXJyb3JzIG11c3QgcHJvdmlkZSBzaW5nbGUgb2JqZWN0IGFyZ3VtZW50LicpO1xuICAgICAgfVxuICAgICAgdmFyIGNvZGUgPSBvcHRzLmNvZGU7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29kZSkgfHwgY29kZSA+IC0zMjAwNSB8fCBjb2RlIDwgLTMyMDk5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyIHN1Y2ggdGhhdDogLTMyMDk5IDw9IGNvZGUgPD0gLTMyMDA1Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGNvZGUsIG9wdHMpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIEludmFsaWQgSW5wdXQgKC0zMjAwMCkgZXJyb3IuXG4gICAgICovXG4gICAgaW52YWxpZElucHV0OiBmdW5jdGlvbiBpbnZhbGlkSW5wdXQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludmFsaWRJbnB1dCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBSZXNvdXJjZSBOb3QgRm91bmQgKC0zMjAwMSkgZXJyb3IuXG4gICAgICovXG4gICAgcmVzb3VyY2VOb3RGb3VuZDogZnVuY3Rpb24gcmVzb3VyY2VOb3RGb3VuZChhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMucmVzb3VyY2VOb3RGb3VuZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBSZXNvdXJjZSBVbmF2YWlsYWJsZSAoLTMyMDAyKSBlcnJvci5cbiAgICAgKi9cbiAgICByZXNvdXJjZVVuYXZhaWxhYmxlOiBmdW5jdGlvbiByZXNvdXJjZVVuYXZhaWxhYmxlKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5yZXNvdXJjZVVuYXZhaWxhYmxlLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIFRyYW5zYWN0aW9uIFJlamVjdGVkICgtMzIwMDMpIGVycm9yLlxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uUmVqZWN0ZWQ6IGZ1bmN0aW9uIHRyYW5zYWN0aW9uUmVqZWN0ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLnRyYW5zYWN0aW9uUmVqZWN0ZWQsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgTWV0aG9kIE5vdCBTdXBwb3J0ZWQgKC0zMjAwNCkgZXJyb3IuXG4gICAgICovXG4gICAgbWV0aG9kTm90U3VwcG9ydGVkOiBmdW5jdGlvbiBtZXRob2ROb3RTdXBwb3J0ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBMaW1pdCBFeGNlZWRlZCAoLTMyMDA1KSBlcnJvci5cbiAgICAgKi9cbiAgICBsaW1pdEV4Y2VlZGVkOiBmdW5jdGlvbiBsaW1pdEV4Y2VlZGVkKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5saW1pdEV4Y2VlZGVkLCBhcmcpO1xuICAgIH1cbiAgfSxcbiAgcHJvdmlkZXI6IHtcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgVXNlciBSZWplY3RlZCBSZXF1ZXN0ICg0MDAxKSBlcnJvci5cbiAgICAgKi9cbiAgICB1c2VyUmVqZWN0ZWRSZXF1ZXN0OiBmdW5jdGlvbiB1c2VyUmVqZWN0ZWRSZXF1ZXN0KGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0LCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVuYXV0aG9yaXplZCAoNDEwMCkgZXJyb3IuXG4gICAgICovXG4gICAgdW5hdXRob3JpemVkOiBmdW5jdGlvbiB1bmF1dGhvcml6ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBVbnN1cHBvcnRlZCBNZXRob2QgKDQyMDApIGVycm9yLlxuICAgICAqL1xuICAgIHVuc3VwcG9ydGVkTWV0aG9kOiBmdW5jdGlvbiB1bnN1cHBvcnRlZE1ldGhvZChhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucHJvdmlkZXIudW5zdXBwb3J0ZWRNZXRob2QsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgTm90IENvbm5lY3RlZCAoNDkwMCkgZXJyb3IuXG4gICAgICovXG4gICAgZGlzY29ubmVjdGVkOiBmdW5jdGlvbiBkaXNjb25uZWN0ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnByb3ZpZGVyLmRpc2Nvbm5lY3RlZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBDaGFpbiBOb3QgQ29ubmVjdGVkICg0OTAxKSBlcnJvci5cbiAgICAgKi9cbiAgICBjaGFpbkRpc2Nvbm5lY3RlZDogZnVuY3Rpb24gY2hhaW5EaXNjb25uZWN0ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnByb3ZpZGVyLmNoYWluRGlzY29ubmVjdGVkLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgY3VzdG9tIEV0aGVyZXVtIFByb3ZpZGVyIGVycm9yLlxuICAgICAqL1xuICAgIGN1c3RvbTogZnVuY3Rpb24gY3VzdG9tKG9wdHMpIHtcbiAgICAgIGlmICghb3B0cyB8fCBfdHlwZW9mKG9wdHMpICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXRoZXJldW0gUHJvdmlkZXIgY3VzdG9tIGVycm9ycyBtdXN0IHByb3ZpZGUgc2luZ2xlIG9iamVjdCBhcmd1bWVudC4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2RlID0gb3B0cy5jb2RlLFxuICAgICAgICBtZXNzYWdlID0gb3B0cy5tZXNzYWdlLFxuICAgICAgICBkYXRhID0gb3B0cy5kYXRhO1xuICAgICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZVwiIG11c3QgYmUgYSBub25lbXB0eSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgY2xhc3Nlc18xLkV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9XG4gIH1cbn07XG4vLyBJbnRlcm5hbFxuZnVuY3Rpb24gZ2V0RXRoSnNvblJwY0Vycm9yKGNvZGUsIGFyZykge1xuICB2YXIgX3BhcnNlT3B0cyA9IHBhcnNlT3B0cyhhcmcpLFxuICAgIF9wYXJzZU9wdHMyID0gX3NsaWNlZFRvQXJyYXkoX3BhcnNlT3B0cywgMiksXG4gICAgbWVzc2FnZSA9IF9wYXJzZU9wdHMyWzBdLFxuICAgIGRhdGEgPSBfcGFyc2VPcHRzMlsxXTtcbiAgcmV0dXJuIG5ldyBjbGFzc2VzXzEuRXRoZXJldW1ScGNFcnJvcihjb2RlLCBtZXNzYWdlIHx8IHV0aWxzXzEuZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIGdldEV0aFByb3ZpZGVyRXJyb3IoY29kZSwgYXJnKSB7XG4gIHZhciBfcGFyc2VPcHRzMyA9IHBhcnNlT3B0cyhhcmcpLFxuICAgIF9wYXJzZU9wdHM0ID0gX3NsaWNlZFRvQXJyYXkoX3BhcnNlT3B0czMsIDIpLFxuICAgIG1lc3NhZ2UgPSBfcGFyc2VPcHRzNFswXSxcbiAgICBkYXRhID0gX3BhcnNlT3B0czRbMV07XG4gIHJldHVybiBuZXcgY2xhc3Nlc18xLkV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlIHx8IHV0aWxzXzEuZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIHBhcnNlT3B0cyhhcmcpIHtcbiAgaWYgKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFthcmddO1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IGFyZy5tZXNzYWdlLFxuICAgICAgICBkYXRhID0gYXJnLmRhdGE7XG4gICAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgc3RyaW5nIG1lc3NhZ2UuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW21lc3NhZ2UgfHwgdW5kZWZpbmVkLCBkYXRhXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0cy5nZXRNZXNzYWdlRnJvbUNvZGUgPSBleHBvcnRzLnNlcmlhbGl6ZUVycm9yID0gZXhwb3J0cy5FdGhlcmV1bVByb3ZpZGVyRXJyb3IgPSBleHBvcnRzLkV0aGVyZXVtUnBjRXJyb3IgPSBleHBvcnRzLmV0aEVycm9ycyA9IGV4cG9ydHMuZXJyb3JDb2RlcyA9IHZvaWQgMDtcbiAgdmFyIGNsYXNzZXNfMSA9IGNsYXNzZXM7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyZXVtUnBjRXJyb3JcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gY2xhc3Nlc18xLkV0aGVyZXVtUnBjRXJyb3I7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXRoZXJldW1Qcm92aWRlckVycm9yXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGNsYXNzZXNfMS5FdGhlcmV1bVByb3ZpZGVyRXJyb3I7XG4gICAgfVxuICB9KTtcbiAgdmFyIHV0aWxzXzEgPSB1dGlscztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VyaWFsaXplRXJyb3JcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdXRpbHNfMS5zZXJpYWxpemVFcnJvcjtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRNZXNzYWdlRnJvbUNvZGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdXRpbHNfMS5nZXRNZXNzYWdlRnJvbUNvZGU7XG4gICAgfVxuICB9KTtcbiAgdmFyIGVycm9yc18xID0gZXJyb3JzO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJldGhFcnJvcnNcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZXJyb3JzXzEuZXRoRXJyb3JzO1xuICAgIH1cbiAgfSk7XG4gIHZhciBlcnJvcl9jb25zdGFudHNfMSA9IGVycm9yQ29uc3RhbnRzO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlcnJvckNvZGVzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXM7XG4gICAgfVxuICB9KTtcbn0pKGRpc3QpO1xuXG52YXIgZ2xvYmFsJDEgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6XG4gIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSk7XG5cbnZhciBsb29rdXAgPSBbXTtcbnZhciByZXZMb29rdXAgPSBbXTtcbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXk7XG52YXIgaW5pdGVkID0gZmFsc2U7XG5mdW5jdGlvbiBpbml0ICgpIHtcbiAgaW5pdGVkID0gdHJ1ZTtcbiAgdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbG9va3VwW2ldID0gY29kZVtpXTtcbiAgICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gIH1cblxuICByZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjI7XG4gIHJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2Mztcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICBpZiAoIWluaXRlZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFycjtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGg7XG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHBsYWNlSG9sZGVycyA9IGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDA7XG5cbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuO1xuXG4gIHZhciBMID0gMDtcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldO1xuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGO1xuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7XG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGO1xuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpO1xuICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMik7XG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRjtcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcDtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSk7XG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgaWYgKCFpbml0ZWQpIHtcbiAgICBpbml0KCk7XG4gIH1cbiAgdmFyIHRtcDtcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aDtcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzOyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MzsgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSk7XG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl07XG4gICAgb3V0cHV0ICs9ICc9PSc7XG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSk7XG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSAnPSc7XG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dCk7XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIHJlYWQgKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG07XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSAtNztcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMDtcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxO1xuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5mdW5jdGlvbiB3cml0ZSAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGM7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApO1xuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpO1xuICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7XG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn1cblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIElOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsJDEuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsJDEuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHRydWU7XG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmtNYXhMZW5ndGgoKTtcblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MjsgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIHJldHVybiBhcnJcbn07XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufTtcblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGU7XG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5O1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikgO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn07XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59O1xuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufTtcblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7XG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpO1xuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1O1xuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoOyAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKGludGVybmFsSXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMDtcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbik7XG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKTtcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuQnVmZmVyLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5mdW5jdGlvbiBpbnRlcm5hbElzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYSkgfHwgIWludGVybmFsSXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufTtcblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGk7XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gIHZhciBwb3MgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcyk7XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufTtcblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMDtcbiAgc3RhcnQgPj4+PSAwO1xuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZTtcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl07XG4gIGJbbl0gPSBiW21dO1xuICBiW21dID0gaTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpO1xuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNyk7XG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpO1xuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNCk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDA7XG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIG1heCA9IElOU1BFQ1RfTUFYX0JZVEVTO1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJyk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJztcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwO1xuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDA7XG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDA7XG4gIGVuZCA+Pj49IDA7XG4gIHRoaXNTdGFydCA+Pj49IDA7XG4gIHRoaXNFbmQgPj4+PSAwO1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0O1xuICB2YXIgeSA9IGVuZCAtIHN0YXJ0O1xuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSk7XG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpO1xuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV07XG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufTtcblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0O1xuICAgIGJ5dGVPZmZzZXQgPSAwO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmY7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwO1xuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDsgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0O1xuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMDtcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKTtcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRjsgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMTtcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoO1xuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMjtcbiAgICAgIGFyckxlbmd0aCAvPSAyO1xuICAgICAgdmFsTGVuZ3RoIC89IDI7XG4gICAgICBieXRlT2Zmc2V0IC89IDI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpO1xuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4O1xuICAgICAgICBmb3VuZEluZGV4ID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoO1xuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59O1xuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDA7XG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTtcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkO1xuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIG9mZnNldCA9IDA7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgb2Zmc2V0ID0gMDtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMDtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4JztcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nO1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59O1xuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG4gIHZhciByZXMgPSBbXTtcblxuICB2YXIgaSA9IHN0YXJ0O1xuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV07XG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGw7XG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxO1xuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludDtcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM107XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkQ7XG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGO1xuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwO1xuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnO1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3Rik7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJztcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG5cbiAgdmFyIG91dCA9ICcnO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pO1xuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1Nik7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBzdGFydCA9IH5+c3RhcnQ7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmQ7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlbjtcbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlbjtcbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbjtcbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMDtcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW47XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIHZhciBuZXdCdWY7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCk7XG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59O1xuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXTtcbiAgdmFyIG11bCA9IDE7XG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgfVxuICBtdWwgKj0gMHg4MDtcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciBpID0gYnl0ZUxlbmd0aDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV07XG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWw7XG4gIH1cbiAgbXVsICo9IDB4ODA7XG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCk7XG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpO1xuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufTtcblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICB9XG5cbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gIHZhciBtdWwgPSAxO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDg7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDE7XG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMTtcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKTtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQpO1xuICB9XG4gIHdyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCk7XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59O1xuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4KTtcbiAgfVxuICB3cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpO1xuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufTtcblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDA7XG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7XG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMDtcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQ7XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIHZhciBpO1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbGVuXG59O1xuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZDtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1O1xuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwO1xuXG4gIGlmICghdmFsKSB2YWwgPSAwO1xuXG4gIHZhciBpO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBpbnRlcm5hbElzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSk7XG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn07XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nO1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpO1xuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSc7XG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHk7XG4gIHZhciBjb2RlUG9pbnQ7XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG4gIHZhciBieXRlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvO1xuICB2YXIgYnl0ZUFycmF5ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGkgPSBjID4+IDg7XG4gICAgbG8gPSBjICUgMjU2O1xuICAgIGJ5dGVBcnJheS5wdXNoKGxvKTtcbiAgICBieXRlQXJyYXkucHVzaChoaSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiB0b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG4vLyB0aGUgZm9sbG93aW5nIGlzIGZyb20gaXMtYnVmZmVyLCBhbHNvIGJ5IEZlcm9zcyBBYm91a2hhZGlqZWggYW5kIHdpdGggc2FtZSBsaXNlbmNlXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5mdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmICghIW9iai5faXNCdWZmZXIgfHwgaXNGYXN0QnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikpXG59XG5cbmZ1bmN0aW9uIGlzRmFzdEJ1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzRmFzdEJ1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cbmNvbnN0IGlzSGV4U3RyaW5nID0gKGhleCkgPT4gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgJiYgL14weFswLTlBLUZhLWZdKiQvLnRlc3QoaGV4KTtcbmNvbnN0IHV0ZjhUb0hleCA9IChzdHIpID0+IHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCAndXRmOCcpLnRvU3RyaW5nKCdoZXgnKTtcbn07XG5cbnZhciBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMsIF9FdGhlcmV1bVByb3ZpZGVyX2FkZFRvU3dpdGNoYWJsZSwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZDtcbmZ1bmN0aW9uIHBhcnNlQ2hhaW5JZChjaGFpbklkKSB7XG4gICAgaWYgKCFjaGFpbklkKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoYWluSWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBjaGFpbklkO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFpbklkLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGNoYWluSWQsIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KGNoYWluSWQsIDEwKTtcbn1cbmNsYXNzIEV0aGVyZXVtUHJvdmlkZXIgZXh0ZW5kcyBCbG9jdG9Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoeyBjaGFpbklkLCBycGMsIHdhbGxldFNlcnZlciwgYXBwSWQgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gJzEnOyAvLyBzYW1lIGFzIGNoYWluSWQgYnV0IGluIGRlY2ltYWxcbiAgICAgICAgLy8gc2V0dXAgY2hhaW5JZFxuICAgICAgICBpbnZhcmlhbnQoY2hhaW5JZCwgXCInY2hhaW5JZCcgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIHRoaXMubmV0d29ya1ZlcnNpb24gPSBgJHtwYXJzZUNoYWluSWQoY2hhaW5JZCl9YDtcbiAgICAgICAgdGhpcy5jaGFpbklkID0gYDB4JHtwYXJzZUNoYWluSWQoY2hhaW5JZCkudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgIC8vIHNldHVwIHJwY1xuICAgICAgICB0aGlzLnJwYyA9IHJwYyB8fCBFVEhfUlBDX0xJU1RbdGhpcy5uZXR3b3JrVmVyc2lvbl07XG4gICAgICAgIGludmFyaWFudCh0aGlzLnJwYywgXCIncnBjJyBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgLy8gc2V0dXAgaW5qZWN0ZWRXYWxsZXRTZXJ2ZXJcbiAgICAgICAgdGhpcy5pbmplY3RlZFdhbGxldFNlcnZlciA9IHdhbGxldFNlcnZlcjtcbiAgICAgICAgLy8gTk9URTogX2Jsb2N0byBpcyBub3QgZnVsbHkgaW5pdGlhbGl6ZWQgeWV0IGF0IHRoaXMgcG9pbnRcbiAgICAgICAgLy8gQW55IGZ1bmN0aW9uIHNob3VsZCBjYWxsICNnZXRCbG9jdG9Qcm9wZXJ0aWVzKCkgdG8gZ2V0IHRoZSBmdWxsIF9ibG9jdG8gcHJvcGVydGllc1xuICAgICAgICB0aGlzLl9ibG9jdG8gPSB7XG4gICAgICAgICAgICBzZXNzaW9uS2V5OiBLRVlfU0VTU0lPTi5wcm9kLFxuICAgICAgICAgICAgd2FsbGV0U2VydmVyOiB0aGlzLmluamVjdGVkV2FsbGV0U2VydmVyIHx8ICcnLFxuICAgICAgICAgICAgYmxvY2tjaGFpbk5hbWU6ICcnLFxuICAgICAgICAgICAgbmV0d29ya1R5cGU6ICcnLFxuICAgICAgICAgICAgc3VwcG9ydE5ldHdvcmtMaXN0OiB7fSxcbiAgICAgICAgICAgIHN3aXRjaGFibGVOZXR3b3JrOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkIHx8IERFRkFVTFRfQVBQX0lEO1xuICAgIH1cbiAgICAvLyBERVBSRUNBVEVEIEFQSTogc2VlIGh0dHBzOi8vZG9jcy5tZXRhbWFzay5pby9ndWlkZS9ldGhlcmV1bS1wcm92aWRlci5odG1sI2V0aGVyZXVtLXNlbmQtZGVwcmVjYXRlZFxuICAgIHNlbmQobWV0aG9kT3JQYXlsb2FkLCBwYXJhbXNPckNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBzaWduYXR1cmUgdHlwZSAxOiBhcmcxIC0gSlNPTi1SUEMgcGF5bG9hZCwgYXJnMiAtIGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIC8vIGV0aGVyZXVtLnNlbmQocGF5bG9hZDogSnNvblJwY1JlcXVlc3QsIGNhbGxiYWNrOiBKc29uUnBjQ2FsbGJhY2spOiB2b2lkO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2lnbmF0dXJlIGlzIGV4YWN0bHkgbGlrZSBldGhlcmV1bS5zZW5kQXN5bmMoKVxuICAgICAgICAgICAgICAgIGNhc2UgcGFyYW1zT3JDYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kQXN5bmMobWV0aG9kT3JQYXlsb2FkLCBwYXJhbXNPckNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAvLyBzaWduYXR1cmUgdHlwZSAyOiBhcmcxIC0gSlNPTi1SUEMgbWV0aG9kIG5hbWUsIGFyZzIgLSBwYXJhbXMgYXJyYXk7XG4gICAgICAgICAgICAgICAgLy8gZXRoZXJldW0uc2VuZChtZXRob2Q6IHN0cmluZywgcGFyYW1zPzogQXJyYXk8dW5rbm93bj4pOiBQcm9taXNlPEpzb25ScGNSZXNwb25zZT47XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaWduYXR1cmUgaXMgbGlrZSBhbiBhc3luYyBldGhlcmV1bS5zZW5kQXN5bmMoKSB3aXRoIG1ldGhvZCBhbmQgcGFyYW1zIGFzIGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIGEgSlNPTi1SUEMgcGF5bG9hZCBhbmQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVvZiBtZXRob2RPclBheWxvYWQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocGFyYW1zT3JDYWxsYmFjayk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kT3JQYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNPckNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBzaWduYXR1cmUgdHlwZSAzOiBhcmcxIC0gSlNPTi1SUEMgcGF5bG9hZChzaG91bGQgYmUgc3luY2hyb25vdXMgbWV0aG9kcylcbiAgICAgICAgICAgICAgICAvLyBldGhlcmV1bS5zZW5kKHBheWxvYWQ6IEpzb25ScGNSZXF1ZXN0KTogdW5rbm93bjtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNpZ25hdHVyZSBlbmFibGVzIHlvdSB0byBjYWxsIHNvbWUgdHlwZSBvZiBSUEMgbWV0aG9kcyBzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEFzeW5jKG1ldGhvZE9yUGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBERVBSRUNBVEVEIEFQSTogc2VlIGh0dHBzOi8vZG9jcy5tZXRhbWFzay5pby9ndWlkZS9ldGhlcmV1bS1wcm92aWRlci5odG1sI2xlZ2FjeS1tZXRob2RzIGltcGxlbWVudGF0aW9uXG4gICAgLy8gd2ViMyB2MS54IEJhdGNoUmVxdWVzdCBzdGlsbCBkZXBlbmRzIG9uIGl0IHNvIHdlIG5lZWQgdG8gaW1wbGVtZW50IGFueXdheSDCr1xcXyjjg4QpXy/Cr1xuICAgIHNlbmRBc3luYyhwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlUmVxdWVzdCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gd2ViMyB2MS54IGNvbmNhdCBiYXRjaGVkIEpTT04tUlBDIHJlcXVlc3RzIHRvIGFuIGFycmF5LCBoYW5kbGUgaXQgaGVyZVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgdHJhbnNhY3Rpb25zIGFuZCBzZW5kIGJhdGNoIHdpdGggY3VzdG9tIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChyZXF1ZXN0KSA9PiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgocmVxdWVzdCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSByZXF1ZXN0LnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWRCYXNlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXRjaGVkUmVxdWVzdFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdibG9jdG9fc2VuZEJhdGNoVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB0cmFuc2FjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoUmVzcG9uc2VQcm9taXNlID0gdGhpcy5yZXF1ZXN0KGJhdGNoZWRSZXF1ZXN0UGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RzID0gcGF5bG9hZC5tYXAoKHsgbWV0aG9kLCBwYXJhbXMgfSwgaW5kZXgpID0+IG1ldGhvZCA9PT0gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGJhdGNoUmVzcG9uc2VQcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkQmFzZSArIGluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlIHJlc3BvbnNlIHdoZW4gYWxsIHJlcXVlc3QgYXJlIGV4ZWN1dGVkXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsU2V0dGxlZChyZXF1ZXN0cylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChyZXNwb25zZXMpID0+IHJlc29sdmUocmVzcG9uc2VzLm1hcCgocmVzcG9uc2UsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBTdHJpbmcoaWRCYXNlICsgaW5kZXggKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHBheWxvYWRbaW5kZXhdLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3BvbnNlLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogcmVzcG9uc2Uuc3RhdHVzICE9PSAnZnVsZmlsbGVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLnJlYXNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGF5bG9hZCksIHsgaWQ6IE51bWJlcihwYXlsb2FkLmlkKSB9KSkudGhlbihyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgY2FsbGJhY2sgb3IgcmV0dXJuIHByb21pc2UsIGRlcGRlbmRzIG9uIGNhbGxiYWNrIGFyZyBnaXZlbiBvciBub3RcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGhhbmRsZVJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IGNhbGxiYWNrKG51bGwsIGRhdGEpKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiBjYWxsYmFjayhlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlcXVlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kaW5nIHVzZXJPcGVyYXRpb24gdXNpbmcgQmxvY3RvIFNESy5cbiAgICAgKiBAcGFyYW0ge0lVc2VyT3BlcmF0aW9ufSB1c2VyT3AgLSB1c2VyT3BlcmF0aW9uIG9iamVjdFxuICAgICAqIEByZW1hcmtzIE5vIG5lZWQgdG8gaW5jbHVkZSBub25jZSwgaW5pdENvZGUsIGFuZCBzaWduYXR1cmUgYXMgcGFyYW1ldGVycyB3aGVuIHVzaW5nIEJsb2N0b1NESyB0byBzZW5kIHVzZXJPcGVyYXRpb24uXG4gICAgICogVGhlc2UgcGFyYW1ldGVycyB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSB1c2VyT3BlcmF0aW9uIGhhc2hcbiAgICAgKi9cbiAgICBzZW5kVXNlck9wZXJhdGlvbih1c2VyT3ApIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9zZW5kVXNlck9wZXJhdGlvbicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbdXNlck9wXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWVzdChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaztcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghKHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5tZXRob2QpKVxuICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUmVxdWVzdCgpO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5ldGhlcmV1bTtcbiAgICAgICAgICAgIGlmIChleGlzdGVkU0RLICYmIGV4aXN0ZWRTREsuaXNCbG9jdG8pIHtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgPT09ICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoKF9iID0gKF9hID0gcGF5bG9hZCA9PT0gbnVsbCB8fCBwYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsucmVxdWVzdChwYXlsb2FkKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXR3b3JrVmVyc2lvbiA9IGAke3BhcnNlQ2hhaW5JZCgoX2EgPSBwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0uY2hhaW5JZCl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhaW5JZCA9IGAweCR7cGFyc2VDaGFpbklkKChfYiA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5wYXJhbXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlswXS5jaGFpbklkKS50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnBjID0gKF9jID0gc3dpdGNoYWJsZU5ldHdvcmsgPT09IG51bGwgfHwgc3dpdGNoYWJsZU5ldHdvcmsgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN3aXRjaGFibGVOZXR3b3JrW3RoaXMubmV0d29ya1ZlcnNpb25dKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucnBjX3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsucmVxdWVzdChwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgYmxvY2tjaGFpbk5hbWUsIHN3aXRjaGFibGVOZXR3b3JrLCBzZXNzaW9uS2V5IH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvLyBtZXRob2QgdGhhdCBkb2Vzbid0IHJlcXVpcmUgdXNlciB0byBiZSBjb25uZWN0ZWRcbiAgICAgICAgICAgIHN3aXRjaCAocGF5bG9hZC5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdldGhfY2hhaW5JZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhaW5JZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV0X3ZlcnNpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtWZXJzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbic6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZFN3aXRjaGFibGVOZXR3b3JrKChwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQucGFyYW1zKSB8fCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9jYWxsJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuaGFuZGxlUmVhZFJlcXVlc3RzKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlIHx8IChyZXNwb25zZSAmJiAhcmVzcG9uc2UucmVzdWx0ICYmIHJlc3BvbnNlLmVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gKChfYyA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5lcnJvcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZS5lcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnUmVxdWVzdCBmYWlsZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludGVybmFsKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKChfZSA9IChfZCA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5wYXJhbXMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZFswXSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNoYWluSWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q2hhaW5JZCA9IHBheWxvYWQucGFyYW1zWzBdLmNoYWluSWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2V0Q2hhaW5BZGRyZXNzKHNlc3Npb25LZXksIGJsb2NrY2hhaW5OYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlyZWN0bHkgc3dpdGNoIG5ldHdvcmsgaWYgdXNlciBpcyBub3QgY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBhZGQgYSBjb25maXJtIHN3aXRjaCBuZXR3b3JrIGRpYWxvZ1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGhhc2VkQ2hhaW5JZCA9IHBhcnNlQ2hhaW5JZChuZXdDaGFpbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3dpdGNoYWJsZU5ldHdvcmtbcGhhc2VkQ2hhaW5JZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci5jdXN0b20oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiA0OTAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgVW5yZWNvZ25pemVkIGNoYWluIElEIFwiJHtuZXdDaGFpbklkfVwiLiBUcnkgYWRkaW5nIHRoZSBjaGFpbiB1c2luZyB3YWxsZXRfYWRkRXRoZXJldW1DaGFpbiBmaXJzdC5gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXR3b3JrVmVyc2lvbiA9IGAke3BoYXNlZENoYWluSWR9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhaW5JZCA9IGAweCR7cGhhc2VkQ2hhaW5JZC50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnBjID0gc3dpdGNoYWJsZU5ldHdvcmtbcGhhc2VkQ2hhaW5JZF0ucnBjX3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuY2hhaW5DaGFuZ2VkLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcih0aGlzLmNoYWluSWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ldGhvZCB0aGF0IHJlcXVpcmVzIHVzZXIgdG8gYmUgY29ubmVjdGVkXG4gICAgICAgICAgICBpZiAoIWdldENoYWluQWRkcmVzcyhzZXNzaW9uS2V5LCBibG9ja2NoYWluTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWFpbCA9IChfZiA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5wYXJhbXMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZlswXTtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgPT09ICdldGhfcmVxdWVzdEFjY291bnRzJyAmJiBpc0VtYWlsKGVtYWlsKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmVuYWJsZShlbWFpbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9yZXF1ZXN0QWNjb3VudHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5mZXRjaEFjY291bnRzKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfYWNjb3VudHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2V0Q2hhaW5BZGRyZXNzKHNlc3Npb25LZXksIGJsb2NrY2hhaW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfY29pbmJhc2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAoX2cgPSBnZXRDaGFpbkFkZHJlc3Moc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUpKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfc2lnblR5cGVkRGF0YV92Myc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zaWduVHlwZWREYXRhJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ25UeXBlZERhdGFfdjQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdwZXJzb25hbF9zaWduJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ24nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCB0aGlzLmhhbmRsZVNpZ24ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3YWxsZXRfZGlzY29ubmVjdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zZW5kVHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgdGhpcy5oYW5kbGVTZW5kVHJhbnNhY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmxvY3RvX3NlbmRCYXRjaFRyYW5zYWN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuaGFuZGxlU2VuZEJhdGNoVHJhbnNhY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ25UcmFuc2FjdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCdNZXRob2QgTm90IFN1cHBvcnRlZDogJyArIHBheWxvYWQubWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfc2VuZFVzZXJPcGVyYXRpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgdGhpcy5oYW5kbGVTZW5kVXNlck9wZXJhdGlvbihwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKChfaiA9IChfaCA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5wYXJhbXMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaFswXSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmNoYWluSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZEFjY291bnQgPSAoX2sgPSBnZXRDaGFpbkFkZHJlc3Moc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUpKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2tbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRDaGFpbklkID0gdGhpcy5jaGFpbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q2hhaW5JZCA9IHBheWxvYWQucGFyYW1zWzBdLmNoYWluSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN3aXRjaGFibGVOZXR3b3JrW3BhcnNlQ2hhaW5JZChuZXdDaGFpbklkKV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci5jdXN0b20oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiA0OTAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgVW5yZWNvZ25pemVkIGNoYWluIElEIFwiJHtwYXJzZUNoYWluSWQocGF5bG9hZC5wYXJhbXNbMF0uY2hhaW5JZCl9XCIuIFRyeSBhZGRpbmcgdGhlIGNoYWluIHVzaW5nIHdhbGxldF9hZGRFdGhlcmV1bUNoYWluIGZpcnN0LmAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gYCR7cGFyc2VDaGFpbklkKG5ld0NoYWluSWQpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYWluSWQgPSBgMHgke3BhcnNlQ2hhaW5JZChuZXdDaGFpbklkKS50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnBjID0gc3dpdGNoYWJsZU5ldHdvcmtbdGhpcy5uZXR3b3JrVmVyc2lvbl0ucnBjX3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZW5hYmxlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoW25ld0FjY291bnRdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdBY2NvdW50ICE9PSBvbGRBY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2NvdW50c0NoYW5nZWQuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKFtuZXdBY2NvdW50XSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmNoYWluQ2hhbmdlZC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIodGhpcy5jaGFpbklkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV0d29ya1ZlcnNpb24gPSBgJHtwYXJzZUNoYWluSWQob2xkQ2hhaW5JZCl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYWluSWQgPSBgMHgke3BhcnNlQ2hhaW5JZChvbGRDaGFpbklkKS50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJwYyA9IHN3aXRjaGFibGVOZXR3b3JrW3RoaXMubmV0d29ya1ZlcnNpb25dLnJwY191cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9lc3RpbWF0ZVVzZXJPcGVyYXRpb25HYXMnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfZ2V0VXNlck9wZXJhdGlvbkJ5SGFzaCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9nZXRVc2VyT3BlcmF0aW9uUmVjZWlwdCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zdXBwb3J0ZWRFbnRyeVBvaW50cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCB0aGlzLmhhbmRsZUJ1bmRsZXIocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0geWllbGQgdGhpcy5oYW5kbGVSZWFkUmVxdWVzdHMocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiAhcmVzcG9uc2UucmVzdWx0ICYmIHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHJlc3BvbnNlLmVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2UuZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAnUmVxdWVzdCBmYWlsZWQnO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYmxvY3RvQXBpKHVybCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdhbGxldFNlcnZlciwgYmxvY2tjaGFpbk5hbWUsIHNlc3Npb25LZXkgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2EgPSBnZXRBY2NvdW50U3RvcmFnZShzZXNzaW9uS2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpIHx8ICcnO1xuICAgICAgICAgICAgaWYgKCFzZXNzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci51bmF1dGhvcml6ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmZXRjaChgJHt3YWxsZXRTZXJ2ZXJ9L2FwaS8ke2Jsb2NrY2hhaW5OYW1lfSR7dXJsfWAsIE9iamVjdC5hc3NpZ24oeyBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0gfSwgb3B0aW9ucykpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZVNlc3Npb25HdWFyZChyZXNwb25zZSwgc2Vzc2lvbktleSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmV2ZW50TGlzdGVuZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuZGlzY29ubmVjdGVkKCkpKTtcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLmVycm9yX2NvZGUpID09PSAndW5zdXBwb3J0ZWRfbWV0aG9kJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCdNZXRob2QgTm90IFN1cHBvcnRlZDogJyArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuc2VydmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IC0zMjAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBCbG9jdG8gc2VydmVyIGVycm9yOiAke2UubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3BvbnNlTGlzdGVuZXIoZnJhbWUsIG9iamVjdEtleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyB3YWxsZXRTZXJ2ZXIgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlRXZlbnRMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBldmVudDtcbiAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gPT09IHdhbGxldFNlcnZlciAmJlxuICAgICAgICAgICAgICAgICAgICBlLmRhdGEudHlwZSA9PT0gJ0VUSDpGUkFNRTpSRVNQT05TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdBUFBST1ZFRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGUuZGF0YVtvYmplY3RLZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0RFQ0xJTkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuZXJyb3JDb2RlID09PSAnaW5jb3JyZWN0X3Nlc3Npb25faWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdChlLmRhdGEuZXJyb3JNZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnRVRIOkZSQU1FOkNMT1NFJykge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChkaXN0LmV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KCdVc2VyIGRlY2xpbmVkIHRoZSByZXF1ZXN0JykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldElmcmFtZSh1cmwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnByb3ZpZGVyLmN1c3RvbSh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IDEwMDEsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdCbG9jdG8gU0RLIG9ubHkgd29ya3MgaW4gYnJvd3NlciBlbnZpcm9ubWVudCcsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHdhbGxldFNlcnZlciwgYmxvY2tjaGFpbk5hbWUgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lID0gY3JlYXRlRnJhbWUoYCR7d2FsbGV0U2VydmVyfS8ke3RoaXMuYXBwSWR9LyR7YmxvY2tjaGFpbk5hbWV9JHt1cmx9YCk7XG4gICAgICAgICAgICBhdHRhY2hGcmFtZShmcmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlaXAtMTEwMiBhbGlhc1xuICAgIC8vIERFUFJFQ0FURUQgQVBJOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vRUlQcy9ibG9iL21hc3Rlci9FSVBTL2VpcC0xMTAyLm1kXG4gICAgZW5hYmxlKGVtYWlsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdhbGxldFNlcnZlciwgYmxvY2tjaGFpbk5hbWUsIHNlc3Npb25LZXkgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuZXRoZXJldW07XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESyAmJiBleGlzdGVkU0RLLmlzQmxvY3RvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0ZWRTREsuY2hhaW5JZCAhPT0gdGhpcy5jaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGV4aXN0ZWRTREsucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IHRoaXMuY2hhaW5JZCB9XSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGV4aXN0ZWRTREsucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IHRoaXMuY2hhaW5JZCB9XSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNldENoYWluQWRkcmVzcyhzZXNzaW9uS2V5LCBibG9ja2NoYWluTmFtZSwgW2V4aXN0ZWRTREsuYWRkcmVzc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gXG4gICAgICAgICAgICAgICAgLy8gYWRkIGEgc21hbGwgZGVsYXkgdG8gbWFrZSBzdXJlIHRoZSBuZXR3b3JrIGhhcyBiZWVuIHN3aXRjaGVkXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBleGlzdGVkU0RLLmVuYWJsZSgpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KSwgMTApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRDaGFpbkFkZHJlc3Moc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoJ2w2bicsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICAgICAgcGFyYW1zLnNldCgndicsIFNES19WRVJTSU9OKTtcbiAgICAgICAgICAgIGNvbnN0IGVtYWlsUGFyYW0gPSBlbWFpbCAmJiBpc0VtYWlsKGVtYWlsKSA/IGAvJHtlbWFpbH1gIDogJyc7XG4gICAgICAgICAgICBjb25zdCBsb2dpbkZyYW1lID0geWllbGQgdGhpcy5zZXRJZnJhbWUoYC9hdXRobiR7ZW1haWxQYXJhbX0/JHtwYXJhbXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIoJ21lc3NhZ2UnLCAoZXZlbnQsIHJlbW92ZUxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gPT09IHdhbGxldFNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnRVRIOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGxvZ2luRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25uZWN0LmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcih7IGNoYWluSWQ6IHRoaXMuY2hhaW5JZCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QWNjb3VudFN0b3JhZ2Uoc2Vzc2lvbktleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBlLmRhdGEuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Jsb2NrY2hhaW5OYW1lXTogW2UuZGF0YS5hZGRyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBlLmRhdGEuZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtlLmRhdGEuYWRkcl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnRVRIOkZSQU1FOkNMT1NFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGxvZ2luRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChkaXN0LmV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoQWNjb3VudHMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IGJsb2NrY2hhaW5OYW1lLCBzZXNzaW9uS2V5IH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSB5aWVsZCB0aGlzLmJsb2N0b0FwaShgL2FjY291bnRzYCk7XG4gICAgICAgICAgICBzZXRDaGFpbkFkZHJlc3Moc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUsIGFjY291bnRzKTtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVJlYWRSZXF1ZXN0cyhwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2godGhpcy5ycGMsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKHsgaWQ6IDEsIGpzb25ycGM6ICcyLjAnIH0sIHBheWxvYWQpKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludGVybmFsKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVTaWduKHsgbWV0aG9kLCBwYXJhbXMgfSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAnZXRoX3NpZ24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBpc0hleFN0cmluZyhwYXJhbXNbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmFtc1sxXS5zbGljZSgyKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1dGY4VG9IZXgocGFyYW1zWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0aG9kID09PSAncGVyc29uYWxfc2lnbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGlzSGV4U3RyaW5nKHBhcmFtc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyYW1zWzBdLnNsaWNlKDIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHV0ZjhUb0hleChwYXJhbXNbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChbXG4gICAgICAgICAgICAgICAgICAgICdldGhfc2lnblR5cGVkRGF0YScsXG4gICAgICAgICAgICAgICAgICAgICdldGhfc2lnblR5cGVkRGF0YV92MycsXG4gICAgICAgICAgICAgICAgICAgICdldGhfc2lnblR5cGVkRGF0YV92NCcsXG4gICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBwYXJhbXNbMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9tYWluIH0gPSBKU09OLnBhcnNlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoZG9tYWluLmNoYWluSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhgUHJvdmlkZWQgY2hhaW5JZCBcIiR7ZG9tYWluLmNoYWluSWR9XCIgbXVzdCBiZSBhIG51bWJlcmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUNoYWluSWQoZG9tYWluLmNoYWluSWQpICE9PSBwYXJzZUNoYWluSWQodGhpcy5jaGFpbklkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoYFByb3ZpZGVkIGNoYWluSWQgXCIke2RvbWFpbi5jaGFpbklkfVwiIG11c3QgbWF0Y2ggdGhlIGFjdGl2ZSBjaGFpbklkIFwiJHtwYXJzZUNoYWluSWQodGhpcy5jaGFpbklkKX1cImApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9jaGVja05ldHdvcmtNYXRjaGVkKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgeyBzaWduYXR1cmVJZCB9ID0geWllbGQgdGhpcy5ibG9jdG9BcGkoYC91c2VyLXNpZ25hdHVyZWAsIHsgbWV0aG9kOiAnUE9TVCcsIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgbWV0aG9kLCBtZXNzYWdlIH0pIH0pO1xuICAgICAgICAgICAgY29uc3Qgc2lnbkZyYW1lID0geWllbGQgdGhpcy5zZXRJZnJhbWUoYC91c2VyLXNpZ25hdHVyZS8ke3NpZ25hdHVyZUlkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VMaXN0ZW5lcihzaWduRnJhbWUsICdzaWduYXR1cmUnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVNlbmRUcmFuc2FjdGlvbihwYXlsb2FkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZFRyYW5zYWN0aW9uKChfYSA9IHBheWxvYWQucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgYXV0aG9yaXphdGlvbklkIH0gPSB5aWVsZCB0aGlzLmJsb2N0b0FwaShgL2F1dGh6YCwgeyBtZXRob2Q6ICdQT1NUJywgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZC5wYXJhbXMpIH0pO1xuICAgICAgICAgICAgY29uc3QgYXV0aHpGcmFtZSA9IHlpZWxkIHRoaXMuc2V0SWZyYW1lKGAvYXV0aHovJHthdXRob3JpemF0aW9uSWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZUxpc3RlbmVyKGF1dGh6RnJhbWUsICd0eEhhc2gnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVNlbmRCYXRjaFRyYW5zYWN0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhY3RQYXJhbXMgPSAocGFyYW1zKSA9PiBwYXJhbXMubWFwKChwYXJhbSkgPT4gJ3BhcmFtcycgaW4gcGFyYW1cbiAgICAgICAgICAgICAgICA/IHBhcmFtLnBhcmFtc1swXSAvLyBoYW5kbGUgcGFzc2luZyB3ZWIzLmV0aC5zZW5kVHJhbnNhY3Rpb24ucmVxdWVzdCguLi4pIGFzIGEgcGFyYW1ldGVyIHdpdGggcGFyYW1zXG4gICAgICAgICAgICAgICAgOiBwYXJhbSk7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXRQYXJhbXMgPSBleHRyYWN0UGFyYW1zKHBheWxvYWQucGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnN0IGNvcHlQYXlsb2FkID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXlsb2FkKSwgeyBwYXJhbXM6IGZvcm1hdFBhcmFtcyB9KTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZFRyYW5zYWN0aW9ucyhjb3B5UGF5bG9hZC5wYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbmRUcmFuc2FjdGlvbihjb3B5UGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVTZW5kVXNlck9wZXJhdGlvbihwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhvcml6YXRpb25JZCB9ID0geWllbGQgdGhpcy5ibG9jdG9BcGkoYC91c2VyLW9wZXJhdGlvbmAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkLnBhcmFtcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJPUEZyYW1lID0geWllbGQgdGhpcy5zZXRJZnJhbWUoYC91c2VyLW9wZXJhdGlvbi8ke2F1dGhvcml6YXRpb25JZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlTGlzdGVuZXIodXNlck9QRnJhbWUsICd1c2VyT3BIYXNoJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVCdW5kbGVyKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsb2N0b0FwaShgL3JwYy9idW5kbGVyYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oeyBpZDogMSwganNvbnJwYzogJzIuMCcgfSwgcGF5bG9hZCkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVEaXNjb25uZWN0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGVkU0RLID0gd2luZG93LmV0aGVyZXVtO1xuICAgICAgICAgICAgaWYgKGV4aXN0ZWRTREsgJiYgZXhpc3RlZFNESy5pc0Jsb2N0bykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGVkU0RLLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHJlbW92ZUNoYWluQWRkcmVzcyhzZXNzaW9uS2V5LCBibG9ja2NoYWluTmFtZSk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmV2ZW50TGlzdGVuZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuZGlzY29ubmVjdGVkKCkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxvYWRTd2l0Y2hhYmxlTmV0d29yayhuZXR3b3JrTGlzdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gc2V0dXAgc3dpdGNoYWJsZSBsaXN0IGlmIHVzZXIgc2V0IG5ldHdvcmtMaXN0XG4gICAgICAgICAgICBpZiAobmV0d29ya0xpc3QgPT09IG51bGwgfHwgbmV0d29ya0xpc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5ldHdvcmtMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RUb0FkZCA9IG5ldHdvcmtMaXN0Lm1hcCgoeyBjaGFpbklkLCBycGNVcmxzIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGFpbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoJ0VtcHR5IGNoYWluSWQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocnBjVXJscyA9PT0gbnVsbCB8fCBycGNVcmxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBycGNVcmxzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcygnRW1wdHkgcnBjVXJscycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9hZGRUb1N3aXRjaGFibGUpLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogYCR7cGFyc2VDaGFpbklkKGNoYWluSWQpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBycGNVcmxzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobGlzdFRvQWRkKS50aGVuKCgpID0+IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoJ0VtcHR5IG5ldHdvcmtMaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbl9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMgPSBmdW5jdGlvbiBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5fYmxvY3RvLnN1cHBvcnROZXR3b3JrTGlzdCkubGVuZ3RoKSB7XG4gICAgICAgICAgICB5aWVsZCBnZXRFdm1TdXBwb3J0KClcbiAgICAgICAgICAgICAgICAudGhlbigocmVzdWx0KSA9PiAodGhpcy5fYmxvY3RvLnN1cHBvcnROZXR3b3JrTGlzdCA9IHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogMTAwMSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEdldCBibG9jdG8gc2VydmVyIGZhaWxlZDogJHtlLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2hhaW5faWQsIG5hbWUsIG5ldHdvcmtfdHlwZSwgYmxvY3RvX3NlcnZpY2VfZW52aXJvbm1lbnQsIGRpc3BsYXlfbmFtZSwgfSA9IHRoaXMuX2Jsb2N0by5zdXBwb3J0TmV0d29ya0xpc3RbdGhpcy5uZXR3b3JrVmVyc2lvbl07XG4gICAgICAgIGlmICghY2hhaW5faWQpXG4gICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci51bnN1cHBvcnRlZE1ldGhvZChgR2V0IHN1cHBvcnQgY2hhaW4gZmFpbGVkOiAke3RoaXMubmV0d29ya1ZlcnNpb259IG1pZ2h0IG5vdCBiZSBzdXBwb3J0ZWQgeWV0LmApO1xuICAgICAgICB0aGlzLl9ibG9jdG8gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2Jsb2N0byksIHsgc2Vzc2lvbktleTogRVRIX1NFU1NJT05fS0VZX01BUFBJTkdbYmxvY3RvX3NlcnZpY2VfZW52aXJvbm1lbnRdLCB3YWxsZXRTZXJ2ZXI6IHRoaXMuaW5qZWN0ZWRXYWxsZXRTZXJ2ZXIgfHxcbiAgICAgICAgICAgICAgICBFVEhfRU5WX1dBTExFVF9TRVJWRVJfTUFQUElOR1tibG9jdG9fc2VydmljZV9lbnZpcm9ubWVudF0sIGJsb2NrY2hhaW5OYW1lOiBuYW1lLCBuZXR3b3JrVHlwZTogbmV0d29ya190eXBlLCBzd2l0Y2hhYmxlTmV0d29yazogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9ibG9jdG8uc3dpdGNoYWJsZU5ldHdvcmspLCB7IFtjaGFpbl9pZF06IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9uYW1lLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHdhbGxldF93ZWJfdXJsOiB0aGlzLl9ibG9jdG8ud2FsbGV0U2VydmVyLFxuICAgICAgICAgICAgICAgICAgICBycGNfdXJsOiB0aGlzLnJwYyxcbiAgICAgICAgICAgICAgICB9IH0pIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxvY3RvO1xuICAgIH0pO1xufSwgX0V0aGVyZXVtUHJvdmlkZXJfYWRkVG9Td2l0Y2hhYmxlID0gZnVuY3Rpb24gX0V0aGVyZXVtUHJvdmlkZXJfYWRkVG9Td2l0Y2hhYmxlKHsgY2hhaW5JZCwgcnBjVXJscywgfSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHsgc3VwcG9ydE5ldHdvcmtMaXN0IH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5faWQsIG5hbWUsIGRpc3BsYXlfbmFtZSwgbmV0d29ya190eXBlLCBibG9jdG9fc2VydmljZV9lbnZpcm9ubWVudCwgfSA9IHN1cHBvcnROZXR3b3JrTGlzdFtjaGFpbklkXTtcbiAgICAgICAgY29uc3Qgd2FsbGV0X3dlYl91cmwgPSBFVEhfRU5WX1dBTExFVF9TRVJWRVJfTUFQUElOR1tibG9jdG9fc2VydmljZV9lbnZpcm9ubWVudF07XG4gICAgICAgIHRoaXMuX2Jsb2N0by5zd2l0Y2hhYmxlTmV0d29ya1tjaGFpbl9pZF0gPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGlzcGxheV9uYW1lLFxuICAgICAgICAgICAgbmV0d29ya190eXBlLFxuICAgICAgICAgICAgd2FsbGV0X3dlYl91cmwsXG4gICAgICAgICAgICBycGNfdXJsOiBycGNVcmxzWzBdLFxuICAgICAgICB9O1xuICAgIH0pO1xufSwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCA9IGZ1bmN0aW9uIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQoKSB7XG4gICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5ldGhlcmV1bTtcbiAgICBpZiAoZXhpc3RlZFNESyAmJlxuICAgICAgICBleGlzdGVkU0RLLmlzQmxvY3RvICYmXG4gICAgICAgIHBhcnNlQ2hhaW5JZChleGlzdGVkU0RLLmNoYWluSWQpICE9PSBwYXJzZUNoYWluSWQodGhpcy5jaGFpbklkKSkge1xuICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci5jaGFpbkRpc2Nvbm5lY3RlZCgpO1xuICAgIH1cbn07XG5cbi8vIGJhc2UteCBlbmNvZGluZyAvIGRlY29kaW5nXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTggYmFzZS14IGNvbnRyaWJ1dG9yc1xuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTggVGhlIEJpdGNvaW4gQ29yZSBkZXZlbG9wZXJzIChiYXNlNTguY3BwKVxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBMSUNFTlNFIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuZnVuY3Rpb24gYmFzZSAoQUxQSEFCRVQpIHtcbiAgaWYgKEFMUEhBQkVULmxlbmd0aCA+PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxwaGFiZXQgdG9vIGxvbmcnKSB9XG4gIHZhciBCQVNFX01BUCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgQkFTRV9NQVAubGVuZ3RoOyBqKyspIHtcbiAgICBCQVNFX01BUFtqXSA9IDI1NTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHggPSBBTFBIQUJFVC5jaGFyQXQoaSk7XG4gICAgdmFyIHhjID0geC5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChCQVNFX01BUFt4Y10gIT09IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpIH1cbiAgICBCQVNFX01BUFt4Y10gPSBpO1xuICB9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoO1xuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApO1xuICB2YXIgRkFDVE9SID0gTWF0aC5sb2coQkFTRSkgLyBNYXRoLmxvZygyNTYpOyAvLyBsb2coQkFTRSkgLyBsb2coMjU2KSwgcm91bmRlZCB1cFxuICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKTsgLy8gbG9nKDI1NikgLyBsb2coQkFTRSksIHJvdW5kZWQgdXBcbiAgZnVuY3Rpb24gZW5jb2RlIChzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkgOyBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc291cmNlKSkge1xuICAgICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlLmJ1ZmZlciwgc291cmNlLmJ5dGVPZmZzZXQsIHNvdXJjZS5ieXRlTGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgc291cmNlID0gVWludDhBcnJheS5mcm9tKHNvdXJjZSk7XG4gICAgfVxuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnIH1cbiAgICAgICAgLy8gU2tpcCAmIGNvdW50IGxlYWRpbmcgemVyb2VzLlxuICAgIHZhciB6ZXJvZXMgPSAwO1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHZhciBwYmVnaW4gPSAwO1xuICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aDtcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICBwYmVnaW4rKztcbiAgICAgIHplcm9lcysrO1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTU4IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxKSA+Pj4gMDtcbiAgICB2YXIgYjU4ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGJ5dGVzLlxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQpIHtcbiAgICAgIHZhciBjYXJyeSA9IHNvdXJjZVtwYmVnaW5dO1xuICAgICAgICAgICAgLy8gQXBwbHkgXCJiNTggPSBiNTggKiAyNTYgKyBjaFwiLlxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yICh2YXIgaXQxID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQxICE9PSAtMSk7IGl0MS0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKDI1NiAqIGI1OFtpdDFdKSA+Pj4gMDtcbiAgICAgICAgYjU4W2l0MV0gPSAoY2FycnkgJSBCQVNFKSA+Pj4gMDtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSA+Pj4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaTtcbiAgICAgIHBiZWdpbisrO1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiYXNlNTggcmVzdWx0LlxuICAgIHZhciBpdDIgPSBzaXplIC0gbGVuZ3RoO1xuICAgIHdoaWxlIChpdDIgIT09IHNpemUgJiYgYjU4W2l0Ml0gPT09IDApIHtcbiAgICAgIGl0MisrO1xuICAgIH1cbiAgICAgICAgLy8gVHJhbnNsYXRlIHRoZSByZXN1bHQgaW50byBhIHN0cmluZy5cbiAgICB2YXIgc3RyID0gTEVBREVSLnJlcGVhdCh6ZXJvZXMpO1xuICAgIGZvciAoOyBpdDIgPCBzaXplOyArK2l0MikgeyBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdKTsgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUgKHNvdXJjZSkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBTdHJpbmcnKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KCkgfVxuICAgIHZhciBwc3ogPSAwO1xuICAgICAgICAvLyBTa2lwIGFuZCBjb3VudCBsZWFkaW5nICcxJ3MuXG4gICAgdmFyIHplcm9lcyA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdID09PSBMRUFERVIpIHtcbiAgICAgIHplcm9lcysrO1xuICAgICAgcHN6Kys7XG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlMjU2IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKCgoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IpICsgMSkgPj4+IDA7IC8vIGxvZyg1OCkgLyBsb2coMjU2KSwgcm91bmRlZCB1cC5cbiAgICB2YXIgYjI1NiA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSBjaGFyYWN0ZXJzLlxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSkge1xuICAgICAgICAgICAgLy8gRGVjb2RlIGNoYXJhY3RlclxuICAgICAgdmFyIGNhcnJ5ID0gQkFTRV9NQVBbc291cmNlLmNoYXJDb2RlQXQocHN6KV07XG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNoYXJhY3RlclxuICAgICAgaWYgKGNhcnJ5ID09PSAyNTUpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MyAhPT0gLTEpOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IChCQVNFICogYjI1NltpdDNdKSA+Pj4gMDtcbiAgICAgICAgYjI1NltpdDNdID0gKGNhcnJ5ICUgMjU2KSA+Pj4gMDtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyAyNTYpID4+PiAwO1xuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpO1xuICAgICAgcHN6Kys7XG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGIyNTYuXG4gICAgdmFyIGl0NCA9IHNpemUgLSBsZW5ndGg7XG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrO1xuICAgIH1cbiAgICB2YXIgdmNoID0gbmV3IFVpbnQ4QXJyYXkoemVyb2VzICsgKHNpemUgLSBpdDQpKTtcbiAgICB2YXIgaiA9IHplcm9lcztcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdO1xuICAgIH1cbiAgICByZXR1cm4gdmNoXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gZGVjb2RlVW5zYWZlKHN0cmluZyk7XG4gICAgaWYgKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1iYXNlJyArIEJBU0UgKyAnIGNoYXJhY3RlcicpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9XG59XG52YXIgc3JjID0gYmFzZTtcblxuY29uc3QgYmFzZXggPSBzcmM7XG5jb25zdCBBTFBIQUJFVCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6JztcblxudmFyIGJzNTggPSBiYXNleChBTFBIQUJFVCk7XG5cbnZhciBiczU4JDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYnM1OCk7XG5cbmxldCBTb2xhbmE7XG50cnkge1xuICAgIFNvbGFuYSA9IHJlcXVpcmUoJ0Bzb2xhbmEvd2ViMy5qcycpO1xufVxuY2F0Y2ggKF9hKSB7XG4gICAgLy8gcHJldmVudCBjcmFzaCBpZiB0aGVyZSBpcyBubyBAc29sYW5hL3dlYjMuanMuXG59XG5jbGFzcyBTb2xhbmFQcm92aWRlciBleHRlbmRzIEJsb2N0b1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG5ldCA9ICdtYWlubmV0LWJldGEnLCBzZXJ2ZXIsIGFwcElkLCBycGMsIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaW52YXJpYW50KG5ldCwgXCInbmV0JyBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgaW52YXJpYW50KE9iamVjdC52YWx1ZXMoU09MX05FVCkuaW5jbHVkZXMobmV0KSwgJ3Vuc3VwcG9ydGVkIG5ldCcpO1xuICAgICAgICB0aGlzLm5ldCA9IG5ldDtcbiAgICAgICAgdGhpcy5ycGMgPVxuICAgICAgICAgICAgcnBjIHx8XG4gICAgICAgICAgICAgICAgKG5ldCA9PT0gJ21haW5uZXQtYmV0YSdcbiAgICAgICAgICAgICAgICAgICAgPyAnaHR0cHM6Ly9mcmVlLnJwY3Bvb2wuY29tJ1xuICAgICAgICAgICAgICAgICAgICA6IGBodHRwczovL2FwaS4ke25ldH0uc29sYW5hLmNvbWApO1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlciB8fCBTT0xfTkVUX1NFUlZFUl9NQVBQSU5HW3RoaXMubmV0XSB8fCAnJztcbiAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkIHx8IERFRkFVTFRfQVBQX0lEO1xuICAgICAgICB0aGlzLnNlc3Npb25LZXkgPSBTT0xfU0VTU0lPTl9LRVlfTUFQUElOR1t0aGlzLm5ldF07XG4gICAgICAgIGlmICghU29sYW5hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEBzb2xhbmEvd2ViMy5qcyBpbnN0YWxsZWQuIFBsZWFzZSBpbnN0YWxsIGl0IHRvIGludGVyYWN0IHdpdGggU29sYW5hLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3QocGF5bG9hZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGVkU0RLID0gd2luZG93LnNvbGFuYTtcbiAgICAgICAgICAgIGlmIChleGlzdGVkU0RLICYmIGV4aXN0ZWRTREsuaXNCbG9jdG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RlZFNESy5yZXF1ZXN0KHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5TT0xBTkEpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwYXlsb2FkLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuZmV0Y2hBY2NvdW50cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ2V0QWNjb3VudHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKChfYSA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLlNPTEFOQSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5TT0xBTkEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB5aWVsZCB0aGlzLmZldGNoQWNjb3VudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXRBY2NvdW50SW5mbyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCB0aGUgZGF0YSBhcyB0aGUgc2FtZSBmb3JtYXQgcmV0dXJuaW5nIGZyb20gQ29ubmVjdGlvbi5nZXRBY2NvdW50SW5mbyBmcm9tIEBzb2xhbmEvd2ViMy5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVmOiBodHRwczovL3NvbGFuYS1sYWJzLmdpdGh1Yi5pby9zb2xhbmEtd2ViMy5qcy9jbGFzc2VzL0Nvbm5lY3Rpb24uaHRtbCNnZXRBY2NvdW50SW5mb1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudEluZm8gPSB5aWVsZCB0aGlzLmhhbmRsZVJlYWRSZXF1ZXN0cyhwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtidWZmZXJEYXRhLCBlbmNvZGluZ10gPSBhY2NvdW50SW5mby5yZXN1bHQudmFsdWUuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjb3VudEluZm8ucmVzdWx0LnZhbHVlKSwgeyBkYXRhOiBCdWZmZXIuZnJvbShidWZmZXJEYXRhLCBlbmNvZGluZyksIG93bmVyOiBuZXcgU29sYW5hLlB1YmxpY0tleShhY2NvdW50SW5mby5yZXN1bHQudmFsdWUub3duZXIpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY3VzdG9tIEpTT04tUlBDIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb252ZXJ0VG9Qcm9ncmFtV2FsbGV0VHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgdGhpcy5oYW5kbGVDb252ZXJ0VHJhbnNhY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VzdG9tIEpTT04tUlBDIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduQW5kU2VuZFRyYW5zYWN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuaGFuZGxlU2lnbkFuZFNlbmRUcmFuc2FjdGlvbihwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBibG9jayB1c2VyIGZyb20gdXNpbmcgdHJhZGl0aW9uYWwgbWV0aG9kc1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduVHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduQWxsVHJhbnNhY3Rpb25zJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmxvY3RvIGlzIHByb2dyYW0gd2FsbGV0LCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgJHtwYXlsb2FkLm1ldGhvZH0uIFVzZSBzaWduQW5kU2VuZFRyYW5zYWN0aW9uIGluc3RlYWQuYCk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkIHRoaXMuaGFuZGxlUmVhZFJlcXVlc3RzKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgIXJlc3BvbnNlLnJlc3VsdCAmJiByZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSByZXNwb25zZS5lcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLmVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ1JlcXVlc3QgZmFpbGVkJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5zb2xhbmE7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESyAmJiBleGlzdGVkU0RLLmlzQmxvY3RvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0ZWRTREsub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5TT0xBTkEsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGVkU0RLLnB1YmxpY0tleS50b0Jhc2U1OCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBleGlzdGVkU0RLLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoJ0N1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBpbiBicm93c2VyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5TT0xBTkEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gZW5jb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ2luRnJhbWUgPSBjcmVhdGVGcmFtZShgJHt0aGlzLnNlcnZlcn0vJHt0aGlzLmFwcElkfS9zb2xhbmEvYXV0aG4/bDZuPSR7bG9jYXRpb259JnY9JHtTREtfVkVSU0lPTn1gKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hGcmFtZShsb2dpbkZyYW1lKTtcbiAgICAgICAgICAgICAgICBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlTGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gPT09IHRoaXMuc2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnR5cGUgPT09ICdTT0w6RlJBTUU6UkVTUE9OU0UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhdGNoRnJhbWUobG9naW5GcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5jb25uZWN0LmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcih0aGlzLm5ldCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFjY291bnRTdG9yYWdlKHRoaXMuc2Vzc2lvbktleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBlLmRhdGEuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0NIQUlOLlNPTEFOQV06IFtlLmRhdGEuYWRkcl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZS5kYXRhLmV4cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnU09MOkZSQU1FOkNMT1NFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGxvZ2luRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1VzZXIgZGVjbGluZWQgdGhlIGxvZ2luIHJlcXVlc3QnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuc29sYW5hO1xuICAgICAgICAgICAgaWYgKGV4aXN0ZWRTREsgJiYgZXhpc3RlZFNESy5pc0Jsb2N0bykge1xuICAgICAgICAgICAgICAgIHlpZWxkIGV4aXN0ZWRTREsuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuZGlzY29ubmVjdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIobnVsbCkpO1xuICAgICAgICAgICAgcmVtb3ZlQ2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uU09MQU5BKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoQWNjb3VudHMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2EgPSBnZXRBY2NvdW50U3RvcmFnZSh0aGlzLnNlc3Npb25LZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSB5aWVsZCBmZXRjaChgJHt0aGlzLnNlcnZlcn0vYXBpL3NvbGFuYS9hY2NvdW50c2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgY2hlY2sgdGhlIGV4aXN0ZW5jZSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1BcHBsaWNhdGlvbi1JZGVudGlmaWVyJzogdGhpcy5hcHBJZCxcbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1TZXNzaW9uLUlkZW50aWZpZXInOiBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZVNlc3Npb25HdWFyZChyZXNwb25zZSwgdGhpcy5zZXNzaW9uS2V5KSk7XG4gICAgICAgICAgICBzZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5TT0xBTkEsIGFjY291bnRzKTtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVJlYWRSZXF1ZXN0cyhwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2godGhpcy5ycGMsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKHsgaWQ6IDEsIGpzb25ycGM6ICcyLjAnIH0sIHBheWxvYWQpKSxcbiAgICAgICAgICAgIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gc29sYW5hIHdlYjMgdXRpbGl0eVxuICAgIGNvbnZlcnRUb1Byb2dyYW1XYWxsZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5zb2xhbmE7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESyAmJiBleGlzdGVkU0RLLmlzQmxvY3RvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsuY29udmVydFRvUHJvZ3JhbVdhbGxldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2NvbnZlcnRUb1Byb2dyYW1XYWxsZXRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZU1lc3NhZ2UoKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9UcmFuc2FjdGlvbihtZXNzYWdlLCBbXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBzb2xhbmEgd2ViMyB1dGlsaXR5XG4gICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5zb2xhbmE7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESyAmJiBleGlzdGVkU0RLLmlzQmxvY3RvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleHRyYSA9IHt9O1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5jb21taXRtZW50KVxuICAgICAgICAgICAgICAgICAgICBleHRyYS5jb21taXRtZW50ID0gY29ubmVjdGlvbi5jb21taXRtZW50O1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjb25uZWN0aW9uIG9iamVjdCBwYXNzZWQtaW4gaGFzIGRpZmZlcmVudCBycGMgZW5kcG9pbnQsIHJlY29ubmVjdCB0byBpdFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHJwYyA9IGNvbm5lY3Rpb24gPyBjb25uZWN0aW9uLl9ycGNFbmRwb2ludCA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJwYyAmJiBycGMgIT09IHRoaXMucnBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnBjID0gcnBjO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnc2lnbkFuZFNlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHsgc2lnbmF0dXJlczogeWllbGQgdGhpcy5jb2xsZWN0U2lnbmF0dXJlcyh0cmFuc2FjdGlvbiksIG1lc3NhZ2U6IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZU1lc3NhZ2UoKS50b1N0cmluZygnaGV4JykgfSwgZXh0cmEpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBzb2xhbmEgd2ViMyB1dGlsaXR5XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICB0b1RyYW5zYWN0aW9uKHJhdywgc2lnbmF0dXJlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFNvbGFuYS5NZXNzYWdlLmZyb20oQnVmZmVyLmZyb20ocmF3LCAnaGV4JykpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgU29sYW5hLlRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBtZXNzYWdlLnJlY2VudEJsb2NraGFzaDtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBtZXNzYWdlLmFjY291bnRLZXlzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2lnbmF0dXJlcy5mb3JFYWNoKChzaWduYXR1cmUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnUHVia2V5UGFpciA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUgPT09IFNvbGFuYS5QdWJsaWNLZXkuZGVmYXVsdC50b0Jhc2U1OCgpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYnM1OCQxLmRlY29kZShzaWduYXR1cmUpLFxuICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IG1lc3NhZ2UuYWNjb3VudEtleXNbaW5kZXhdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uc2lnbmF0dXJlcy5wdXNoKHNpZ1B1YmtleVBhaXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtZXNzYWdlLmluc3RydWN0aW9ucy5mb3JFYWNoKChpbnN0cnVjdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBpbnN0cnVjdGlvbi5hY2NvdW50cy5tYXAoKGFjY291bnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHVia2V5ID0gbWVzc2FnZS5hY2NvdW50S2V5c1thY2NvdW50XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2lnbmVyOiBhY2NvdW50IDwgbWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNXcml0YWJsZTogbWVzc2FnZS5pc0FjY291bnRXcml0YWJsZShhY2NvdW50KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5pbnN0cnVjdGlvbnMucHVzaChuZXcgU29sYW5hLlRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtSWQ6IG1lc3NhZ2UuYWNjb3VudEtleXNbaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBiczU4JDEuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gc29sYW5hIHdlYjMgdXRpbGl0eVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgY29sbGVjdFNpZ25hdHVyZXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbi5zaWduYXR1cmVzLnJlZHVjZSgoYWNjLCBjdXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLnNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NbY3VyLnB1YmxpY0tleS50b0Jhc2U1OCgpXSA9IGN1ci5zaWduYXR1cmUudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlQ29udmVydFRyYW5zYWN0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gKChfYSA9IGdldEFjY291bnRTdG9yYWdlKHRoaXMuc2Vzc2lvbktleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBmZXRjaChgJHt0aGlzLnNlcnZlcn0vYXBpL3NvbGFuYS9jb252ZXJ0VG9XYWxsZXRUeGAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgY2hlY2sgdGhlIGV4aXN0ZW5jZSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1BcHBsaWNhdGlvbi1JZGVudGlmaWVyJzogdGhpcy5hcHBJZCxcbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1TZXNzaW9uLUlkZW50aWZpZXInOiBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkLnBhcmFtcyksXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIHRoaXMuc2Vzc2lvbktleSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlU2lnbkFuZFNlbmRUcmFuc2FjdGlvbihwYXlsb2FkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2EgPSBnZXRBY2NvdW50U3RvcmFnZSh0aGlzLnNlc3Npb25LZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhvcml6YXRpb25JZCB9ID0geWllbGQgZmV0Y2goYCR7dGhpcy5zZXJ2ZXJ9L2FwaS9zb2xhbmEvYXV0aHpgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGNoZWNrIHRoZSBleGlzdGVuY2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZC5wYXJhbXMpLFxuICAgICAgICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlU2Vzc2lvbkd1YXJkKHJlc3BvbnNlLCB0aGlzLnNlc3Npb25LZXkpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF1dGh6RnJhbWUgPSBjcmVhdGVGcmFtZShgJHt0aGlzLnNlcnZlcn0vJHt0aGlzLmFwcElkfS9zb2xhbmEvYXV0aHovJHthdXRob3JpemF0aW9uSWR9YCk7XG4gICAgICAgICAgICBhdHRhY2hGcmFtZShhdXRoekZyYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlRXZlbnRMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBldmVudDtcbiAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gPT09IHRoaXMuc2VydmVyICYmXG4gICAgICAgICAgICAgICAgICAgIGUuZGF0YS50eXBlID09PSAnU09MOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0FQUFJPVkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGF1dGh6RnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlLmRhdGEudHhIYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0RFQ0xJTkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGF1dGh6RnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5lcnJvckNvZGUgPT09ICdpbmNvcnJlY3Rfc2Vzc2lvbl9pZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZS5kYXRhLmVycm9yTWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IGNoZWNrTWVzc2FnZVBheWxvYWRGb3JtYXQgPSAocGF5bG9hZCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZm9ybWF0dGVkUGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oe30sIHBheWxvYWQpO1xuICAgIGNvbnN0IHsgbWVzc2FnZSwgbm9uY2UsIGFkZHJlc3MsIGFwcGxpY2F0aW9uLCBjaGFpbklkIH0gPSBwYXlsb2FkO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9ybWF0dGVkUGF5bG9hZC5tZXNzYWdlID0gKF9hID0gU3RyaW5nKG1lc3NhZ2UpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBub25jZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9ybWF0dGVkUGF5bG9hZC5ub25jZSA9IChfYiA9IFN0cmluZyhub25jZSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICAgIH1cbiAgICBpZiAoYWRkcmVzcyAmJiB0eXBlb2YgYWRkcmVzcyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGZvcm1hdHRlZFBheWxvYWQuYWRkcmVzcyA9ICEhYWRkcmVzcztcbiAgICB9XG4gICAgaWYgKGFwcGxpY2F0aW9uICYmIHR5cGVvZiBhcHBsaWNhdGlvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGZvcm1hdHRlZFBheWxvYWQuYXBwbGljYXRpb24gPSAhIWFwcGxpY2F0aW9uO1xuICAgIH1cbiAgICBpZiAoY2hhaW5JZCAmJiB0eXBlb2YgY2hhaW5JZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGZvcm1hdHRlZFBheWxvYWQuY2hhaW5JZCA9ICEhY2hhaW5JZDtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlZFBheWxvYWQ7XG59O1xuY2xhc3MgQXB0b3NQcm92aWRlciBleHRlbmRzIEJsb2N0b1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNoYWluSWQsIHNlcnZlciwgYXBwSWQgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnB1YmxpY0tleSA9IFtdO1xuICAgICAgICB0aGlzLmF1dGhLZXkgPSAnJztcbiAgICAgICAgaW52YXJpYW50KGNoYWluSWQsIFwiJ2NoYWluSWQnIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICBpbnZhcmlhbnQoYXBwSWQsICdJdCBpcyBuZWNlc3NhcnkgdG8gaW50ZXJhY3Qgd2l0aCBCbG9jdG8gd2FsbGV0IHZpYSB5b3VyIGFwcCBpZC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZGV2ZWxvcGVycy5ibG9jdG8uYXBwIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIHRoaXMubmV0d29ya05hbWUgPSBBUFRfQ0hBSU5fSURfTkFNRV9NQVBQSU5HW2NoYWluSWRdO1xuICAgICAgICB0aGlzLmFwaSA9IEFQVF9DSEFJTl9JRF9SUENfTUFQUElOR1tjaGFpbklkXTtcbiAgICAgICAgdGhpcy5zZXNzaW9uS2V5ID0gQVBUX1NFU1NJT05fS0VZX01BUFBJTkdbY2hhaW5JZF07XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTZXJ2ZXIgPSBBUFRfQ0hBSU5fSURfU0VSVkVSX01BUFBJTkdbY2hhaW5JZF07XG4gICAgICAgIHRoaXMuYXBwSWQgPSBhcHBJZCB8fCBERUZBVUxUX0FQUF9JRDtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXIgfHwgZGVmYXVsdFNlcnZlciB8fCAnJztcbiAgICB9XG4gICAgZ2V0IHB1YmxpY0FjY291bnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3M6ICgoX2EgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgfHwgbnVsbCxcbiAgICAgICAgICAgIHB1YmxpY0tleTogdGhpcy5wdWJsaWNLZXkubGVuZ3RoID8gdGhpcy5wdWJsaWNLZXkgOiBudWxsLFxuICAgICAgICAgICAgLy8gQHRvZG86IHByb3ZpZGUgYXV0aGtleVxuICAgICAgICAgICAgYXV0aEtleTogbnVsbCxcbiAgICAgICAgICAgIG1pbktleXNSZXF1aXJlZDogMixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uZXR3b3JrTmFtZSxcbiAgICAgICAgICAgICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW5JZC50b1N0cmluZygpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISEoKF9hID0gZ2V0QWNjb3VudFN0b3JhZ2UodGhpcy5zZXNzaW9uS2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuYmxvY3RvQXB0b3M7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGVkU0RLLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYXNDb25uZWN0ZWQgPSB5aWVsZCB0aGlzLmlzQ29ubmVjdGVkKCk7XG4gICAgICAgICAgICBpZiAoIWhhc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoKF9hID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbCB0byBnZXQgYWNjb3VudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduVHJhbnNhY3Rpb24gbWV0aG9kIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5ibG9jdG9BcHRvcztcbiAgICAgICAgICAgIGlmIChleGlzdGVkU0RLKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgZXhpc3RlZFNESy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlQ2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCB0eE9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5ibG9jdG9BcHRvcztcbiAgICAgICAgICAgIGlmIChleGlzdGVkU0RLKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsuc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCB0eE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFzQ29ubmVjdGVkID0geWllbGQgdGhpcy5pc0Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgaWYgKCFoYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKChfYSA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWwgdG8gZ2V0IGFjY291bnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2IgPSBnZXRBY2NvdW50U3RvcmFnZSh0aGlzLnNlc3Npb25LZXkpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29kZSkgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhvcml6YXRpb25JZCB9ID0geWllbGQgZmV0Y2goYCR7dGhpcy5zZXJ2ZXJ9L2FwaS9hcHRvcy9hdXRoemAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgY2hlY2sgdGhlIGV4aXN0ZW5jZSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1BcHBsaWNhdGlvbi1JZGVudGlmaWVyJzogdGhpcy5hcHBJZCxcbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1TZXNzaW9uLUlkZW50aWZpZXInOiBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zYWN0aW9uKSwgdHhPcHRpb25zKSksXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIHRoaXMuc2Vzc2lvbktleSkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXV0aHpGcmFtZSA9IGNyZWF0ZUZyYW1lKGAke3RoaXMuc2VydmVyfS8ke3RoaXMuYXBwSWR9L2FwdG9zL2F1dGh6LyR7YXV0aG9yaXphdGlvbklkfWApO1xuICAgICAgICAgICAgYXR0YWNoRnJhbWUoYXV0aHpGcmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIoJ21lc3NhZ2UnLCAoZXZlbnQsIHJlbW92ZUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luID09PSB0aGlzLnNlcnZlciAmJlxuICAgICAgICAgICAgICAgICAgICBlLmRhdGEudHlwZSA9PT0gJ0FQVE9TOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0FQUFJPVkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGF1dGh6RnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGhhc2g6IGUuZGF0YS50eEhhc2ggfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdERUNMSU5FRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShhdXRoekZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuZXJyb3JDb2RlID09PSAnaW5jb3JyZWN0X3Nlc3Npb25faWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGUuZGF0YS5lcnJvck1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuYmxvY3RvQXB0b3M7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRQYXlsb2FkID0gY2hlY2tNZXNzYWdlUGF5bG9hZEZvcm1hdChwYXlsb2FkKTtcbiAgICAgICAgICAgIGlmIChleGlzdGVkU0RLKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsuc2lnbk1lc3NhZ2UoZm9ybWF0dGVkUGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYXNDb25uZWN0ZWQgPSB5aWVsZCB0aGlzLmlzQ29ubmVjdGVkKCk7XG4gICAgICAgICAgICBpZiAoIWhhc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoKF9hID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbCB0byBnZXQgYWNjb3VudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gKChfYiA9IGdldEFjY291bnRTdG9yYWdlKHRoaXMuc2Vzc2lvbktleSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb2RlKSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHsgc2lnbmF0dXJlSWQgfSA9IHlpZWxkIGZldGNoKGAke3RoaXMuc2VydmVyfS9hcGkvYXB0b3MvdXNlci1zaWduYXR1cmVgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGNoZWNrIHRoZSBleGlzdGVuY2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZm9ybWF0dGVkUGF5bG9hZCksXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIHRoaXMuc2Vzc2lvbktleSkpO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5zZXJ2ZXJ9LyR7dGhpcy5hcHBJZH0vYXB0b3MvdXNlci1zaWduYXR1cmUvJHtzaWduYXR1cmVJZH1gO1xuICAgICAgICAgICAgY29uc3Qgc2lnbkZyYW1lID0gY3JlYXRlRnJhbWUodXJsKTtcbiAgICAgICAgICAgIGF0dGFjaEZyYW1lKHNpZ25GcmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIoJ21lc3NhZ2UnLCAoZXZlbnQsIHJlbW92ZUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luID09PSB0aGlzLnNlcnZlciAmJlxuICAgICAgICAgICAgICAgICAgICBlLmRhdGEudHlwZSA9PT0gJ0FQVE9TOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0FQUFJPVkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKHNpZ25GcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdERUNMSU5FRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShzaWduRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5lcnJvckNvZGUgPT09ICdpbmNvcnJlY3Rfc2Vzc2lvbl9pZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZS5kYXRhLmVycm9yTWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuYmxvY3RvQXB0b3M7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBcbiAgICAgICAgICAgICAgICAvLyBhZGQgYSBzbWFsbCBkZWxheSB0byBtYWtlIHN1cmUgdGhlIG5ldHdvcmsgaGFzIGJlZW4gc3dpdGNoZWRcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGV4aXN0ZWRTREsuY29ubmVjdCgpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KSwgMTApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgnQ3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChfYSA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiAoKF9iID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF0pIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IHRoaXMucHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aEtleTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbktleXNSZXF1aXJlZDogMixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gZW5jb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ2luRnJhbWUgPSBjcmVhdGVGcmFtZShgJHt0aGlzLnNlcnZlcn0vJHt0aGlzLmFwcElkfS9hcHRvcy9hdXRobj9sNm49JHtsb2NhdGlvbn0mdj0ke1NES19WRVJTSU9OfX1gKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hGcmFtZShsb2dpbkZyYW1lKTtcbiAgICAgICAgICAgICAgICBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlTGlzdGVuZXIpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luID09PSB0aGlzLnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnQVBUT1M6RlJBTUU6UkVTUE9OU0UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhdGNoRnJhbWUobG9naW5GcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QWNjb3VudFN0b3JhZ2UodGhpcy5zZXNzaW9uS2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGUuZGF0YS5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbQ0hBSU4uQVBUT1NdOiBbZS5kYXRhLmFkZHJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGUuZGF0YS5leHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2MgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcHVibGljX2tleXM6IHB1YmxpY0tleXMgfSA9IHlpZWxkIGZldGNoKGAke3RoaXMuc2VydmVyfS9ibG9jdG8vYXB0b3MvYWNjb3VudHMvJHsoX2QgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZFswXX1gKS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGljS2V5ID0gcHVibGljS2V5cyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6ICgoX2UgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiB0aGlzLnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoS2V5OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbktleXNSZXF1aXJlZDogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvOiBiZXR0ZXIgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEudHlwZSA9PT0gJ0FQVE9TOkZSQU1FOkNMT1NFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGxvZ2luRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1VzZXIgZGVjbGluZWQgdGhlIGxvZ2luIHJlcXVlc3QnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoQWRkcmVzcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gKChfYSA9IGdldEFjY291bnRTdG9yYWdlKHRoaXMuc2Vzc2lvbktleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHsgYWNjb3VudHMgfSA9IHlpZWxkIGZldGNoKGAke3RoaXMuc2VydmVyfS9hcGkvYXB0b3MvYWNjb3VudHNgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGNoZWNrIHRoZSBleGlzdGVuY2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIHRoaXMuc2Vzc2lvbktleSkpO1xuICAgICAgICAgICAgc2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MsIGFjY291bnRzKTtcbiAgICAgICAgICAgIHJldHVybiAoYWNjb3VudHMgPT09IG51bGwgfHwgYWNjb3VudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjY291bnRzWzBdKSB8fCAnJztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBCbG9jdG9TREsge1xuICAgIGNvbnN0cnVjdG9yKHsgYXBwSWQsIGV0aGVyZXVtLCBzb2xhbmEsIGFwdG9zIH0pIHtcbiAgICAgICAgaWYgKGV0aGVyZXVtKSB7XG4gICAgICAgICAgICB0aGlzLmV0aGVyZXVtID0gbmV3IEV0aGVyZXVtUHJvdmlkZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldGhlcmV1bSksIHsgYXBwSWQgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb2xhbmEpIHtcbiAgICAgICAgICAgIHRoaXMuc29sYW5hID0gbmV3IFNvbGFuYVByb3ZpZGVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc29sYW5hKSwgeyBhcHBJZCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFwdG9zKSB7XG4gICAgICAgICAgICB0aGlzLmFwdG9zID0gbmV3IEFwdG9zUHJvdmlkZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhcHRvcyksIHsgYXBwSWQgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBCbG9jdG9TREsgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJyZWNlaXZlciIsInN0YXRlIiwia2luZCIsImYiLCJUeXBlRXJyb3IiLCJoYXMiLCJjYWxsIiwiZ2V0IiwiU3VwcHJlc3NlZEVycm9yIiwiZXJyb3IiLCJzdXBwcmVzc2VkIiwibWVzc2FnZSIsIkVycm9yIiwibmFtZSIsImludmFyaWFudCIsImNvbmRpdGlvbiIsImZvcm1hdCIsIktFWV9TRVNTSU9OIiwiQ0hBSU4iLCJNZW1vcnlTdG9yYWdlIiwiY29uc3RydWN0b3IiLCJzdG9yYWdlIiwiZ2V0SXRlbSIsImtleSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwibWVtb3J5U3RvcmFnZSIsIndpbmRvdyIsImlzU3VwcG9ydGVkIiwic2Vzc2lvblN0b3JhZ2UiLCJkZWZhdWx0VmFsdWUiLCJKU09OIiwicGFyc2UiLCJTeW50YXhFcnJvciIsInN0cmluZ2lmeSIsImdldEFjY291bnRTdG9yYWdlIiwicmF3QWNjb3VudFN0b3JhZ2UiLCJEYXRlIiwiZ2V0VGltZSIsImV4cGlyeSIsInYiLCJTREtfVkVSU0lPTiIsImRhdGEiLCJzZXRBY2NvdW50U3RvcmFnZSIsIl9hIiwiX2IiLCJfYyIsIm5ld0FjY291bnRTdG9yYWdlIiwiY29kZSIsImNvbm5lY3RlZCIsImFjY291bnRzIiwiT2JqZWN0IiwiYXNzaWduIiwiTE9HSU5fUEVSU0lTVElOR19USU1FIiwiZ2V0Q2hhaW5BZGRyZXNzIiwiY2hhaW4iLCJzZXRDaGFpbkFkZHJlc3MiLCJhY2NvdW50IiwicmVtb3ZlQ2hhaW5BZGRyZXNzIiwidW5kZWZpbmVkIiwiRVRIX1JQQ19MSVNUIiwiRVRIX0VOVl9XQUxMRVRfU0VSVkVSX01BUFBJTkciLCJwcm9kIiwic3RhZ2luZyIsImRldiIsIkVUSF9TRVNTSU9OX0tFWV9NQVBQSU5HIiwiU09MX05FVCIsIk1haW5uZXRCZXRhIiwiVGVzdG5ldCIsIkRldm5ldCIsIlNPTF9ORVRfU0VSVkVSX01BUFBJTkciLCJTT0xfU0VTU0lPTl9LRVlfTUFQUElORyIsIkFQVF9TRVNTSU9OX0tFWV9NQVBQSU5HIiwiQVBUX0NIQUlOX0lEX1NFUlZFUl9NQVBQSU5HIiwiV2FsbGV0QWRhcHRlck5ldHdvcmsiLCJBUFRfQ0hBSU5fSURfTkFNRV9NQVBQSU5HIiwiTWFpbm5ldCIsIlRlc3RpbmciLCJQcmVtYWlubmV0IiwiQVBUX0NIQUlOX0lEX1JQQ19NQVBQSU5HIiwiRUlQMTE5M19FVkVOVFMiLCJERUZBVUxUX0FQUF9JRCIsIkJsb2N0b1Byb3ZpZGVyIiwiaXNCbG9jdG8iLCJpc0Nvbm5lY3RpbmciLCJldmVudExpc3RlbmVycyIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwiZm9yRWFjaCIsImV2ZW50IiwiYXBwSWQiLCJyZXF1ZXN0IiwicGF5bG9hZCIsIm9uIiwibGlzdGVuZXIiLCJpbmNsdWRlcyIsInB1c2giLCJvbmNlIiwibGlzdGVuZXJzIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJpdGVtIiwic3BsaWNlIiwiSUZSQU1FX1NUWUxFIiwiY3JlYXRlRnJhbWUiLCJ1cmwiLCJmcmFtZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImF0dGFjaEZyYW1lIiwiYm9keSIsImFwcGVuZENoaWxkIiwiZGV0YXRjaEZyYW1lIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiRnVuY3Rpb24iLCJhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlciIsImV2ZW50VHlwZSIsImhhbmRsZXIiLCJ0YXJnZXQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlc3BvbnNlU2Vzc2lvbkd1YXJkIiwicmVzcG9uc2UiLCJkaXNjb25uZWN0SGFuZGxlciIsInN0YXR1cyIsIm9rIiwianNvbiIsImVycm9yX2NvZGUiLCJpc0VtYWlsIiwidGVzdCIsImlzVmFsaWRUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIiwiaXNWYWxpZFRyYW5zYWN0aW9ucyIsInRyYW5zYWN0aW9ucyIsIkFycmF5IiwiaXNBcnJheSIsImV2ZXJ5IiwidHgiLCJnZXRFdm1TdXBwb3J0IiwibmV0d29ya3MiLCJmZXRjaCIsImV2bVN1cHBvcnRNYXAiLCJyZWR1Y2UiLCJhIiwiY2hhaW5faWQiLCJnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyIsIngiLCJfX2VzTW9kdWxlIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJkaXN0IiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl90b1ByaW1pdGl2ZSIsImlucHV0IiwiaGludCIsInByaW0iLCJ0b1ByaW1pdGl2ZSIsInJlcyIsIlN0cmluZyIsIk51bWJlciIsIl90b1Byb3BlcnR5S2V5IiwiYXJnIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfc2V0UHJvdG90eXBlT2YiLCJvIiwicCIsInNldFByb3RvdHlwZU9mIiwiYmluZCIsIl9fcHJvdG9fXyIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9nZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX2lzTmF0aXZlRnVuY3Rpb24iLCJmbiIsInRvU3RyaW5nIiwiaW5kZXhPZiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMSIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzaGFtIiwiUHJveHkiLCJCb29sZWFuIiwidmFsdWVPZiIsIl9jb25zdHJ1Y3QiLCJQYXJlbnQiLCJhcmdzIiwiQ2xhc3MiLCJhcmd1bWVudHMiLCJfd3JhcE5hdGl2ZVN1cGVyIiwiX2NhY2hlIiwiTWFwIiwic2V0IiwiV3JhcHBlciIsImNsYXNzZXMiLCJmYXN0U2FmZVN0cmluZ2lmeSIsInN0YWJsZSIsImRldGVybWluaXN0aWNTdHJpbmdpZnkiLCJzdGFibGVTdHJpbmdpZnkiLCJMSU1JVF9SRVBMQUNFX05PREUiLCJDSVJDVUxBUl9SRVBMQUNFX05PREUiLCJhcnIiLCJyZXBsYWNlclN0YWNrIiwiZGVmYXVsdE9wdGlvbnMiLCJkZXB0aExpbWl0IiwiTUFYX1NBRkVfSU5URUdFUiIsImVkZ2VzTGltaXQiLCJyZXBsYWNlciIsInNwYWNlciIsIm9wdGlvbnMiLCJkZWNpcmMiLCJyZXBsYWNlR2V0dGVyVmFsdWVzIiwiXyIsInBhcnQiLCJwb3AiLCJzZXRSZXBsYWNlIiwicmVwbGFjZSIsInZhbCIsImsiLCJwYXJlbnQiLCJwcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlZGdlSW5kZXgiLCJzdGFjayIsImRlcHRoIiwia2V5cyIsImNvbXBhcmVGdW5jdGlvbiIsImIiLCJ0bXAiLCJkZXRlcm1pbmlzdGljRGVjaXJjIiwidG9KU09OIiwic29ydCIsIl9jcmVhdGVTdXBlciIsIkRlcml2ZWQiLCJoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9jcmVhdGVTdXBlckludGVybmFsIiwiU3VwZXIiLCJOZXdUYXJnZXQiLCJFdGhlcmV1bVByb3ZpZGVyRXJyb3IiLCJFdGhlcmV1bVJwY0Vycm9yIiwiZmFzdF9zYWZlX3N0cmluZ2lmeV8xIiwiX0Vycm9yIiwiX3N1cGVyIiwiX3RoaXMiLCJpc0ludGVnZXIiLCJzZXJpYWxpemUiLCJzZXJpYWxpemVkIiwic3RyaW5naWZ5UmVwbGFjZXIiLCJfRXRoZXJldW1ScGNFcnJvciIsIl9zdXBlcjIiLCJpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlIiwidXRpbHMiLCJlcnJvckNvbnN0YW50cyIsImVycm9yVmFsdWVzIiwiZXJyb3JDb2RlcyIsInJwYyIsImludmFsaWRJbnB1dCIsInJlc291cmNlTm90Rm91bmQiLCJyZXNvdXJjZVVuYXZhaWxhYmxlIiwidHJhbnNhY3Rpb25SZWplY3RlZCIsIm1ldGhvZE5vdFN1cHBvcnRlZCIsImxpbWl0RXhjZWVkZWQiLCJpbnZhbGlkUmVxdWVzdCIsIm1ldGhvZE5vdEZvdW5kIiwiaW52YWxpZFBhcmFtcyIsImludGVybmFsIiwicHJvdmlkZXIiLCJ1c2VyUmVqZWN0ZWRSZXF1ZXN0IiwidW5hdXRob3JpemVkIiwidW5zdXBwb3J0ZWRNZXRob2QiLCJkaXNjb25uZWN0ZWQiLCJjaGFpbkRpc2Nvbm5lY3RlZCIsInN0YW5kYXJkIiwiZXhwb3J0cyIsInNlcmlhbGl6ZUVycm9yIiwiaXNWYWxpZENvZGUiLCJnZXRNZXNzYWdlRnJvbUNvZGUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSIsImVycm9yX2NvbnN0YW50c18xIiwiY2xhc3Nlc18xIiwiRkFMTEJBQ0tfRVJST1JfQ09ERSIsIkZBTExCQUNLX01FU1NBR0UiLCJGQUxMQkFDS19FUlJPUiIsImZhbGxiYWNrTWVzc2FnZSIsImNvZGVTdHJpbmciLCJoYXNLZXkiLCJpc0pzb25ScGNTZXJ2ZXJFcnJvciIsIl9yZWYiLCJfcmVmJGZhbGxiYWNrRXJyb3IiLCJmYWxsYmFja0Vycm9yIiwiX3JlZiRzaG91bGRJbmNsdWRlU3RhIiwic2hvdWxkSW5jbHVkZVN0YWNrIiwiX2Vycm9yIiwib3JpZ2luYWxFcnJvciIsImFzc2lnbk9yaWdpbmFsRXJyb3IiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfaSIsIl9zIiwiX2UiLCJfeCIsIl9yIiwiX2FyciIsIl9uIiwiX2QiLCJlcnIiLCJfYXJyYXlMaWtlVG9BcnJheSIsImxlbiIsImFycjIiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJtaW5MZW4iLCJuIiwic2xpY2UiLCJmcm9tIiwiX25vbkl0ZXJhYmxlUmVzdCIsIl9zbGljZWRUb0FycmF5IiwiZXJyb3JzIiwiZXRoRXJyb3JzIiwidXRpbHNfMSIsImdldEV0aEpzb25ScGNFcnJvciIsInNlcnZlciIsIm9wdHMiLCJnZXRFdGhQcm92aWRlckVycm9yIiwiY3VzdG9tIiwiX3BhcnNlT3B0cyIsInBhcnNlT3B0cyIsIl9wYXJzZU9wdHMyIiwiX3BhcnNlT3B0czMiLCJfcGFyc2VPcHRzNCIsImVycm9yc18xIiwiZ2xvYmFsJDEiLCJnbG9iYWwiLCJsb29rdXAiLCJyZXZMb29rdXAiLCJBcnIiLCJVaW50OEFycmF5IiwiaW5pdGVkIiwiaW5pdCIsImNoYXJDb2RlQXQiLCJ0b0J5dGVBcnJheSIsImI2NCIsImoiLCJsIiwicGxhY2VIb2xkZXJzIiwiTCIsInRyaXBsZXRUb0Jhc2U2NCIsIm51bSIsImVuY29kZUNodW5rIiwidWludDgiLCJzdGFydCIsImVuZCIsIm91dHB1dCIsImpvaW4iLCJmcm9tQnl0ZUFycmF5IiwiZXh0cmFCeXRlcyIsInBhcnRzIiwibWF4Q2h1bmtMZW5ndGgiLCJsZW4yIiwicmVhZCIsImJ1ZmZlciIsIm9mZnNldCIsImlzTEUiLCJtTGVuIiwibkJ5dGVzIiwibSIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsImQiLCJzIiwiTmFOIiwiSW5maW5pdHkiLCJNYXRoIiwicG93Iiwid3JpdGUiLCJjIiwicnQiLCJhYnMiLCJpc05hTiIsImZsb29yIiwibG9nIiwiTE4yIiwiSU5TUEVDVF9NQVhfQllURVMiLCJCdWZmZXIiLCJUWVBFRF9BUlJBWV9TVVBQT1JUIiwia01heExlbmd0aCIsImNyZWF0ZUJ1ZmZlciIsInRoYXQiLCJSYW5nZUVycm9yIiwiZW5jb2RpbmdPck9mZnNldCIsImFsbG9jVW5zYWZlIiwicG9vbFNpemUiLCJfYXVnbWVudCIsIkFycmF5QnVmZmVyIiwiZnJvbUFycmF5QnVmZmVyIiwiZnJvbVN0cmluZyIsImZyb21PYmplY3QiLCJzcGVjaWVzIiwiYXNzZXJ0U2l6ZSIsInNpemUiLCJhbGxvYyIsImZpbGwiLCJlbmNvZGluZyIsImNoZWNrZWQiLCJhbGxvY1Vuc2FmZVNsb3ciLCJzdHJpbmciLCJpc0VuY29kaW5nIiwiYnl0ZUxlbmd0aCIsImFjdHVhbCIsImZyb21BcnJheUxpa2UiLCJhcnJheSIsImJ5dGVPZmZzZXQiLCJpbnRlcm5hbElzQnVmZmVyIiwiY29weSIsImlzbmFuIiwidHlwZSIsImlzQnVmZmVyIiwiX2lzQnVmZmVyIiwiY29tcGFyZSIsInkiLCJtaW4iLCJ0b0xvd2VyQ2FzZSIsImNvbmNhdCIsImxpc3QiLCJwb3MiLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiZXF1YWxzIiwiaW5zcGVjdCIsInN0ciIsIm1heCIsIm1hdGNoIiwidGhpc1N0YXJ0IiwidGhpc0VuZCIsInRoaXNDb3B5IiwidGFyZ2V0Q29weSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwiZGlyIiwiYXJyYXlJbmRleE9mIiwibGFzdEluZGV4T2YiLCJpbmRleFNpemUiLCJhcnJMZW5ndGgiLCJ2YWxMZW5ndGgiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJoZXhXcml0ZSIsInJlbWFpbmluZyIsInN0ckxlbiIsInBhcnNlZCIsInBhcnNlSW50Iiwic3Vic3RyIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJpc0Zpbml0ZSIsImZpcnN0Qnl0ZSIsImNvZGVQb2ludCIsImJ5dGVzUGVyU2VxdWVuY2UiLCJzZWNvbmRCeXRlIiwidGhpcmRCeXRlIiwiZm91cnRoQnl0ZSIsInRlbXBDb2RlUG9pbnQiLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJNQVhfQVJHVU1FTlRTX0xFTkdUSCIsImNvZGVQb2ludHMiLCJmcm9tQ2hhckNvZGUiLCJyZXQiLCJvdXQiLCJ0b0hleCIsImJ5dGVzIiwibmV3QnVmIiwic3ViYXJyYXkiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4Iiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIm9iamVjdFdyaXRlVUludDMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnQzMkJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsIklOVkFMSURfQkFTRTY0X1JFIiwiYmFzZTY0Y2xlYW4iLCJzdHJpbmd0cmltIiwidHJpbSIsInVuaXRzIiwibGVhZFN1cnJvZ2F0ZSIsImJ5dGVBcnJheSIsImhpIiwibG8iLCJzcmMiLCJkc3QiLCJpc0Zhc3RCdWZmZXIiLCJpc1Nsb3dCdWZmZXIiLCJpc0hleFN0cmluZyIsImhleCIsInV0ZjhUb0hleCIsIl9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcyIsIl9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMiLCJfRXRoZXJldW1Qcm92aWRlcl9hZGRUb1N3aXRjaGFibGUiLCJfRXRoZXJldW1Qcm92aWRlcl9jaGVja05ldHdvcmtNYXRjaGVkIiwicGFyc2VDaGFpbklkIiwiY2hhaW5JZCIsInN0YXJ0c1dpdGgiLCJFdGhlcmV1bVByb3ZpZGVyIiwid2FsbGV0U2VydmVyIiwiYWRkIiwibmV0d29ya1ZlcnNpb24iLCJpbmplY3RlZFdhbGxldFNlcnZlciIsIl9ibG9jdG8iLCJzZXNzaW9uS2V5IiwiYmxvY2tjaGFpbk5hbWUiLCJuZXR3b3JrVHlwZSIsInN1cHBvcnROZXR3b3JrTGlzdCIsInN3aXRjaGFibGVOZXR3b3JrIiwic2VuZCIsIm1ldGhvZE9yUGF5bG9hZCIsInBhcmFtc09yQ2FsbGJhY2siLCJzZW5kQXN5bmMiLCJqc29ucnBjIiwibWV0aG9kIiwicGFyYW1zIiwiY2FsbGJhY2siLCJoYW5kbGVSZXF1ZXN0IiwiZmlsdGVyIiwibWFwIiwiaWRCYXNlIiwicmFuZG9tIiwiYmF0Y2hlZFJlcXVlc3RQYXlsb2FkIiwiYmF0Y2hSZXNwb25zZVByb21pc2UiLCJyZXF1ZXN0cyIsImlkIiwiYWxsU2V0dGxlZCIsInJlc3BvbnNlcyIsInJlYXNvbiIsImNhdGNoIiwic2VuZFVzZXJPcGVyYXRpb24iLCJ1c2VyT3AiLCJfZiIsIl9nIiwiX2giLCJfaiIsIl9rIiwiZXhpc3RlZFNESyIsImV0aGVyZXVtIiwicnBjX3VybCIsImxvYWRTd2l0Y2hhYmxlTmV0d29yayIsImhhbmRsZVJlYWRSZXF1ZXN0cyIsImVycm9yTWVzc2FnZSIsIm5ld0NoYWluSWQiLCJwaGFzZWRDaGFpbklkIiwiY2hhaW5DaGFuZ2VkIiwiZW1haWwiLCJlbmFibGUiLCJmZXRjaEFjY291bnRzIiwiaGFuZGxlU2lnbiIsImhhbmRsZURpc2Nvbm5lY3QiLCJoYW5kbGVTZW5kVHJhbnNhY3Rpb24iLCJoYW5kbGVTZW5kQmF0Y2hUcmFuc2FjdGlvbiIsImhhbmRsZVNlbmRVc2VyT3BlcmF0aW9uIiwib2xkQWNjb3VudCIsIm9sZENoYWluSWQiLCJuZXdBY2NvdW50IiwiYWNjb3VudHNDaGFuZ2VkIiwiaGFuZGxlQnVuZGxlciIsImJsb2N0b0FwaSIsInNlc3Npb25JZCIsImhlYWRlcnMiLCJkaXNjb25uZWN0IiwicmVzcG9uc2VMaXN0ZW5lciIsIm9iamVjdEtleSIsIm9yaWdpbiIsImVycm9yQ29kZSIsInNldElmcmFtZSIsImFkZHJlc3MiLCJzZXRUaW1lb3V0IiwiVVJMU2VhcmNoUGFyYW1zIiwibG9jYXRpb24iLCJlbWFpbFBhcmFtIiwibG9naW5GcmFtZSIsImNvbm5lY3QiLCJhZGRyIiwiZXhwIiwiZG9tYWluIiwic2lnbmF0dXJlSWQiLCJzaWduRnJhbWUiLCJhdXRob3JpemF0aW9uSWQiLCJhdXRoekZyYW1lIiwiZXh0cmFjdFBhcmFtcyIsInBhcmFtIiwiZm9ybWF0UGFyYW1zIiwiY29weVBheWxvYWQiLCJ1c2VyT1BGcmFtZSIsIm5ldHdvcmtMaXN0IiwibGlzdFRvQWRkIiwicnBjVXJscyIsImFsbCIsIldlYWtTZXQiLCJuZXR3b3JrX3R5cGUiLCJibG9jdG9fc2VydmljZV9lbnZpcm9ubWVudCIsImRpc3BsYXlfbmFtZSIsIndhbGxldF93ZWJfdXJsIiwiYmFzZSIsIkFMUEhBQkVUIiwiQkFTRV9NQVAiLCJjaGFyQXQiLCJ4YyIsIkJBU0UiLCJMRUFERVIiLCJGQUNUT1IiLCJpRkFDVE9SIiwiZW5jb2RlIiwic291cmNlIiwiemVyb2VzIiwicGJlZ2luIiwicGVuZCIsImI1OCIsImNhcnJ5IiwiaXQxIiwiaXQyIiwicmVwZWF0IiwiZGVjb2RlVW5zYWZlIiwicHN6IiwiYjI1NiIsIml0MyIsIml0NCIsInZjaCIsImRlY29kZSIsImJhc2V4IiwiYnM1OCIsImJzNTgkMSIsIlNvbGFuYSIsInJlcXVpcmUiLCJTb2xhbmFQcm92aWRlciIsIm5ldCIsInZhbHVlcyIsInNvbGFuYSIsIlNPTEFOQSIsImFjY291bnRJbmZvIiwiYnVmZmVyRGF0YSIsIm93bmVyIiwiUHVibGljS2V5IiwiaGFuZGxlQ29udmVydFRyYW5zYWN0aW9uIiwiaGFuZGxlU2lnbkFuZFNlbmRUcmFuc2FjdGlvbiIsImNvbnNvbGUiLCJwdWJsaWNLZXkiLCJ0b0Jhc2U1OCIsImVuY29kZVVSSUNvbXBvbmVudCIsImNvbnZlcnRUb1Byb2dyYW1XYWxsZXRUcmFuc2FjdGlvbiIsInNlcmlhbGl6ZU1lc3NhZ2UiLCJ0b1RyYW5zYWN0aW9uIiwic2lnbkFuZFNlbmRUcmFuc2FjdGlvbiIsImNvbm5lY3Rpb24iLCJleHRyYSIsImNvbW1pdG1lbnQiLCJfcnBjRW5kcG9pbnQiLCJzaWduYXR1cmVzIiwiY29sbGVjdFNpZ25hdHVyZXMiLCJyYXciLCJNZXNzYWdlIiwiVHJhbnNhY3Rpb24iLCJyZWNlbnRCbG9ja2hhc2giLCJoZWFkZXIiLCJudW1SZXF1aXJlZFNpZ25hdHVyZXMiLCJmZWVQYXllciIsImFjY291bnRLZXlzIiwic2lnbmF0dXJlIiwic2lnUHVia2V5UGFpciIsImRlZmF1bHQiLCJpbnN0cnVjdGlvbnMiLCJpbnN0cnVjdGlvbiIsInB1YmtleSIsImlzU2lnbmVyIiwiaXNXcml0YWJsZSIsImlzQWNjb3VudFdyaXRhYmxlIiwiVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiIsInByb2dyYW1JZCIsInByb2dyYW1JZEluZGV4IiwiYWNjIiwiY3VyIiwidHhIYXNoIiwiY2hlY2tNZXNzYWdlUGF5bG9hZEZvcm1hdCIsImZvcm1hdHRlZFBheWxvYWQiLCJub25jZSIsImFwcGxpY2F0aW9uIiwiQXB0b3NQcm92aWRlciIsImF1dGhLZXkiLCJuZXR3b3JrTmFtZSIsImFwaSIsImRlZmF1bHRTZXJ2ZXIiLCJwdWJsaWNBY2NvdW50IiwiQVBUT1MiLCJtaW5LZXlzUmVxdWlyZWQiLCJuZXR3b3JrIiwiaXNDb25uZWN0ZWQiLCJzaWduVHJhbnNhY3Rpb24iLCJibG9jdG9BcHRvcyIsImhhc0Nvbm5lY3RlZCIsInNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbiIsInR4T3B0aW9ucyIsImhhc2giLCJzaWduTWVzc2FnZSIsInB1YmxpY19rZXlzIiwicHVibGljS2V5cyIsImZldGNoQWRkcmVzcyIsIkJsb2N0b1NESyIsImFwdG9zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@blocto+sdk@0.5.5/node_modules/@blocto/sdk/dist/blocto-sdk.module.js\n");

/***/ })

};
;