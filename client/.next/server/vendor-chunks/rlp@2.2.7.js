"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rlp@2.2.7";
exports.ids = ["vendor-chunks/rlp@2.2.7"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/rlp@2.2.7/node_modules/rlp/dist/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/.pnpm/rlp@2.2.7/node_modules/rlp/dist/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getLength = exports.decode = exports.encode = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.0/node_modules/bn.js/lib/bn.js\"));\n/**\n * RLP Encoding based on: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP\n * This function takes in a data, convert it to buffer if not, and a length for recursion\n * @param input - will be converted to buffer\n * @returns returns buffer of encoded data\n **/ function encode(input) {\n    if (Array.isArray(input)) {\n        const output = [];\n        for(let i = 0; i < input.length; i++){\n            output.push(encode(input[i]));\n        }\n        const buf = Buffer.concat(output);\n        return Buffer.concat([\n            encodeLength(buf.length, 192),\n            buf\n        ]);\n    } else {\n        const inputBuf = toBuffer(input);\n        return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : Buffer.concat([\n            encodeLength(inputBuf.length, 128),\n            inputBuf\n        ]);\n    }\n}\nexports.encode = encode;\n/**\n * Parse integers. Check if there is no leading zeros\n * @param v The value to parse\n * @param base The base to parse the integer into\n */ function safeParseInt(v, base) {\n    if (v[0] === \"0\" && v[1] === \"0\") {\n        throw new Error(\"invalid RLP: extra zeros\");\n    }\n    return parseInt(v, base);\n}\nfunction encodeLength(len, offset) {\n    if (len < 56) {\n        return Buffer.from([\n            len + offset\n        ]);\n    } else {\n        const hexLength = intToHex(len);\n        const lLength = hexLength.length / 2;\n        const firstByte = intToHex(offset + 55 + lLength);\n        return Buffer.from(firstByte + hexLength, \"hex\");\n    }\n}\nfunction decode(input, stream = false) {\n    if (!input || input.length === 0) {\n        return Buffer.from([]);\n    }\n    const inputBuffer = toBuffer(input);\n    const decoded = _decode(inputBuffer);\n    if (stream) {\n        return decoded;\n    }\n    if (decoded.remainder.length !== 0) {\n        throw new Error(\"invalid remainder\");\n    }\n    return decoded.data;\n}\nexports.decode = decode;\n/**\n * Get the length of the RLP input\n * @param input\n * @returns The length of the input or an empty Buffer if no input\n */ function getLength(input) {\n    if (!input || input.length === 0) {\n        return Buffer.from([]);\n    }\n    const inputBuffer = toBuffer(input);\n    const firstByte = inputBuffer[0];\n    if (firstByte <= 0x7f) {\n        return inputBuffer.length;\n    } else if (firstByte <= 0xb7) {\n        return firstByte - 0x7f;\n    } else if (firstByte <= 0xbf) {\n        return firstByte - 0xb6;\n    } else if (firstByte <= 0xf7) {\n        // a list between  0-55 bytes long\n        return firstByte - 0xbf;\n    } else {\n        // a list  over 55 bytes long\n        const llength = firstByte - 0xf6;\n        const length = safeParseInt(inputBuffer.slice(1, llength).toString(\"hex\"), 16);\n        return llength + length;\n    }\n}\nexports.getLength = getLength;\n/** Decode an input with RLP */ function _decode(input) {\n    let length, llength, data, innerRemainder, d;\n    const decoded = [];\n    const firstByte = input[0];\n    if (firstByte <= 0x7f) {\n        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.\n        return {\n            data: input.slice(0, 1),\n            remainder: input.slice(1)\n        };\n    } else if (firstByte <= 0xb7) {\n        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string\n        // The range of the first byte is [0x80, 0xb7]\n        length = firstByte - 0x7f;\n        // set 0x80 null to 0\n        if (firstByte === 0x80) {\n            data = Buffer.from([]);\n        } else {\n            data = input.slice(1, length);\n        }\n        if (length === 2 && data[0] < 0x80) {\n            throw new Error(\"invalid rlp encoding: byte must be less 0x80\");\n        }\n        return {\n            data: data,\n            remainder: input.slice(length)\n        };\n    } else if (firstByte <= 0xbf) {\n        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),\n        // followed by the length, followed by the string\n        llength = firstByte - 0xb6;\n        if (input.length - 1 < llength) {\n            throw new Error(\"invalid RLP: not enough bytes for string length\");\n        }\n        length = safeParseInt(input.slice(1, llength).toString(\"hex\"), 16);\n        if (length <= 55) {\n            throw new Error(\"invalid RLP: expected string length to be greater than 55\");\n        }\n        data = input.slice(llength, length + llength);\n        if (data.length < length) {\n            throw new Error(\"invalid RLP: not enough bytes for string\");\n        }\n        return {\n            data: data,\n            remainder: input.slice(length + llength)\n        };\n    } else if (firstByte <= 0xf7) {\n        // a list between  0-55 bytes long\n        length = firstByte - 0xbf;\n        innerRemainder = input.slice(1, length);\n        while(innerRemainder.length){\n            d = _decode(innerRemainder);\n            decoded.push(d.data);\n            innerRemainder = d.remainder;\n        }\n        return {\n            data: decoded,\n            remainder: input.slice(length)\n        };\n    } else {\n        // a list  over 55 bytes long\n        llength = firstByte - 0xf6;\n        length = safeParseInt(input.slice(1, llength).toString(\"hex\"), 16);\n        const totalLength = llength + length;\n        if (totalLength > input.length) {\n            throw new Error(\"invalid rlp: total length is larger than the data\");\n        }\n        innerRemainder = input.slice(llength, totalLength);\n        if (innerRemainder.length === 0) {\n            throw new Error(\"invalid rlp, List has a invalid length\");\n        }\n        while(innerRemainder.length){\n            d = _decode(innerRemainder);\n            decoded.push(d.data);\n            innerRemainder = d.remainder;\n        }\n        return {\n            data: decoded,\n            remainder: input.slice(totalLength)\n        };\n    }\n}\n/** Check if a string is prefixed by 0x */ function isHexPrefixed(str) {\n    return str.slice(0, 2) === \"0x\";\n}\n/** Removes 0x from a given String */ function stripHexPrefix(str) {\n    if (typeof str !== \"string\") {\n        return str;\n    }\n    return isHexPrefixed(str) ? str.slice(2) : str;\n}\n/** Transform an integer into its hexadecimal value */ function intToHex(integer) {\n    if (integer < 0) {\n        throw new Error(\"Invalid integer as argument, must be unsigned!\");\n    }\n    const hex = integer.toString(16);\n    return hex.length % 2 ? `0${hex}` : hex;\n}\n/** Pad a string to be even */ function padToEven(a) {\n    return a.length % 2 ? `0${a}` : a;\n}\n/** Transform an integer into a Buffer */ function intToBuffer(integer) {\n    const hex = intToHex(integer);\n    return Buffer.from(hex, \"hex\");\n}\n/** Transform anything into a Buffer */ function toBuffer(v) {\n    if (!Buffer.isBuffer(v)) {\n        if (typeof v === \"string\") {\n            if (isHexPrefixed(v)) {\n                return Buffer.from(padToEven(stripHexPrefix(v)), \"hex\");\n            } else {\n                return Buffer.from(v);\n            }\n        } else if (typeof v === \"number\" || typeof v === \"bigint\") {\n            if (!v) {\n                return Buffer.from([]);\n            } else {\n                return intToBuffer(v);\n            }\n        } else if (v === null || v === undefined) {\n            return Buffer.from([]);\n        } else if (v instanceof Uint8Array) {\n            return Buffer.from(v);\n        } else if (bn_js_1.default.isBN(v)) {\n            // converts a BN to a Buffer\n            return Buffer.from(v.toArray());\n        } else {\n            throw new Error(\"invalid type\");\n        }\n    }\n    return v;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmxwQDIuMi43L25vZGVfbW9kdWxlcy9ybHAvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDM0QsTUFBTUssVUFBVVYsZ0JBQWdCVyxtQkFBT0EsQ0FBQyxrRkFBTztBQUMvQzs7Ozs7RUFLRSxHQUNGLFNBQVNGLE9BQU9HLEtBQUs7SUFDakIsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixRQUFRO1FBQ3RCLE1BQU1HLFNBQVMsRUFBRTtRQUNqQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUosTUFBTUssTUFBTSxFQUFFRCxJQUFLO1lBQ25DRCxPQUFPRyxJQUFJLENBQUNULE9BQU9HLEtBQUssQ0FBQ0ksRUFBRTtRQUMvQjtRQUNBLE1BQU1HLE1BQU1DLE9BQU9DLE1BQU0sQ0FBQ047UUFDMUIsT0FBT0ssT0FBT0MsTUFBTSxDQUFDO1lBQUNDLGFBQWFILElBQUlGLE1BQU0sRUFBRTtZQUFNRTtTQUFJO0lBQzdELE9BQ0s7UUFDRCxNQUFNSSxXQUFXQyxTQUFTWjtRQUMxQixPQUFPVyxTQUFTTixNQUFNLEtBQUssS0FBS00sUUFBUSxDQUFDLEVBQUUsR0FBRyxNQUN4Q0EsV0FDQUgsT0FBT0MsTUFBTSxDQUFDO1lBQUNDLGFBQWFDLFNBQVNOLE1BQU0sRUFBRTtZQUFNTTtTQUFTO0lBQ3RFO0FBQ0o7QUFDQWxCLGNBQWMsR0FBR0k7QUFDakI7Ozs7Q0FJQyxHQUNELFNBQVNnQixhQUFhQyxDQUFDLEVBQUVDLElBQUk7SUFD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QUFLO0FBQzVCO0FBQ0EscUNBQXFDLEdBQ3JDLFNBQVM3QixTQUFTRSxDQUFDO0lBQ2YsSUFBSSxDQUFDTixPQUFPcUMsUUFBUSxDQUFDL0IsSUFBSTtRQUNyQixJQUFJLE9BQU9BLE1BQU0sVUFBVTtZQUN2QixJQUFJdUIsY0FBY3ZCLElBQUk7Z0JBQ2xCLE9BQU9OLE9BQU9ZLElBQUksQ0FBQ3NCLFVBQVVILGVBQWV6QixLQUFLO1lBQ3JELE9BQ0s7Z0JBQ0QsT0FBT04sT0FBT1ksSUFBSSxDQUFDTjtZQUN2QjtRQUNKLE9BQ0ssSUFBSSxPQUFPQSxNQUFNLFlBQVksT0FBT0EsTUFBTSxVQUFVO1lBQ3JELElBQUksQ0FBQ0EsR0FBRztnQkFDSixPQUFPTixPQUFPWSxJQUFJLENBQUMsRUFBRTtZQUN6QixPQUNLO2dCQUNELE9BQU93QixZQUFZOUI7WUFDdkI7UUFDSixPQUNLLElBQUlBLE1BQU0sUUFBUUEsTUFBTWdDLFdBQVc7WUFDcEMsT0FBT3RDLE9BQU9ZLElBQUksQ0FBQyxFQUFFO1FBQ3pCLE9BQ0ssSUFBSU4sYUFBYWlDLFlBQVk7WUFDOUIsT0FBT3ZDLE9BQU9ZLElBQUksQ0FBQ047UUFDdkIsT0FDSyxJQUFJaEIsUUFBUWtELE9BQU8sQ0FBQ0MsSUFBSSxDQUFDbkMsSUFBSTtZQUM5Qiw0QkFBNEI7WUFDNUIsT0FBT04sT0FBT1ksSUFBSSxDQUFDTixFQUFFb0MsT0FBTztRQUNoQyxPQUNLO1lBQ0QsTUFBTSxJQUFJbEMsTUFBTTtRQUNwQjtJQUNKO0lBQ0EsT0FBT0Y7QUFDWCxFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy8ucG5wbS9ybHBAMi4yLjcvbm9kZV9tb2R1bGVzL3JscC9kaXN0L2luZGV4LmpzP2Q0ZjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldExlbmd0aCA9IGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5lbmNvZGUgPSB2b2lkIDA7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG4vKipcbiAqIFJMUCBFbmNvZGluZyBiYXNlZCBvbjogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS8lNUJFbmdsaXNoJTVELVJMUFxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBpbiBhIGRhdGEsIGNvbnZlcnQgaXQgdG8gYnVmZmVyIGlmIG5vdCwgYW5kIGEgbGVuZ3RoIGZvciByZWN1cnNpb25cbiAqIEBwYXJhbSBpbnB1dCAtIHdpbGwgYmUgY29udmVydGVkIHRvIGJ1ZmZlclxuICogQHJldHVybnMgcmV0dXJucyBidWZmZXIgb2YgZW5jb2RlZCBkYXRhXG4gKiovXG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGVuY29kZShpbnB1dFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5jb25jYXQob3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2VuY29kZUxlbmd0aChidWYubGVuZ3RoLCAxOTIpLCBidWZdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGlucHV0QnVmID0gdG9CdWZmZXIoaW5wdXQpO1xuICAgICAgICByZXR1cm4gaW5wdXRCdWYubGVuZ3RoID09PSAxICYmIGlucHV0QnVmWzBdIDwgMTI4XG4gICAgICAgICAgICA/IGlucHV0QnVmXG4gICAgICAgICAgICA6IEJ1ZmZlci5jb25jYXQoW2VuY29kZUxlbmd0aChpbnB1dEJ1Zi5sZW5ndGgsIDEyOCksIGlucHV0QnVmXSk7XG4gICAgfVxufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vKipcbiAqIFBhcnNlIGludGVnZXJzLiBDaGVjayBpZiB0aGVyZSBpcyBubyBsZWFkaW5nIHplcm9zXG4gKiBAcGFyYW0gdiBUaGUgdmFsdWUgdG8gcGFyc2VcbiAqIEBwYXJhbSBiYXNlIFRoZSBiYXNlIHRvIHBhcnNlIHRoZSBpbnRlZ2VyIGludG9cbiAqL1xuZnVuY3Rpb24gc2FmZVBhcnNlSW50KHYsIGJhc2UpIHtcbiAgICBpZiAodlswXSA9PT0gJzAnICYmIHZbMV0gPT09ICcwJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBleHRyYSB6ZXJvcycpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQodiwgYmFzZSk7XG59XG5mdW5jdGlvbiBlbmNvZGVMZW5ndGgobGVuLCBvZmZzZXQpIHtcbiAgICBpZiAobGVuIDwgNTYpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtsZW4gKyBvZmZzZXRdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGhleExlbmd0aCA9IGludFRvSGV4KGxlbik7XG4gICAgICAgIGNvbnN0IGxMZW5ndGggPSBoZXhMZW5ndGgubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgZmlyc3RCeXRlID0gaW50VG9IZXgob2Zmc2V0ICsgNTUgKyBsTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGZpcnN0Qnl0ZSArIGhleExlbmd0aCwgJ2hleCcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlY29kZShpbnB1dCwgc3RyZWFtID0gZmFsc2UpIHtcbiAgICBpZiAoIWlucHV0IHx8IGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oW10pO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dEJ1ZmZlciA9IHRvQnVmZmVyKGlucHV0KTtcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShpbnB1dEJ1ZmZlcik7XG4gICAgaWYgKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICB9XG4gICAgaWYgKGRlY29kZWQucmVtYWluZGVyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVtYWluZGVyJyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkLmRhdGE7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIFJMUCBpbnB1dFxuICogQHBhcmFtIGlucHV0XG4gKiBAcmV0dXJucyBUaGUgbGVuZ3RoIG9mIHRoZSBpbnB1dCBvciBhbiBlbXB0eSBCdWZmZXIgaWYgbm8gaW5wdXRcbiAqL1xuZnVuY3Rpb24gZ2V0TGVuZ3RoKGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCB8fCBpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtdKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRCdWZmZXIgPSB0b0J1ZmZlcihpbnB1dCk7XG4gICAgY29uc3QgZmlyc3RCeXRlID0gaW5wdXRCdWZmZXJbMF07XG4gICAgaWYgKGZpcnN0Qnl0ZSA8PSAweDdmKSB7XG4gICAgICAgIHJldHVybiBpbnB1dEJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGI3KSB7XG4gICAgICAgIHJldHVybiBmaXJzdEJ5dGUgLSAweDdmO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhiZikge1xuICAgICAgICByZXR1cm4gZmlyc3RCeXRlIC0gMHhiNjtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4ZjcpIHtcbiAgICAgICAgLy8gYSBsaXN0IGJldHdlZW4gIDAtNTUgYnl0ZXMgbG9uZ1xuICAgICAgICByZXR1cm4gZmlyc3RCeXRlIC0gMHhiZjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGEgbGlzdCAgb3ZlciA1NSBieXRlcyBsb25nXG4gICAgICAgIGNvbnN0IGxsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGY2O1xuICAgICAgICBjb25zdCBsZW5ndGggPSBzYWZlUGFyc2VJbnQoaW5wdXRCdWZmZXIuc2xpY2UoMSwgbGxlbmd0aCkudG9TdHJpbmcoJ2hleCcpLCAxNik7XG4gICAgICAgIHJldHVybiBsbGVuZ3RoICsgbGVuZ3RoO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0TGVuZ3RoID0gZ2V0TGVuZ3RoO1xuLyoqIERlY29kZSBhbiBpbnB1dCB3aXRoIFJMUCAqL1xuZnVuY3Rpb24gX2RlY29kZShpbnB1dCkge1xuICAgIGxldCBsZW5ndGgsIGxsZW5ndGgsIGRhdGEsIGlubmVyUmVtYWluZGVyLCBkO1xuICAgIGNvbnN0IGRlY29kZWQgPSBbXTtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBpbnB1dFswXTtcbiAgICBpZiAoZmlyc3RCeXRlIDw9IDB4N2YpIHtcbiAgICAgICAgLy8gYSBzaW5nbGUgYnl0ZSB3aG9zZSB2YWx1ZSBpcyBpbiB0aGUgWzB4MDAsIDB4N2ZdIHJhbmdlLCB0aGF0IGJ5dGUgaXMgaXRzIG93biBSTFAgZW5jb2RpbmcuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5zbGljZSgwLCAxKSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UoMSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGI3KSB7XG4gICAgICAgIC8vIHN0cmluZyBpcyAwLTU1IGJ5dGVzIGxvbmcuIEEgc2luZ2xlIGJ5dGUgd2l0aCB2YWx1ZSAweDgwIHBsdXMgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGZvbGxvd2VkIGJ5IHRoZSBzdHJpbmdcbiAgICAgICAgLy8gVGhlIHJhbmdlIG9mIHRoZSBmaXJzdCBieXRlIGlzIFsweDgwLCAweGI3XVxuICAgICAgICBsZW5ndGggPSBmaXJzdEJ5dGUgLSAweDdmO1xuICAgICAgICAvLyBzZXQgMHg4MCBudWxsIHRvIDBcbiAgICAgICAgaWYgKGZpcnN0Qnl0ZSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBpbnB1dC5zbGljZSgxLCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IDIgJiYgZGF0YVswXSA8IDB4ODApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBybHAgZW5jb2Rpbmc6IGJ5dGUgbXVzdCBiZSBsZXNzIDB4ODAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UobGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4YmYpIHtcbiAgICAgICAgLy8gc3RyaW5nIGlzIGdyZWF0ZXIgdGhhbiA1NSBieXRlcyBsb25nLiBBIHNpbmdsZSBieXRlIHdpdGggdGhlIHZhbHVlICgweGI3IHBsdXMgdGhlIGxlbmd0aCBvZiB0aGUgbGVuZ3RoKSxcbiAgICAgICAgLy8gZm9sbG93ZWQgYnkgdGhlIGxlbmd0aCwgZm9sbG93ZWQgYnkgdGhlIHN0cmluZ1xuICAgICAgICBsbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhiNjtcbiAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCAtIDEgPCBsbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBub3QgZW5vdWdoIGJ5dGVzIGZvciBzdHJpbmcgbGVuZ3RoJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoID0gc2FmZVBhcnNlSW50KGlucHV0LnNsaWNlKDEsIGxsZW5ndGgpLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xuICAgICAgICBpZiAobGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBleHBlY3RlZCBzdHJpbmcgbGVuZ3RoIHRvIGJlIGdyZWF0ZXIgdGhhbiA1NScpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBpbnB1dC5zbGljZShsbGVuZ3RoLCBsZW5ndGggKyBsbGVuZ3RoKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBub3QgZW5vdWdoIGJ5dGVzIGZvciBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UobGVuZ3RoICsgbGxlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGY3KSB7XG4gICAgICAgIC8vIGEgbGlzdCBiZXR3ZWVuICAwLTU1IGJ5dGVzIGxvbmdcbiAgICAgICAgbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhiZjtcbiAgICAgICAgaW5uZXJSZW1haW5kZXIgPSBpbnB1dC5zbGljZSgxLCBsZW5ndGgpO1xuICAgICAgICB3aGlsZSAoaW5uZXJSZW1haW5kZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBkID0gX2RlY29kZShpbm5lclJlbWFpbmRlcik7XG4gICAgICAgICAgICBkZWNvZGVkLnB1c2goZC5kYXRhKTtcbiAgICAgICAgICAgIGlubmVyUmVtYWluZGVyID0gZC5yZW1haW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRlY29kZWQsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhIGxpc3QgIG92ZXIgNTUgYnl0ZXMgbG9uZ1xuICAgICAgICBsbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhmNjtcbiAgICAgICAgbGVuZ3RoID0gc2FmZVBhcnNlSW50KGlucHV0LnNsaWNlKDEsIGxsZW5ndGgpLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xuICAgICAgICBjb25zdCB0b3RhbExlbmd0aCA9IGxsZW5ndGggKyBsZW5ndGg7XG4gICAgICAgIGlmICh0b3RhbExlbmd0aCA+IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJscDogdG90YWwgbGVuZ3RoIGlzIGxhcmdlciB0aGFuIHRoZSBkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5uZXJSZW1haW5kZXIgPSBpbnB1dC5zbGljZShsbGVuZ3RoLCB0b3RhbExlbmd0aCk7XG4gICAgICAgIGlmIChpbm5lclJlbWFpbmRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBybHAsIExpc3QgaGFzIGEgaW52YWxpZCBsZW5ndGgnKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW5uZXJSZW1haW5kZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBkID0gX2RlY29kZShpbm5lclJlbWFpbmRlcik7XG4gICAgICAgICAgICBkZWNvZGVkLnB1c2goZC5kYXRhKTtcbiAgICAgICAgICAgIGlubmVyUmVtYWluZGVyID0gZC5yZW1haW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRlY29kZWQsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKHRvdGFsTGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKiogQ2hlY2sgaWYgYSBzdHJpbmcgaXMgcHJlZml4ZWQgYnkgMHggKi9cbmZ1bmN0aW9uIGlzSGV4UHJlZml4ZWQoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zbGljZSgwLCAyKSA9PT0gJzB4Jztcbn1cbi8qKiBSZW1vdmVzIDB4IGZyb20gYSBnaXZlbiBTdHJpbmcgKi9cbmZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4KHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICByZXR1cm4gaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyLnNsaWNlKDIpIDogc3RyO1xufVxuLyoqIFRyYW5zZm9ybSBhbiBpbnRlZ2VyIGludG8gaXRzIGhleGFkZWNpbWFsIHZhbHVlICovXG5mdW5jdGlvbiBpbnRUb0hleChpbnRlZ2VyKSB7XG4gICAgaWYgKGludGVnZXIgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlZ2VyIGFzIGFyZ3VtZW50LCBtdXN0IGJlIHVuc2lnbmVkIScpO1xuICAgIH1cbiAgICBjb25zdCBoZXggPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAlIDIgPyBgMCR7aGV4fWAgOiBoZXg7XG59XG4vKiogUGFkIGEgc3RyaW5nIHRvIGJlIGV2ZW4gKi9cbmZ1bmN0aW9uIHBhZFRvRXZlbihhKSB7XG4gICAgcmV0dXJuIGEubGVuZ3RoICUgMiA/IGAwJHthfWAgOiBhO1xufVxuLyoqIFRyYW5zZm9ybSBhbiBpbnRlZ2VyIGludG8gYSBCdWZmZXIgKi9cbmZ1bmN0aW9uIGludFRvQnVmZmVyKGludGVnZXIpIHtcbiAgICBjb25zdCBoZXggPSBpbnRUb0hleChpbnRlZ2VyKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaGV4LCAnaGV4Jyk7XG59XG4vKiogVHJhbnNmb3JtIGFueXRoaW5nIGludG8gYSBCdWZmZXIgKi9cbmZ1bmN0aW9uIHRvQnVmZmVyKHYpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXhQcmVmaXhlZCh2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgodikpLCAnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2ID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRUb0J1ZmZlcih2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJuX2pzXzEuZGVmYXVsdC5pc0JOKHYpKSB7XG4gICAgICAgICAgICAvLyBjb252ZXJ0cyBhIEJOIHRvIGEgQnVmZmVyXG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odi50b0FycmF5KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRMZW5ndGgiLCJkZWNvZGUiLCJlbmNvZGUiLCJibl9qc18xIiwicmVxdWlyZSIsImlucHV0IiwiQXJyYXkiLCJpc0FycmF5Iiwib3V0cHV0IiwiaSIsImxlbmd0aCIsInB1c2giLCJidWYiLCJCdWZmZXIiLCJjb25jYXQiLCJlbmNvZGVMZW5ndGgiLCJpbnB1dEJ1ZiIsInRvQnVmZmVyIiwic2FmZVBhcnNlSW50IiwidiIsImJhc2UiLCJFcnJvciIsInBhcnNlSW50IiwibGVuIiwib2Zmc2V0IiwiZnJvbSIsImhleExlbmd0aCIsImludFRvSGV4IiwibExlbmd0aCIsImZpcnN0Qnl0ZSIsInN0cmVhbSIsImlucHV0QnVmZmVyIiwiZGVjb2RlZCIsIl9kZWNvZGUiLCJyZW1haW5kZXIiLCJkYXRhIiwibGxlbmd0aCIsInNsaWNlIiwidG9TdHJpbmciLCJpbm5lclJlbWFpbmRlciIsImQiLCJ0b3RhbExlbmd0aCIsImlzSGV4UHJlZml4ZWQiLCJzdHIiLCJzdHJpcEhleFByZWZpeCIsImludGVnZXIiLCJoZXgiLCJwYWRUb0V2ZW4iLCJhIiwiaW50VG9CdWZmZXIiLCJpc0J1ZmZlciIsInVuZGVmaW5lZCIsIlVpbnQ4QXJyYXkiLCJkZWZhdWx0IiwiaXNCTiIsInRvQXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/rlp@2.2.7/node_modules/rlp/dist/index.js\n");

/***/ })

};
;