"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/secp256k1@4.0.3";
exports.ids = ["vendor-chunks/secp256k1@4.0.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/bindings.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/bindings.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst addon = __webpack_require__(/*! node-gyp-build */ \"(ssr)/./node_modules/.pnpm/node-gyp-build@4.8.0/node_modules/node-gyp-build/index.js\")(__dirname);\nmodule.exports = __webpack_require__(/*! ./lib */ \"(ssr)/./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/lib/index.js\")(new addon.Secp256k1());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc2VjcDI1NmsxQDQuMC4zL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvYmluZGluZ3MuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLFFBQVFDLG1CQUFPQSxDQUFDLDhHQUFrQkM7QUFDeENDLE9BQU9DLE9BQU8sR0FBR0gsbUJBQU9BLENBQUMsK0ZBQVMsSUFBSUQsTUFBTUssU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy8ucG5wbS9zZWNwMjU2azFANC4wLjMvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9iaW5kaW5ncy5qcz82OGZjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGFkZG9uID0gcmVxdWlyZSgnbm9kZS1neXAtYnVpbGQnKShfX2Rpcm5hbWUpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJykobmV3IGFkZG9uLlNlY3AyNTZrMSgpKVxuIl0sIm5hbWVzIjpbImFkZG9uIiwicmVxdWlyZSIsIl9fZGlybmFtZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJTZWNwMjU2azEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/bindings.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/elliptic.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/elliptic.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = __webpack_require__(/*! ./lib */ \"(ssr)/./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/lib/index.js\")(__webpack_require__(/*! ./lib/elliptic */ \"(ssr)/./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/lib/elliptic.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc2VjcDI1NmsxQDQuMC4zL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvZWxsaXB0aWMuanMiLCJtYXBwaW5ncyI6IjtBQUFBQSxPQUFPQyxPQUFPLEdBQUdDLG1CQUFPQSxDQUFDLCtGQUFTQSxtQkFBT0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy8ucG5wbS9zZWNwMjU2azFANC4wLjMvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9lbGxpcHRpYy5qcz83YTNiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWInKShyZXF1aXJlKCcuL2xpYi9lbGxpcHRpYycpKVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/elliptic.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\ntry {\n    module.exports = __webpack_require__(/*! ./bindings */ \"(ssr)/./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/bindings.js\");\n} catch (err) {\n    module.exports = __webpack_require__(/*! ./elliptic */ \"(ssr)/./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/elliptic.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc2VjcDI1NmsxQDQuMC4zL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBLElBQUk7SUFDRkEsdUlBQXlCO0FBQzNCLEVBQUUsT0FBT0csS0FBSztJQUNaSCx1SUFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvLnBucG0vc2VjcDI1NmsxQDQuMC4zL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvaW5kZXguanM/Y2NjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ0cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYmluZGluZ3MnKVxufSBjYXRjaCAoZXJyKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9lbGxpcHRpYycpXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiLCJlcnIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/lib/elliptic.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/lib/elliptic.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst EC = (__webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic.js\").ec);\nconst ec = new EC(\"secp256k1\");\nconst ecparams = ec.curve;\n// Hack, we can not use bn.js@5, while elliptic uses bn.js@4\n// See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758\nconst BN = ecparams.n.constructor;\nfunction loadCompressedPublicKey(first, xbuf) {\n    let x = new BN(xbuf);\n    // overflow\n    if (x.cmp(ecparams.p) >= 0) return null;\n    x = x.toRed(ecparams.red);\n    // compute corresponding Y\n    let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();\n    if (first === 0x03 !== y.isOdd()) y = y.redNeg();\n    return ec.keyPair({\n        pub: {\n            x: x,\n            y: y\n        }\n    });\n}\nfunction loadUncompressedPublicKey(first, xbuf, ybuf) {\n    let x = new BN(xbuf);\n    let y = new BN(ybuf);\n    // overflow\n    if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null;\n    x = x.toRed(ecparams.red);\n    y = y.toRed(ecparams.red);\n    // is odd flag\n    if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null;\n    // x*x*x + b = y*y\n    const x3 = x.redSqr().redIMul(x);\n    if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null;\n    return ec.keyPair({\n        pub: {\n            x: x,\n            y: y\n        }\n    });\n}\nfunction loadPublicKey(pubkey) {\n    // length should be validated in interface\n    const first = pubkey[0];\n    switch(first){\n        case 0x02:\n        case 0x03:\n            if (pubkey.length !== 33) return null;\n            return loadCompressedPublicKey(first, pubkey.subarray(1, 33));\n        case 0x04:\n        case 0x06:\n        case 0x07:\n            if (pubkey.length !== 65) return null;\n            return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));\n        default:\n            return null;\n    }\n}\nfunction savePublicKey(output, point) {\n    const pubkey = point.encode(null, output.length === 33);\n    // Loop should be faster because we do not need create extra Uint8Array\n    // output.set(new Uint8Array(pubkey))\n    for(let i = 0; i < output.length; ++i)output[i] = pubkey[i];\n}\nmodule.exports = {\n    contextRandomize () {\n        return 0;\n    },\n    privateKeyVerify (seckey) {\n        const bn = new BN(seckey);\n        return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1;\n    },\n    privateKeyNegate (seckey) {\n        const bn = new BN(seckey);\n        const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, \"be\", 32);\n        seckey.set(negate);\n        return 0;\n    },\n    privateKeyTweakAdd (seckey, tweak) {\n        const bn = new BN(tweak);\n        if (bn.cmp(ecparams.n) >= 0) return 1;\n        bn.iadd(new BN(seckey));\n        if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n);\n        if (bn.isZero()) return 1;\n        const tweaked = bn.toArrayLike(Uint8Array, \"be\", 32);\n        seckey.set(tweaked);\n        return 0;\n    },\n    privateKeyTweakMul (seckey, tweak) {\n        let bn = new BN(tweak);\n        if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;\n        bn.imul(new BN(seckey));\n        if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n);\n        const tweaked = bn.toArrayLike(Uint8Array, \"be\", 32);\n        seckey.set(tweaked);\n        return 0;\n    },\n    publicKeyVerify (pubkey) {\n        const pair = loadPublicKey(pubkey);\n        return pair === null ? 1 : 0;\n    },\n    publicKeyCreate (output, seckey) {\n        const bn = new BN(seckey);\n        if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;\n        const point = ec.keyFromPrivate(seckey).getPublic();\n        savePublicKey(output, point);\n        return 0;\n    },\n    publicKeyConvert (output, pubkey) {\n        const pair = loadPublicKey(pubkey);\n        if (pair === null) return 1;\n        const point = pair.getPublic();\n        savePublicKey(output, point);\n        return 0;\n    },\n    publicKeyNegate (output, pubkey) {\n        const pair = loadPublicKey(pubkey);\n        if (pair === null) return 1;\n        const point = pair.getPublic();\n        point.y = point.y.redNeg();\n        savePublicKey(output, point);\n        return 0;\n    },\n    publicKeyCombine (output, pubkeys) {\n        const pairs = new Array(pubkeys.length);\n        for(let i = 0; i < pubkeys.length; ++i){\n            pairs[i] = loadPublicKey(pubkeys[i]);\n            if (pairs[i] === null) return 1;\n        }\n        let point = pairs[0].getPublic();\n        for(let i = 1; i < pairs.length; ++i)point = point.add(pairs[i].pub);\n        if (point.isInfinity()) return 2;\n        savePublicKey(output, point);\n        return 0;\n    },\n    publicKeyTweakAdd (output, pubkey, tweak) {\n        const pair = loadPublicKey(pubkey);\n        if (pair === null) return 1;\n        tweak = new BN(tweak);\n        if (tweak.cmp(ecparams.n) >= 0) return 2;\n        const point = pair.getPublic().add(ecparams.g.mul(tweak));\n        if (point.isInfinity()) return 2;\n        savePublicKey(output, point);\n        return 0;\n    },\n    publicKeyTweakMul (output, pubkey, tweak) {\n        const pair = loadPublicKey(pubkey);\n        if (pair === null) return 1;\n        tweak = new BN(tweak);\n        if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2;\n        const point = pair.getPublic().mul(tweak);\n        savePublicKey(output, point);\n        return 0;\n    },\n    signatureNormalize (sig) {\n        const r = new BN(sig.subarray(0, 32));\n        const s = new BN(sig.subarray(32, 64));\n        if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1;\n        if (s.cmp(ec.nh) === 1) {\n            sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, \"be\", 32), 32);\n        }\n        return 0;\n    },\n    // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js\n    // Adapted for Uint8Array instead Buffer\n    signatureExport (obj, sig) {\n        const sigR = sig.subarray(0, 32);\n        const sigS = sig.subarray(32, 64);\n        if (new BN(sigR).cmp(ecparams.n) >= 0) return 1;\n        if (new BN(sigS).cmp(ecparams.n) >= 0) return 1;\n        const { output } = obj;\n        // Prepare R\n        let r = output.subarray(4, 4 + 33);\n        r[0] = 0x00;\n        r.set(sigR, 1);\n        let lenR = 33;\n        let posR = 0;\n        for(; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);\n        r = r.subarray(posR);\n        if (r[0] & 0x80) return 1;\n        if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80)) return 1;\n        // Prepare S\n        let s = output.subarray(6 + 33, 6 + 33 + 33);\n        s[0] = 0x00;\n        s.set(sigS, 1);\n        let lenS = 33;\n        let posS = 0;\n        for(; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);\n        s = s.subarray(posS);\n        if (s[0] & 0x80) return 1;\n        if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80)) return 1;\n        // Set output length for return\n        obj.outputlen = 6 + lenR + lenS;\n        // Output in specified format\n        // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n        output[0] = 0x30;\n        output[1] = obj.outputlen - 2;\n        output[2] = 0x02;\n        output[3] = r.length;\n        output.set(r, 4);\n        output[4 + lenR] = 0x02;\n        output[5 + lenR] = s.length;\n        output.set(s, 6 + lenR);\n        return 0;\n    },\n    // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js\n    // Adapted for Uint8Array instead Buffer\n    signatureImport (output, sig) {\n        if (sig.length < 8) return 1;\n        if (sig.length > 72) return 1;\n        if (sig[0] !== 0x30) return 1;\n        if (sig[1] !== sig.length - 2) return 1;\n        if (sig[2] !== 0x02) return 1;\n        const lenR = sig[3];\n        if (lenR === 0) return 1;\n        if (5 + lenR >= sig.length) return 1;\n        if (sig[4 + lenR] !== 0x02) return 1;\n        const lenS = sig[5 + lenR];\n        if (lenS === 0) return 1;\n        if (6 + lenR + lenS !== sig.length) return 1;\n        if (sig[4] & 0x80) return 1;\n        if (lenR > 1 && sig[4] === 0x00 && !(sig[5] & 0x80)) return 1;\n        if (sig[lenR + 6] & 0x80) return 1;\n        if (lenS > 1 && sig[lenR + 6] === 0x00 && !(sig[lenR + 7] & 0x80)) return 1;\n        let sigR = sig.subarray(4, 4 + lenR);\n        if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1);\n        if (sigR.length > 32) return 1;\n        let sigS = sig.subarray(6 + lenR);\n        if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1);\n        if (sigS.length > 32) throw new Error(\"S length is too long\");\n        let r = new BN(sigR);\n        if (r.cmp(ecparams.n) >= 0) r = new BN(0);\n        let s = new BN(sig.subarray(6 + lenR));\n        if (s.cmp(ecparams.n) >= 0) s = new BN(0);\n        output.set(r.toArrayLike(Uint8Array, \"be\", 32), 0);\n        output.set(s.toArrayLike(Uint8Array, \"be\", 32), 32);\n        return 0;\n    },\n    ecdsaSign (obj, message, seckey, data, noncefn) {\n        if (noncefn) {\n            const _noncefn = noncefn;\n            noncefn = (counter)=>{\n                const nonce = _noncefn(message, seckey, null, data, counter);\n                const isValid = nonce instanceof Uint8Array && nonce.length === 32;\n                if (!isValid) throw new Error(\"This is the way\");\n                return new BN(nonce);\n            };\n        }\n        const d = new BN(seckey);\n        if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1;\n        let sig;\n        try {\n            sig = ec.sign(message, seckey, {\n                canonical: true,\n                k: noncefn,\n                pers: data\n            });\n        } catch (err) {\n            return 1;\n        }\n        obj.signature.set(sig.r.toArrayLike(Uint8Array, \"be\", 32), 0);\n        obj.signature.set(sig.s.toArrayLike(Uint8Array, \"be\", 32), 32);\n        obj.recid = sig.recoveryParam;\n        return 0;\n    },\n    ecdsaVerify (sig, msg32, pubkey) {\n        const sigObj = {\n            r: sig.subarray(0, 32),\n            s: sig.subarray(32, 64)\n        };\n        const sigr = new BN(sigObj.r);\n        const sigs = new BN(sigObj.s);\n        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;\n        if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3;\n        const pair = loadPublicKey(pubkey);\n        if (pair === null) return 2;\n        const point = pair.getPublic();\n        const isValid = ec.verify(msg32, sigObj, point);\n        return isValid ? 0 : 3;\n    },\n    ecdsaRecover (output, sig, recid, msg32) {\n        const sigObj = {\n            r: sig.slice(0, 32),\n            s: sig.slice(32, 64)\n        };\n        const sigr = new BN(sigObj.r);\n        const sigs = new BN(sigObj.s);\n        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;\n        if (sigr.isZero() || sigs.isZero()) return 2;\n        // Can throw `throw new Error('Unable to find sencond key candinate');`\n        let point;\n        try {\n            point = ec.recoverPubKey(msg32, sigObj, recid);\n        } catch (err) {\n            return 2;\n        }\n        savePublicKey(output, point);\n        return 0;\n    },\n    ecdh (output, pubkey, seckey, data, hashfn, xbuf, ybuf) {\n        const pair = loadPublicKey(pubkey);\n        if (pair === null) return 1;\n        const scalar = new BN(seckey);\n        if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2;\n        const point = pair.getPublic().mul(scalar);\n        if (hashfn === undefined) {\n            const data = point.encode(null, true);\n            const sha256 = ec.hash().update(data).digest();\n            for(let i = 0; i < 32; ++i)output[i] = sha256[i];\n        } else {\n            if (!xbuf) xbuf = new Uint8Array(32);\n            const x = point.getX().toArray(\"be\", 32);\n            for(let i = 0; i < 32; ++i)xbuf[i] = x[i];\n            if (!ybuf) ybuf = new Uint8Array(32);\n            const y = point.getY().toArray(\"be\", 32);\n            for(let i = 0; i < 32; ++i)ybuf[i] = y[i];\n            const hash = hashfn(xbuf, ybuf, data);\n            const isValid = hash instanceof Uint8Array && hash.length === output.length;\n            if (!isValid) return 2;\n            output.set(hash);\n        }\n        return 0;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc2VjcDI1NmsxQDQuMC4zL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL2VsbGlwdGljLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxLQUFLQywySEFBc0I7QUFFakMsTUFBTUMsS0FBSyxJQUFJRixHQUFHO0FBQ2xCLE1BQU1HLFdBQVdELEdBQUdFLEtBQUs7QUFFekIsNERBQTREO0FBQzVELDRFQUE0RTtBQUM1RSxNQUFNQyxLQUFLRixTQUFTRyxDQUFDLENBQUNDLFdBQVc7QUFFakMsU0FBU0Msd0JBQXlCQyxLQUFLLEVBQUVDLElBQUk7SUFDM0MsSUFBSUMsSUFBSSxJQUFJTixHQUFHSztJQUVmLFdBQVc7SUFDWCxJQUFJQyxFQUFFQyxHQUFHLENBQUNULFNBQVNVLENBQUMsS0FBSyxHQUFHLE9BQU87SUFDbkNGLElBQUlBLEVBQUVHLEtBQUssQ0FBQ1gsU0FBU1ksR0FBRztJQUV4QiwwQkFBMEI7SUFDMUIsSUFBSUMsSUFBSUwsRUFBRU0sTUFBTSxHQUFHQyxPQUFPLENBQUNQLEdBQUdRLE9BQU8sQ0FBQ2hCLFNBQVNpQixDQUFDLEVBQUVDLE9BQU87SUFDekQsSUFBSSxVQUFXLFNBQVVMLEVBQUVNLEtBQUssSUFBSU4sSUFBSUEsRUFBRU8sTUFBTTtJQUVoRCxPQUFPckIsR0FBR3NCLE9BQU8sQ0FBQztRQUFFQyxLQUFLO1lBQUVkLEdBQUdBO1lBQUdLLEdBQUdBO1FBQUU7SUFBRTtBQUMxQztBQUVBLFNBQVNVLDBCQUEyQmpCLEtBQUssRUFBRUMsSUFBSSxFQUFFaUIsSUFBSTtJQUNuRCxJQUFJaEIsSUFBSSxJQUFJTixHQUFHSztJQUNmLElBQUlNLElBQUksSUFBSVgsR0FBR3NCO0lBRWYsV0FBVztJQUNYLElBQUloQixFQUFFQyxHQUFHLENBQUNULFNBQVNVLENBQUMsS0FBSyxLQUFLRyxFQUFFSixHQUFHLENBQUNULFNBQVNVLENBQUMsS0FBSyxHQUFHLE9BQU87SUFFN0RGLElBQUlBLEVBQUVH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WixNQUFNQSxPQUFPLElBQUl3QixXQUFXO1lBQ2pDLE1BQU1uQyxJQUFJcUIsTUFBTTRGLElBQUksR0FBR0QsT0FBTyxDQUFDLE1BQU07WUFDckMsSUFBSyxJQUFJekYsSUFBSSxHQUFHQSxJQUFJLElBQUksRUFBRUEsRUFBR1osSUFBSSxDQUFDWSxFQUFFLEdBQUd2QixDQUFDLENBQUN1QixFQUFFO1lBRTNDLE1BQU1xRixPQUFPSixPQUFPOUcsTUFBTWlCLE1BQU1xRTtZQUVoQyxNQUFNSyxVQUFVdUIsZ0JBQWdCekUsY0FBY3lFLEtBQUszRixNQUFNLEtBQUtHLE9BQU9ILE1BQU07WUFDM0UsSUFBSSxDQUFDb0UsU0FBUyxPQUFPO1lBRXJCakUsT0FBT2dCLEdBQUcsQ0FBQ3dFO1FBQ2I7UUFFQSxPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy8ucG5wbS9zZWNwMjU2azFANC4wLjMvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9saWIvZWxsaXB0aWMuanM/N2U5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFQyA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWNcblxuY29uc3QgZWMgPSBuZXcgRUMoJ3NlY3AyNTZrMScpXG5jb25zdCBlY3BhcmFtcyA9IGVjLmN1cnZlXG5cbi8vIEhhY2ssIHdlIGNhbiBub3QgdXNlIGJuLmpzQDUsIHdoaWxlIGVsbGlwdGljIHVzZXMgYm4uanNANFxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2VsbGlwdGljL2lzc3Vlcy8xOTEjaXNzdWVjb21tZW50LTU2OTg4ODc1OFxuY29uc3QgQk4gPSBlY3BhcmFtcy5uLmNvbnN0cnVjdG9yXG5cbmZ1bmN0aW9uIGxvYWRDb21wcmVzc2VkUHVibGljS2V5IChmaXJzdCwgeGJ1Zikge1xuICBsZXQgeCA9IG5ldyBCTih4YnVmKVxuXG4gIC8vIG92ZXJmbG93XG4gIGlmICh4LmNtcChlY3BhcmFtcy5wKSA+PSAwKSByZXR1cm4gbnVsbFxuICB4ID0geC50b1JlZChlY3BhcmFtcy5yZWQpXG5cbiAgLy8gY29tcHV0ZSBjb3JyZXNwb25kaW5nIFlcbiAgbGV0IHkgPSB4LnJlZFNxcigpLnJlZElNdWwoeCkucmVkSUFkZChlY3BhcmFtcy5iKS5yZWRTcXJ0KClcbiAgaWYgKChmaXJzdCA9PT0gMHgwMykgIT09IHkuaXNPZGQoKSkgeSA9IHkucmVkTmVnKClcblxuICByZXR1cm4gZWMua2V5UGFpcih7IHB1YjogeyB4OiB4LCB5OiB5IH0gfSlcbn1cblxuZnVuY3Rpb24gbG9hZFVuY29tcHJlc3NlZFB1YmxpY0tleSAoZmlyc3QsIHhidWYsIHlidWYpIHtcbiAgbGV0IHggPSBuZXcgQk4oeGJ1ZilcbiAgbGV0IHkgPSBuZXcgQk4oeWJ1ZilcblxuICAvLyBvdmVyZmxvd1xuICBpZiAoeC5jbXAoZWNwYXJhbXMucCkgPj0gMCB8fCB5LmNtcChlY3BhcmFtcy5wKSA+PSAwKSByZXR1cm4gbnVsbFxuXG4gIHggPSB4LnRvUmVkKGVjcGFyYW1zLnJlZClcbiAgeSA9IHkudG9SZWQoZWNwYXJhbXMucmVkKVxuXG4gIC8vIGlzIG9kZCBmbGFnXG4gIGlmICgoZmlyc3QgPT09IDB4MDYgfHwgZmlyc3QgPT09IDB4MDcpICYmIHkuaXNPZGQoKSAhPT0gKGZpcnN0ID09PSAweDA3KSkgcmV0dXJuIG51bGxcblxuICAvLyB4KngqeCArIGIgPSB5KnlcbiAgY29uc3QgeDMgPSB4LnJlZFNxcigpLnJlZElNdWwoeClcbiAgaWYgKCF5LnJlZFNxcigpLnJlZElTdWIoeDMucmVkSUFkZChlY3BhcmFtcy5iKSkuaXNaZXJvKCkpIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIGVjLmtleVBhaXIoeyBwdWI6IHsgeDogeCwgeTogeSB9IH0pXG59XG5cbmZ1bmN0aW9uIGxvYWRQdWJsaWNLZXkgKHB1YmtleSkge1xuICAvLyBsZW5ndGggc2hvdWxkIGJlIHZhbGlkYXRlZCBpbiBpbnRlcmZhY2VcbiAgY29uc3QgZmlyc3QgPSBwdWJrZXlbMF1cbiAgc3dpdGNoIChmaXJzdCkge1xuICAgIGNhc2UgMHgwMjpcbiAgICBjYXNlIDB4MDM6XG4gICAgICBpZiAocHVia2V5Lmxlbmd0aCAhPT0gMzMpIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gbG9hZENvbXByZXNzZWRQdWJsaWNLZXkoZmlyc3QsIHB1YmtleS5zdWJhcnJheSgxLCAzMykpXG4gICAgY2FzZSAweDA0OlxuICAgIGNhc2UgMHgwNjpcbiAgICBjYXNlIDB4MDc6XG4gICAgICBpZiAocHVia2V5Lmxlbmd0aCAhPT0gNjUpIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gbG9hZFVuY29tcHJlc3NlZFB1YmxpY0tleShmaXJzdCwgcHVia2V5LnN1YmFycmF5KDEsIDMzKSwgcHVia2V5LnN1YmFycmF5KDMzLCA2NSkpXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZnVuY3Rpb24gc2F2ZVB1YmxpY0tleSAob3V0cHV0LCBwb2ludCkge1xuICBjb25zdCBwdWJrZXkgPSBwb2ludC5lbmNvZGUobnVsbCwgb3V0cHV0Lmxlbmd0aCA9PT0gMzMpXG4gIC8vIExvb3Agc2hvdWxkIGJlIGZhc3RlciBiZWNhdXNlIHdlIGRvIG5vdCBuZWVkIGNyZWF0ZSBleHRyYSBVaW50OEFycmF5XG4gIC8vIG91dHB1dC5zZXQobmV3IFVpbnQ4QXJyYXkocHVia2V5KSlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyArK2kpIG91dHB1dFtpXSA9IHB1YmtleVtpXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29udGV4dFJhbmRvbWl6ZSAoKSB7XG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwcml2YXRlS2V5VmVyaWZ5IChzZWNrZXkpIHtcbiAgICBjb25zdCBibiA9IG5ldyBCTihzZWNrZXkpXG4gICAgcmV0dXJuIGJuLmNtcChlY3BhcmFtcy5uKSA8IDAgJiYgIWJuLmlzWmVybygpID8gMCA6IDFcbiAgfSxcblxuICBwcml2YXRlS2V5TmVnYXRlIChzZWNrZXkpIHtcbiAgICBjb25zdCBibiA9IG5ldyBCTihzZWNrZXkpXG4gICAgY29uc3QgbmVnYXRlID0gZWNwYXJhbXMubi5zdWIoYm4pLnVtb2QoZWNwYXJhbXMubikudG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpXG4gICAgc2Vja2V5LnNldChuZWdhdGUpXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwcml2YXRlS2V5VHdlYWtBZGQgKHNlY2tleSwgdHdlYWspIHtcbiAgICBjb25zdCBibiA9IG5ldyBCTih0d2VhaylcbiAgICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAxXG5cbiAgICBibi5pYWRkKG5ldyBCTihzZWNrZXkpKVxuICAgIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCkgYm4uaXN1YihlY3BhcmFtcy5uKVxuICAgIGlmIChibi5pc1plcm8oKSkgcmV0dXJuIDFcblxuICAgIGNvbnN0IHR3ZWFrZWQgPSBibi50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMilcbiAgICBzZWNrZXkuc2V0KHR3ZWFrZWQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHByaXZhdGVLZXlUd2Vha011bCAoc2Vja2V5LCB0d2Vhaykge1xuICAgIGxldCBibiA9IG5ldyBCTih0d2VhaylcbiAgICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpIHJldHVybiAxXG5cbiAgICBibi5pbXVsKG5ldyBCTihzZWNrZXkpKVxuICAgIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCkgYm4gPSBibi51bW9kKGVjcGFyYW1zLm4pXG5cbiAgICBjb25zdCB0d2Vha2VkID0gYm4udG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpXG4gICAgc2Vja2V5LnNldCh0d2Vha2VkKVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwdWJsaWNLZXlWZXJpZnkgKHB1YmtleSkge1xuICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmtleSlcbiAgICByZXR1cm4gcGFpciA9PT0gbnVsbCA/IDEgOiAwXG4gIH0sXG5cbiAgcHVibGljS2V5Q3JlYXRlIChvdXRwdXQsIHNlY2tleSkge1xuICAgIGNvbnN0IGJuID0gbmV3IEJOKHNlY2tleSlcbiAgICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpIHJldHVybiAxXG5cbiAgICBjb25zdCBwb2ludCA9IGVjLmtleUZyb21Qcml2YXRlKHNlY2tleSkuZ2V0UHVibGljKClcbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHB1YmxpY0tleUNvbnZlcnQgKG91dHB1dCwgcHVia2V5KSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIGlmIChwYWlyID09PSBudWxsKSByZXR1cm4gMVxuXG4gICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwdWJsaWNLZXlOZWdhdGUgKG91dHB1dCwgcHVia2V5KSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIGlmIChwYWlyID09PSBudWxsKSByZXR1cm4gMVxuXG4gICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpXG4gICAgcG9pbnQueSA9IHBvaW50LnkucmVkTmVnKClcbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHB1YmxpY0tleUNvbWJpbmUgKG91dHB1dCwgcHVia2V5cykge1xuICAgIGNvbnN0IHBhaXJzID0gbmV3IEFycmF5KHB1YmtleXMubGVuZ3RoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHVia2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgcGFpcnNbaV0gPSBsb2FkUHVibGljS2V5KHB1YmtleXNbaV0pXG4gICAgICBpZiAocGFpcnNbaV0gPT09IG51bGwpIHJldHVybiAxXG4gICAgfVxuXG4gICAgbGV0IHBvaW50ID0gcGFpcnNbMF0uZ2V0UHVibGljKClcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhaXJzLmxlbmd0aDsgKytpKSBwb2ludCA9IHBvaW50LmFkZChwYWlyc1tpXS5wdWIpXG4gICAgaWYgKHBvaW50LmlzSW5maW5pdHkoKSkgcmV0dXJuIDJcblxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHVibGljS2V5VHdlYWtBZGQgKG91dHB1dCwgcHVia2V5LCB0d2Vhaykge1xuICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmtleSlcbiAgICBpZiAocGFpciA9PT0gbnVsbCkgcmV0dXJuIDFcblxuICAgIHR3ZWFrID0gbmV3IEJOKHR3ZWFrKVxuICAgIGlmICh0d2Vhay5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDJcblxuICAgIGNvbnN0IHBvaW50ID0gcGFpci5nZXRQdWJsaWMoKS5hZGQoZWNwYXJhbXMuZy5tdWwodHdlYWspKVxuICAgIGlmIChwb2ludC5pc0luZmluaXR5KCkpIHJldHVybiAyXG5cbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHB1YmxpY0tleVR3ZWFrTXVsIChvdXRwdXQsIHB1YmtleSwgdHdlYWspIHtcbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgaWYgKHBhaXIgPT09IG51bGwpIHJldHVybiAxXG5cbiAgICB0d2VhayA9IG5ldyBCTih0d2VhaylcbiAgICBpZiAodHdlYWsuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgdHdlYWsuaXNaZXJvKCkpIHJldHVybiAyXG5cbiAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKCkubXVsKHR3ZWFrKVxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgc2lnbmF0dXJlTm9ybWFsaXplIChzaWcpIHtcbiAgICBjb25zdCByID0gbmV3IEJOKHNpZy5zdWJhcnJheSgwLCAzMikpXG4gICAgY29uc3QgcyA9IG5ldyBCTihzaWcuc3ViYXJyYXkoMzIsIDY0KSlcbiAgICBpZiAoci5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMVxuXG4gICAgaWYgKHMuY21wKGVjLm5oKSA9PT0gMSkge1xuICAgICAgc2lnLnNldChlY3BhcmFtcy5uLnN1YihzKS50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMiksIDMyKVxuICAgIH1cblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgLy8gQ29waWVkIDEtdG8tMSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luanMvYmlwNjYvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAgLy8gQWRhcHRlZCBmb3IgVWludDhBcnJheSBpbnN0ZWFkIEJ1ZmZlclxuICBzaWduYXR1cmVFeHBvcnQgKG9iaiwgc2lnKSB7XG4gICAgY29uc3Qgc2lnUiA9IHNpZy5zdWJhcnJheSgwLCAzMilcbiAgICBjb25zdCBzaWdTID0gc2lnLnN1YmFycmF5KDMyLCA2NClcbiAgICBpZiAobmV3IEJOKHNpZ1IpLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMVxuICAgIGlmIChuZXcgQk4oc2lnUykuY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAxXG5cbiAgICBjb25zdCB7IG91dHB1dCB9ID0gb2JqXG5cbiAgICAvLyBQcmVwYXJlIFJcbiAgICBsZXQgciA9IG91dHB1dC5zdWJhcnJheSg0LCA0ICsgMzMpXG4gICAgclswXSA9IDB4MDBcbiAgICByLnNldChzaWdSLCAxKVxuXG4gICAgbGV0IGxlblIgPSAzM1xuICAgIGxldCBwb3NSID0gMFxuICAgIGZvciAoOyBsZW5SID4gMSAmJiByW3Bvc1JdID09PSAweDAwICYmICEocltwb3NSICsgMV0gJiAweDgwKTsgLS1sZW5SLCArK3Bvc1IpO1xuXG4gICAgciA9IHIuc3ViYXJyYXkocG9zUilcbiAgICBpZiAoclswXSAmIDB4ODApIHJldHVybiAxXG4gICAgaWYgKGxlblIgPiAxICYmIChyWzBdID09PSAweDAwKSAmJiAhKHJbMV0gJiAweDgwKSkgcmV0dXJuIDFcblxuICAgIC8vIFByZXBhcmUgU1xuICAgIGxldCBzID0gb3V0cHV0LnN1YmFycmF5KDYgKyAzMywgNiArIDMzICsgMzMpXG4gICAgc1swXSA9IDB4MDBcbiAgICBzLnNldChzaWdTLCAxKVxuXG4gICAgbGV0IGxlblMgPSAzM1xuICAgIGxldCBwb3NTID0gMFxuICAgIGZvciAoOyBsZW5TID4gMSAmJiBzW3Bvc1NdID09PSAweDAwICYmICEoc1twb3NTICsgMV0gJiAweDgwKTsgLS1sZW5TLCArK3Bvc1MpO1xuXG4gICAgcyA9IHMuc3ViYXJyYXkocG9zUylcbiAgICBpZiAoc1swXSAmIDB4ODApIHJldHVybiAxXG4gICAgaWYgKGxlblMgPiAxICYmIChzWzBdID09PSAweDAwKSAmJiAhKHNbMV0gJiAweDgwKSkgcmV0dXJuIDFcblxuICAgIC8vIFNldCBvdXRwdXQgbGVuZ3RoIGZvciByZXR1cm5cbiAgICBvYmoub3V0cHV0bGVuID0gNiArIGxlblIgKyBsZW5TXG5cbiAgICAvLyBPdXRwdXQgaW4gc3BlY2lmaWVkIGZvcm1hdFxuICAgIC8vIDB4MzAgW3RvdGFsLWxlbmd0aF0gMHgwMiBbUi1sZW5ndGhdIFtSXSAweDAyIFtTLWxlbmd0aF0gW1NdXG4gICAgb3V0cHV0WzBdID0gMHgzMFxuICAgIG91dHB1dFsxXSA9IG9iai5vdXRwdXRsZW4gLSAyXG4gICAgb3V0cHV0WzJdID0gMHgwMlxuICAgIG91dHB1dFszXSA9IHIubGVuZ3RoXG4gICAgb3V0cHV0LnNldChyLCA0KVxuICAgIG91dHB1dFs0ICsgbGVuUl0gPSAweDAyXG4gICAgb3V0cHV0WzUgKyBsZW5SXSA9IHMubGVuZ3RoXG4gICAgb3V0cHV0LnNldChzLCA2ICsgbGVuUilcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgLy8gQ29waWVkIDEtdG8tMSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luanMvYmlwNjYvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAgLy8gQWRhcHRlZCBmb3IgVWludDhBcnJheSBpbnN0ZWFkIEJ1ZmZlclxuICBzaWduYXR1cmVJbXBvcnQgKG91dHB1dCwgc2lnKSB7XG4gICAgaWYgKHNpZy5sZW5ndGggPCA4KSByZXR1cm4gMVxuICAgIGlmIChzaWcubGVuZ3RoID4gNzIpIHJldHVybiAxXG4gICAgaWYgKHNpZ1swXSAhPT0gMHgzMCkgcmV0dXJuIDFcbiAgICBpZiAoc2lnWzFdICE9PSBzaWcubGVuZ3RoIC0gMikgcmV0dXJuIDFcbiAgICBpZiAoc2lnWzJdICE9PSAweDAyKSByZXR1cm4gMVxuXG4gICAgY29uc3QgbGVuUiA9IHNpZ1szXVxuICAgIGlmIChsZW5SID09PSAwKSByZXR1cm4gMVxuICAgIGlmICg1ICsgbGVuUiA+PSBzaWcubGVuZ3RoKSByZXR1cm4gMVxuICAgIGlmIChzaWdbNCArIGxlblJdICE9PSAweDAyKSByZXR1cm4gMVxuXG4gICAgY29uc3QgbGVuUyA9IHNpZ1s1ICsgbGVuUl1cbiAgICBpZiAobGVuUyA9PT0gMCkgcmV0dXJuIDFcbiAgICBpZiAoKDYgKyBsZW5SICsgbGVuUykgIT09IHNpZy5sZW5ndGgpIHJldHVybiAxXG5cbiAgICBpZiAoc2lnWzRdICYgMHg4MCkgcmV0dXJuIDFcbiAgICBpZiAobGVuUiA+IDEgJiYgKHNpZ1s0XSA9PT0gMHgwMCkgJiYgIShzaWdbNV0gJiAweDgwKSkgcmV0dXJuIDFcblxuICAgIGlmIChzaWdbbGVuUiArIDZdICYgMHg4MCkgcmV0dXJuIDFcbiAgICBpZiAobGVuUyA+IDEgJiYgKHNpZ1tsZW5SICsgNl0gPT09IDB4MDApICYmICEoc2lnW2xlblIgKyA3XSAmIDB4ODApKSByZXR1cm4gMVxuXG4gICAgbGV0IHNpZ1IgPSBzaWcuc3ViYXJyYXkoNCwgNCArIGxlblIpXG4gICAgaWYgKHNpZ1IubGVuZ3RoID09PSAzMyAmJiBzaWdSWzBdID09PSAweDAwKSBzaWdSID0gc2lnUi5zdWJhcnJheSgxKVxuICAgIGlmIChzaWdSLmxlbmd0aCA+IDMyKSByZXR1cm4gMVxuXG4gICAgbGV0IHNpZ1MgPSBzaWcuc3ViYXJyYXkoNiArIGxlblIpXG4gICAgaWYgKHNpZ1MubGVuZ3RoID09PSAzMyAmJiBzaWdTWzBdID09PSAweDAwKSBzaWdTID0gc2lnUy5zbGljZSgxKVxuICAgIGlmIChzaWdTLmxlbmd0aCA+IDMyKSB0aHJvdyBuZXcgRXJyb3IoJ1MgbGVuZ3RoIGlzIHRvbyBsb25nJylcblxuICAgIGxldCByID0gbmV3IEJOKHNpZ1IpXG4gICAgaWYgKHIuY21wKGVjcGFyYW1zLm4pID49IDApIHIgPSBuZXcgQk4oMClcblxuICAgIGxldCBzID0gbmV3IEJOKHNpZy5zdWJhcnJheSg2ICsgbGVuUikpXG4gICAgaWYgKHMuY21wKGVjcGFyYW1zLm4pID49IDApIHMgPSBuZXcgQk4oMClcblxuICAgIG91dHB1dC5zZXQoci50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMiksIDApXG4gICAgb3V0cHV0LnNldChzLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKSwgMzIpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIGVjZHNhU2lnbiAob2JqLCBtZXNzYWdlLCBzZWNrZXksIGRhdGEsIG5vbmNlZm4pIHtcbiAgICBpZiAobm9uY2Vmbikge1xuICAgICAgY29uc3QgX25vbmNlZm4gPSBub25jZWZuXG4gICAgICBub25jZWZuID0gKGNvdW50ZXIpID0+IHtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBfbm9uY2VmbihtZXNzYWdlLCBzZWNrZXksIG51bGwsIGRhdGEsIGNvdW50ZXIpXG5cbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IG5vbmNlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBub25jZS5sZW5ndGggPT09IDMyXG4gICAgICAgIGlmICghaXNWYWxpZCkgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGlzIHRoZSB3YXknKVxuXG4gICAgICAgIHJldHVybiBuZXcgQk4obm9uY2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZCA9IG5ldyBCTihzZWNrZXkpXG4gICAgaWYgKGQuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgZC5pc1plcm8oKSkgcmV0dXJuIDFcblxuICAgIGxldCBzaWdcbiAgICB0cnkge1xuICAgICAgc2lnID0gZWMuc2lnbihtZXNzYWdlLCBzZWNrZXksIHsgY2Fub25pY2FsOiB0cnVlLCBrOiBub25jZWZuLCBwZXJzOiBkYXRhIH0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIG9iai5zaWduYXR1cmUuc2V0KHNpZy5yLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKSwgMClcbiAgICBvYmouc2lnbmF0dXJlLnNldChzaWcucy50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMiksIDMyKVxuICAgIG9iai5yZWNpZCA9IHNpZy5yZWNvdmVyeVBhcmFtXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIGVjZHNhVmVyaWZ5IChzaWcsIG1zZzMyLCBwdWJrZXkpIHtcbiAgICBjb25zdCBzaWdPYmogPSB7IHI6IHNpZy5zdWJhcnJheSgwLCAzMiksIHM6IHNpZy5zdWJhcnJheSgzMiwgNjQpIH1cblxuICAgIGNvbnN0IHNpZ3IgPSBuZXcgQk4oc2lnT2JqLnIpXG4gICAgY29uc3Qgc2lncyA9IG5ldyBCTihzaWdPYmoucylcbiAgICBpZiAoc2lnci5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzaWdzLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMVxuICAgIGlmIChzaWdzLmNtcChlYy5uaCkgPT09IDEgfHwgc2lnci5pc1plcm8oKSB8fCBzaWdzLmlzWmVybygpKSByZXR1cm4gM1xuXG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIGlmIChwYWlyID09PSBudWxsKSByZXR1cm4gMlxuXG4gICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpXG4gICAgY29uc3QgaXNWYWxpZCA9IGVjLnZlcmlmeShtc2czMiwgc2lnT2JqLCBwb2ludClcbiAgICByZXR1cm4gaXNWYWxpZCA/IDAgOiAzXG4gIH0sXG5cbiAgZWNkc2FSZWNvdmVyIChvdXRwdXQsIHNpZywgcmVjaWQsIG1zZzMyKSB7XG4gICAgY29uc3Qgc2lnT2JqID0geyByOiBzaWcuc2xpY2UoMCwgMzIpLCBzOiBzaWcuc2xpY2UoMzIsIDY0KSB9XG5cbiAgICBjb25zdCBzaWdyID0gbmV3IEJOKHNpZ09iai5yKVxuICAgIGNvbnN0IHNpZ3MgPSBuZXcgQk4oc2lnT2JqLnMpXG4gICAgaWYgKHNpZ3IuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2lncy5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDFcblxuICAgIGlmIChzaWdyLmlzWmVybygpIHx8IHNpZ3MuaXNaZXJvKCkpIHJldHVybiAyXG5cbiAgICAvLyBDYW4gdGhyb3cgYHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgc2VuY29uZCBrZXkgY2FuZGluYXRlJyk7YFxuICAgIGxldCBwb2ludFxuICAgIHRyeSB7XG4gICAgICBwb2ludCA9IGVjLnJlY292ZXJQdWJLZXkobXNnMzIsIHNpZ09iaiwgcmVjaWQpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gMlxuICAgIH1cblxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgZWNkaCAob3V0cHV0LCBwdWJrZXksIHNlY2tleSwgZGF0YSwgaGFzaGZuLCB4YnVmLCB5YnVmKSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIGlmIChwYWlyID09PSBudWxsKSByZXR1cm4gMVxuXG4gICAgY29uc3Qgc2NhbGFyID0gbmV3IEJOKHNlY2tleSlcbiAgICBpZiAoc2NhbGFyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNjYWxhci5pc1plcm8oKSkgcmV0dXJuIDJcblxuICAgIGNvbnN0IHBvaW50ID0gcGFpci5nZXRQdWJsaWMoKS5tdWwoc2NhbGFyKVxuXG4gICAgaWYgKGhhc2hmbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBkYXRhID0gcG9pbnQuZW5jb2RlKG51bGwsIHRydWUpXG4gICAgICBjb25zdCBzaGEyNTYgPSBlYy5oYXNoKCkudXBkYXRlKGRhdGEpLmRpZ2VzdCgpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyArK2kpIG91dHB1dFtpXSA9IHNoYTI1NltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXhidWYpIHhidWYgPSBuZXcgVWludDhBcnJheSgzMilcbiAgICAgIGNvbnN0IHggPSBwb2ludC5nZXRYKCkudG9BcnJheSgnYmUnLCAzMilcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7ICsraSkgeGJ1ZltpXSA9IHhbaV1cblxuICAgICAgaWYgKCF5YnVmKSB5YnVmID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG4gICAgICBjb25zdCB5ID0gcG9pbnQuZ2V0WSgpLnRvQXJyYXkoJ2JlJywgMzIpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyArK2kpIHlidWZbaV0gPSB5W2ldXG5cbiAgICAgIGNvbnN0IGhhc2ggPSBoYXNoZm4oeGJ1ZiwgeWJ1ZiwgZGF0YSlcblxuICAgICAgY29uc3QgaXNWYWxpZCA9IGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGhhc2gubGVuZ3RoID09PSBvdXRwdXQubGVuZ3RoXG4gICAgICBpZiAoIWlzVmFsaWQpIHJldHVybiAyXG5cbiAgICAgIG91dHB1dC5zZXQoaGFzaClcbiAgICB9XG5cbiAgICByZXR1cm4gMFxuICB9XG59XG4iXSwibmFtZXMiOlsiRUMiLCJyZXF1aXJlIiwiZWMiLCJlY3BhcmFtcyIsImN1cnZlIiwiQk4iLCJuIiwiY29uc3RydWN0b3IiLCJsb2FkQ29tcHJlc3NlZFB1YmxpY0tleSIsImZpcnN0IiwieGJ1ZiIsIngiLCJjbXAiLCJwIiwidG9SZWQiLCJyZWQiLCJ5IiwicmVkU3FyIiwicmVkSU11bCIsInJlZElBZGQiLCJiIiwicmVkU3FydCIsImlzT2RkIiwicmVkTmVnIiwia2V5UGFpciIsInB1YiIsImxvYWRVbmNvbXByZXNzZWRQdWJsaWNLZXkiLCJ5YnVmIiwieDMiLCJyZWRJU3ViIiwiaXNaZXJvIiwibG9hZFB1YmxpY0tleSIsInB1YmtleSIsImxlbmd0aCIsInN1YmFycmF5Iiwic2F2ZVB1YmxpY0tleSIsIm91dHB1dCIsInBvaW50IiwiZW5jb2RlIiwiaSIsIm1vZHVsZSIsImV4cG9ydHMiLCJjb250ZXh0UmFuZG9taXplIiwicHJpdmF0ZUtleVZlcmlmeSIsInNlY2tleSIsImJuIiwicHJpdmF0ZUtleU5lZ2F0ZSIsIm5lZ2F0ZSIsInN1YiIsInVtb2QiLCJ0b0FycmF5TGlrZSIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJwcml2YXRlS2V5VHdlYWtBZGQiLCJ0d2VhayIsImlhZGQiLCJpc3ViIiwidHdlYWtlZCIsInByaXZhdGVLZXlUd2Vha011bCIsImltdWwiLCJwdWJsaWNLZXlWZXJpZnkiLCJwYWlyIiwicHVibGljS2V5Q3JlYXRlIiwia2V5RnJvbVByaXZhdGUiLCJnZXRQdWJsaWMiLCJwdWJsaWNLZXlDb252ZXJ0IiwicHVibGljS2V5TmVnYXRlIiwicHVibGljS2V5Q29tYmluZSIsInB1YmtleXMiLCJwYWlycyIsIkFycmF5IiwiYWRkIiwiaXNJbmZpbml0eSIsInB1YmxpY0tleVR3ZWFrQWRkIiwiZyIsIm11bCIsInB1YmxpY0tleVR3ZWFrTXVsIiwic2lnbmF0dXJlTm9ybWFsaXplIiwic2lnIiwiciIsInMiLCJuaCIsInNpZ25hdHVyZUV4cG9ydCIsIm9iaiIsInNpZ1IiLCJzaWdTIiwibGVuUiIsInBvc1IiLCJsZW5TIiwicG9zUyIsIm91dHB1dGxlbiIsInNpZ25hdHVyZUltcG9ydCIsInNsaWNlIiwiRXJyb3IiLCJlY2RzYVNpZ24iLCJtZXNzYWdlIiwiZGF0YSIsIm5vbmNlZm4iLCJfbm9uY2VmbiIsImNvdW50ZXIiLCJub25jZSIsImlzVmFsaWQiLCJkIiwic2lnbiIsImNhbm9uaWNhbCIsImsiLCJwZXJzIiwiZXJyIiwic2lnbmF0dXJlIiwicmVjaWQiLCJyZWNvdmVyeVBhcmFtIiwiZWNkc2FWZXJpZnkiLCJtc2czMiIsInNpZ09iaiIsInNpZ3IiLCJzaWdzIiwidmVyaWZ5IiwiZWNkc2FSZWNvdmVyIiwicmVjb3ZlclB1YktleSIsImVjZGgiLCJoYXNoZm4iLCJzY2FsYXIiLCJ1bmRlZmluZWQiLCJzaGEyNTYiLCJoYXNoIiwidXBkYXRlIiwiZGlnZXN0IiwiZ2V0WCIsInRvQXJyYXkiLCJnZXRZIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/lib/elliptic.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/lib/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/lib/index.js ***!
  \********************************************************************************/
/***/ ((module) => {

eval("\nconst errors = {\n    IMPOSSIBLE_CASE: \"Impossible case. Please create issue.\",\n    TWEAK_ADD: \"The tweak was out of range or the resulted private key is invalid\",\n    TWEAK_MUL: \"The tweak was out of range or equal to zero\",\n    CONTEXT_RANDOMIZE_UNKNOW: \"Unknow error on context randomization\",\n    SECKEY_INVALID: \"Private Key is invalid\",\n    PUBKEY_PARSE: \"Public Key could not be parsed\",\n    PUBKEY_SERIALIZE: \"Public Key serialization error\",\n    PUBKEY_COMBINE: \"The sum of the public keys is not valid\",\n    SIG_PARSE: \"Signature could not be parsed\",\n    SIGN: \"The nonce generation function failed, or the private key was invalid\",\n    RECOVER: \"Public key could not be recover\",\n    ECDH: \"Scalar was invalid (zero or overflow)\"\n};\nfunction assert(cond, msg) {\n    if (!cond) throw new Error(msg);\n}\nfunction isUint8Array(name, value, length) {\n    assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);\n    if (length !== undefined) {\n        if (Array.isArray(length)) {\n            const numbers = length.join(\", \");\n            const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;\n            assert(length.includes(value.length), msg);\n        } else {\n            const msg = `Expected ${name} to be an Uint8Array with length ${length}`;\n            assert(value.length === length, msg);\n        }\n    }\n}\nfunction isCompressed(value) {\n    assert(toTypeString(value) === \"Boolean\", \"Expected compressed to be a Boolean\");\n}\nfunction getAssertedOutput(output = (len)=>new Uint8Array(len), length) {\n    if (typeof output === \"function\") output = output(length);\n    isUint8Array(\"output\", output, length);\n    return output;\n}\nfunction toTypeString(value) {\n    return Object.prototype.toString.call(value).slice(8, -1);\n}\nmodule.exports = (secp256k1)=>{\n    return {\n        contextRandomize (seed) {\n            assert(seed === null || seed instanceof Uint8Array, \"Expected seed to be an Uint8Array or null\");\n            if (seed !== null) isUint8Array(\"seed\", seed, 32);\n            switch(secp256k1.contextRandomize(seed)){\n                case 1:\n                    throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);\n            }\n        },\n        privateKeyVerify (seckey) {\n            isUint8Array(\"private key\", seckey, 32);\n            return secp256k1.privateKeyVerify(seckey) === 0;\n        },\n        privateKeyNegate (seckey) {\n            isUint8Array(\"private key\", seckey, 32);\n            switch(secp256k1.privateKeyNegate(seckey)){\n                case 0:\n                    return seckey;\n                case 1:\n                    throw new Error(errors.IMPOSSIBLE_CASE);\n            }\n        },\n        privateKeyTweakAdd (seckey, tweak) {\n            isUint8Array(\"private key\", seckey, 32);\n            isUint8Array(\"tweak\", tweak, 32);\n            switch(secp256k1.privateKeyTweakAdd(seckey, tweak)){\n                case 0:\n                    return seckey;\n                case 1:\n                    throw new Error(errors.TWEAK_ADD);\n            }\n        },\n        privateKeyTweakMul (seckey, tweak) {\n            isUint8Array(\"private key\", seckey, 32);\n            isUint8Array(\"tweak\", tweak, 32);\n            switch(secp256k1.privateKeyTweakMul(seckey, tweak)){\n                case 0:\n                    return seckey;\n                case 1:\n                    throw new Error(errors.TWEAK_MUL);\n            }\n        },\n        publicKeyVerify (pubkey) {\n            isUint8Array(\"public key\", pubkey, [\n                33,\n                65\n            ]);\n            return secp256k1.publicKeyVerify(pubkey) === 0;\n        },\n        publicKeyCreate (seckey, compressed = true, output) {\n            isUint8Array(\"private key\", seckey, 32);\n            isCompressed(compressed);\n            output = getAssertedOutput(output, compressed ? 33 : 65);\n            switch(secp256k1.publicKeyCreate(output, seckey)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.SECKEY_INVALID);\n                case 2:\n                    throw new Error(errors.PUBKEY_SERIALIZE);\n            }\n        },\n        publicKeyConvert (pubkey, compressed = true, output) {\n            isUint8Array(\"public key\", pubkey, [\n                33,\n                65\n            ]);\n            isCompressed(compressed);\n            output = getAssertedOutput(output, compressed ? 33 : 65);\n            switch(secp256k1.publicKeyConvert(output, pubkey)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.PUBKEY_PARSE);\n                case 2:\n                    throw new Error(errors.PUBKEY_SERIALIZE);\n            }\n        },\n        publicKeyNegate (pubkey, compressed = true, output) {\n            isUint8Array(\"public key\", pubkey, [\n                33,\n                65\n            ]);\n            isCompressed(compressed);\n            output = getAssertedOutput(output, compressed ? 33 : 65);\n            switch(secp256k1.publicKeyNegate(output, pubkey)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.PUBKEY_PARSE);\n                case 2:\n                    throw new Error(errors.IMPOSSIBLE_CASE);\n                case 3:\n                    throw new Error(errors.PUBKEY_SERIALIZE);\n            }\n        },\n        publicKeyCombine (pubkeys, compressed = true, output) {\n            assert(Array.isArray(pubkeys), \"Expected public keys to be an Array\");\n            assert(pubkeys.length > 0, \"Expected public keys array will have more than zero items\");\n            for (const pubkey of pubkeys){\n                isUint8Array(\"public key\", pubkey, [\n                    33,\n                    65\n                ]);\n            }\n            isCompressed(compressed);\n            output = getAssertedOutput(output, compressed ? 33 : 65);\n            switch(secp256k1.publicKeyCombine(output, pubkeys)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.PUBKEY_PARSE);\n                case 2:\n                    throw new Error(errors.PUBKEY_COMBINE);\n                case 3:\n                    throw new Error(errors.PUBKEY_SERIALIZE);\n            }\n        },\n        publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {\n            isUint8Array(\"public key\", pubkey, [\n                33,\n                65\n            ]);\n            isUint8Array(\"tweak\", tweak, 32);\n            isCompressed(compressed);\n            output = getAssertedOutput(output, compressed ? 33 : 65);\n            switch(secp256k1.publicKeyTweakAdd(output, pubkey, tweak)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.PUBKEY_PARSE);\n                case 2:\n                    throw new Error(errors.TWEAK_ADD);\n            }\n        },\n        publicKeyTweakMul (pubkey, tweak, compressed = true, output) {\n            isUint8Array(\"public key\", pubkey, [\n                33,\n                65\n            ]);\n            isUint8Array(\"tweak\", tweak, 32);\n            isCompressed(compressed);\n            output = getAssertedOutput(output, compressed ? 33 : 65);\n            switch(secp256k1.publicKeyTweakMul(output, pubkey, tweak)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.PUBKEY_PARSE);\n                case 2:\n                    throw new Error(errors.TWEAK_MUL);\n            }\n        },\n        signatureNormalize (sig) {\n            isUint8Array(\"signature\", sig, 64);\n            switch(secp256k1.signatureNormalize(sig)){\n                case 0:\n                    return sig;\n                case 1:\n                    throw new Error(errors.SIG_PARSE);\n            }\n        },\n        signatureExport (sig, output) {\n            isUint8Array(\"signature\", sig, 64);\n            output = getAssertedOutput(output, 72);\n            const obj = {\n                output,\n                outputlen: 72\n            };\n            switch(secp256k1.signatureExport(obj, sig)){\n                case 0:\n                    return output.slice(0, obj.outputlen);\n                case 1:\n                    throw new Error(errors.SIG_PARSE);\n                case 2:\n                    throw new Error(errors.IMPOSSIBLE_CASE);\n            }\n        },\n        signatureImport (sig, output) {\n            isUint8Array(\"signature\", sig);\n            output = getAssertedOutput(output, 64);\n            switch(secp256k1.signatureImport(output, sig)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.SIG_PARSE);\n                case 2:\n                    throw new Error(errors.IMPOSSIBLE_CASE);\n            }\n        },\n        ecdsaSign (msg32, seckey, options = {}, output) {\n            isUint8Array(\"message\", msg32, 32);\n            isUint8Array(\"private key\", seckey, 32);\n            assert(toTypeString(options) === \"Object\", \"Expected options to be an Object\");\n            if (options.data !== undefined) isUint8Array(\"options.data\", options.data);\n            if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === \"Function\", \"Expected options.noncefn to be a Function\");\n            output = getAssertedOutput(output, 64);\n            const obj = {\n                signature: output,\n                recid: null\n            };\n            switch(secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)){\n                case 0:\n                    return obj;\n                case 1:\n                    throw new Error(errors.SIGN);\n                case 2:\n                    throw new Error(errors.IMPOSSIBLE_CASE);\n            }\n        },\n        ecdsaVerify (sig, msg32, pubkey) {\n            isUint8Array(\"signature\", sig, 64);\n            isUint8Array(\"message\", msg32, 32);\n            isUint8Array(\"public key\", pubkey, [\n                33,\n                65\n            ]);\n            switch(secp256k1.ecdsaVerify(sig, msg32, pubkey)){\n                case 0:\n                    return true;\n                case 3:\n                    return false;\n                case 1:\n                    throw new Error(errors.SIG_PARSE);\n                case 2:\n                    throw new Error(errors.PUBKEY_PARSE);\n            }\n        },\n        ecdsaRecover (sig, recid, msg32, compressed = true, output) {\n            isUint8Array(\"signature\", sig, 64);\n            assert(toTypeString(recid) === \"Number\" && recid >= 0 && recid <= 3, \"Expected recovery id to be a Number within interval [0, 3]\");\n            isUint8Array(\"message\", msg32, 32);\n            isCompressed(compressed);\n            output = getAssertedOutput(output, compressed ? 33 : 65);\n            switch(secp256k1.ecdsaRecover(output, sig, recid, msg32)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.SIG_PARSE);\n                case 2:\n                    throw new Error(errors.RECOVER);\n                case 3:\n                    throw new Error(errors.IMPOSSIBLE_CASE);\n            }\n        },\n        ecdh (pubkey, seckey, options = {}, output) {\n            isUint8Array(\"public key\", pubkey, [\n                33,\n                65\n            ]);\n            isUint8Array(\"private key\", seckey, 32);\n            assert(toTypeString(options) === \"Object\", \"Expected options to be an Object\");\n            if (options.data !== undefined) isUint8Array(\"options.data\", options.data);\n            if (options.hashfn !== undefined) {\n                assert(toTypeString(options.hashfn) === \"Function\", \"Expected options.hashfn to be a Function\");\n                if (options.xbuf !== undefined) isUint8Array(\"options.xbuf\", options.xbuf, 32);\n                if (options.ybuf !== undefined) isUint8Array(\"options.ybuf\", options.ybuf, 32);\n                isUint8Array(\"output\", output);\n            } else {\n                output = getAssertedOutput(output, 32);\n            }\n            switch(secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)){\n                case 0:\n                    return output;\n                case 1:\n                    throw new Error(errors.PUBKEY_PARSE);\n                case 2:\n                    throw new Error(errors.ECDH);\n            }\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc2VjcDI1NmsxQDQuMC4zL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxTQUFTO0lBQ2JDLGlCQUFpQjtJQUNqQkMsV0FDRTtJQUNGQyxXQUFXO0lBQ1hDLDBCQUEwQjtJQUMxQkMsZ0JBQWdCO0lBQ2hCQyxjQUFjO0lBQ2RDLGtCQUFrQjtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyxXQUFXO0lBQ1hDLE1BQU07SUFDTkMsU0FBUztJQUNUQyxNQUFNO0FBQ1I7QUFFQSxTQUFTQyxPQUFRQyxJQUFJLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxDQUFDRCxNQUFNLE1BQU0sSUFBSUUsTUFBTUQ7QUFDN0I7QUFFQSxTQUFTRSxhQUFjQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsTUFBTTtJQUN4Q1AsT0FBT00saUJBQWlCRSxZQUFZLENBQUMsU0FBUyxFQUFFSCxLQUFLLG9CQUFvQixDQUFDO0lBRTFFLElBQUlFLFdBQVdFLFdBQVc7UUFDeEIsSUFBSUMsTUFBTUMsT0FBTyxDQUFDSixTQUFTO1lBQ3pCLE1BQU1LLFVBQVVMLE9BQU9NLElBQUksQ0FBQztZQUM1QixNQUFNWCxNQUFNLENBQUMsU0FBUyxFQUFFRyxLQUFLLGtDQUFrQyxFQUFFTyxRQUFRLENBQUMsQ0FBQztZQUMzRVosT0FBT08sT0FBT08sUUFBUSxDQUFDUixNQUFNQyxNQUFNLEdBQUdMO1FBQ3hDLE9BQU87WUFDTCxNQUFNQSxNQUFNLENBQUMsU0FBUyxFQUFFRyxLQUFLLGlDQUFpQyxFQUFFRSxPQUFPLENBQUM7WUFDeEVQLE9BQU9NLE1BQU1DLE1BQU0sS0FBS0EsUUFBUUw7UUFDbEM7SUFDRjtBQUNGO0FBRUEsU0FBU2EsYUFBY1QsS0FBSztJQUMxQk4sT0FBT2dCLGFBQWFWLFdBQVcsV0FBVztBQUM1QztBQUVBLFNBQVNXLGtCQUFtQkMsU0FBUyxDQUFDQyxNQUFRLElBQUlYLFdBQVdXLElBQUksRUFBRVosTUFBTTtJQUN2RSxJQUFJLE9BQU9XLFdBQVcsWUFBWUEsU0FBU0EsT0FBT1g7SUFDbERILGFBQWEsVUFBVWMsUUFBUVg7SUFDL0IsT0FBT1c7QUFDVDtBQUVBLFNBQVNGLGFBQWNWLEtBQUs7SUFDMUIsT0FBT2MsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ2pCLE9BQU9rQixLQUFLLENBQUMsR0FBRyxDQUFDO0FBQ3pEO0FBRUFDLE9BQU9DLE9BQU8sR0FBRyxDQUFDQztJQUNoQixPQUFPO1FBQ0xDLGtCQUFrQkMsSUFBSTtZQUNwQjdCLE9BQ0U2QixTQUFTLFFBQVFBLGdCQUFnQnJCLFlBQ2pDO1lBRUYsSUFBSXFCLFNBQVMsTUFBTXpCLGFBQWEsUUFBUXlCLE1BQU07WUFFOUMsT0FBUUYsVUFBVUMsZ0JBQWdCLENBQUNDO2dCQUNqQyxLQUFLO29CQUNILE1BQU0sSUFBSTFCLE1BQU1oQixPQUFPSSx3QkFBd0I7WUFDbkQ7UUFDRjtRQUVBdUMsa0JBQWtCQyxNQUFNO1lBQ3RCM0IsYUFBYSxlQUFlMkIsUUFBUTtZQUVwQyxPQUFPSixVQUFVRyxnQkFBZ0IsQ0FBQ0MsWUFBWTtRQUNoRDtRQUVBQyxrQkFBa0JELE1BQU07WUFDdEIzQixhQUFhLGVBQWUyQixRQUFRO1lBRXBDLE9BQVFKLFVBQVVLLGdCQUFnQixDQUFDRDtnQkFDakMsS0FBSztvQkFDSCxPQUFPQTtnQkFDVCxLQUFLO29CQUNILE1BQU0sSUFBSTVCLE1BQU1oQixPQUFPQyxlQUFlO1lBQzFDO1FBQ0Y7UUFFQTZDLG9CQUFvQkYsTUFBTSxFQUFFRyxLQUFLO1lBQy9COUIsYUFBYSxlQUFlMkIsUUFBUTtZQUNwQzNCLGFBQWEsU0FBUzhCLE9BQU87WUFFN0IsT0FBUVAsVUFBVU0sa0JBQWtCLENBQUNGLFFBQVFHO2dCQUMzQyxLQUFLO29CQUNILE9BQU9IO2dCQUNULEtBQUs7b0JBQ0gsTUFBTSxJQUFJNUIsTUFBTWhCLE9BQU9FLFNBQVM7WUFDcEM7UUFDRjtRQUVBOEMsb0JBQW9CSixNQUFNLEVBQUVHLEtBQUs7WUFDL0I5QixhQUFhLGVBQWUyQixRQUFRO1lBQ3BDM0IsYUFBYSxTQUFTOEIsT0FBTztZQUU3QixPQUFRUCxVQUFVUSxrQkFBa0IsQ0FBQ0osUUFBUUc7Z0JBQzNDLEtBQUs7b0JBQ0gsT0FBT0g7Z0JBQ1QsS0FBSztvQkFDSCxNQUFNLElBQUk1QixNQUFNaEIsT0FBT0csU0FBUztZQUNwQztRQUNGO1FBRUE4QyxpQkFBaUJDLE1BQU07WUFDckJqQyxhQUFhLGNBQWNpQyxRQUFRO2dCQUFDO2dCQUFJO2FBQUc7WUFFM0MsT0FBT1YsVUFBVVMsZUFBZSxDQUFDQyxZQUFZO1FBQy9DO1FBRUFDLGlCQUFpQlAsTUFBTSxFQUFFUSxhQUFhLElBQUksRUFBRXJCLE1BQU07WUFDaERkLGFBQWEsZUFBZTJCLFFBQVE7WUFDcENoQixhQUFhd0I7WUFDYnJCLFNBQVNELGtCQUFrQkMsUUFBUXFCLGFBQWEsS0FBSztZQUVyRCxPQUFRWixVQUFVVyxlQUFlLENBQUNwQixRQUFRYTtnQkFDeEMsS0FBSztvQkFDSCxPQUFPYjtnQkFDVCxLQUFLO29CQUNILE1BQU0sSUFBSWYsTUFBTWhCLE9BQU9LLGNBQWM7Z0JBQ3ZDLEtBQUs7b0JBQ0gsTUFBTSxJQUFJVyxNQUFNaEIsT0FBT08sZ0JBQWdCO1lBQzNDO1FBQ0Y7UUFFQThDLGtCQUFrQkgsTUFBTSxFQUFFRSxhQUFhLElBQUksRUFBRXJCLE1BQU07WUFDakRkLGFBQWEsY0FBY2lDLFFBQVE7Z0JBQUM7Z0JBQUk7YUFBRztZQUMzQ3RCLGFBQWF3QjtZQUNickIsU0FBU0Qsa0JBQWtCQyxRQUFRcUIsYUFBYSxLQUFLO1lBRXJELE9BQVFaLFVBQVVhLGdCQUFnQixDQUFDdEIsUUFBUW1CO2dCQUN6QyxLQUFLO29CQUNILE9BQU9uQjtnQkFDVCxLQUFLO29CQUNILE1BQU0sSUFBSWYsTUFBTWhCLE9BQU9NLFlBQVk7Z0JBQ3JDLEtBQUs7b0JBQ0gsTUFBTSxJQUFJVSxNQUFNaEIsT0FBT08sZ0JBQWdCO1lBQzNDO1FBQ0Y7UUFFQStDLGlCQUFpQkosTUFBTSxFQUFFRSxhQUFhLElBQUksRUFBRXJCLE1BQU07WUFDaERkLGFBQWEsY0FBY2lDLFFBQVE7Z0JBQUM7Z0JBQUk7YUFBRztZQUMzQ3RCLGFBQWF3QjtZQUNickIsU0FBU0Qsa0JBQWtCQyxRQUFRcUIsYUFBYSxLQUFLO1lBRXJELE9BQVFaLFVBQVVjLGVBQWUsQ0FBQ3ZCLFFBQVFtQjtnQkFDeEMsS0FBSztvQkFDSCxPQUFPbkI7Z0JBQ1QsS0FBSztvQkFDSCxNQUFNLElBQUlmLE1BQU1oQixPQUFPTSxZQUFZO2dCQUNyQyxLQUFLO29CQUNILE1BQU0sSUFBSVUsTUFBTWhCLE9BQU9DLGVBQWU7Z0JBQ3hDLEtBQUs7b0JBQ0gsTUFBTSxJQUFJZSxNQUFNaEIsT0FBT08sZ0JBQWdCO1lBQzNDO1FBQ0Y7UUFFQWdELGtCQUFrQkMsT0FBTyxFQUFFSixhQUFhLElBQUksRUFBRXJCLE1BQU07WUFDbERsQixPQUFPVSxNQUFNQyxPQUFPLENBQUNnQyxVQUFVO1lBQy9CM0MsT0FBTzJDLFFBQVFwQyxNQUFNLEdBQUcsR0FBRztZQUMzQixLQUFLLE1BQU04QixVQUFVTSxRQUFTO2dCQUM1QnZDLGFBQWEsY0FBY2lDLFFBQVE7b0JBQUM7b0JBQUk7aUJBQUc7WUFDN0M7WUFDQXRCLGFBQWF3QjtZQUNickIsU0FBU0Qsa0JBQWtCQyxRQUFRcUIsYUFBYSxLQUFLO1lBRXJELE9BQVFaLFVBQVVlLGdCQUFnQixDQUFDeEIsUUFBUXlCO2dCQUN6QyxLQUFLO29CQUNILE9BQU96QjtnQkFDVCxLQUFLO29CQUNILE1BQU0sSUFBSWYsTUFBTWhCLE9BQU9NLFlBQVk7Z0JBQ3JDLEtBQUs7b0JBQ0gsTUFBTSxJQUFJVSxNQUFNaEIsT0FBT1EsY0FBYztnQkFDdkMsS0FBSztvQkFDSCxNQUFNLElBQUlRLE1BQU1oQixPQUFPTyxnQkFBZ0I7WUFDM0M7UUFDRjtRQUVBa0QsbUJBQW1CUCxNQUFNLEVBQUVILEtBQUssRUFBRUssYUFBYSxJQUFJLEVBQUVyQixNQUFNO1lBQ3pEZCxhQUFhLGNBQWNpQyxRQUFRO2dCQUFDO2dCQUFJO2FBQUc7WUFDM0NqQyxhQUFhLFNBQVM4QixPQUFPO1lBQzdCbkIsYUFBYXdCO1lBQ2JyQixTQUFTRCxrQkFBa0JDLFFBQVFxQixhQUFhLEtBQUs7WUFFckQsT0FBUVosVUFBVWlCLGlCQUFpQixDQUFDMUIsUUFBUW1CLFFBQVFIO2dCQUNsRCxLQUFLO29CQUNILE9BQU9oQjtnQkFDVCxLQUFLO29CQUNILE1BQU0sSUFBSWYsTUFBTWhCLE9BQU9NLFlBQVk7Z0JBQ3JDLEtBQUs7b0JBQ0gsTUFBTSxJQUFJVSxNQUFNaEIsT0FBT0UsU0FBUztZQUNwQztRQUNGO1FBRUF3RCxtQkFBbUJSLE1BQU0sRUFBRUgsS0FBSyxFQUFFSyxhQUFhLElBQUksRUFBRXJCLE1BQU07WUFDekRkLGFBQWEsY0FBY2lDLFFBQVE7Z0JBQUM7Z0JBQUk7YUFBRztZQUMzQ2pDLGFBQWEsU0FBUzhCLE9BQU87WUFDN0JuQixhQUFhd0I7WUFDYnJCLFNBQVNELGtCQUFrQkMsUUFBUXFCLGFBQWEsS0FBSztZQUVyRCxPQUFRWixVQUFVa0IsaUJBQWlCLENBQUMzQixRQUFRbUIsUUFBUUg7Z0JBQ2xELEtBQUs7b0JBQ0gsT0FBT2hCO2dCQUNULEtBQUs7b0JBQ0gsTUFBTSxJQUFJZixNQUFNaEIsT0FBT00sWUFBWTtnQkFDckMsS0FBSztvQkFDSCxNQUFNLElBQUlVLE1BQU1oQixPQUFPRyxTQUFTO1lBQ3BDO1FBQ0Y7UUFFQXdELG9CQUFvQkMsR0FBRztZQUNyQjNDLGFBQWEsYUFBYTJDLEtBQUs7WUFFL0IsT0FBUXBCLFVBQVVtQixrQkFBa0IsQ0FBQ0M7Z0JBQ25DLEtBQUs7b0JBQ0gsT0FBT0E7Z0JBQ1QsS0FBSztvQkFDSCxNQUFNLElBQUk1QyxNQUFNaEIsT0FBT1MsU0FBUztZQUNwQztRQUNGO1FBRUFvRCxpQkFBaUJELEdBQUcsRUFBRTdCLE1BQU07WUFDMUJkLGFBQWEsYUFBYTJDLEtBQUs7WUFDL0I3QixTQUFTRCxrQkFBa0JDLFFBQVE7WUFFbkMsTUFBTStCLE1BQU07Z0JBQUUvQjtnQkFBUWdDLFdBQVc7WUFBRztZQUNwQyxPQUFRdkIsVUFBVXFCLGVBQWUsQ0FBQ0MsS0FBS0Y7Z0JBQ3JDLEtBQUs7b0JBQ0gsT0FBTzdCLE9BQU9NLEtBQUssQ0FBQyxHQUFHeUIsSUFBSUMsU0FBUztnQkFDdEMsS0FBSztvQkFDSCxNQUFNLElBQUkvQyxNQUFNaEIsT0FBT1MsU0FBUztnQkFDbEMsS0FBSztvQkFDSCxNQUFNLElBQUlPLE1BQU1oQixPQUFPQyxlQUFlO1lBQzFDO1FBQ0Y7UUFFQStELGlCQUFpQkosR0FBRyxFQUFFN0IsTUFBTTtZQUMxQmQsYUFBYSxhQUFhMkM7WUFDMUI3QixTQUFTRCxrQkFBa0JDLFFBQVE7WUFFbkMsT0FBUVMsVUFBVXdCLGVBQWUsQ0FBQ2pDLFFBQVE2QjtnQkFDeEMsS0FBSztvQkFDSCxPQUFPN0I7Z0JBQ1QsS0FBSztvQkFDSCxNQUFNLElBQUlmLE1BQU1oQixPQUFPUyxTQUFTO2dCQUNsQyxLQUFLO29CQUNILE1BQU0sSUFBSU8sTUFBTWhCLE9BQU9DLGVBQWU7WUFDMUM7UUFDRjtRQUVBZ0UsV0FBV0MsS0FBSyxFQUFFdEIsTUFBTSxFQUFFdUIsVUFBVSxDQUFDLENBQUMsRUFBRXBDLE1BQU07WUFDNUNkLGFBQWEsV0FBV2lELE9BQU87WUFDL0JqRCxhQUFhLGVBQWUyQixRQUFRO1lBQ3BDL0IsT0FBT2dCLGFBQWFzQyxhQUFhLFVBQVU7WUFDM0MsSUFBSUEsUUFBUUMsSUFBSSxLQUFLOUMsV0FBV0wsYUFBYSxnQkFBZ0JrRCxRQUFRQyxJQUFJO1lBQ3pFLElBQUlELFFBQVFFLE9BQU8sS0FBSy9DLFdBQVdULE9BQU9nQixhQUFhc0MsUUFBUUUsT0FBTyxNQUFNLFlBQVk7WUFDeEZ0QyxTQUFTRCxrQkFBa0JDLFFBQVE7WUFFbkMsTUFBTStCLE1BQU07Z0JBQUVRLFdBQVd2QztnQkFBUXdDLE9BQU87WUFBSztZQUM3QyxPQUFRL0IsVUFBVXlCLFNBQVMsQ0FBQ0gsS0FBS0ksT0FBT3RCLFFBQVF1QixRQUFRQyxJQUFJLEVBQUVELFFBQVFFLE9BQU87Z0JBQzNFLEtBQUs7b0JBQ0gsT0FBT1A7Z0JBQ1QsS0FBSztvQkFDSCxNQUFNLElBQUk5QyxNQUFNaEIsT0FBT1UsSUFBSTtnQkFDN0IsS0FBSztvQkFDSCxNQUFNLElBQUlNLE1BQU1oQixPQUFPQyxlQUFlO1lBQzFDO1FBQ0Y7UUFFQXVFLGFBQWFaLEdBQUcsRUFBRU0sS0FBSyxFQUFFaEIsTUFBTTtZQUM3QmpDLGFBQWEsYUFBYTJDLEtBQUs7WUFDL0IzQyxhQUFhLFdBQVdpRCxPQUFPO1lBQy9CakQsYUFBYSxjQUFjaUMsUUFBUTtnQkFBQztnQkFBSTthQUFHO1lBRTNDLE9BQVFWLFVBQVVnQyxXQUFXLENBQUNaLEtBQUtNLE9BQU9oQjtnQkFDeEMsS0FBSztvQkFDSCxPQUFPO2dCQUNULEtBQUs7b0JBQ0gsT0FBTztnQkFDVCxLQUFLO29CQUNILE1BQU0sSUFBSWxDLE1BQU1oQixPQUFPUyxTQUFTO2dCQUNsQyxLQUFLO29CQUNILE1BQU0sSUFBSU8sTUFBTWhCLE9BQU9NLFlBQVk7WUFDdkM7UUFDRjtRQUVBbUUsY0FBY2IsR0FBRyxFQUFFVyxLQUFLLEVBQUVMLEtBQUssRUFBRWQsYUFBYSxJQUFJLEVBQUVyQixNQUFNO1lBQ3hEZCxhQUFhLGFBQWEyQyxLQUFLO1lBQy9CL0MsT0FDRWdCLGFBQWEwQyxXQUFXLFlBQ3RCQSxTQUFTLEtBQ1RBLFNBQVMsR0FDWDtZQUVGdEQsYUFBYSxXQUFXaUQsT0FBTztZQUMvQnRDLGFBQWF3QjtZQUNickIsU0FBU0Qsa0JBQWtCQyxRQUFRcUIsYUFBYSxLQUFLO1lBRXJELE9BQVFaLFVBQVVpQyxZQUFZLENBQUMxQyxRQUFRNkIsS0FBS1csT0FBT0w7Z0JBQ2pELEtBQUs7b0JBQ0gsT0FBT25DO2dCQUNULEtBQUs7b0JBQ0gsTUFBTSxJQUFJZixNQUFNaEIsT0FBT1MsU0FBUztnQkFDbEMsS0FBSztvQkFDSCxNQUFNLElBQUlPLE1BQU1oQixPQUFPVyxPQUFPO2dCQUNoQyxLQUFLO29CQUNILE1BQU0sSUFBSUssTUFBTWhCLE9BQU9DLGVBQWU7WUFDMUM7UUFDRjtRQUVBeUUsTUFBTXhCLE1BQU0sRUFBRU4sTUFBTSxFQUFFdUIsVUFBVSxDQUFDLENBQUMsRUFBRXBDLE1BQU07WUFDeENkLGFBQWEsY0FBY2lDLFFBQVE7Z0JBQUM7Z0JBQUk7YUFBRztZQUMzQ2pDLGFBQWEsZUFBZTJCLFFBQVE7WUFDcEMvQixPQUFPZ0IsYUFBYXNDLGFBQWEsVUFBVTtZQUMzQyxJQUFJQSxRQUFRQyxJQUFJLEtBQUs5QyxXQUFXTCxhQUFhLGdCQUFnQmtELFFBQVFDLElBQUk7WUFDekUsSUFBSUQsUUFBUVEsTUFBTSxLQUFLckQsV0FBVztnQkFDaENULE9BQU9nQixhQUFhc0MsUUFBUVEsTUFBTSxNQUFNLFlBQVk7Z0JBQ3BELElBQUlSLFFBQVFTLElBQUksS0FBS3RELFdBQVdMLGFBQWEsZ0JBQWdCa0QsUUFBUVMsSUFBSSxFQUFFO2dCQUMzRSxJQUFJVCxRQUFRVSxJQUFJLEtBQUt2RCxXQUFXTCxhQUFhLGdCQUFnQmtELFFBQVFVLElBQUksRUFBRTtnQkFDM0U1RCxhQUFhLFVBQVVjO1lBQ3pCLE9BQU87Z0JBQ0xBLFNBQVNELGtCQUFrQkMsUUFBUTtZQUNyQztZQUVBLE9BQVFTLFVBQVVrQyxJQUFJLENBQUMzQyxRQUFRbUIsUUFBUU4sUUFBUXVCLFFBQVFDLElBQUksRUFBRUQsUUFBUVEsTUFBTSxFQUFFUixRQUFRUyxJQUFJLEVBQUVULFFBQVFVLElBQUk7Z0JBQ3JHLEtBQUs7b0JBQ0gsT0FBTzlDO2dCQUNULEtBQUs7b0JBQ0gsTUFBTSxJQUFJZixNQUFNaEIsT0FBT00sWUFBWTtnQkFDckMsS0FBSztvQkFDSCxNQUFNLElBQUlVLE1BQU1oQixPQUFPWSxJQUFJO1lBQy9CO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3NlY3AyNTZrMUA0LjAuMy9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2xpYi9pbmRleC5qcz9iMmYxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGVycm9ycyA9IHtcbiAgSU1QT1NTSUJMRV9DQVNFOiAnSW1wb3NzaWJsZSBjYXNlLiBQbGVhc2UgY3JlYXRlIGlzc3VlLicsXG4gIFRXRUFLX0FERDpcbiAgICAnVGhlIHR3ZWFrIHdhcyBvdXQgb2YgcmFuZ2Ugb3IgdGhlIHJlc3VsdGVkIHByaXZhdGUga2V5IGlzIGludmFsaWQnLFxuICBUV0VBS19NVUw6ICdUaGUgdHdlYWsgd2FzIG91dCBvZiByYW5nZSBvciBlcXVhbCB0byB6ZXJvJyxcbiAgQ09OVEVYVF9SQU5ET01JWkVfVU5LTk9XOiAnVW5rbm93IGVycm9yIG9uIGNvbnRleHQgcmFuZG9taXphdGlvbicsXG4gIFNFQ0tFWV9JTlZBTElEOiAnUHJpdmF0ZSBLZXkgaXMgaW52YWxpZCcsXG4gIFBVQktFWV9QQVJTRTogJ1B1YmxpYyBLZXkgY291bGQgbm90IGJlIHBhcnNlZCcsXG4gIFBVQktFWV9TRVJJQUxJWkU6ICdQdWJsaWMgS2V5IHNlcmlhbGl6YXRpb24gZXJyb3InLFxuICBQVUJLRVlfQ09NQklORTogJ1RoZSBzdW0gb2YgdGhlIHB1YmxpYyBrZXlzIGlzIG5vdCB2YWxpZCcsXG4gIFNJR19QQVJTRTogJ1NpZ25hdHVyZSBjb3VsZCBub3QgYmUgcGFyc2VkJyxcbiAgU0lHTjogJ1RoZSBub25jZSBnZW5lcmF0aW9uIGZ1bmN0aW9uIGZhaWxlZCwgb3IgdGhlIHByaXZhdGUga2V5IHdhcyBpbnZhbGlkJyxcbiAgUkVDT1ZFUjogJ1B1YmxpYyBrZXkgY291bGQgbm90IGJlIHJlY292ZXInLFxuICBFQ0RIOiAnU2NhbGFyIHdhcyBpbnZhbGlkICh6ZXJvIG9yIG92ZXJmbG93KSdcbn1cblxuZnVuY3Rpb24gYXNzZXJ0IChjb25kLCBtc2cpIHtcbiAgaWYgKCFjb25kKSB0aHJvdyBuZXcgRXJyb3IobXNnKVxufVxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkgKG5hbWUsIHZhbHVlLCBsZW5ndGgpIHtcbiAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSwgYEV4cGVjdGVkICR7bmFtZX0gdG8gYmUgYW4gVWludDhBcnJheWApXG5cbiAgaWYgKGxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGVuZ3RoKSkge1xuICAgICAgY29uc3QgbnVtYmVycyA9IGxlbmd0aC5qb2luKCcsICcpXG4gICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgJHtuYW1lfSB0byBiZSBhbiBVaW50OEFycmF5IHdpdGggbGVuZ3RoIFske251bWJlcnN9XWBcbiAgICAgIGFzc2VydChsZW5ndGguaW5jbHVkZXModmFsdWUubGVuZ3RoKSwgbXNnKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgJHtuYW1lfSB0byBiZSBhbiBVaW50OEFycmF5IHdpdGggbGVuZ3RoICR7bGVuZ3RofWBcbiAgICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggPT09IGxlbmd0aCwgbXNnKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbXByZXNzZWQgKHZhbHVlKSB7XG4gIGFzc2VydCh0b1R5cGVTdHJpbmcodmFsdWUpID09PSAnQm9vbGVhbicsICdFeHBlY3RlZCBjb21wcmVzc2VkIHRvIGJlIGEgQm9vbGVhbicpXG59XG5cbmZ1bmN0aW9uIGdldEFzc2VydGVkT3V0cHV0IChvdXRwdXQgPSAobGVuKSA9PiBuZXcgVWludDhBcnJheShsZW4pLCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicpIG91dHB1dCA9IG91dHB1dChsZW5ndGgpXG4gIGlzVWludDhBcnJheSgnb3V0cHV0Jywgb3V0cHV0LCBsZW5ndGgpXG4gIHJldHVybiBvdXRwdXRcbn1cblxuZnVuY3Rpb24gdG9UeXBlU3RyaW5nICh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoc2VjcDI1NmsxKSA9PiB7XG4gIHJldHVybiB7XG4gICAgY29udGV4dFJhbmRvbWl6ZSAoc2VlZCkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBzZWVkID09PSBudWxsIHx8IHNlZWQgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgICAgICAnRXhwZWN0ZWQgc2VlZCB0byBiZSBhbiBVaW50OEFycmF5IG9yIG51bGwnXG4gICAgICApXG4gICAgICBpZiAoc2VlZCAhPT0gbnVsbCkgaXNVaW50OEFycmF5KCdzZWVkJywgc2VlZCwgMzIpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLmNvbnRleHRSYW5kb21pemUoc2VlZCkpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuQ09OVEVYVF9SQU5ET01JWkVfVU5LTk9XKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5VmVyaWZ5IChzZWNrZXkpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHJpdmF0ZSBrZXknLCBzZWNrZXksIDMyKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkoc2Vja2V5KSA9PT0gMFxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5TmVnYXRlIChzZWNrZXkpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHJpdmF0ZSBrZXknLCBzZWNrZXksIDMyKVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wcml2YXRlS2V5TmVnYXRlKHNlY2tleSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBzZWNrZXlcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU1QT1NTSUJMRV9DQVNFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5VHdlYWtBZGQgKHNlY2tleSwgdHdlYWspIHtcbiAgICAgIGlzVWludDhBcnJheSgncHJpdmF0ZSBrZXknLCBzZWNrZXksIDMyKVxuICAgICAgaXNVaW50OEFycmF5KCd0d2VhaycsIHR3ZWFrLCAzMilcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrQWRkKHNlY2tleSwgdHdlYWspKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gc2Vja2V5XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlRXRUFLX0FERClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleVR3ZWFrTXVsIChzZWNrZXksIHR3ZWFrKSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGlzVWludDhBcnJheSgndHdlYWsnLCB0d2VhaywgMzIpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnByaXZhdGVLZXlUd2Vha011bChzZWNrZXksIHR3ZWFrKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHNlY2tleVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5UV0VBS19NVUwpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1YmxpY0tleVZlcmlmeSAocHVia2V5KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShwdWJrZXkpID09PSAwXG4gICAgfSxcblxuICAgIHB1YmxpY0tleUNyZWF0ZSAoc2Vja2V5LCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKG91dHB1dCwgc2Vja2V5KSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TRUNLRVlfSU5WQUxJRClcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1NFUklBTElaRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHVibGljS2V5Q29udmVydCAocHVia2V5LCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KG91dHB1dCwgcHVia2V5KSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9TRVJJQUxJWkUpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1YmxpY0tleU5lZ2F0ZSAocHVia2V5LCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlOZWdhdGUob3V0cHV0LCBwdWJrZXkpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU1QT1NTSUJMRV9DQVNFKVxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfU0VSSUFMSVpFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlDb21iaW5lIChwdWJrZXlzLCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShwdWJrZXlzKSwgJ0V4cGVjdGVkIHB1YmxpYyBrZXlzIHRvIGJlIGFuIEFycmF5JylcbiAgICAgIGFzc2VydChwdWJrZXlzLmxlbmd0aCA+IDAsICdFeHBlY3RlZCBwdWJsaWMga2V5cyBhcnJheSB3aWxsIGhhdmUgbW9yZSB0aGFuIHplcm8gaXRlbXMnKVxuICAgICAgZm9yIChjb25zdCBwdWJrZXkgb2YgcHVia2V5cykge1xuICAgICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgfVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlDb21iaW5lKG91dHB1dCwgcHVia2V5cykpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfQ09NQklORSlcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1NFUklBTElaRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHVibGljS2V5VHdlYWtBZGQgKHB1YmtleSwgdHdlYWssIGNvbXByZXNzZWQgPSB0cnVlLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHVibGljIGtleScsIHB1YmtleSwgWzMzLCA2NV0pXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3R3ZWFrJywgdHdlYWssIDMyKVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZChvdXRwdXQsIHB1YmtleSwgdHdlYWspKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuVFdFQUtfQUREKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlUd2Vha011bCAocHVia2V5LCB0d2VhaywgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcbiAgICAgIGlzVWludDhBcnJheSgndHdlYWsnLCB0d2VhaywgMzIpXG4gICAgICBpc0NvbXByZXNzZWQoY29tcHJlc3NlZClcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgY29tcHJlc3NlZCA/IDMzIDogNjUpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrTXVsKG91dHB1dCwgcHVia2V5LCB0d2VhaykpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5UV0VBS19NVUwpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHNpZ25hdHVyZU5vcm1hbGl6ZSAoc2lnKSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3NpZ25hdHVyZScsIHNpZywgNjQpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnNpZ25hdHVyZU5vcm1hbGl6ZShzaWcpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gc2lnXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNJR19QQVJTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2lnbmF0dXJlRXhwb3J0IChzaWcsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcsIDY0KVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCA3MilcblxuICAgICAgY29uc3Qgb2JqID0geyBvdXRwdXQsIG91dHB1dGxlbjogNzIgfVxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuc2lnbmF0dXJlRXhwb3J0KG9iaiwgc2lnKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dC5zbGljZSgwLCBvYmoub3V0cHV0bGVuKVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2lnbmF0dXJlSW1wb3J0IChzaWcsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIDY0KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5zaWduYXR1cmVJbXBvcnQob3V0cHV0LCBzaWcpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNJR19QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU1QT1NTSUJMRV9DQVNFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBlY2RzYVNpZ24gKG1zZzMyLCBzZWNrZXksIG9wdGlvbnMgPSB7fSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ21lc3NhZ2UnLCBtc2czMiwgMzIpXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGFzc2VydCh0b1R5cGVTdHJpbmcob3B0aW9ucykgPT09ICdPYmplY3QnLCAnRXhwZWN0ZWQgb3B0aW9ucyB0byBiZSBhbiBPYmplY3QnKVxuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gdW5kZWZpbmVkKSBpc1VpbnQ4QXJyYXkoJ29wdGlvbnMuZGF0YScsIG9wdGlvbnMuZGF0YSlcbiAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4gIT09IHVuZGVmaW5lZCkgYXNzZXJ0KHRvVHlwZVN0cmluZyhvcHRpb25zLm5vbmNlZm4pID09PSAnRnVuY3Rpb24nLCAnRXhwZWN0ZWQgb3B0aW9ucy5ub25jZWZuIHRvIGJlIGEgRnVuY3Rpb24nKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCA2NClcblxuICAgICAgY29uc3Qgb2JqID0geyBzaWduYXR1cmU6IG91dHB1dCwgcmVjaWQ6IG51bGwgfVxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuZWNkc2FTaWduKG9iaiwgbXNnMzIsIHNlY2tleSwgb3B0aW9ucy5kYXRhLCBvcHRpb25zLm5vbmNlZm4pKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNJR04pXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWNkc2FWZXJpZnkgKHNpZywgbXNnMzIsIHB1YmtleSkge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcsIDY0KVxuICAgICAgaXNVaW50OEFycmF5KCdtZXNzYWdlJywgbXNnMzIsIDMyKVxuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuZWNkc2FWZXJpZnkoc2lnLCBtc2czMiwgcHVia2V5KSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWNkc2FSZWNvdmVyIChzaWcsIHJlY2lkLCBtc2czMiwgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcsIDY0KVxuICAgICAgYXNzZXJ0KFxuICAgICAgICB0b1R5cGVTdHJpbmcocmVjaWQpID09PSAnTnVtYmVyJyAmJlxuICAgICAgICAgIHJlY2lkID49IDAgJiZcbiAgICAgICAgICByZWNpZCA8PSAzLFxuICAgICAgICAnRXhwZWN0ZWQgcmVjb3ZlcnkgaWQgdG8gYmUgYSBOdW1iZXIgd2l0aGluIGludGVydmFsIFswLCAzXSdcbiAgICAgIClcbiAgICAgIGlzVWludDhBcnJheSgnbWVzc2FnZScsIG1zZzMyLCAzMilcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuZWNkc2FSZWNvdmVyKG91dHB1dCwgc2lnLCByZWNpZCwgbXNnMzIpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNJR19QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUkVDT1ZFUilcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU1QT1NTSUJMRV9DQVNFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBlY2RoIChwdWJrZXksIHNlY2tleSwgb3B0aW9ucyA9IHt9LCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHVibGljIGtleScsIHB1YmtleSwgWzMzLCA2NV0pXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGFzc2VydCh0b1R5cGVTdHJpbmcob3B0aW9ucykgPT09ICdPYmplY3QnLCAnRXhwZWN0ZWQgb3B0aW9ucyB0byBiZSBhbiBPYmplY3QnKVxuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gdW5kZWZpbmVkKSBpc1VpbnQ4QXJyYXkoJ29wdGlvbnMuZGF0YScsIG9wdGlvbnMuZGF0YSlcbiAgICAgIGlmIChvcHRpb25zLmhhc2hmbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFzc2VydCh0b1R5cGVTdHJpbmcob3B0aW9ucy5oYXNoZm4pID09PSAnRnVuY3Rpb24nLCAnRXhwZWN0ZWQgb3B0aW9ucy5oYXNoZm4gdG8gYmUgYSBGdW5jdGlvbicpXG4gICAgICAgIGlmIChvcHRpb25zLnhidWYgIT09IHVuZGVmaW5lZCkgaXNVaW50OEFycmF5KCdvcHRpb25zLnhidWYnLCBvcHRpb25zLnhidWYsIDMyKVxuICAgICAgICBpZiAob3B0aW9ucy55YnVmICE9PSB1bmRlZmluZWQpIGlzVWludDhBcnJheSgnb3B0aW9ucy55YnVmJywgb3B0aW9ucy55YnVmLCAzMilcbiAgICAgICAgaXNVaW50OEFycmF5KCdvdXRwdXQnLCBvdXRwdXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIDMyKVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5lY2RoKG91dHB1dCwgcHVia2V5LCBzZWNrZXksIG9wdGlvbnMuZGF0YSwgb3B0aW9ucy5oYXNoZm4sIG9wdGlvbnMueGJ1Ziwgb3B0aW9ucy55YnVmKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLkVDREgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiZXJyb3JzIiwiSU1QT1NTSUJMRV9DQVNFIiwiVFdFQUtfQUREIiwiVFdFQUtfTVVMIiwiQ09OVEVYVF9SQU5ET01JWkVfVU5LTk9XIiwiU0VDS0VZX0lOVkFMSUQiLCJQVUJLRVlfUEFSU0UiLCJQVUJLRVlfU0VSSUFMSVpFIiwiUFVCS0VZX0NPTUJJTkUiLCJTSUdfUEFSU0UiLCJTSUdOIiwiUkVDT1ZFUiIsIkVDREgiLCJhc3NlcnQiLCJjb25kIiwibXNnIiwiRXJyb3IiLCJpc1VpbnQ4QXJyYXkiLCJuYW1lIiwidmFsdWUiLCJsZW5ndGgiLCJVaW50OEFycmF5IiwidW5kZWZpbmVkIiwiQXJyYXkiLCJpc0FycmF5IiwibnVtYmVycyIsImpvaW4iLCJpbmNsdWRlcyIsImlzQ29tcHJlc3NlZCIsInRvVHlwZVN0cmluZyIsImdldEFzc2VydGVkT3V0cHV0Iiwib3V0cHV0IiwibGVuIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJtb2R1bGUiLCJleHBvcnRzIiwic2VjcDI1NmsxIiwiY29udGV4dFJhbmRvbWl6ZSIsInNlZWQiLCJwcml2YXRlS2V5VmVyaWZ5Iiwic2Vja2V5IiwicHJpdmF0ZUtleU5lZ2F0ZSIsInByaXZhdGVLZXlUd2Vha0FkZCIsInR3ZWFrIiwicHJpdmF0ZUtleVR3ZWFrTXVsIiwicHVibGljS2V5VmVyaWZ5IiwicHVia2V5IiwicHVibGljS2V5Q3JlYXRlIiwiY29tcHJlc3NlZCIsInB1YmxpY0tleUNvbnZlcnQiLCJwdWJsaWNLZXlOZWdhdGUiLCJwdWJsaWNLZXlDb21iaW5lIiwicHVia2V5cyIsInB1YmxpY0tleVR3ZWFrQWRkIiwicHVibGljS2V5VHdlYWtNdWwiLCJzaWduYXR1cmVOb3JtYWxpemUiLCJzaWciLCJzaWduYXR1cmVFeHBvcnQiLCJvYmoiLCJvdXRwdXRsZW4iLCJzaWduYXR1cmVJbXBvcnQiLCJlY2RzYVNpZ24iLCJtc2czMiIsIm9wdGlvbnMiLCJkYXRhIiwibm9uY2VmbiIsInNpZ25hdHVyZSIsInJlY2lkIiwiZWNkc2FWZXJpZnkiLCJlY2RzYVJlY292ZXIiLCJlY2RoIiwiaGFzaGZuIiwieGJ1ZiIsInlidWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/secp256k1@4.0.3/node_modules/secp256k1/lib/index.js\n");

/***/ })

};
;