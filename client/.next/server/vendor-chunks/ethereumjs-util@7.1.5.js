"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethereumjs-util@7.1.5";
exports.ids = ["vendor-chunks/ethereumjs-util@7.1.5"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/account.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/account.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/externals.js\");\nconst secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(ssr)/./node_modules/.pnpm/ethereum-cryptography@0.1.3/node_modules/ethereum-cryptography/secp256k1.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/internal.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/constants.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/bytes.js\");\nconst hash_1 = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/hash.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/helpers.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/types.js\");\nclass Account {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating an Account from varying data types.\n     */ constructor(nonce = new externals_1.BN(0), balance = new externals_1.BN(0), stateRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL){\n        this.nonce = nonce;\n        this.balance = balance;\n        this.stateRoot = stateRoot;\n        this.codeHash = codeHash;\n        this._validate();\n    }\n    static fromAccountData(accountData) {\n        const { nonce, balance, stateRoot, codeHash } = accountData;\n        return new Account(nonce ? new externals_1.BN((0, bytes_1.toBuffer)(nonce)) : undefined, balance ? new externals_1.BN((0, bytes_1.toBuffer)(balance)) : undefined, stateRoot ? (0, bytes_1.toBuffer)(stateRoot) : undefined, codeHash ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n    }\n    static fromRlpSerializedAccount(serialized) {\n        const values = externals_1.rlp.decode(serialized);\n        if (!Array.isArray(values)) {\n            throw new Error(\"Invalid serialized account input. Must be array\");\n        }\n        return this.fromValuesArray(values);\n    }\n    static fromValuesArray(values) {\n        const [nonce, balance, stateRoot, codeHash] = values;\n        return new Account(new externals_1.BN(nonce), new externals_1.BN(balance), stateRoot, codeHash);\n    }\n    _validate() {\n        if (this.nonce.lt(new externals_1.BN(0))) {\n            throw new Error(\"nonce must be greater than zero\");\n        }\n        if (this.balance.lt(new externals_1.BN(0))) {\n            throw new Error(\"balance must be greater than zero\");\n        }\n        if (this.stateRoot.length !== 32) {\n            throw new Error(\"stateRoot must have a length of 32\");\n        }\n        if (this.codeHash.length !== 32) {\n            throw new Error(\"codeHash must have a length of 32\");\n        }\n    }\n    /**\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\n     */ raw() {\n        return [\n            (0, types_1.bnToUnpaddedBuffer)(this.nonce),\n            (0, types_1.bnToUnpaddedBuffer)(this.balance),\n            this.stateRoot,\n            this.codeHash\n        ];\n    }\n    /**\n     * Returns the RLP serialization of the account as a `Buffer`.\n     */ serialize() {\n        return externals_1.rlp.encode(this.raw());\n    }\n    /**\n     * Returns a `Boolean` determining if the account is a contract.\n     */ isContract() {\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n    /**\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n     */ isEmpty() {\n        return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n}\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */ const isValidAddress = function(hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    } catch (e) {\n        return false;\n    }\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */ const toChecksumAddress = function(hexAddress, eip1191ChainId) {\n    (0, helpers_1.assertIsHexString)(hexAddress);\n    const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n    let prefix = \"\";\n    if (eip1191ChainId) {\n        const chainId = (0, types_1.toType)(eip1191ChainId, types_1.TypeOutput.BN);\n        prefix = chainId.toString() + \"0x\";\n    }\n    const hash = (0, hash_1.keccakFromString)(prefix + address).toString(\"hex\");\n    let ret = \"0x\";\n    for(let i = 0; i < address.length; i++){\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        } else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */ const isValidChecksumAddress = function(hexAddress, eip1191ChainId) {\n    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */ const generateAddress = function(from, nonce) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(nonce);\n    const nonceBN = new externals_1.BN(nonce);\n    if (nonceBN.isZero()) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return (0, hash_1.rlphash)([\n            from,\n            null\n        ]).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return (0, hash_1.rlphash)([\n        from,\n        Buffer.from(nonceBN.toArray())\n    ]).slice(-20);\n};\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */ const generateAddress2 = function(from, salt, initCode) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(salt);\n    (0, helpers_1.assertIsBuffer)(initCode);\n    (0, assert_1.default)(from.length === 20);\n    (0, assert_1.default)(salt.length === 32);\n    const address = (0, hash_1.keccak256)(Buffer.concat([\n        Buffer.from(\"ff\", \"hex\"),\n        from,\n        salt,\n        (0, hash_1.keccak256)(initCode)\n    ]));\n    return address.slice(-20);\n};\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */ const isValidPrivate = function(privateKey) {\n    return (0, secp256k1_1.privateKeyVerify)(privateKey);\n};\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */ const isValidPublic = function(publicKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        return (0, secp256k1_1.publicKeyVerify)(Buffer.concat([\n            Buffer.from([\n                4\n            ]),\n            publicKey\n        ]));\n    }\n    if (!sanitize) {\n        return false;\n    }\n    return (0, secp256k1_1.publicKeyVerify)(publicKey);\n};\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */ const pubToAddress = function(pubKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(pubKey, false).slice(1));\n    }\n    (0, assert_1.default)(pubKey.length === 64);\n    // Only take the lower 160bits of the hash\n    return (0, hash_1.keccak)(pubKey).slice(-20);\n};\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */ const privateToPublic = function(privateKey) {\n    (0, helpers_1.assertIsBuffer)(privateKey);\n    // skip the type flag and use the X, Y points\n    return Buffer.from((0, secp256k1_1.publicKeyCreate)(privateKey, false)).slice(1);\n};\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */ const privateToAddress = function(privateKey) {\n    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */ const importPublic = function(publicKey) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(publicKey, false).slice(1));\n    }\n    return publicKey;\n};\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */ const zeroAddress = function() {\n    const addressLength = 20;\n    const addr = (0, bytes_1.zeros)(addressLength);\n    return (0, bytes_1.bufferToHex)(addr);\n};\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */ const isZeroAddress = function(hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    } catch (e) {\n        return false;\n    }\n    const zeroAddr = (0, exports.zeroAddress)();\n    return zeroAddr === hexAddress;\n};\nexports.isZeroAddress = isZeroAddress; //# sourceMappingURL=account.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW1qcy11dGlsQDcuMS41L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9hY2NvdW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBR0EsbUJBQW1CLEdBQUdBLG9CQUFvQixHQUFHQSx3QkFBd0IsR0FBR0EsdUJBQXVCLEdBQUdBLHVCQUF1QixHQUFHQSxvQkFBb0IsR0FBR0EscUJBQXFCLEdBQUdBLHNCQUFzQixHQUFHQSx3QkFBd0IsR0FBR0EsdUJBQXVCLEdBQUdBLDhCQUE4QixHQUFHQSx5QkFBeUIsR0FBR0Esc0JBQXNCLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQzlYLE1BQU1pQixXQUFXdEIsZ0JBQWdCdUIsbUJBQU9BLENBQUMsc0JBQVE7QUFDakQsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsb0hBQWE7QUFDekMsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsK0lBQWlDO0FBQzdELE1BQU1HLGFBQWFILG1CQUFPQSxDQUFDLGtIQUFZO0FBQ3ZDLE1BQU1JLGNBQWNKLG1CQUFPQSxDQUFDLG9IQUFhO0FBQ3pDLE1BQU1LLFVBQVVMLG1CQUFPQSxDQUFDLDRHQUFTO0FBQ2pDLE1BQU1NLFNBQVNOLG1CQUFPQSxDQUFDLDBHQUFRO0FBQy9CLE1BQU1PLFlBQVlQLG1CQUFPQSxDQUFDLGdIQUFXO0FBQ3JDLE1BQU1RLFVBQVVSLG1CQUFPQSxDQUFDLDRHQUFTO0FBQ2pDLE1BQU1GO0lBQ0Y7OztLQUdDLEdBQ0RXLFlBQVlDLFFBQVEsSUFBSVQsWUFBWVUsRUFBRSxDQUFD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Q0EsTUFBTTJDLFdBQVcsQ0FBQyxHQUFHeEcsUUFBUUcsV0FBVztJQUN4QyxPQUFPcUcsYUFBYTdDO0FBQ3hCO0FBQ0EzRCxxQkFBcUIsR0FBR0UsZUFDeEIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyZXVtanMtdXRpbEA3LjEuNS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYWNjb3VudC5qcz81YWI2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1plcm9BZGRyZXNzID0gZXhwb3J0cy56ZXJvQWRkcmVzcyA9IGV4cG9ydHMuaW1wb3J0UHVibGljID0gZXhwb3J0cy5wcml2YXRlVG9BZGRyZXNzID0gZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMgPSBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcyA9IGV4cG9ydHMucHViVG9BZGRyZXNzID0gZXhwb3J0cy5pc1ZhbGlkUHVibGljID0gZXhwb3J0cy5pc1ZhbGlkUHJpdmF0ZSA9IGV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzMiA9IGV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzID0gZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZEFkZHJlc3MgPSBleHBvcnRzLkFjY291bnQgPSB2b2lkIDA7XG5jb25zdCBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbmNvbnN0IGV4dGVybmFsc18xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxzXCIpO1xuY29uc3Qgc2VjcDI1NmsxXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3NlY3AyNTZrMVwiKTtcbmNvbnN0IGludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuY29uc3QgaGFzaF8xID0gcmVxdWlyZShcIi4vaGFzaFwiKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jbGFzcyBBY2NvdW50IHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNvbnN0cnVjdG9yIGFzc2lnbnMgYW5kIHZhbGlkYXRlcyB0aGUgdmFsdWVzLlxuICAgICAqIFVzZSB0aGUgc3RhdGljIGZhY3RvcnkgbWV0aG9kcyB0byBhc3Npc3QgaW4gY3JlYXRpbmcgYW4gQWNjb3VudCBmcm9tIHZhcnlpbmcgZGF0YSB0eXBlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub25jZSA9IG5ldyBleHRlcm5hbHNfMS5CTigwKSwgYmFsYW5jZSA9IG5ldyBleHRlcm5hbHNfMS5CTigwKSwgc3RhdGVSb290ID0gY29uc3RhbnRzXzEuS0VDQ0FLMjU2X1JMUCwgY29kZUhhc2ggPSBjb25zdGFudHNfMS5LRUNDQUsyNTZfTlVMTCkge1xuICAgICAgICB0aGlzLm5vbmNlID0gbm9uY2U7XG4gICAgICAgIHRoaXMuYmFsYW5jZSA9IGJhbGFuY2U7XG4gICAgICAgIHRoaXMuc3RhdGVSb290ID0gc3RhdGVSb290O1xuICAgICAgICB0aGlzLmNvZGVIYXNoID0gY29kZUhhc2g7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQWNjb3VudERhdGEoYWNjb3VudERhdGEpIHtcbiAgICAgICAgY29uc3QgeyBub25jZSwgYmFsYW5jZSwgc3RhdGVSb290LCBjb2RlSGFzaCB9ID0gYWNjb3VudERhdGE7XG4gICAgICAgIHJldHVybiBuZXcgQWNjb3VudChub25jZSA/IG5ldyBleHRlcm5hbHNfMS5CTigoMCwgYnl0ZXNfMS50b0J1ZmZlcikobm9uY2UpKSA6IHVuZGVmaW5lZCwgYmFsYW5jZSA/IG5ldyBleHRlcm5hbHNfMS5CTigoMCwgYnl0ZXNfMS50b0J1ZmZlcikoYmFsYW5jZSkpIDogdW5kZWZpbmVkLCBzdGF0ZVJvb3QgPyAoMCwgYnl0ZXNfMS50b0J1ZmZlcikoc3RhdGVSb290KSA6IHVuZGVmaW5lZCwgY29kZUhhc2ggPyAoMCwgYnl0ZXNfMS50b0J1ZmZlcikoY29kZUhhc2gpIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21SbHBTZXJpYWxpemVkQWNjb3VudChzZXJpYWxpemVkKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGV4dGVybmFsc18xLnJscC5kZWNvZGUoc2VyaWFsaXplZCk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VyaWFsaXplZCBhY2NvdW50IGlucHV0LiBNdXN0IGJlIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVZhbHVlc0FycmF5KHZhbHVlcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IFtub25jZSwgYmFsYW5jZSwgc3RhdGVSb290LCBjb2RlSGFzaF0gPSB2YWx1ZXM7XG4gICAgICAgIHJldHVybiBuZXcgQWNjb3VudChuZXcgZXh0ZXJuYWxzXzEuQk4obm9uY2UpLCBuZXcgZXh0ZXJuYWxzXzEuQk4oYmFsYW5jZSksIHN0YXRlUm9vdCwgY29kZUhhc2gpO1xuICAgIH1cbiAgICBfdmFsaWRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vbmNlLmx0KG5ldyBleHRlcm5hbHNfMS5CTigwKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm9uY2UgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVybycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJhbGFuY2UubHQobmV3IGV4dGVybmFsc18xLkJOKDApKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWxhbmNlIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZVJvb3QubGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGF0ZVJvb3QgbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIDMyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29kZUhhc2gubGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb2RlSGFzaCBtdXN0IGhhdmUgYSBsZW5ndGggb2YgMzInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQnVmZmVyIEFycmF5IG9mIHRoZSByYXcgQnVmZmVycyBmb3IgdGhlIGFjY291bnQsIGluIG9yZGVyLlxuICAgICAqL1xuICAgIHJhdygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICgwLCB0eXBlc18xLmJuVG9VbnBhZGRlZEJ1ZmZlcikodGhpcy5ub25jZSksXG4gICAgICAgICAgICAoMCwgdHlwZXNfMS5iblRvVW5wYWRkZWRCdWZmZXIpKHRoaXMuYmFsYW5jZSksXG4gICAgICAgICAgICB0aGlzLnN0YXRlUm9vdCxcbiAgICAgICAgICAgIHRoaXMuY29kZUhhc2gsXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFJMUCBzZXJpYWxpemF0aW9uIG9mIHRoZSBhY2NvdW50IGFzIGEgYEJ1ZmZlcmAuXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4gZXh0ZXJuYWxzXzEucmxwLmVuY29kZSh0aGlzLnJhdygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGBCb29sZWFuYCBkZXRlcm1pbmluZyBpZiB0aGUgYWNjb3VudCBpcyBhIGNvbnRyYWN0LlxuICAgICAqL1xuICAgIGlzQ29udHJhY3QoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb2RlSGFzaC5lcXVhbHMoY29uc3RhbnRzXzEuS0VDQ0FLMjU2X05VTEwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYEJvb2xlYW5gIGRldGVybWluaW5nIGlmIHRoZSBhY2NvdW50IGlzIGVtcHR5IGNvbXBseWluZyB0byB0aGUgZGVmaW5pdGlvbiBvZlxuICAgICAqIGFjY291bnQgZW1wdGluZXNzIGluIFtFSVAtMTYxXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTE2MSk6XG4gICAgICogXCJBbiBhY2NvdW50IGlzIGNvbnNpZGVyZWQgZW1wdHkgd2hlbiBpdCBoYXMgbm8gY29kZSBhbmQgemVybyBub25jZSBhbmQgemVybyBiYWxhbmNlLlwiXG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZS5pc1plcm8oKSAmJiB0aGlzLm5vbmNlLmlzWmVybygpICYmIHRoaXMuY29kZUhhc2guZXF1YWxzKGNvbnN0YW50c18xLktFQ0NBSzI1Nl9OVUxMKTtcbiAgICB9XG59XG5leHBvcnRzLkFjY291bnQgPSBBY2NvdW50O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZC4gQWNjZXB0cyBjaGVja3N1bW1lZCBhZGRyZXNzZXMgdG9vLlxuICovXG5jb25zdCBpc1ZhbGlkQWRkcmVzcyA9IGZ1bmN0aW9uIChoZXhBZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc1N0cmluZykoaGV4QWRkcmVzcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIC9eMHhbMC05YS1mQS1GXXs0MH0kLy50ZXN0KGhleEFkZHJlc3MpO1xufTtcbmV4cG9ydHMuaXNWYWxpZEFkZHJlc3MgPSBpc1ZhbGlkQWRkcmVzcztcbi8qKlxuICogUmV0dXJucyBhIGNoZWNrc3VtbWVkIGFkZHJlc3MuXG4gKlxuICogSWYgYW4gZWlwMTE5MUNoYWluSWQgaXMgcHJvdmlkZWQsIHRoZSBjaGFpbklkIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIGNoZWNrc3VtIGNhbGN1bGF0aW9uLiBUaGlzXG4gKiBoYXMgdGhlIGVmZmVjdCBvZiBjaGVja3N1bW1lZCBhZGRyZXNzZXMgZm9yIG9uZSBjaGFpbiBoYXZpbmcgaW52YWxpZCBjaGVja3N1bXMgZm9yIG90aGVycy5cbiAqIEZvciBtb3JlIGRldGFpbHMgc2VlIFtFSVAtMTE5MV0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMTkxKS5cbiAqXG4gKiBXQVJOSU5HOiBDaGVja3N1bXMgd2l0aCBhbmQgd2l0aG91dCB0aGUgY2hhaW5JZCB3aWxsIGRpZmZlciBhbmQgdGhlIEVJUC0xMTkxIGNoZWNrc3VtIGlzIG5vdFxuICogYmFja3dhcmRzIGNvbXBhdGlibGUgdG8gdGhlIG9yaWdpbmFsIHdpZGVseSBhZG9wdGVkIGNoZWNrc3VtIGZvcm1hdCBzdGFuZGFyZCBpbnRyb2R1Y2VkIGluXG4gKiBbRUlQLTU1XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTU1KSwgc28gdGhpcyB3aWxsIGJyZWFrIGluIGV4aXN0aW5nIGFwcGxpY2F0aW9ucy5cbiAqIFVzYWdlIG9mIHRoaXMgRUlQIGlzIHRoZXJlZm9yZSBkaXNjb3VyYWdlZCB1bmxlc3MgeW91IGhhdmUgYSB2ZXJ5IHRhcmdldGVkIHVzZSBjYXNlLlxuICovXG5jb25zdCB0b0NoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChoZXhBZGRyZXNzLCBlaXAxMTkxQ2hhaW5JZCkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNIZXhTdHJpbmcpKGhleEFkZHJlc3MpO1xuICAgIGNvbnN0IGFkZHJlc3MgPSAoMCwgaW50ZXJuYWxfMS5zdHJpcEhleFByZWZpeCkoaGV4QWRkcmVzcykudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgcHJlZml4ID0gJyc7XG4gICAgaWYgKGVpcDExOTFDaGFpbklkKSB7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSAoMCwgdHlwZXNfMS50b1R5cGUpKGVpcDExOTFDaGFpbklkLCB0eXBlc18xLlR5cGVPdXRwdXQuQk4pO1xuICAgICAgICBwcmVmaXggPSBjaGFpbklkLnRvU3RyaW5nKCkgKyAnMHgnO1xuICAgIH1cbiAgICBjb25zdCBoYXNoID0gKDAsIGhhc2hfMS5rZWNjYWtGcm9tU3RyaW5nKShwcmVmaXggKyBhZGRyZXNzKS50b1N0cmluZygnaGV4Jyk7XG4gICAgbGV0IHJldCA9ICcweCc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwYXJzZUludChoYXNoW2ldLCAxNikgPj0gOCkge1xuICAgICAgICAgICAgcmV0ICs9IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldCArPSBhZGRyZXNzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyA9IHRvQ2hlY2tzdW1BZGRyZXNzO1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZCBjaGVja3N1bW1lZCBhZGRyZXNzLlxuICpcbiAqIFNlZSB0b0NoZWNrc3VtQWRkcmVzcycgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscyBhYm91dCB0aGUgZWlwMTE5MUNoYWluSWQgcGFyYW1ldGVyLlxuICovXG5jb25zdCBpc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGhleEFkZHJlc3MsIGVpcDExOTFDaGFpbklkKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmlzVmFsaWRBZGRyZXNzKShoZXhBZGRyZXNzKSAmJiAoMCwgZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcykoaGV4QWRkcmVzcywgZWlwMTE5MUNoYWluSWQpID09PSBoZXhBZGRyZXNzO1xufTtcbmV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGlzVmFsaWRDaGVja3N1bUFkZHJlc3M7XG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIG9mIGEgbmV3bHkgY3JlYXRlZCBjb250cmFjdC5cbiAqIEBwYXJhbSBmcm9tIFRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAqIEBwYXJhbSBub25jZSBUaGUgbm9uY2Ugb2YgdGhlIGZyb20gYWNjb3VudFxuICovXG5jb25zdCBnZW5lcmF0ZUFkZHJlc3MgPSBmdW5jdGlvbiAoZnJvbSwgbm9uY2UpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShmcm9tKTtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShub25jZSk7XG4gICAgY29uc3Qgbm9uY2VCTiA9IG5ldyBleHRlcm5hbHNfMS5CTihub25jZSk7XG4gICAgaWYgKG5vbmNlQk4uaXNaZXJvKCkpIHtcbiAgICAgICAgLy8gaW4gUkxQIHdlIHdhbnQgdG8gZW5jb2RlIG51bGwgaW4gdGhlIGNhc2Ugb2YgemVybyBub25jZVxuICAgICAgICAvLyByZWFkIHRoZSBSTFAgZG9jdW1lbnRhdGlvbiBmb3IgYW4gYW5zd2VyIGlmIHlvdSBkYXJlXG4gICAgICAgIHJldHVybiAoMCwgaGFzaF8xLnJscGhhc2gpKFtmcm9tLCBudWxsXSkuc2xpY2UoLTIwKTtcbiAgICB9XG4gICAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gICAgcmV0dXJuICgwLCBoYXNoXzEucmxwaGFzaCkoW2Zyb20sIEJ1ZmZlci5mcm9tKG5vbmNlQk4udG9BcnJheSgpKV0pLnNsaWNlKC0yMCk7XG59O1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBnZW5lcmF0ZUFkZHJlc3M7XG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIGZvciBhIGNvbnRyYWN0IGNyZWF0ZWQgdXNpbmcgQ1JFQVRFMi5cbiAqIEBwYXJhbSBmcm9tIFRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAqIEBwYXJhbSBzYWx0IEEgc2FsdFxuICogQHBhcmFtIGluaXRDb2RlIFRoZSBpbml0IGNvZGUgb2YgdGhlIGNvbnRyYWN0IGJlaW5nIGNyZWF0ZWRcbiAqL1xuY29uc3QgZ2VuZXJhdGVBZGRyZXNzMiA9IGZ1bmN0aW9uIChmcm9tLCBzYWx0LCBpbml0Q29kZSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGZyb20pO1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKHNhbHQpO1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGluaXRDb2RlKTtcbiAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoZnJvbS5sZW5ndGggPT09IDIwKTtcbiAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoc2FsdC5sZW5ndGggPT09IDMyKTtcbiAgICBjb25zdCBhZGRyZXNzID0gKDAsIGhhc2hfMS5rZWNjYWsyNTYpKEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKCdmZicsICdoZXgnKSwgZnJvbSwgc2FsdCwgKDAsIGhhc2hfMS5rZWNjYWsyNTYpKGluaXRDb2RlKV0pKTtcbiAgICByZXR1cm4gYWRkcmVzcy5zbGljZSgtMjApO1xufTtcbmV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzMiA9IGdlbmVyYXRlQWRkcmVzczI7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJpdmF0ZSBrZXkgc2F0aXNmaWVzIHRoZSBydWxlcyBvZiB0aGUgY3VydmUgc2VjcDI1NmsxLlxuICovXG5jb25zdCBpc1ZhbGlkUHJpdmF0ZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuICgwLCBzZWNwMjU2azFfMS5wcml2YXRlS2V5VmVyaWZ5KShwcml2YXRlS2V5KTtcbn07XG5leHBvcnRzLmlzVmFsaWRQcml2YXRlID0gaXNWYWxpZFByaXZhdGU7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHVibGljIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azFcbiAqIGFuZCB0aGUgcmVxdWlyZW1lbnRzIG9mIEV0aGVyZXVtLlxuICogQHBhcmFtIHB1YmxpY0tleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHNhbml0aXplIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKi9cbmNvbnN0IGlzVmFsaWRQdWJsaWMgPSBmdW5jdGlvbiAocHVibGljS2V5LCBzYW5pdGl6ZSA9IGZhbHNlKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikocHVibGljS2V5KTtcbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgLy8gQ29udmVydCB0byBTRUMxIGZvciBzZWNwMjU2azFcbiAgICAgICAgcmV0dXJuICgwLCBzZWNwMjU2azFfMS5wdWJsaWNLZXlWZXJpZnkpKEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFs0XSksIHB1YmxpY0tleV0pKTtcbiAgICB9XG4gICAgaWYgKCFzYW5pdGl6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoMCwgc2VjcDI1NmsxXzEucHVibGljS2V5VmVyaWZ5KShwdWJsaWNLZXkpO1xufTtcbmV4cG9ydHMuaXNWYWxpZFB1YmxpYyA9IGlzVmFsaWRQdWJsaWM7XG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwdWJsaWMga2V5LlxuICogQWNjZXB0cyBcIkV0aGVyZXVtIHB1YmxpYyBrZXlzXCIgYW5kIFNFQzEgZW5jb2RlZCBrZXlzLlxuICogQHBhcmFtIHB1YktleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHNhbml0aXplIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKi9cbmNvbnN0IHB1YlRvQWRkcmVzcyA9IGZ1bmN0aW9uIChwdWJLZXksIHNhbml0aXplID0gZmFsc2UpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShwdWJLZXkpO1xuICAgIGlmIChzYW5pdGl6ZSAmJiBwdWJLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICBwdWJLZXkgPSBCdWZmZXIuZnJvbSgoMCwgc2VjcDI1NmsxXzEucHVibGljS2V5Q29udmVydCkocHViS2V5LCBmYWxzZSkuc2xpY2UoMSkpO1xuICAgIH1cbiAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkocHViS2V5Lmxlbmd0aCA9PT0gNjQpO1xuICAgIC8vIE9ubHkgdGFrZSB0aGUgbG93ZXIgMTYwYml0cyBvZiB0aGUgaGFzaFxuICAgIHJldHVybiAoMCwgaGFzaF8xLmtlY2NhaykocHViS2V5KS5zbGljZSgtMjApO1xufTtcbmV4cG9ydHMucHViVG9BZGRyZXNzID0gcHViVG9BZGRyZXNzO1xuZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MgPSBleHBvcnRzLnB1YlRvQWRkcmVzcztcbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gcHVibGljIGtleSBvZiBhIGdpdmVuIHByaXZhdGUga2V5LlxuICogQHBhcmFtIHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAqL1xuY29uc3QgcHJpdmF0ZVRvUHVibGljID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShwcml2YXRlS2V5KTtcbiAgICAvLyBza2lwIHRoZSB0eXBlIGZsYWcgYW5kIHVzZSB0aGUgWCwgWSBwb2ludHNcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIHNlY3AyNTZrMV8xLnB1YmxpY0tleUNyZWF0ZSkocHJpdmF0ZUtleSwgZmFsc2UpKS5zbGljZSgxKTtcbn07XG5leHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IHByaXZhdGVUb1B1YmxpYztcbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHByaXZhdGUga2V5LlxuICogQHBhcmFtIHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAqL1xuY29uc3QgcHJpdmF0ZVRvQWRkcmVzcyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcykoKDAsIGV4cG9ydHMucHJpdmF0ZVRvUHVibGljKShwcml2YXRlS2V5KSk7XG59O1xuZXhwb3J0cy5wcml2YXRlVG9BZGRyZXNzID0gcHJpdmF0ZVRvQWRkcmVzcztcbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIHRoZSBFdGhlcmV1bSBmb3JtYXQuXG4gKi9cbmNvbnN0IGltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShwdWJsaWNLZXkpO1xuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICBwdWJsaWNLZXkgPSBCdWZmZXIuZnJvbSgoMCwgc2VjcDI1NmsxXzEucHVibGljS2V5Q29udmVydCkocHVibGljS2V5LCBmYWxzZSkuc2xpY2UoMSkpO1xuICAgIH1cbiAgICByZXR1cm4gcHVibGljS2V5O1xufTtcbmV4cG9ydHMuaW1wb3J0UHVibGljID0gaW1wb3J0UHVibGljO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSB6ZXJvIGFkZHJlc3MuXG4gKi9cbmNvbnN0IHplcm9BZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGFkZHJlc3NMZW5ndGggPSAyMDtcbiAgICBjb25zdCBhZGRyID0gKDAsIGJ5dGVzXzEuemVyb3MpKGFkZHJlc3NMZW5ndGgpO1xuICAgIHJldHVybiAoMCwgYnl0ZXNfMS5idWZmZXJUb0hleCkoYWRkcik7XG59O1xuZXhwb3J0cy56ZXJvQWRkcmVzcyA9IHplcm9BZGRyZXNzO1xuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBhZGRyZXNzIGlzIHRoZSB6ZXJvIGFkZHJlc3MuXG4gKi9cbmNvbnN0IGlzWmVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoaGV4QWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNTdHJpbmcpKGhleEFkZHJlc3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHplcm9BZGRyID0gKDAsIGV4cG9ydHMuemVyb0FkZHJlc3MpKCk7XG4gICAgcmV0dXJuIHplcm9BZGRyID09PSBoZXhBZGRyZXNzO1xufTtcbmV4cG9ydHMuaXNaZXJvQWRkcmVzcyA9IGlzWmVyb0FkZHJlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2NvdW50LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpc1plcm9BZGRyZXNzIiwiemVyb0FkZHJlc3MiLCJpbXBvcnRQdWJsaWMiLCJwcml2YXRlVG9BZGRyZXNzIiwicHJpdmF0ZVRvUHVibGljIiwicHVibGljVG9BZGRyZXNzIiwicHViVG9BZGRyZXNzIiwiaXNWYWxpZFB1YmxpYyIsImlzVmFsaWRQcml2YXRlIiwiZ2VuZXJhdGVBZGRyZXNzMiIsImdlbmVyYXRlQWRkcmVzcyIsImlzVmFsaWRDaGVja3N1bUFkZHJlc3MiLCJ0b0NoZWNrc3VtQWRkcmVzcyIsImlzVmFsaWRBZGRyZXNzIiwiQWNjb3VudCIsImFzc2VydF8xIiwicmVxdWlyZSIsImV4dGVybmFsc18xIiwic2VjcDI1NmsxXzEiLCJpbnRlcm5hbF8xIiwiY29uc3RhbnRzXzEiLCJieXRlc18xIiwiaGFzaF8xIiwiaGVscGVyc18xIiwidHlwZXNfMSIsImNvbnN0cnVjdG9yIiwibm9uY2UiLCJCTiIsImJhbGFuY2UiLCJzdGF0ZVJvb3QiLCJLRUNDQUsyNTZfUkxQIiwiY29kZUhhc2giLCJLRUNDQUsyNTZfTlVMTCIsIl92YWxpZGF0ZSIsImZyb21BY2NvdW50RGF0YSIsImFjY291bnREYXRhIiwidG9CdWZmZXIiLCJ1bmRlZmluZWQiLCJmcm9tUmxwU2VyaWFsaXplZEFjY291bnQiLCJzZXJpYWxpemVkIiwidmFsdWVzIiwicmxwIiwiZGVjb2RlIiwiQXJyYXkiLCJpc0FycmF5IiwiRXJyb3IiLCJmcm9tVmFsdWVzQXJyYXkiLCJsdCIsImxlbmd0aCIsInJhdyIsImJuVG9VbnBhZGRlZEJ1ZmZlciIsInNlcmlhbGl6ZSIsImVuY29kZSIsImlzQ29udHJhY3QiLCJlcXVhbHMiLCJpc0VtcHR5IiwiaXNaZXJvIiwiaGV4QWRkcmVzcyIsImFzc2VydElzU3RyaW5nIiwiZSIsInRlc3QiLCJlaXAxMTkxQ2hhaW5JZCIsImFzc2VydElzSGV4U3RyaW5nIiwiYWRkcmVzcyIsInN0cmlwSGV4UHJlZml4IiwidG9Mb3dlckNhc2UiLCJwcmVmaXgiLCJjaGFpbklkIiwidG9UeXBlIiwiVHlwZU91dHB1dCIsInRvU3RyaW5nIiwiaGFzaCIsImtlY2Nha0Zyb21TdHJpbmciLCJyZXQiLCJpIiwicGFyc2VJbnQiLCJ0b1VwcGVyQ2FzZSIsImZyb20iLCJhc3NlcnRJc0J1ZmZlciIsIm5vbmNlQk4iLCJybHBoYXNoIiwic2xpY2UiLCJCdWZmZXIiLCJ0b0FycmF5Iiwic2FsdCIsImluaXRDb2RlIiwiZGVmYXVsdCIsImtlY2NhazI1NiIsImNvbmNhdCIsInByaXZhdGVLZXkiLCJwcml2YXRlS2V5VmVyaWZ5IiwicHVibGljS2V5Iiwic2FuaXRpemUiLCJwdWJsaWNLZXlWZXJpZnkiLCJwdWJLZXkiLCJwdWJsaWNLZXlDb252ZXJ0Iiwia2VjY2FrIiwicHVibGljS2V5Q3JlYXRlIiwiYWRkcmVzc0xlbmd0aCIsImFkZHIiLCJ6ZXJvcyIsImJ1ZmZlclRvSGV4IiwiemVyb0FkZHIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/account.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/address.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/address.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Address = void 0;\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/externals.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/bytes.js\");\nconst account_1 = __webpack_require__(/*! ./account */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/account.js\");\nclass Address {\n    constructor(buf){\n        (0, assert_1.default)(buf.length === 20, \"Invalid address length\");\n        this.buf = buf;\n    }\n    /**\n     * Returns the zero address.\n     */ static zero() {\n        return new Address((0, bytes_1.zeros)(20));\n    }\n    /**\n     * Returns an Address object from a hex-encoded string.\n     * @param str - Hex-encoded address\n     */ static fromString(str) {\n        (0, assert_1.default)((0, account_1.isValidAddress)(str), \"Invalid address\");\n        return new Address((0, bytes_1.toBuffer)(str));\n    }\n    /**\n     * Returns an address for a given public key.\n     * @param pubKey The two points of an uncompressed key\n     */ static fromPublicKey(pubKey) {\n        (0, assert_1.default)(Buffer.isBuffer(pubKey), \"Public key should be Buffer\");\n        const buf = (0, account_1.pubToAddress)(pubKey);\n        return new Address(buf);\n    }\n    /**\n     * Returns an address for a given private key.\n     * @param privateKey A private key must be 256 bits wide\n     */ static fromPrivateKey(privateKey) {\n        (0, assert_1.default)(Buffer.isBuffer(privateKey), \"Private key should be Buffer\");\n        const buf = (0, account_1.privateToAddress)(privateKey);\n        return new Address(buf);\n    }\n    /**\n     * Generates an address for a newly created contract.\n     * @param from The address which is creating this new address\n     * @param nonce The nonce of the from account\n     */ static generate(from, nonce) {\n        (0, assert_1.default)(externals_1.BN.isBN(nonce));\n        return new Address((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));\n    }\n    /**\n     * Generates an address for a contract created using CREATE2.\n     * @param from The address which is creating this new address\n     * @param salt A salt\n     * @param initCode The init code of the contract being created\n     */ static generate2(from, salt, initCode) {\n        (0, assert_1.default)(Buffer.isBuffer(salt));\n        (0, assert_1.default)(Buffer.isBuffer(initCode));\n        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n    }\n    /**\n     * Is address equal to another.\n     */ equals(address) {\n        return this.buf.equals(address.buf);\n    }\n    /**\n     * Is address zero.\n     */ isZero() {\n        return this.equals(Address.zero());\n    }\n    /**\n     * True if address is in the address range defined\n     * by EIP-1352\n     */ isPrecompileOrSystemAddress() {\n        const addressBN = new externals_1.BN(this.buf);\n        const rangeMin = new externals_1.BN(0);\n        const rangeMax = new externals_1.BN(\"ffff\", \"hex\");\n        return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\n    }\n    /**\n     * Returns hex encoding of address.\n     */ toString() {\n        return \"0x\" + this.buf.toString(\"hex\");\n    }\n    /**\n     * Returns Buffer representation of address.\n     */ toBuffer() {\n        return Buffer.from(this.buf);\n    }\n}\nexports.Address = Address; //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW1qcy11dGlsQDcuMS41L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxlQUFlLEdBQUcsS0FBSztBQUN2QixNQUFNRyxXQUFXUixnQkFBZ0JTLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pELE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLG9IQUFhO0FBQ3pDLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLDRHQUFTO0FBQ2pDLE1BQU1HLFlBQVlILG1CQUFPQSxDQUFDLGdIQUFXO0FBQ3JDLE1BQU1GO0lBQ0ZNLFlBQVlDLEdBQUcsQ0FBRTtRQUNaLElBQUdOLFNBQVNPLE9BQU8sRUFBRUQsSUFBSUUsTUFBTSxLQUFLLElBQUk7UUFDekMsSUFBSSxDQUFDRixHQUFHLEdBQUdBO0lBQ2Y7SUFDQTs7S0FFQyxHQUNELE9BQU9HLE9BQU87UUFDVixPQUFPLElBQUlWLFFBQVEsQ0FBQyxHQUFHSSxRQUFRTyxLQUFLLEVBQUU7SUFDMUM7SUFDQTs7O0tBR0MsR0FDRCxPQUFPQyxXQUFXQyxHQUFHLEVBQUU7UUFDbEIsSUFBR1osU0FBU08sT0FBTyxFQUFFLENBQUMsR0FBR0gsVUFBVVMsY0FBYyxFQUFFRCxNQUFNO1FBQzFELE9BQU8sSUFBSWIsUUFBUSxDQUFDLEdBQUdJLFFBQVFXLFFBQVEsRUFBRUY7SUFDN0M7SUFDQTs7O0tBR0MsR0FDRCxPQUFPRyxjQUFjQyxNQUFNLEVBQUU7UUFDeEIsSUFBR2hCLFNBQVNPLE9BQU8sRUFBRVUsT0FBT0MsUUFBUSxDQUFDRixTQUFTO1FBQy9DLE1BQU1WLE1BQU0sQ0FBQyxHQUFHRixVQUFVZSxZQUFZLEVBQUVIO1FBQ3hDLE9BQU8sSUFBSWpCLFFBQVFPO0lBQ3ZCO0lBQ0E7OztLQUdDLEdBQ0QsT0FBT2MsZUFBZUMsVUFBVSxFQUFFO1FBQzdCLElBQUdyQixTQUFTTyxPQUFPLEVBQUVVLE9BQU9DLFFBQVEsQ0FBQ0csYUFBYTtRQUNuRCxNQUFNZixNQUFNLENBQUMsR0FBR0YsVUFBVWtCLGdCQUFnQixFQUFFRDtRQUM1QyxPQUFPLElBQUl0QixRQUFRTztJQUN2QjtJQUNBOzs7O0tBSUMsR0FDRCxPQUFPaUIsU0FBU0MsSUFBSSxFQUFFQyxLQUFLLEVBQUU7UUFDeEIsSUFBR3pCLFNBQVNPLE9BQU8sRUFBRUwsWUFBWXdCLEVBQUUsQ0FBQ0MsSUFBSSxDQUFDRjtRQUMxQyxPQUFPLElBQUkxQixRQUFRLENBQUMsR0FBR0ssVUFBVXdCLGVBQWUsRUFBRUosS0FBS2xCLEdBQUcsRUFBRW1CLE1BQU1JLFdBQVcsQ0FBQ1o7SUFDbEY7SUFDQTs7Ozs7S0FLQyxHQUNELE9BQU9hLFVBQVVOLElBQUksRUFBRU8sSUFBSSxFQUFFQyxRQUFRLEVBQUU7UUFDbEMsSUFBR2hDLFNBQVNPLE9BQU8sRUFBRVUsT0FBT0MsUUFBUSxDQUFDYTtRQUNyQyxJQUFHL0IsU0FBU08sT0FBTyxFQUFFVSxPQUFPQyxRQUFRLENBQUNjO1FBQ3RDLE9BQU8sSUFBSWpDLFFBQVEsQ0FBQyxHQUFHSyxVQUFVNkIsZ0JBQWdCLEVBQUVULEtBQUtsQixHQUFHLEVBQUV5QixNQUFNQztJQUN2RTtJQUNBOztLQUVDLEdBQ0RFLE9BQU9DLE9BQU8sRUFBRTtRQUNaLE9BQU8sSUFBSSxDQUFDN0IsR0FBRyxDQUFDNEIsTUFBTSxDQUFDQyxRQUFRN0IsR0FBRztJQUN0QztJQUNBOztLQUVDLEdBQ0Q4QixTQUFTO1FBQ0wsT0FBTyxJQUFJLENBQUNGLE1BQU0sQ0FBQ25DLFFBQVFVLElBQUk7SUFDbkM7SUFDQTs7O0tBR0MsR0FDRDRCLDhCQUE4QjtRQUMxQixNQUFNQyxZQUFZLElBQUlwQyxZQUFZd0IsRUFBRSxDQUFDLElBQUksQ0FBQ3BCLEdBQUc7UUFDN0MsTUFBTWlDLFdBQVcsSUFBSXJDLFlBQVl3QixFQUFFLENBQUM7UUFDcEMsTUFBTWMsV0FBVyxJQUFJdEMsWUFBWXdCLEVBQUUsQ0FBQyxRQUFRO1FBQzVDLE9BQU9ZLFVBQVVHLEdBQUcsQ0FBQ0YsYUFBYUQsVUFBVUksR0FBRyxDQUFDRjtJQUNwRDtJQUNBOztLQUVDLEdBQ0RHLFdBQVc7UUFDUCxPQUFPLE9BQU8sSUFBSSxDQUFDckMsR0FBRyxDQUFDcUMsUUFBUSxDQUFDO0lBQ3BDO0lBQ0E7O0tBRUMsR0FDRDdCLFdBQVc7UUFDUCxPQUFPRyxPQUFPTyxJQUFJLENBQUMsSUFBSSxDQUFDbEIsR0FBRztJQUMvQjtBQUNKO0FBQ0FULGVBQWUsR0FBR0UsU0FDbEIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyZXVtanMtdXRpbEA3LjEuNS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYWRkcmVzcy5qcz8wNzExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGRyZXNzID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzc2VydFwiKSk7XG5jb25zdCBleHRlcm5hbHNfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsc1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbmNvbnN0IGFjY291bnRfMSA9IHJlcXVpcmUoXCIuL2FjY291bnRcIik7XG5jbGFzcyBBZGRyZXNzIHtcbiAgICBjb25zdHJ1Y3RvcihidWYpIHtcbiAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKGJ1Zi5sZW5ndGggPT09IDIwLCAnSW52YWxpZCBhZGRyZXNzIGxlbmd0aCcpO1xuICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgemVybyBhZGRyZXNzLlxuICAgICAqL1xuICAgIHN0YXRpYyB6ZXJvKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoKDAsIGJ5dGVzXzEuemVyb3MpKDIwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gQWRkcmVzcyBvYmplY3QgZnJvbSBhIGhleC1lbmNvZGVkIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gc3RyIC0gSGV4LWVuY29kZWQgYWRkcmVzc1xuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHN0cikge1xuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoKDAsIGFjY291bnRfMS5pc1ZhbGlkQWRkcmVzcykoc3RyKSwgJ0ludmFsaWQgYWRkcmVzcycpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoKDAsIGJ5dGVzXzEudG9CdWZmZXIpKHN0cikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFkZHJlc3MgZm9yIGEgZ2l2ZW4gcHVibGljIGtleS5cbiAgICAgKiBAcGFyYW0gcHViS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXlcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVB1YmxpY0tleShwdWJLZXkpIHtcbiAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKEJ1ZmZlci5pc0J1ZmZlcihwdWJLZXkpLCAnUHVibGljIGtleSBzaG91bGQgYmUgQnVmZmVyJyk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9ICgwLCBhY2NvdW50XzEucHViVG9BZGRyZXNzKShwdWJLZXkpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoYnVmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhZGRyZXNzIGZvciBhIGdpdmVuIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKEJ1ZmZlci5pc0J1ZmZlcihwcml2YXRlS2V5KSwgJ1ByaXZhdGUga2V5IHNob3VsZCBiZSBCdWZmZXInKTtcbiAgICAgICAgY29uc3QgYnVmID0gKDAsIGFjY291bnRfMS5wcml2YXRlVG9BZGRyZXNzKShwcml2YXRlS2V5KTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKGJ1Zik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIGZvciBhIG5ld2x5IGNyZWF0ZWQgY29udHJhY3QuXG4gICAgICogQHBhcmFtIGZyb20gVGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICAgICAqIEBwYXJhbSBub25jZSBUaGUgbm9uY2Ugb2YgdGhlIGZyb20gYWNjb3VudFxuICAgICAqL1xuICAgIHN0YXRpYyBnZW5lcmF0ZShmcm9tLCBub25jZSkge1xuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoZXh0ZXJuYWxzXzEuQk4uaXNCTihub25jZSkpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoKDAsIGFjY291bnRfMS5nZW5lcmF0ZUFkZHJlc3MpKGZyb20uYnVmLCBub25jZS50b0FycmF5TGlrZShCdWZmZXIpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIGZvciBhIGNvbnRyYWN0IGNyZWF0ZWQgdXNpbmcgQ1JFQVRFMi5cbiAgICAgKiBAcGFyYW0gZnJvbSBUaGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gICAgICogQHBhcmFtIHNhbHQgQSBzYWx0XG4gICAgICogQHBhcmFtIGluaXRDb2RlIFRoZSBpbml0IGNvZGUgb2YgdGhlIGNvbnRyYWN0IGJlaW5nIGNyZWF0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2VuZXJhdGUyKGZyb20sIHNhbHQsIGluaXRDb2RlKSB7XG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShCdWZmZXIuaXNCdWZmZXIoc2FsdCkpO1xuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoQnVmZmVyLmlzQnVmZmVyKGluaXRDb2RlKSk7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcygoMCwgYWNjb3VudF8xLmdlbmVyYXRlQWRkcmVzczIpKGZyb20uYnVmLCBzYWx0LCBpbml0Q29kZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyBhZGRyZXNzIGVxdWFsIHRvIGFub3RoZXIuXG4gICAgICovXG4gICAgZXF1YWxzKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLmVxdWFscyhhZGRyZXNzLmJ1Zik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIGFkZHJlc3MgemVyby5cbiAgICAgKi9cbiAgICBpc1plcm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhBZGRyZXNzLnplcm8oKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgYWRkcmVzcyBpcyBpbiB0aGUgYWRkcmVzcyByYW5nZSBkZWZpbmVkXG4gICAgICogYnkgRUlQLTEzNTJcbiAgICAgKi9cbiAgICBpc1ByZWNvbXBpbGVPclN5c3RlbUFkZHJlc3MoKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NCTiA9IG5ldyBleHRlcm5hbHNfMS5CTih0aGlzLmJ1Zik7XG4gICAgICAgIGNvbnN0IHJhbmdlTWluID0gbmV3IGV4dGVybmFsc18xLkJOKDApO1xuICAgICAgICBjb25zdCByYW5nZU1heCA9IG5ldyBleHRlcm5hbHNfMS5CTignZmZmZicsICdoZXgnKTtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3NCTi5ndGUocmFuZ2VNaW4pICYmIGFkZHJlc3NCTi5sdGUocmFuZ2VNYXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhleCBlbmNvZGluZyBvZiBhZGRyZXNzLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJzB4JyArIHRoaXMuYnVmLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBCdWZmZXIgcmVwcmVzZW50YXRpb24gb2YgYWRkcmVzcy5cbiAgICAgKi9cbiAgICB0b0J1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuYnVmKTtcbiAgICB9XG59XG5leHBvcnRzLkFkZHJlc3MgPSBBZGRyZXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQWRkcmVzcyIsImFzc2VydF8xIiwicmVxdWlyZSIsImV4dGVybmFsc18xIiwiYnl0ZXNfMSIsImFjY291bnRfMSIsImNvbnN0cnVjdG9yIiwiYnVmIiwiZGVmYXVsdCIsImxlbmd0aCIsInplcm8iLCJ6ZXJvcyIsImZyb21TdHJpbmciLCJzdHIiLCJpc1ZhbGlkQWRkcmVzcyIsInRvQnVmZmVyIiwiZnJvbVB1YmxpY0tleSIsInB1YktleSIsIkJ1ZmZlciIsImlzQnVmZmVyIiwicHViVG9BZGRyZXNzIiwiZnJvbVByaXZhdGVLZXkiLCJwcml2YXRlS2V5IiwicHJpdmF0ZVRvQWRkcmVzcyIsImdlbmVyYXRlIiwiZnJvbSIsIm5vbmNlIiwiQk4iLCJpc0JOIiwiZ2VuZXJhdGVBZGRyZXNzIiwidG9BcnJheUxpa2UiLCJnZW5lcmF0ZTIiLCJzYWx0IiwiaW5pdENvZGUiLCJnZW5lcmF0ZUFkZHJlc3MyIiwiZXF1YWxzIiwiYWRkcmVzcyIsImlzWmVybyIsImlzUHJlY29tcGlsZU9yU3lzdGVtQWRkcmVzcyIsImFkZHJlc3NCTiIsInJhbmdlTWluIiwicmFuZ2VNYXgiLCJndGUiLCJsdGUiLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/bytes.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/bytes.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/externals.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/internal.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/helpers.js\");\n/**\n * Converts a `Number` into a hex `String`\n * @param {Number} i\n * @return {String}\n */ const intToHex = function(i) {\n    if (!Number.isSafeInteger(i) || i < 0) {\n        throw new Error(`Received an invalid integer type: ${i}`);\n    }\n    return `0x${i.toString(16)}`;\n};\nexports.intToHex = intToHex;\n/**\n * Converts an `Number` to a `Buffer`\n * @param {Number} i\n * @return {Buffer}\n */ const intToBuffer = function(i) {\n    const hex = (0, exports.intToHex)(i);\n    return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), \"hex\");\n};\nexports.intToBuffer = intToBuffer;\n/**\n * Returns a buffer filled with 0s.\n * @param bytes the number of bytes the buffer should be\n */ const zeros = function(bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\nexports.zeros = zeros;\n/**\n * Pads a `Buffer` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @param right whether to start padding form the left or right\n * @return (Buffer)\n */ const setLength = function(msg, length, right) {\n    const buf = (0, exports.zeros)(length);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    } else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n};\n/**\n * Left Pads a `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */ const setLengthLeft = function(msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, false);\n};\nexports.setLengthLeft = setLengthLeft;\n/**\n * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */ const setLengthRight = function(msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, true);\n};\nexports.setLengthRight = setLengthRight;\n/**\n * Trims leading zeros from a `Buffer`, `String` or `Number[]`.\n * @param a (Buffer|Array|String)\n * @return (Buffer|Array|String)\n */ const stripZeros = function(a) {\n    let first = a[0];\n    while(a.length > 0 && first.toString() === \"0\"){\n        a = a.slice(1);\n        first = a[0];\n    }\n    return a;\n};\n/**\n * Trims leading zeros from a `Buffer`.\n * @param a (Buffer)\n * @return (Buffer)\n */ const unpadBuffer = function(a) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return stripZeros(a);\n};\nexports.unpadBuffer = unpadBuffer;\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param a (number[])\n * @return (number[])\n */ const unpadArray = function(a) {\n    (0, helpers_1.assertIsArray)(a);\n    return stripZeros(a);\n};\nexports.unpadArray = unpadArray;\n/**\n * Trims leading zeros from a hex-prefixed `String`.\n * @param a (String)\n * @return (String)\n */ const unpadHexString = function(a) {\n    (0, helpers_1.assertIsHexString)(a);\n    a = (0, internal_1.stripHexPrefix)(a);\n    return stripZeros(a);\n};\nexports.unpadHexString = unpadHexString;\n/**\n * Attempts to turn a value into a `Buffer`.\n * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BN` and other objects\n * with a `toArray()` or `toBuffer()` method.\n * @param v the value\n */ const toBuffer = function(v) {\n    if (v === null || v === undefined) {\n        return Buffer.allocUnsafe(0);\n    }\n    if (Buffer.isBuffer(v)) {\n        return Buffer.from(v);\n    }\n    if (Array.isArray(v) || v instanceof Uint8Array) {\n        return Buffer.from(v);\n    }\n    if (typeof v === \"string\") {\n        if (!(0, internal_1.isHexString)(v)) {\n            throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);\n        }\n        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), \"hex\");\n    }\n    if (typeof v === \"number\") {\n        return (0, exports.intToBuffer)(v);\n    }\n    if (externals_1.BN.isBN(v)) {\n        if (v.isNeg()) {\n            throw new Error(`Cannot convert negative BN to buffer. Given: ${v}`);\n        }\n        return v.toArrayLike(Buffer);\n    }\n    if (v.toArray) {\n        // converts a BN to a Buffer\n        return Buffer.from(v.toArray());\n    }\n    if (v.toBuffer) {\n        return Buffer.from(v.toBuffer());\n    }\n    throw new Error(\"invalid type\");\n};\nexports.toBuffer = toBuffer;\n/**\n * Converts a `Buffer` to a `Number`.\n * @param buf `Buffer` object to convert\n * @throws If the input number exceeds 53 bits.\n */ const bufferToInt = function(buf) {\n    return new externals_1.BN((0, exports.toBuffer)(buf)).toNumber();\n};\nexports.bufferToInt = bufferToInt;\n/**\n * Converts a `Buffer` into a `0x`-prefixed hex `String`.\n * @param buf `Buffer` object to convert\n */ const bufferToHex = function(buf) {\n    buf = (0, exports.toBuffer)(buf);\n    return \"0x\" + buf.toString(\"hex\");\n};\nexports.bufferToHex = bufferToHex;\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.\n * @param num Signed integer value\n */ const fromSigned = function(num) {\n    return new externals_1.BN(num).fromTwos(256);\n};\nexports.fromSigned = fromSigned;\n/**\n * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param num\n */ const toUnsigned = function(num) {\n    return Buffer.from(num.toTwos(256).toArray());\n};\nexports.toUnsigned = toUnsigned;\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\n */ const addHexPrefix = function(str) {\n    if (typeof str !== \"string\") {\n        return str;\n    }\n    return (0, internal_1.isHexPrefixed)(str) ? str : \"0x\" + str;\n};\nexports.addHexPrefix = addHexPrefix;\n/**\n * Returns the utf8 string representation from a hex string.\n *\n * Examples:\n *\n * Input 1: '657468657265756d000000000000000000000000000000000000000000000000'\n * Input 2: '657468657265756d'\n * Input 3: '000000000000000000000000000000000000000000000000657468657265756d'\n *\n * Output (all 3 input variants): 'ethereum'\n *\n * Note that this method is not intended to be used with hex strings\n * representing quantities in both big endian or little endian notation.\n *\n * @param string Hex string, should be `0x` prefixed\n * @return Utf8 string\n */ const toUtf8 = function(hex) {\n    const zerosRegexp = /^(00)+|(00)+$/g;\n    hex = (0, internal_1.stripHexPrefix)(hex);\n    if (hex.length % 2 !== 0) {\n        throw new Error(\"Invalid non-even hex string input for toUtf8() provided\");\n    }\n    const bufferVal = Buffer.from(hex.replace(zerosRegexp, \"\"), \"hex\");\n    return bufferVal.toString(\"utf8\");\n};\nexports.toUtf8 = toUtf8;\n/**\n * Converts a `Buffer` or `Array` to JSON.\n * @param ba (Buffer|Array)\n * @return (Array|String|null)\n */ const baToJSON = function(ba) {\n    if (Buffer.isBuffer(ba)) {\n        return `0x${ba.toString(\"hex\")}`;\n    } else if (ba instanceof Array) {\n        const array = [];\n        for(let i = 0; i < ba.length; i++){\n            array.push((0, exports.baToJSON)(ba[i]));\n        }\n        return array;\n    }\n};\nexports.baToJSON = baToJSON;\n/**\n * Checks provided Buffers for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Buffer values\n * @throws if any provided value is found to have leading zero bytes\n */ const validateNoLeadingZeroes = function(values) {\n    for (const [k, v] of Object.entries(values)){\n        if (v !== undefined && v.length > 0 && v[0] === 0) {\n            throw new Error(`${k} cannot have leading zeroes, received: ${v.toString(\"hex\")}`);\n        }\n    }\n};\nexports.validateNoLeadingZeroes = validateNoLeadingZeroes;\nfunction arrToBufArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Buffer.from(arr);\n    }\n    return arr.map((a)=>arrToBufArr(a));\n}\nexports.arrToBufArr = arrToBufArr;\nfunction bufArrToArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Uint8Array.from(arr !== null && arr !== void 0 ? arr : []);\n    }\n    return arr.map((a)=>bufArrToArr(a));\n}\nexports.bufArrToArr = bufArrToArr; //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW1qcy11dGlsQDcuMS41L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9ieXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLG1CQUFtQixHQUFHQSwrQkFBK0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGNBQWMsR0FBR0Esb0JBQW9CLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLG1CQUFtQixHQUFHQSxnQkFBZ0IsR0FBR0Esc0JBQXNCLEdBQUdBLGtCQUFrQixHQUFHQSxtQkFBbUIsR0FBR0Esc0JBQXNCLEdBQUdBLHFCQUFxQixHQUFHQSxhQUFhLEdBQUdBLG1CQUFtQixHQUFHQSxnQkFBZ0IsR0FBRyxLQUFLO0FBQ3JhLE1BQU1xQixjQUFjQyxtQkFBT0EsQ0FBQyxvSEFBYTtBQUN6QyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxrSEFBWTtBQUN2QyxNQUFNRSxZQUFZRixtQkFBT0EsQ0FBQyxnSEFBVztBQUNyQzs7OztDQUlDLEdBQ0QsTUFBTUYsV0FBVyxTQUFVSyxDQUFDO0lBQ3hCLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixNQUFNQSxJQUFJLEdBQUc7UUFDbkMsTUFBTSxJQUFJRyxNQUFNLENBQUMsa0NBQWtDLEVBQUVILEVBQUUsQ0FBQztJQUM1RDtJQUNBLE9BQU8sQ0FBQyxFQUFFLEVBQUVBLEVBQUVJLFFBQVEsQ0FBQyxJQUFJLENBQUM7QUFDaEM7QUFDQTdCLGdCQUFnQixHQUFHb0I7QUFDbkI7Ozs7Q0FJQyxHQUNELE1BQU1ELGNBQWMsU0FBVU0sQ0FBQztJQUMzQixNQUFNSyxNQUFNLENBQUMsR0FBRzlCLFFBQVFvQixRQUFRLEVBQUVLO0lBQ2xDLE9BQU9NLE9BQU9DLElBQUksQ0FBQyxDQUFDLEdBQUdULFdBQVdVLFNBQVMsRUFB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bW9kdWxlcy8ucG5wbS9ldGhlcmV1bWpzLXV0aWxANy4xLjUvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2J5dGVzLmpzPzg5NWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ1ZkFyclRvQXJyID0gZXhwb3J0cy5hcnJUb0J1ZkFyciA9IGV4cG9ydHMudmFsaWRhdGVOb0xlYWRpbmdaZXJvZXMgPSBleHBvcnRzLmJhVG9KU09OID0gZXhwb3J0cy50b1V0ZjggPSBleHBvcnRzLmFkZEhleFByZWZpeCA9IGV4cG9ydHMudG9VbnNpZ25lZCA9IGV4cG9ydHMuZnJvbVNpZ25lZCA9IGV4cG9ydHMuYnVmZmVyVG9IZXggPSBleHBvcnRzLmJ1ZmZlclRvSW50ID0gZXhwb3J0cy50b0J1ZmZlciA9IGV4cG9ydHMudW5wYWRIZXhTdHJpbmcgPSBleHBvcnRzLnVucGFkQXJyYXkgPSBleHBvcnRzLnVucGFkQnVmZmVyID0gZXhwb3J0cy5zZXRMZW5ndGhSaWdodCA9IGV4cG9ydHMuc2V0TGVuZ3RoTGVmdCA9IGV4cG9ydHMuemVyb3MgPSBleHBvcnRzLmludFRvQnVmZmVyID0gZXhwb3J0cy5pbnRUb0hleCA9IHZvaWQgMDtcbmNvbnN0IGV4dGVybmFsc18xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxzXCIpO1xuY29uc3QgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xuY29uc3QgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbi8qKlxuICogQ29udmVydHMgYSBgTnVtYmVyYCBpbnRvIGEgaGV4IGBTdHJpbmdgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5jb25zdCBpbnRUb0hleCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpKSB8fCBpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkIGFuIGludmFsaWQgaW50ZWdlciB0eXBlOiAke2l9YCk7XG4gICAgfVxuICAgIHJldHVybiBgMHgke2kudG9TdHJpbmcoMTYpfWA7XG59O1xuZXhwb3J0cy5pbnRUb0hleCA9IGludFRvSGV4O1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBgTnVtYmVyYCB0byBhIGBCdWZmZXJgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5jb25zdCBpbnRUb0J1ZmZlciA9IGZ1bmN0aW9uIChpKSB7XG4gICAgY29uc3QgaGV4ID0gKDAsIGV4cG9ydHMuaW50VG9IZXgpKGkpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgaW50ZXJuYWxfMS5wYWRUb0V2ZW4pKGhleC5zbGljZSgyKSksICdoZXgnKTtcbn07XG5leHBvcnRzLmludFRvQnVmZmVyID0gaW50VG9CdWZmZXI7XG4vKipcbiAqIFJldHVybnMgYSBidWZmZXIgZmlsbGVkIHdpdGggMHMuXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgYnVmZmVyIHNob3VsZCBiZVxuICovXG5jb25zdCB6ZXJvcyA9IGZ1bmN0aW9uIChieXRlcykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZXMpLmZpbGwoMCk7XG59O1xuZXhwb3J0cy56ZXJvcyA9IHplcm9zO1xuLyoqXG4gKiBQYWRzIGEgYEJ1ZmZlcmAgd2l0aCB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIFRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIG9yIGVuZCBvZiBpbnB1dCBpZiBpdHMgbGVuZ3RoIGV4Y2VlZHMgYGxlbmd0aGAuXG4gKiBAcGFyYW0gbXNnIHRoZSB2YWx1ZSB0byBwYWQgKEJ1ZmZlcilcbiAqIEBwYXJhbSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHBhcmFtIHJpZ2h0IHdoZXRoZXIgdG8gc3RhcnQgcGFkZGluZyBmb3JtIHRoZSBsZWZ0IG9yIHJpZ2h0XG4gKiBAcmV0dXJuIChCdWZmZXIpXG4gKi9cbmNvbnN0IHNldExlbmd0aCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCwgcmlnaHQpIHtcbiAgICBjb25zdCBidWYgPSAoMCwgZXhwb3J0cy56ZXJvcykobGVuZ3RoKTtcbiAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIG1zZy5jb3B5KGJ1Zik7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtc2cuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBtc2cuY29weShidWYsIGxlbmd0aCAtIG1zZy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXNnLnNsaWNlKC1sZW5ndGgpO1xuICAgIH1cbn07XG4vKipcbiAqIExlZnQgUGFkcyBhIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAcGFyYW0gbXNnIHRoZSB2YWx1ZSB0byBwYWQgKEJ1ZmZlcilcbiAqIEBwYXJhbSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHJldHVybiAoQnVmZmVyKVxuICovXG5jb25zdCBzZXRMZW5ndGhMZWZ0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikobXNnKTtcbiAgICByZXR1cm4gc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCBmYWxzZSk7XG59O1xuZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gc2V0TGVuZ3RoTGVmdDtcbi8qKlxuICogUmlnaHQgUGFkcyBhIGBCdWZmZXJgIHdpdGggdHJhaWxpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBpdCB0cnVuY2F0ZXMgdGhlIGVuZCBpZiBpdCBleGNlZWRzLlxuICogQHBhcmFtIG1zZyB0aGUgdmFsdWUgdG8gcGFkIChCdWZmZXIpXG4gKiBAcGFyYW0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEByZXR1cm4gKEJ1ZmZlcilcbiAqL1xuY29uc3Qgc2V0TGVuZ3RoUmlnaHQgPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShtc2cpO1xuICAgIHJldHVybiBzZXRMZW5ndGgobXNnLCBsZW5ndGgsIHRydWUpO1xufTtcbmV4cG9ydHMuc2V0TGVuZ3RoUmlnaHQgPSBzZXRMZW5ndGhSaWdodDtcbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEgYEJ1ZmZlcmAsIGBTdHJpbmdgIG9yIGBOdW1iZXJbXWAuXG4gKiBAcGFyYW0gYSAoQnVmZmVyfEFycmF5fFN0cmluZylcbiAqIEByZXR1cm4gKEJ1ZmZlcnxBcnJheXxTdHJpbmcpXG4gKi9cbmNvbnN0IHN0cmlwWmVyb3MgPSBmdW5jdGlvbiAoYSkge1xuICAgIGxldCBmaXJzdCA9IGFbMF07XG4gICAgd2hpbGUgKGEubGVuZ3RoID4gMCAmJiBmaXJzdC50b1N0cmluZygpID09PSAnMCcpIHtcbiAgICAgICAgYSA9IGEuc2xpY2UoMSk7XG4gICAgICAgIGZpcnN0ID0gYVswXTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSBgQnVmZmVyYC5cbiAqIEBwYXJhbSBhIChCdWZmZXIpXG4gKiBAcmV0dXJuIChCdWZmZXIpXG4gKi9cbmNvbnN0IHVucGFkQnVmZmVyID0gZnVuY3Rpb24gKGEpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShhKTtcbiAgICByZXR1cm4gc3RyaXBaZXJvcyhhKTtcbn07XG5leHBvcnRzLnVucGFkQnVmZmVyID0gdW5wYWRCdWZmZXI7XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhbiBgQXJyYXlgIChvZiBudW1iZXJzKS5cbiAqIEBwYXJhbSBhIChudW1iZXJbXSlcbiAqIEByZXR1cm4gKG51bWJlcltdKVxuICovXG5jb25zdCB1bnBhZEFycmF5ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQXJyYXkpKGEpO1xuICAgIHJldHVybiBzdHJpcFplcm9zKGEpO1xufTtcbmV4cG9ydHMudW5wYWRBcnJheSA9IHVucGFkQXJyYXk7XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGhleC1wcmVmaXhlZCBgU3RyaW5nYC5cbiAqIEBwYXJhbSBhIChTdHJpbmcpXG4gKiBAcmV0dXJuIChTdHJpbmcpXG4gKi9cbmNvbnN0IHVucGFkSGV4U3RyaW5nID0gZnVuY3Rpb24gKGEpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzSGV4U3RyaW5nKShhKTtcbiAgICBhID0gKDAsIGludGVybmFsXzEuc3RyaXBIZXhQcmVmaXgpKGEpO1xuICAgIHJldHVybiBzdHJpcFplcm9zKGEpO1xufTtcbmV4cG9ydHMudW5wYWRIZXhTdHJpbmcgPSB1bnBhZEhleFN0cmluZztcbi8qKlxuICogQXR0ZW1wdHMgdG8gdHVybiBhIHZhbHVlIGludG8gYSBgQnVmZmVyYC5cbiAqIElucHV0cyBzdXBwb3J0ZWQ6IGBCdWZmZXJgLCBgU3RyaW5nYCAoaGV4LXByZWZpeGVkKSwgYE51bWJlcmAsIG51bGwvdW5kZWZpbmVkLCBgQk5gIGFuZCBvdGhlciBvYmplY3RzXG4gKiB3aXRoIGEgYHRvQXJyYXkoKWAgb3IgYHRvQnVmZmVyKClgIG1ldGhvZC5cbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZVxuICovXG5jb25zdCB0b0J1ZmZlciA9IGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSB8fCB2IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCEoMCwgaW50ZXJuYWxfMS5pc0hleFN0cmluZykodikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlci4gdG9CdWZmZXIgb25seSBzdXBwb3J0cyAweC1wcmVmaXhlZCBoZXggc3RyaW5ncyBhbmQgdGhpcyBzdHJpbmcgd2FzIGdpdmVuOiAke3Z9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBpbnRlcm5hbF8xLnBhZFRvRXZlbikoKDAsIGludGVybmFsXzEuc3RyaXBIZXhQcmVmaXgpKHYpKSwgJ2hleCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5pbnRUb0J1ZmZlcikodik7XG4gICAgfVxuICAgIGlmIChleHRlcm5hbHNfMS5CTi5pc0JOKHYpKSB7XG4gICAgICAgIGlmICh2LmlzTmVnKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbnZlcnQgbmVnYXRpdmUgQk4gdG8gYnVmZmVyLiBHaXZlbjogJHt2fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2LnRvQXJyYXlMaWtlKEJ1ZmZlcik7XG4gICAgfVxuICAgIGlmICh2LnRvQXJyYXkpIHtcbiAgICAgICAgLy8gY29udmVydHMgYSBCTiB0byBhIEJ1ZmZlclxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odi50b0FycmF5KCkpO1xuICAgIH1cbiAgICBpZiAodi50b0J1ZmZlcikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odi50b0J1ZmZlcigpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcbn07XG5leHBvcnRzLnRvQnVmZmVyID0gdG9CdWZmZXI7XG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgdG8gYSBgTnVtYmVyYC5cbiAqIEBwYXJhbSBidWYgYEJ1ZmZlcmAgb2JqZWN0IHRvIGNvbnZlcnRcbiAqIEB0aHJvd3MgSWYgdGhlIGlucHV0IG51bWJlciBleGNlZWRzIDUzIGJpdHMuXG4gKi9cbmNvbnN0IGJ1ZmZlclRvSW50ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHJldHVybiBuZXcgZXh0ZXJuYWxzXzEuQk4oKDAsIGV4cG9ydHMudG9CdWZmZXIpKGJ1ZikpLnRvTnVtYmVyKCk7XG59O1xuZXhwb3J0cy5idWZmZXJUb0ludCA9IGJ1ZmZlclRvSW50O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIGludG8gYSBgMHhgLXByZWZpeGVkIGhleCBgU3RyaW5nYC5cbiAqIEBwYXJhbSBidWYgYEJ1ZmZlcmAgb2JqZWN0IHRvIGNvbnZlcnRcbiAqL1xuY29uc3QgYnVmZmVyVG9IZXggPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgYnVmID0gKDAsIGV4cG9ydHMudG9CdWZmZXIpKGJ1Zik7XG4gICAgcmV0dXJuICcweCcgKyBidWYudG9TdHJpbmcoJ2hleCcpO1xufTtcbmV4cG9ydHMuYnVmZmVyVG9IZXggPSBidWZmZXJUb0hleDtcbi8qKlxuICogSW50ZXJwcmV0cyBhIGBCdWZmZXJgIGFzIGEgc2lnbmVkIGludGVnZXIgYW5kIHJldHVybnMgYSBgQk5gLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSBudW0gU2lnbmVkIGludGVnZXIgdmFsdWVcbiAqL1xuY29uc3QgZnJvbVNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gbmV3IGV4dGVybmFsc18xLkJOKG51bSkuZnJvbVR3b3MoMjU2KTtcbn07XG5leHBvcnRzLmZyb21TaWduZWQgPSBmcm9tU2lnbmVkO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCTmAgdG8gYW4gdW5zaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBpdCBhcyBhIGBCdWZmZXJgLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSBudW1cbiAqL1xuY29uc3QgdG9VbnNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20obnVtLnRvVHdvcygyNTYpLnRvQXJyYXkoKSk7XG59O1xuZXhwb3J0cy50b1Vuc2lnbmVkID0gdG9VbnNpZ25lZDtcbi8qKlxuICogQWRkcyBcIjB4XCIgdG8gYSBnaXZlbiBgU3RyaW5nYCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IHN0YXJ0IHdpdGggXCIweFwiLlxuICovXG5jb25zdCBhZGRIZXhQcmVmaXggPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW50ZXJuYWxfMS5pc0hleFByZWZpeGVkKShzdHIpID8gc3RyIDogJzB4JyArIHN0cjtcbn07XG5leHBvcnRzLmFkZEhleFByZWZpeCA9IGFkZEhleFByZWZpeDtcbi8qKlxuICogUmV0dXJucyB0aGUgdXRmOCBzdHJpbmcgcmVwcmVzZW50YXRpb24gZnJvbSBhIGhleCBzdHJpbmcuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogSW5wdXQgMTogJzY1NzQ2ODY1NzI2NTc1NmQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gKiBJbnB1dCAyOiAnNjU3NDY4NjU3MjY1NzU2ZCdcbiAqIElucHV0IDM6ICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2NTc0Njg2NTcyNjU3NTZkJ1xuICpcbiAqIE91dHB1dCAoYWxsIDMgaW5wdXQgdmFyaWFudHMpOiAnZXRoZXJldW0nXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIG5vdCBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGggaGV4IHN0cmluZ3NcbiAqIHJlcHJlc2VudGluZyBxdWFudGl0aWVzIGluIGJvdGggYmlnIGVuZGlhbiBvciBsaXR0bGUgZW5kaWFuIG5vdGF0aW9uLlxuICpcbiAqIEBwYXJhbSBzdHJpbmcgSGV4IHN0cmluZywgc2hvdWxkIGJlIGAweGAgcHJlZml4ZWRcbiAqIEByZXR1cm4gVXRmOCBzdHJpbmdcbiAqL1xuY29uc3QgdG9VdGY4ID0gZnVuY3Rpb24gKGhleCkge1xuICAgIGNvbnN0IHplcm9zUmVnZXhwID0gL14oMDApK3woMDApKyQvZztcbiAgICBoZXggPSAoMCwgaW50ZXJuYWxfMS5zdHJpcEhleFByZWZpeCkoaGV4KTtcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5vbi1ldmVuIGhleCBzdHJpbmcgaW5wdXQgZm9yIHRvVXRmOCgpIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlclZhbCA9IEJ1ZmZlci5mcm9tKGhleC5yZXBsYWNlKHplcm9zUmVnZXhwLCAnJyksICdoZXgnKTtcbiAgICByZXR1cm4gYnVmZmVyVmFsLnRvU3RyaW5nKCd1dGY4Jyk7XG59O1xuZXhwb3J0cy50b1V0ZjggPSB0b1V0Zjg7XG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgb3IgYEFycmF5YCB0byBKU09OLlxuICogQHBhcmFtIGJhIChCdWZmZXJ8QXJyYXkpXG4gKiBAcmV0dXJuIChBcnJheXxTdHJpbmd8bnVsbClcbiAqL1xuY29uc3QgYmFUb0pTT04gPSBmdW5jdGlvbiAoYmEpIHtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJhKSkge1xuICAgICAgICByZXR1cm4gYDB4JHtiYS50b1N0cmluZygnaGV4Jyl9YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBjb25zdCBhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheS5wdXNoKCgwLCBleHBvcnRzLmJhVG9KU09OKShiYVtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG59O1xuZXhwb3J0cy5iYVRvSlNPTiA9IGJhVG9KU09OO1xuLyoqXG4gKiBDaGVja3MgcHJvdmlkZWQgQnVmZmVycyBmb3IgbGVhZGluZyB6ZXJvZXMgYW5kIHRocm93cyBpZiBmb3VuZC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiBWYWxpZCB2YWx1ZXM6IDB4MSwgMHgsIDB4MDEsIDB4MTIzNFxuICogSW52YWxpZCB2YWx1ZXM6IDB4MCwgMHgwMCwgMHgwMDEsIDB4MDAwMVxuICpcbiAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBmb3IgdmFsaWRhdGluZyB0aGF0IFJMUCBlbmNvZGVkIGludGVnZXJzIGNvbXBseSB3aXRoIHRoZSBydWxlIHRoYXQgYWxsXG4gKiBpbnRlZ2VyIHZhbHVlcyBlbmNvZGVkIHRvIFJMUCBtdXN0IGJlIGluIHRoZSBtb3N0IGNvbXBhY3QgZm9ybSBhbmQgY29udGFpbiBubyBsZWFkaW5nIHplcm8gYnl0ZXNcbiAqIEBwYXJhbSB2YWx1ZXMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgc3RyaW5nIGtleXMgYW5kIEJ1ZmZlciB2YWx1ZXNcbiAqIEB0aHJvd3MgaWYgYW55IHByb3ZpZGVkIHZhbHVlIGlzIGZvdW5kIHRvIGhhdmUgbGVhZGluZyB6ZXJvIGJ5dGVzXG4gKi9cbmNvbnN0IHZhbGlkYXRlTm9MZWFkaW5nWmVyb2VzID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlcykpIHtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCAmJiB2Lmxlbmd0aCA+IDAgJiYgdlswXSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2t9IGNhbm5vdCBoYXZlIGxlYWRpbmcgemVyb2VzLCByZWNlaXZlZDogJHt2LnRvU3RyaW5nKCdoZXgnKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLnZhbGlkYXRlTm9MZWFkaW5nWmVyb2VzID0gdmFsaWRhdGVOb0xlYWRpbmdaZXJvZXM7XG5mdW5jdGlvbiBhcnJUb0J1ZkFycihhcnIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyci5tYXAoKGEpID0+IGFyclRvQnVmQXJyKGEpKTtcbn1cbmV4cG9ydHMuYXJyVG9CdWZBcnIgPSBhcnJUb0J1ZkFycjtcbmZ1bmN0aW9uIGJ1ZkFyclRvQXJyKGFycikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYXJyICE9PSBudWxsICYmIGFyciAhPT0gdm9pZCAwID8gYXJyIDogW10pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyLm1hcCgoYSkgPT4gYnVmQXJyVG9BcnIoYSkpO1xufVxuZXhwb3J0cy5idWZBcnJUb0FyciA9IGJ1ZkFyclRvQXJyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYnVmQXJyVG9BcnIiLCJhcnJUb0J1ZkFyciIsInZhbGlkYXRlTm9MZWFkaW5nWmVyb2VzIiwiYmFUb0pTT04iLCJ0b1V0ZjgiLCJhZGRIZXhQcmVmaXgiLCJ0b1Vuc2lnbmVkIiwiZnJvbVNpZ25lZCIsImJ1ZmZlclRvSGV4IiwiYnVmZmVyVG9JbnQiLCJ0b0J1ZmZlciIsInVucGFkSGV4U3RyaW5nIiwidW5wYWRBcnJheSIsInVucGFkQnVmZmVyIiwic2V0TGVuZ3RoUmlnaHQiLCJzZXRMZW5ndGhMZWZ0IiwiemVyb3MiLCJpbnRUb0J1ZmZlciIsImludFRvSGV4IiwiZXh0ZXJuYWxzXzEiLCJyZXF1aXJlIiwiaW50ZXJuYWxfMSIsImhlbHBlcnNfMSIsImkiLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiRXJyb3IiLCJ0b1N0cmluZyIsImhleCIsIkJ1ZmZlciIsImZyb20iLCJwYWRUb0V2ZW4iLCJzbGljZSIsImJ5dGVzIiwiYWxsb2NVbnNhZmUiLCJmaWxsIiwic2V0TGVuZ3RoIiwibXNnIiwibGVuZ3RoIiwicmlnaHQiLCJidWYiLCJjb3B5IiwiYXNzZXJ0SXNCdWZmZXIiLCJzdHJpcFplcm9zIiwiYSIsImZpcnN0IiwiYXNzZXJ0SXNBcnJheSIsImFzc2VydElzSGV4U3RyaW5nIiwic3RyaXBIZXhQcmVmaXgiLCJ2IiwidW5kZWZpbmVkIiwiaXNCdWZmZXIiLCJBcnJheSIsImlzQXJyYXkiLCJVaW50OEFycmF5IiwiaXNIZXhTdHJpbmciLCJCTiIsImlzQk4iLCJpc05lZyIsInRvQXJyYXlMaWtlIiwidG9BcnJheSIsInRvTnVtYmVyIiwibnVtIiwiZnJvbVR3b3MiLCJ0b1R3b3MiLCJzdHIiLCJpc0hleFByZWZpeGVkIiwiemVyb3NSZWdleHAiLCJidWZmZXJWYWwiLCJyZXBsYWNlIiwiYmEiLCJhcnJheSIsInB1c2giLCJ2YWx1ZXMiLCJrIiwiZW50cmllcyIsImFyciIsIm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/constants.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/constants.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/externals.js\");\n/**\n * 2^64-1\n */ exports.MAX_UINT64 = new externals_1.BN(\"ffffffffffffffff\", 16);\n/**\n * The max integer that the evm can handle (2^256-1)\n */ exports.MAX_INTEGER = new externals_1.BN(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\", 16);\n/**\n * 2^256\n */ exports.TWO_POW256 = new externals_1.BN(\"10000000000000000000000000000000000000000000000000000000000000000\", 16);\n/**\n * Keccak-256 hash of null\n */ exports.KECCAK256_NULL_S = \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\";\n/**\n * Keccak-256 hash of null\n */ exports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, \"hex\");\n/**\n * Keccak-256 of an RLP of an empty array\n */ exports.KECCAK256_RLP_ARRAY_S = \"1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\";\n/**\n * Keccak-256 of an RLP of an empty array\n */ exports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, \"hex\");\n/**\n * Keccak-256 hash of the RLP of null\n */ exports.KECCAK256_RLP_S = \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\";\n/**\n * Keccak-256 hash of the RLP of null\n */ exports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, \"hex\"); //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW1qcy11dGlsQDcuMS41L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHQSx1QkFBdUIsR0FBR0EsMkJBQTJCLEdBQUdBLDZCQUE2QixHQUFHQSxzQkFBc0IsR0FBR0Esd0JBQXdCLEdBQUdBLGtCQUFrQixHQUFHQSxtQkFBbUIsR0FBR0Esa0JBQWtCLEdBQUcsS0FBSztBQUN6TyxNQUFNVyxXQUFXQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyxvSEFBYTtBQUN6Qzs7Q0FFQyxHQUNEWixrQkFBa0IsR0FBRyxJQUFJYSxZQUFZQyxFQUFFLENBQUMsb0JBQW9CO0FBQzVEOztDQUVDLEdBQ0RkLG1CQUFtQixHQUFHLElBQUlhLFlBQVlDLEVBQUUsQ0FBQyxvRUFBb0U7QUFDN0c7O0NBRUMsR0FDRGQsa0JBQWtCLEdBQUcsSUFBSWEsWUFBWUMsRUFBRSxDQUFDLHFFQUFxRTtBQUM3Rzs7Q0FFQyxHQUNEZCx3QkFBd0IsR0FBRztBQUMzQjs7Q0FFQyxHQUNEQSxzQkFBc0IsR0FBR1csU0FBU0ksTUFBTSxDQUFDQyxJQUFJLENBQUNoQixRQUFRTyxnQkFBZ0IsRUFBRTtBQUN4RTs7Q0FFQyxHQUNEUCw2QkFBNkIsR0FBRztBQUNoQzs7Q0FFQyxHQUNEQSwyQkFBMkIsR0FBR1csU0FBU0ksTUFBTSxDQUFDQyxJQUFJLENBQUNoQixRQUFRSyxxQkFBcUIsRUFBRTtBQUNsRjs7Q0FFQyxHQUNETCx1QkFBdUIsR0FBRztBQUMxQjs7Q0FFQyxHQUNEQSxxQkFBcUIsR0FBR1csU0FBU0ksTUFBTSxDQUFDQyxJQUFJLENBQUNoQixRQUFRRyxlQUFlLEVBQUUsUUFDdEUscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyZXVtanMtdXRpbEA3LjEuNS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvY29uc3RhbnRzLmpzPzIzNTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLktFQ0NBSzI1Nl9STFAgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWSA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TID0gZXhwb3J0cy5LRUNDQUsyNTZfTlVMTCA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUyA9IGV4cG9ydHMuVFdPX1BPVzI1NiA9IGV4cG9ydHMuTUFYX0lOVEVHRVIgPSBleHBvcnRzLk1BWF9VSU5UNjQgPSB2b2lkIDA7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG5jb25zdCBleHRlcm5hbHNfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsc1wiKTtcbi8qKlxuICogMl42NC0xXG4gKi9cbmV4cG9ydHMuTUFYX1VJTlQ2NCA9IG5ldyBleHRlcm5hbHNfMS5CTignZmZmZmZmZmZmZmZmZmZmZicsIDE2KTtcbi8qKlxuICogVGhlIG1heCBpbnRlZ2VyIHRoYXQgdGhlIGV2bSBjYW4gaGFuZGxlICgyXjI1Ni0xKVxuICovXG5leHBvcnRzLk1BWF9JTlRFR0VSID0gbmV3IGV4dGVybmFsc18xLkJOKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJywgMTYpO1xuLyoqXG4gKiAyXjI1NlxuICovXG5leHBvcnRzLlRXT19QT1cyNTYgPSBuZXcgZXh0ZXJuYWxzXzEuQk4oJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywgMTYpO1xuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MgPSAnYzVkMjQ2MDE4NmY3MjMzYzkyN2U3ZGIyZGNjNzAzYzBlNTAwYjY1M2NhODIyNzNiN2JmYWQ4MDQ1ZDg1YTQ3MCc7XG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiBudWxsXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTEwgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MsICdoZXgnKTtcbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXlcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MgPSAnMWRjYzRkZThkZWM3NWQ3YWFiODViNTY3YjZjY2Q0MWFkMzEyNDUxYjk0OGE3NDEzZjBhMTQyZmQ0MGQ0OTM0Nyc7XG4vKipcbiAqIEtlY2Nhay0yNTYgb2YgYW4gUkxQIG9mIGFuIGVtcHR5IGFycmF5XG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWSA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TLCAnaGV4Jyk7XG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgUkxQIG9mIG51bGxcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MgPSAnNTZlODFmMTcxYmNjNTVhNmZmODM0NWU2OTJjMGY4NmU1YjQ4ZTAxYjk5NmNhZGMwMDE2MjJmYjVlMzYzYjQyMSc7XG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgUkxQIG9mIG51bGxcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MsICdoZXgnKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJLRUNDQUsyNTZfUkxQIiwiS0VDQ0FLMjU2X1JMUF9TIiwiS0VDQ0FLMjU2X1JMUF9BUlJBWSIsIktFQ0NBSzI1Nl9STFBfQVJSQVlfUyIsIktFQ0NBSzI1Nl9OVUxMIiwiS0VDQ0FLMjU2X05VTExfUyIsIlRXT19QT1cyNTYiLCJNQVhfSU5URUdFUiIsIk1BWF9VSU5UNjQiLCJidWZmZXJfMSIsInJlcXVpcmUiLCJleHRlcm5hbHNfMSIsIkJOIiwiQnVmZmVyIiwiZnJvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/externals.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/externals.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Re-exports commonly used modules:\n * * Exports [`BN`](https://github.com/indutny/bn.js), [`rlp`](https://github.com/ethereumjs/rlp).\n * @packageDocumentation\n */ var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.rlp = exports.BN = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.0/node_modules/bn.js/lib/bn.js\"));\nexports.BN = bn_js_1.default;\nconst rlp = __importStar(__webpack_require__(/*! rlp */ \"(ssr)/./node_modules/.pnpm/rlp@2.2.7/node_modules/rlp/dist/index.js\"));\nexports.rlp = rlp; //# sourceMappingURL=externals.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW1qcy11dGlsQDcuMS41L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9leHRlcm5hbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7OztDQUlDLEdBQ0QsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcscUJBQXFCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsa0JBQWtCLElBQU1mLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVjLENBQUM7SUFDekZoQixPQUFPYyxjQUFjLENBQUNaLEdBQUcsV0FBVztRQUFFVSxZQUFZO1FBQU1LLE9BQU9EO0lBQUU7QUFDckUsSUFBSyxTQUFTZCxDQUFDLEVBQUVjLENBQUM7SUFDZGQsQ0FBQyxDQUFDLFVBQVUsR0FBR2M7QUFDbkI7QUFDQSxJQUFJRSxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVVDLEdBQUc7SUFDM0QsSUFBSUEsT0FBT0EsSUFBSVYsVUFBVSxFQUFFLE9BQU9VO0lBQ2xDLElBQUlDLFNBQVMsQ0FBQztJQUNkLElBQUlELE9BQU8sTUFBTTtRQUFBLElBQUssSUFBSWYsS0FBS2UsSUFBSyxJQUFJZixNQUFNLGFBQWFKLE9BQU9xQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixLQUFLZixJQUFJTCxnQkFBZ0JxQixRQUFRRCxLQUFLZjtJQUFFO0lBQ3hJVyxtQkFBbUJLLFFBQVFEO0lBQzNCLE9BQU9DO0FBQ1g7QUFDQSxJQUFJSSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQUssU0FBVUwsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlWLFVBQVUsR0FBSVUsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQW5CLDhDQUE2QztJQUFFaUIsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RFEsV0FBVyxHQUFHQSxVQUFVLEdBQUcsS0FBSztBQUNoQyxNQUFNRyxVQUFVSixnQkFBZ0JLLG1CQUFPQSxDQUFDLGtGQUFPO0FBQy9DSixVQUFVLEdBQUdHLFFBQVFFLE9BQU87QUFDNUIsTUFBTUosTUFBTVIsYUFBYVcsbUJBQU9BLENBQUMsZ0ZBQUs7QUFDdENKLFdBQVcsR0FBR0MsS0FDZCxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW1qcy11dGlsQDcuMS41L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9leHRlcm5hbHMuanM/ZTU1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogUmUtZXhwb3J0cyBjb21tb25seSB1c2VkIG1vZHVsZXM6XG4gKiAqIEV4cG9ydHMgW2BCTmBdKGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzKSwgW2BybHBgXShodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW1qcy9ybHApLlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ybHAgPSBleHBvcnRzLkJOID0gdm9pZCAwO1xuY29uc3QgYm5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm4uanNcIikpO1xuZXhwb3J0cy5CTiA9IGJuX2pzXzEuZGVmYXVsdDtcbmNvbnN0IHJscCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmxwXCIpKTtcbmV4cG9ydHMucmxwID0gcmxwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0ZXJuYWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJyZXN1bHQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfX2ltcG9ydERlZmF1bHQiLCJleHBvcnRzIiwicmxwIiwiQk4iLCJibl9qc18xIiwicmVxdWlyZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/externals.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/hash.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/hash.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.rlphash = exports.ripemd160FromArray = exports.ripemd160FromString = exports.ripemd160 = exports.sha256FromArray = exports.sha256FromString = exports.sha256 = exports.keccakFromArray = exports.keccakFromHexString = exports.keccakFromString = exports.keccak256 = exports.keccak = void 0;\nconst keccak_1 = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/./node_modules/.pnpm/ethereum-cryptography@0.1.3/node_modules/ethereum-cryptography/keccak.js\");\nconst createHash = __webpack_require__(/*! create-hash */ \"(ssr)/./node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/index.js\");\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/externals.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/bytes.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/helpers.js\");\n/**\n * Creates Keccak hash of a Buffer input\n * @param a The input data (Buffer)\n * @param bits (number = 256) The Keccak width\n */ const keccak = function(a, bits = 256) {\n    (0, helpers_1.assertIsBuffer)(a);\n    switch(bits){\n        case 224:\n            {\n                return (0, keccak_1.keccak224)(a);\n            }\n        case 256:\n            {\n                return (0, keccak_1.keccak256)(a);\n            }\n        case 384:\n            {\n                return (0, keccak_1.keccak384)(a);\n            }\n        case 512:\n            {\n                return (0, keccak_1.keccak512)(a);\n            }\n        default:\n            {\n                throw new Error(`Invald algorithm: keccak${bits}`);\n            }\n    }\n};\nexports.keccak = keccak;\n/**\n * Creates Keccak-256 hash of the input, alias for keccak(a, 256).\n * @param a The input data (Buffer)\n */ const keccak256 = function(a) {\n    return (0, exports.keccak)(a);\n};\nexports.keccak256 = keccak256;\n/**\n * Creates Keccak hash of a utf-8 string input\n * @param a The input data (String)\n * @param bits (number = 256) The Keccak width\n */ const keccakFromString = function(a, bits = 256) {\n    (0, helpers_1.assertIsString)(a);\n    const buf = Buffer.from(a, \"utf8\");\n    return (0, exports.keccak)(buf, bits);\n};\nexports.keccakFromString = keccakFromString;\n/**\n * Creates Keccak hash of an 0x-prefixed string input\n * @param a The input data (String)\n * @param bits (number = 256) The Keccak width\n */ const keccakFromHexString = function(a, bits = 256) {\n    (0, helpers_1.assertIsHexString)(a);\n    return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);\n};\nexports.keccakFromHexString = keccakFromHexString;\n/**\n * Creates Keccak hash of a number array input\n * @param a The input data (number[])\n * @param bits (number = 256) The Keccak width\n */ const keccakFromArray = function(a, bits = 256) {\n    (0, helpers_1.assertIsArray)(a);\n    return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);\n};\nexports.keccakFromArray = keccakFromArray;\n/**\n * Creates SHA256 hash of an input.\n * @param  a The input data (Buffer|Array|String)\n */ const _sha256 = function(a) {\n    a = (0, bytes_1.toBuffer)(a);\n    return createHash(\"sha256\").update(a).digest();\n};\n/**\n * Creates SHA256 hash of a Buffer input.\n * @param a The input data (Buffer)\n */ const sha256 = function(a) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return _sha256(a);\n};\nexports.sha256 = sha256;\n/**\n * Creates SHA256 hash of a string input.\n * @param a The input data (string)\n */ const sha256FromString = function(a) {\n    (0, helpers_1.assertIsString)(a);\n    return _sha256(a);\n};\nexports.sha256FromString = sha256FromString;\n/**\n * Creates SHA256 hash of a number[] input.\n * @param a The input data (number[])\n */ const sha256FromArray = function(a) {\n    (0, helpers_1.assertIsArray)(a);\n    return _sha256(a);\n};\nexports.sha256FromArray = sha256FromArray;\n/**\n * Creates RIPEMD160 hash of the input.\n * @param a The input data (Buffer|Array|String|Number)\n * @param padded Whether it should be padded to 256 bits or not\n */ const _ripemd160 = function(a, padded) {\n    a = (0, bytes_1.toBuffer)(a);\n    const hash = createHash(\"rmd160\").update(a).digest();\n    if (padded === true) {\n        return (0, bytes_1.setLengthLeft)(hash, 32);\n    } else {\n        return hash;\n    }\n};\n/**\n * Creates RIPEMD160 hash of a Buffer input.\n * @param a The input data (Buffer)\n * @param padded Whether it should be padded to 256 bits or not\n */ const ripemd160 = function(a, padded) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return _ripemd160(a, padded);\n};\nexports.ripemd160 = ripemd160;\n/**\n * Creates RIPEMD160 hash of a string input.\n * @param a The input data (String)\n * @param padded Whether it should be padded to 256 bits or not\n */ const ripemd160FromString = function(a, padded) {\n    (0, helpers_1.assertIsString)(a);\n    return _ripemd160(a, padded);\n};\nexports.ripemd160FromString = ripemd160FromString;\n/**\n * Creates RIPEMD160 hash of a number[] input.\n * @param a The input data (number[])\n * @param padded Whether it should be padded to 256 bits or not\n */ const ripemd160FromArray = function(a, padded) {\n    (0, helpers_1.assertIsArray)(a);\n    return _ripemd160(a, padded);\n};\nexports.ripemd160FromArray = ripemd160FromArray;\n/**\n * Creates SHA-3 hash of the RLP encoded version of the input.\n * @param a The input data\n */ const rlphash = function(a) {\n    return (0, exports.keccak)(externals_1.rlp.encode(a));\n};\nexports.rlphash = rlphash; //# sourceMappingURL=hash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW1qcy11dGlsQDcuMS41L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9oYXNoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxlQUFlLEdBQUdBLDBCQUEwQixHQUFHQSwyQkFBMkIsR0FBR0EsaUJBQWlCLEdBQUdBLHVCQUF1QixHQUFHQSx3QkFBd0IsR0FBR0EsY0FBYyxHQUFHQSx1QkFBdUIsR0FBR0EsMkJBQTJCLEdBQUdBLHdCQUF3QixHQUFHQSxpQkFBaUIsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDcFMsTUFBTWMsV0FBV0MsbUJBQU9BLENBQUMseUlBQThCO0FBQ3ZELE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLG9IQUFhO0FBQ3pDLE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLDRHQUFTO0FBQ2pDLE1BQU1JLFlBQVlKLG1CQUFPQSxDQUFDLGdIQUFXO0FBQ3JDOzs7O0NBSUMsR0FDRCxNQUFNRixTQUFTLFNBQVVPLENBQUMsRUFBRUMsT0FBTyxHQUFHO0lBQ2pDLElBQUdGLFVBQVVHLGNBQWMsRUFBRUY7SUFDOUIsT0FBUUM7UUFDSixLQUFLO1lBQUs7Z0JBQ04sT0FBTyxDQUFDLEdBQUdQLFNBQVNTLFNBQVMsRUFBRUg7WUFDbkM7UUFDQSxLQUFLO1lBQUs7Z0JBQ04sT0FBTyxDQUFDLEdBQUdOLFNBQVNGLFNBQVMsRUFBRVE7WUFDbkM7UUFDQSxLQUFLO1lBQUs7Z0JBQ04sT0FBTyxDQUFDLEdBQUdOLFNBQVNVLFNBQVMsRUFBRUo7WUFDbkM7UUFDQSxLQUFLO1lBQUs7Z0JBQ04sT0FBTyxDQUFDLEdBQUdOLFNBQVNXLFNBQVMsRUFBRUw7WUFDbkM7UUFDQTtZQUFTO2dCQUNMLE1BQU0sSUFBSU0sTUFBTSxDQUFDLHdCQUF3QixFQUFFTCxLQUFLLENB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RUFBRWI7SUFDN0IsT0FBT2lCLFdBQVdqQixHQUFHa0I7QUFDekI7QUFDQXRDLDBCQUEwQixHQUFHRztBQUM3Qjs7O0NBR0MsR0FDRCxNQUFNRCxVQUFVLFNBQVVrQixDQUFDO0lBQ3ZCLE9BQU8sQ0FBQyxHQUFHcEIsUUFBUWEsTUFBTSxFQUFFSSxZQUFZd0IsR0FBRyxDQUFDQyxNQUFNLENBQUN0QjtBQUN0RDtBQUNBcEIsZUFBZSxHQUFHRSxTQUNsQixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW1qcy11dGlsQDcuMS41L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9oYXNoLmpzPzZkNWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJscGhhc2ggPSBleHBvcnRzLnJpcGVtZDE2MEZyb21BcnJheSA9IGV4cG9ydHMucmlwZW1kMTYwRnJvbVN0cmluZyA9IGV4cG9ydHMucmlwZW1kMTYwID0gZXhwb3J0cy5zaGEyNTZGcm9tQXJyYXkgPSBleHBvcnRzLnNoYTI1NkZyb21TdHJpbmcgPSBleHBvcnRzLnNoYTI1NiA9IGV4cG9ydHMua2VjY2FrRnJvbUFycmF5ID0gZXhwb3J0cy5rZWNjYWtGcm9tSGV4U3RyaW5nID0gZXhwb3J0cy5rZWNjYWtGcm9tU3RyaW5nID0gZXhwb3J0cy5rZWNjYWsyNTYgPSBleHBvcnRzLmtlY2NhayA9IHZvaWQgMDtcbmNvbnN0IGtlY2Nha18xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWtcIik7XG5jb25zdCBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbmNvbnN0IGV4dGVybmFsc18xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxzXCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuY29uc3QgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbi8qKlxuICogQ3JlYXRlcyBLZWNjYWsgaGFzaCBvZiBhIEJ1ZmZlciBpbnB1dFxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcilcbiAqIEBwYXJhbSBiaXRzIChudW1iZXIgPSAyNTYpIFRoZSBLZWNjYWsgd2lkdGhcbiAqL1xuY29uc3Qga2VjY2FrID0gZnVuY3Rpb24gKGEsIGJpdHMgPSAyNTYpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShhKTtcbiAgICBzd2l0Y2ggKGJpdHMpIHtcbiAgICAgICAgY2FzZSAyMjQ6IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwga2VjY2FrXzEua2VjY2FrMjI0KShhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDI1Njoge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzg0OiB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGtlY2Nha18xLmtlY2NhazM4NCkoYSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA1MTI6IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwga2VjY2FrXzEua2VjY2FrNTEyKShhKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsZCBhbGdvcml0aG06IGtlY2NhayR7Yml0c31gKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLmtlY2NhayA9IGtlY2Nhaztcbi8qKlxuICogQ3JlYXRlcyBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIGlucHV0LCBhbGlhcyBmb3Iga2VjY2FrKGEsIDI1NikuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoQnVmZmVyKVxuICovXG5jb25zdCBrZWNjYWsyNTYgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5rZWNjYWspKGEpO1xufTtcbmV4cG9ydHMua2VjY2FrMjU2ID0ga2VjY2FrMjU2O1xuLyoqXG4gKiBDcmVhdGVzIEtlY2NhayBoYXNoIG9mIGEgdXRmLTggc3RyaW5nIGlucHV0XG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoU3RyaW5nKVxuICogQHBhcmFtIGJpdHMgKG51bWJlciA9IDI1NikgVGhlIEtlY2NhayB3aWR0aFxuICovXG5jb25zdCBrZWNjYWtGcm9tU3RyaW5nID0gZnVuY3Rpb24gKGEsIGJpdHMgPSAyNTYpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzU3RyaW5nKShhKTtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShhLCAndXRmOCcpO1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5rZWNjYWspKGJ1ZiwgYml0cyk7XG59O1xuZXhwb3J0cy5rZWNjYWtGcm9tU3RyaW5nID0ga2VjY2FrRnJvbVN0cmluZztcbi8qKlxuICogQ3JlYXRlcyBLZWNjYWsgaGFzaCBvZiBhbiAweC1wcmVmaXhlZCBzdHJpbmcgaW5wdXRcbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChTdHJpbmcpXG4gKiBAcGFyYW0gYml0cyAobnVtYmVyID0gMjU2KSBUaGUgS2VjY2FrIHdpZHRoXG4gKi9cbmNvbnN0IGtlY2Nha0Zyb21IZXhTdHJpbmcgPSBmdW5jdGlvbiAoYSwgYml0cyA9IDI1Nikge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNIZXhTdHJpbmcpKGEpO1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5rZWNjYWspKCgwLCBieXRlc18xLnRvQnVmZmVyKShhKSwgYml0cyk7XG59O1xuZXhwb3J0cy5rZWNjYWtGcm9tSGV4U3RyaW5nID0ga2VjY2FrRnJvbUhleFN0cmluZztcbi8qKlxuICogQ3JlYXRlcyBLZWNjYWsgaGFzaCBvZiBhIG51bWJlciBhcnJheSBpbnB1dFxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKG51bWJlcltdKVxuICogQHBhcmFtIGJpdHMgKG51bWJlciA9IDI1NikgVGhlIEtlY2NhayB3aWR0aFxuICovXG5jb25zdCBrZWNjYWtGcm9tQXJyYXkgPSBmdW5jdGlvbiAoYSwgYml0cyA9IDI1Nikge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNBcnJheSkoYSk7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmtlY2NhaykoKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGEpLCBiaXRzKTtcbn07XG5leHBvcnRzLmtlY2Nha0Zyb21BcnJheSA9IGtlY2Nha0Zyb21BcnJheTtcbi8qKlxuICogQ3JlYXRlcyBTSEEyNTYgaGFzaCBvZiBhbiBpbnB1dC5cbiAqIEBwYXJhbSAgYSBUaGUgaW5wdXQgZGF0YSAoQnVmZmVyfEFycmF5fFN0cmluZylcbiAqL1xuY29uc3QgX3NoYTI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgYSA9ICgwLCBieXRlc18xLnRvQnVmZmVyKShhKTtcbiAgICByZXR1cm4gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGEpLmRpZ2VzdCgpO1xufTtcbi8qKlxuICogQ3JlYXRlcyBTSEEyNTYgaGFzaCBvZiBhIEJ1ZmZlciBpbnB1dC5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChCdWZmZXIpXG4gKi9cbmNvbnN0IHNoYTI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoYSk7XG4gICAgcmV0dXJuIF9zaGEyNTYoYSk7XG59O1xuZXhwb3J0cy5zaGEyNTYgPSBzaGEyNTY7XG4vKipcbiAqIENyZWF0ZXMgU0hBMjU2IGhhc2ggb2YgYSBzdHJpbmcgaW5wdXQuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoc3RyaW5nKVxuICovXG5jb25zdCBzaGEyNTZGcm9tU3RyaW5nID0gZnVuY3Rpb24gKGEpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzU3RyaW5nKShhKTtcbiAgICByZXR1cm4gX3NoYTI1NihhKTtcbn07XG5leHBvcnRzLnNoYTI1NkZyb21TdHJpbmcgPSBzaGEyNTZGcm9tU3RyaW5nO1xuLyoqXG4gKiBDcmVhdGVzIFNIQTI1NiBoYXNoIG9mIGEgbnVtYmVyW10gaW5wdXQuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAobnVtYmVyW10pXG4gKi9cbmNvbnN0IHNoYTI1NkZyb21BcnJheSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0FycmF5KShhKTtcbiAgICByZXR1cm4gX3NoYTI1NihhKTtcbn07XG5leHBvcnRzLnNoYTI1NkZyb21BcnJheSA9IHNoYTI1NkZyb21BcnJheTtcbi8qKlxuICogQ3JlYXRlcyBSSVBFTUQxNjAgaGFzaCBvZiB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoQnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXIpXG4gKiBAcGFyYW0gcGFkZGVkIFdoZXRoZXIgaXQgc2hvdWxkIGJlIHBhZGRlZCB0byAyNTYgYml0cyBvciBub3RcbiAqL1xuY29uc3QgX3JpcGVtZDE2MCA9IGZ1bmN0aW9uIChhLCBwYWRkZWQpIHtcbiAgICBhID0gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGEpO1xuICAgIGNvbnN0IGhhc2ggPSBjcmVhdGVIYXNoKCdybWQxNjAnKS51cGRhdGUoYSkuZGlnZXN0KCk7XG4gICAgaWYgKHBhZGRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gKDAsIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdCkoaGFzaCwgMzIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxufTtcbi8qKlxuICogQ3JlYXRlcyBSSVBFTUQxNjAgaGFzaCBvZiBhIEJ1ZmZlciBpbnB1dC5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChCdWZmZXIpXG4gKiBAcGFyYW0gcGFkZGVkIFdoZXRoZXIgaXQgc2hvdWxkIGJlIHBhZGRlZCB0byAyNTYgYml0cyBvciBub3RcbiAqL1xuY29uc3QgcmlwZW1kMTYwID0gZnVuY3Rpb24gKGEsIHBhZGRlZCkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGEpO1xuICAgIHJldHVybiBfcmlwZW1kMTYwKGEsIHBhZGRlZCk7XG59O1xuZXhwb3J0cy5yaXBlbWQxNjAgPSByaXBlbWQxNjA7XG4vKipcbiAqIENyZWF0ZXMgUklQRU1EMTYwIGhhc2ggb2YgYSBzdHJpbmcgaW5wdXQuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoU3RyaW5nKVxuICogQHBhcmFtIHBhZGRlZCBXaGV0aGVyIGl0IHNob3VsZCBiZSBwYWRkZWQgdG8gMjU2IGJpdHMgb3Igbm90XG4gKi9cbmNvbnN0IHJpcGVtZDE2MEZyb21TdHJpbmcgPSBmdW5jdGlvbiAoYSwgcGFkZGVkKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc1N0cmluZykoYSk7XG4gICAgcmV0dXJuIF9yaXBlbWQxNjAoYSwgcGFkZGVkKTtcbn07XG5leHBvcnRzLnJpcGVtZDE2MEZyb21TdHJpbmcgPSByaXBlbWQxNjBGcm9tU3RyaW5nO1xuLyoqXG4gKiBDcmVhdGVzIFJJUEVNRDE2MCBoYXNoIG9mIGEgbnVtYmVyW10gaW5wdXQuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAobnVtYmVyW10pXG4gKiBAcGFyYW0gcGFkZGVkIFdoZXRoZXIgaXQgc2hvdWxkIGJlIHBhZGRlZCB0byAyNTYgYml0cyBvciBub3RcbiAqL1xuY29uc3QgcmlwZW1kMTYwRnJvbUFycmF5ID0gZnVuY3Rpb24gKGEsIHBhZGRlZCkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNBcnJheSkoYSk7XG4gICAgcmV0dXJuIF9yaXBlbWQxNjAoYSwgcGFkZGVkKTtcbn07XG5leHBvcnRzLnJpcGVtZDE2MEZyb21BcnJheSA9IHJpcGVtZDE2MEZyb21BcnJheTtcbi8qKlxuICogQ3JlYXRlcyBTSEEtMyBoYXNoIG9mIHRoZSBSTFAgZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBpbnB1dC5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhXG4gKi9cbmNvbnN0IHJscGhhc2ggPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5rZWNjYWspKGV4dGVybmFsc18xLnJscC5lbmNvZGUoYSkpO1xufTtcbmV4cG9ydHMucmxwaGFzaCA9IHJscGhhc2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJscGhhc2giLCJyaXBlbWQxNjBGcm9tQXJyYXkiLCJyaXBlbWQxNjBGcm9tU3RyaW5nIiwicmlwZW1kMTYwIiwic2hhMjU2RnJvbUFycmF5Iiwic2hhMjU2RnJvbVN0cmluZyIsInNoYTI1NiIsImtlY2Nha0Zyb21BcnJheSIsImtlY2Nha0Zyb21IZXhTdHJpbmciLCJrZWNjYWtGcm9tU3RyaW5nIiwia2VjY2FrMjU2Iiwia2VjY2FrIiwia2VjY2FrXzEiLCJyZXF1aXJlIiwiY3JlYXRlSGFzaCIsImV4dGVybmFsc18xIiwiYnl0ZXNfMSIsImhlbHBlcnNfMSIsImEiLCJiaXRzIiwiYXNzZXJ0SXNCdWZmZXIiLCJrZWNjYWsyMjQiLCJrZWNjYWszODQiLCJrZWNjYWs1MTIiLCJFcnJvciIsImFzc2VydElzU3RyaW5nIiwiYnVmIiwiQnVmZmVyIiwiZnJvbSIsImFzc2VydElzSGV4U3RyaW5nIiwidG9CdWZmZXIiLCJhc3NlcnRJc0FycmF5IiwiX3NoYTI1NiIsInVwZGF0ZSIsImRpZ2VzdCIsIl9yaXBlbWQxNjAiLCJwYWRkZWQiLCJoYXNoIiwic2V0TGVuZ3RoTGVmdCIsInJscCIsImVuY29kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/helpers.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/helpers.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/internal.js\");\n/**\n * Throws if a string is not hex prefixed\n * @param {string} input string to check hex prefix of\n */ const assertIsHexString = function(input) {\n    if (!(0, internal_1.isHexString)(input)) {\n        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsHexString = assertIsHexString;\n/**\n * Throws if input is not a buffer\n * @param {Buffer} input value to check\n */ const assertIsBuffer = function(input) {\n    if (!Buffer.isBuffer(input)) {\n        const msg = `This method only supports Buffer but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsBuffer = assertIsBuffer;\n/**\n * Throws if input is not an array\n * @param {number[]} input value to check\n */ const assertIsArray = function(input) {\n    if (!Array.isArray(input)) {\n        const msg = `This method only supports number arrays but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsArray = assertIsArray;\n/**\n * Throws if input is not a string\n * @param {string} input value to check\n */ const assertIsString = function(input) {\n    if (typeof input !== \"string\") {\n        const msg = `This method only supports strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsString = assertIsString; //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW1qcy11dGlsQDcuMS41L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBR0EscUJBQXFCLEdBQUdBLHNCQUFzQixHQUFHQSx5QkFBeUIsR0FBRyxLQUFLO0FBQzNHLE1BQU1NLGFBQWFDLG1CQUFPQSxDQUFDLGtIQUFZO0FBQ3ZDOzs7Q0FHQyxHQUNELE1BQU1GLG9CQUFvQixTQUFVRyxLQUFLO0lBQ3JDLElBQUksQ0FBQyxDQUFDLEdBQUdGLFdBQVdHLFdBQVcsRUFBRUQsUUFBUTtRQUNyQyxNQUFNRSxNQUFNLENBQUMsaUVBQWlFLEVBQUVGLE1BQU0sQ0FBQztRQUN2RixNQUFNLElBQUlHLE1BQU1EO0lBQ3BCO0FBQ0o7QUFDQVYseUJBQXlCLEdBQUdLO0FBQzVCOzs7Q0FHQyxHQUNELE1BQU1ELGlCQUFpQixTQUFVSSxLQUFLO0lBQ2xDLElBQUksQ0FBQ0ksT0FBT0MsUUFBUSxDQUFDTCxRQUFRO1FBQ3pCLE1BQU1FLE1BQU0sQ0FBQyxnREFBZ0QsRUFBRUYsTUFBTSxDQUFDO1FBQ3RFLE1BQU0sSUFBSUcsTUFBTUQ7SUFDcEI7QUFDSjtBQUNBVixzQkFBc0IsR0FBR0k7QUFDekI7OztDQUdDLEdBQ0QsTUFBTUQsZ0JBQWdCLFNBQVVLLEtBQUs7SUFDakMsSUFBSSxDQUFDTSxNQUFNQyxPQUFPLENBQUNQLFFBQVE7UUFDdkIsTUFBTUUsTUFBTSxDQUFDLHVEQUF1RCxFQUFFRixNQUFNLENBQUM7UUFDN0UsTUFBTSxJQUFJRyxNQUFNRDtJQUNwQjtBQUNKO0FBQ0FWLHFCQUFxQixHQUFHRztBQUN4Qjs7O0NBR0MsR0FDRCxNQUFNRCxpQkFBaUIsU0FBVU0sS0FBSztJQUNsQyxJQUFJLE9BQU9BLFVBQVUsVUFBVTtRQUMzQixNQUFNRSxNQUFNLENBQUMsaURBQWlELEVBQUVGLE1BQU0sQ0FBQztRQUN2RSxNQUFNLElBQUlHLE1BQU1EO0lBQ3BCO0FBQ0o7QUFDQVYsc0JBQXNCLEdBQUdFLGdCQUN6QixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW1qcy11dGlsQDcuMS41L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9oZWxwZXJzLmpzP2Y5NTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydElzU3RyaW5nID0gZXhwb3J0cy5hc3NlcnRJc0FycmF5ID0gZXhwb3J0cy5hc3NlcnRJc0J1ZmZlciA9IGV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSB2b2lkIDA7XG5jb25zdCBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG4vKipcbiAqIFRocm93cyBpZiBhIHN0cmluZyBpcyBub3QgaGV4IHByZWZpeGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgc3RyaW5nIHRvIGNoZWNrIGhleCBwcmVmaXggb2ZcbiAqL1xuY29uc3QgYXNzZXJ0SXNIZXhTdHJpbmcgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoISgwLCBpbnRlcm5hbF8xLmlzSGV4U3RyaW5nKShpbnB1dCkpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRoaXMgbWV0aG9kIG9ubHkgc3VwcG9ydHMgMHgtcHJlZml4ZWQgaGV4IHN0cmluZ3MgYnV0IGlucHV0IHdhczogJHtpbnB1dH1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59O1xuZXhwb3J0cy5hc3NlcnRJc0hleFN0cmluZyA9IGFzc2VydElzSGV4U3RyaW5nO1xuLyoqXG4gKiBUaHJvd3MgaWYgaW5wdXQgaXMgbm90IGEgYnVmZmVyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW5wdXQgdmFsdWUgdG8gY2hlY2tcbiAqL1xuY29uc3QgYXNzZXJ0SXNCdWZmZXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRoaXMgbWV0aG9kIG9ubHkgc3VwcG9ydHMgQnVmZmVyIGJ1dCBpbnB1dCB3YXM6ICR7aW5wdXR9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufTtcbmV4cG9ydHMuYXNzZXJ0SXNCdWZmZXIgPSBhc3NlcnRJc0J1ZmZlcjtcbi8qKlxuICogVGhyb3dzIGlmIGlucHV0IGlzIG5vdCBhbiBhcnJheVxuICogQHBhcmFtIHtudW1iZXJbXX0gaW5wdXQgdmFsdWUgdG8gY2hlY2tcbiAqL1xuY29uc3QgYXNzZXJ0SXNBcnJheSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRoaXMgbWV0aG9kIG9ubHkgc3VwcG9ydHMgbnVtYmVyIGFycmF5cyBidXQgaW5wdXQgd2FzOiAke2lucHV0fWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn07XG5leHBvcnRzLmFzc2VydElzQXJyYXkgPSBhc3NlcnRJc0FycmF5O1xuLyoqXG4gKiBUaHJvd3MgaWYgaW5wdXQgaXMgbm90IGEgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgdmFsdWUgdG8gY2hlY2tcbiAqL1xuY29uc3QgYXNzZXJ0SXNTdHJpbmcgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBtc2cgPSBgVGhpcyBtZXRob2Qgb25seSBzdXBwb3J0cyBzdHJpbmdzIGJ1dCBpbnB1dCB3YXM6ICR7aW5wdXR9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufTtcbmV4cG9ydHMuYXNzZXJ0SXNTdHJpbmcgPSBhc3NlcnRJc1N0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYXNzZXJ0SXNTdHJpbmciLCJhc3NlcnRJc0FycmF5IiwiYXNzZXJ0SXNCdWZmZXIiLCJhc3NlcnRJc0hleFN0cmluZyIsImludGVybmFsXzEiLCJyZXF1aXJlIiwiaW5wdXQiLCJpc0hleFN0cmluZyIsIm1zZyIsIkVycm9yIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJBcnJheSIsImlzQXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\n/**\n * Constants\n */ __exportStar(__webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/constants.js\"), exports);\n/**\n * Account class and helper functions\n */ __exportStar(__webpack_require__(/*! ./account */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/account.js\"), exports);\n/**\n * Address type\n */ __exportStar(__webpack_require__(/*! ./address */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/address.js\"), exports);\n/**\n * Hash functions\n */ __exportStar(__webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/hash.js\"), exports);\n/**\n * ECDSA signature\n */ __exportStar(__webpack_require__(/*! ./signature */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/signature.js\"), exports);\n/**\n * Utilities for manipulating Buffers, byte arrays, etc.\n */ __exportStar(__webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/bytes.js\"), exports);\n/**\n * Function for definining properties on an object\n */ __exportStar(__webpack_require__(/*! ./object */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/object.js\"), exports);\n/**\n * External exports (BN, rlp)\n */ __exportStar(__webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/externals.js\"), exports);\n/**\n * Helpful TypeScript types\n */ __exportStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/types.js\"), exports);\n/**\n * Export ethjs-util methods\n */ var internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/internal.js\");\nObject.defineProperty(exports, \"isHexPrefixed\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.isHexPrefixed;\n    }\n}));\nObject.defineProperty(exports, \"stripHexPrefix\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.stripHexPrefix;\n    }\n}));\nObject.defineProperty(exports, \"padToEven\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.padToEven;\n    }\n}));\nObject.defineProperty(exports, \"getBinarySize\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.getBinarySize;\n    }\n}));\nObject.defineProperty(exports, \"arrayContainsArray\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.arrayContainsArray;\n    }\n}));\nObject.defineProperty(exports, \"toAscii\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.toAscii;\n    }\n}));\nObject.defineProperty(exports, \"fromUtf8\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.fromUtf8;\n    }\n}));\nObject.defineProperty(exports, \"fromAscii\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.fromAscii;\n    }\n}));\nObject.defineProperty(exports, \"getKeys\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.getKeys;\n    }\n}));\nObject.defineProperty(exports, \"isHexString\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.isHexString;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW1qcy11dGlsQDcuMS41L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLGVBQWUsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxZQUFZLElBQUssU0FBU1osQ0FBQyxFQUFFYSxRQUFPO0lBQ2pFLElBQUssSUFBSUMsS0FBS2QsRUFBRyxJQUFJYyxNQUFNLGFBQWEsQ0FBQ2pCLE9BQU9rQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixVQUFTQyxJQUFJbEIsZ0JBQWdCaUIsVUFBU2IsR0FBR2M7QUFDM0g7QUFDQWpCLDhDQUE2QztJQUFFcUIsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REwsbUJBQW1CLEdBQUdBLGVBQWUsR0FBR0EsaUJBQWlCLEdBQUdBLGdCQUFnQixHQUFHQSxlQUFlLEdBQUdBLDBCQUEwQixHQUFHQSxxQkFBcUIsR0FBR0EsaUJBQWlCLEdBQUdBLHNCQUFzQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQ2hPOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQyxvSEFBYSxHQUFHaEI7QUFDckM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLGdIQUFXLEdBQUdoQjtBQUNuQzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMsZ0hBQVcsR0FBR2hCO0FBQ25DOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQywwR0FBUSxHQUFHaEI7QUFDaEM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLG9IQUFhLEdBQUdoQjtBQUNyQzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMsNEdBQVMsR0FBR2hCO0FBQ2pDOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQyw4R0FBVSxHQUFHaEI7QUFDbEM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLG9IQUFhLEdBQUdoQjtBQUNyQzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMsNEdBQVMsR0FBR2hCO0FBQ2pDOztDQUVDLEdBQ0QsSUFBSWlCLGFBQWFELG1CQUFPQSxDQUFDLGtIQUFZO0FBQ3JDaEMsaURBQWdEO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXRixhQUFhO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDNUgvQixrREFBaUQ7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdILGNBQWM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM5SDlCLDZDQUE0QztJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV0osU0FBUztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3BIN0IsaURBQWdEO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXTCxhQUFhO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDNUg1QixzREFBcUQ7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdOLGtCQUFrQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3RJM0IsMkNBQTBDO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXUCxPQUFPO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDaEgxQiw0Q0FBMkM7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdSLFFBQVE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNsSHpCLDZDQUE0QztJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV1QsU0FBUztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3BIeEIsMkNBQTBDO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXVixPQUFPO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDaEh2QiwrQ0FBOEM7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdYLFdBQVc7SUFBRTtBQUFFLENBQUMsRUFBQyxFQUN4SCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW1qcy11dGlsQDcuMS41L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9pbmRleC5qcz85MWQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gZXhwb3J0cy5nZXRLZXlzID0gZXhwb3J0cy5mcm9tQXNjaWkgPSBleHBvcnRzLmZyb21VdGY4ID0gZXhwb3J0cy50b0FzY2lpID0gZXhwb3J0cy5hcnJheUNvbnRhaW5zQXJyYXkgPSBleHBvcnRzLmdldEJpbmFyeVNpemUgPSBleHBvcnRzLnBhZFRvRXZlbiA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXggPSBleHBvcnRzLmlzSGV4UHJlZml4ZWQgPSB2b2lkIDA7XG4vKipcbiAqIENvbnN0YW50c1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29uc3RhbnRzXCIpLCBleHBvcnRzKTtcbi8qKlxuICogQWNjb3VudCBjbGFzcyBhbmQgaGVscGVyIGZ1bmN0aW9uc1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWNjb3VudFwiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEFkZHJlc3MgdHlwZVxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWRkcmVzc1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEhhc2ggZnVuY3Rpb25zXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oYXNoXCIpLCBleHBvcnRzKTtcbi8qKlxuICogRUNEU0Egc2lnbmF0dXJlXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zaWduYXR1cmVcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBVdGlsaXRpZXMgZm9yIG1hbmlwdWxhdGluZyBCdWZmZXJzLCBieXRlIGFycmF5cywgZXRjLlxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYnl0ZXNcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBGdW5jdGlvbiBmb3IgZGVmaW5pbmluZyBwcm9wZXJ0aWVzIG9uIGFuIG9iamVjdFxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb2JqZWN0XCIpLCBleHBvcnRzKTtcbi8qKlxuICogRXh0ZXJuYWwgZXhwb3J0cyAoQk4sIHJscClcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4dGVybmFsc1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEhlbHBmdWwgVHlwZVNjcmlwdCB0eXBlc1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBFeHBvcnQgZXRoanMtdXRpbCBtZXRob2RzXG4gKi9cbnZhciBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0hleFByZWZpeGVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLmlzSGV4UHJlZml4ZWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpcEhleFByZWZpeFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5zdHJpcEhleFByZWZpeDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhZFRvRXZlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5wYWRUb0V2ZW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRCaW5hcnlTaXplXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLmdldEJpbmFyeVNpemU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhcnJheUNvbnRhaW5zQXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuYXJyYXlDb250YWluc0FycmF5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9Bc2NpaVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS50b0FzY2lpOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnJvbVV0ZjhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuZnJvbVV0Zjg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmcm9tQXNjaWlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuZnJvbUFzY2lpOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0S2V5c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5nZXRLZXlzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIZXhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuaXNIZXhTdHJpbmc7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19leHBvcnRTdGFyIiwiZXhwb3J0cyIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2YWx1ZSIsImlzSGV4U3RyaW5nIiwiZ2V0S2V5cyIsImZyb21Bc2NpaSIsImZyb21VdGY4IiwidG9Bc2NpaSIsImFycmF5Q29udGFpbnNBcnJheSIsImdldEJpbmFyeVNpemUiLCJwYWRUb0V2ZW4iLCJzdHJpcEhleFByZWZpeCIsImlzSGV4UHJlZml4ZWQiLCJyZXF1aXJlIiwiaW50ZXJuYWxfMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/internal.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/internal.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\nThe MIT License\n\nCopyright (c) 2016 Nick Dodson. nickdodson.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\n/**\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\n * @param str the string input value\n * @return a boolean if it is or is not hex prefixed\n * @throws if the str input is not a string\n */ function isHexPrefixed(str) {\n    if (typeof str !== \"string\") {\n        throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);\n    }\n    return str[0] === \"0\" && str[1] === \"x\";\n}\nexports.isHexPrefixed = isHexPrefixed;\n/**\n * Removes '0x' from a given `String` if present\n * @param str the string value\n * @returns the string without 0x prefix\n */ const stripHexPrefix = (str)=>{\n    if (typeof str !== \"string\") throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);\n    return isHexPrefixed(str) ? str.slice(2) : str;\n};\nexports.stripHexPrefix = stripHexPrefix;\n/**\n * Pads a `String` to have an even length\n * @param value\n * @return output\n */ function padToEven(value) {\n    let a = value;\n    if (typeof a !== \"string\") {\n        throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);\n    }\n    if (a.length % 2) a = `0${a}`;\n    return a;\n}\nexports.padToEven = padToEven;\n/**\n * Get the binary size of a string\n * @param str\n * @returns the number of bytes contained within the string\n */ function getBinarySize(str) {\n    if (typeof str !== \"string\") {\n        throw new Error(`[getBinarySize] method requires input type 'string', recieved ${typeof str}`);\n    }\n    return Buffer.byteLength(str, \"utf8\");\n}\nexports.getBinarySize = getBinarySize;\n/**\n * Returns TRUE if the first specified array contains all elements\n * from the second one. FALSE otherwise.\n *\n * @param superset\n * @param subset\n *\n */ function arrayContainsArray(superset, subset, some) {\n    if (Array.isArray(superset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);\n    }\n    if (Array.isArray(subset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);\n    }\n    return subset[some ? \"some\" : \"every\"]((value)=>superset.indexOf(value) >= 0);\n}\nexports.arrayContainsArray = arrayContainsArray;\n/**\n * Should be called to get ascii from its hex representation\n *\n * @param string in hex\n * @returns ascii string representation of hex value\n */ function toAscii(hex) {\n    let str = \"\";\n    let i = 0;\n    const l = hex.length;\n    if (hex.substring(0, 2) === \"0x\") i = 2;\n    for(; i < l; i += 2){\n        const code = parseInt(hex.substr(i, 2), 16);\n        str += String.fromCharCode(code);\n    }\n    return str;\n}\nexports.toAscii = toAscii;\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @param string\n * @param optional padding\n * @returns hex representation of input string\n */ function fromUtf8(stringValue) {\n    const str = Buffer.from(stringValue, \"utf8\");\n    return `0x${padToEven(str.toString(\"hex\")).replace(/^0+|0+$/g, \"\")}`;\n}\nexports.fromUtf8 = fromUtf8;\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @param  string\n * @param  optional padding\n * @returns  hex representation of input string\n */ function fromAscii(stringValue) {\n    let hex = \"\";\n    for(let i = 0; i < stringValue.length; i++){\n        const code = stringValue.charCodeAt(i);\n        const n = code.toString(16);\n        hex += n.length < 2 ? `0${n}` : n;\n    }\n    return `0x${hex}`;\n}\nexports.fromAscii = fromAscii;\n/**\n * Returns the keys from an array of objects.\n * @example\n * ```js\n * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']\n *````\n * @param  params\n * @param  key\n * @param  allowEmpty\n * @returns output just a simple array of output keys\n */ function getKeys(params, key, allowEmpty) {\n    if (!Array.isArray(params)) {\n        throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);\n    }\n    if (typeof key !== \"string\") {\n        throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);\n    }\n    const result = [];\n    for(let i = 0; i < params.length; i++){\n        let value = params[i][key];\n        if (allowEmpty && !value) {\n            value = \"\";\n        } else if (typeof value !== \"string\") {\n            throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);\n        }\n        result.push(value);\n    }\n    return result;\n}\nexports.getKeys = getKeys;\n/**\n * Is the string a hex string.\n *\n * @param  value\n * @param  length\n * @returns  output the string is a hex string\n */ function isHexString(value, length) {\n    if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) return false;\n    if (length && value.length !== 2 + 2 * length) return false;\n    return true;\n}\nexports.isHexString = isHexString; //# sourceMappingURL=internal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW1qcy11dGlsQDcuMS41L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9pbnRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBR0EsZUFBZSxHQUFHQSxpQkFBaUIsR0FBR0EsZ0JBQWdCLEdBQUdBLGVBQWUsR0FBR0EsMEJBQTBCLEdBQUdBLHFCQUFxQixHQUFHQSxpQkFBaUIsR0FBR0Esc0JBQXNCLEdBQUdBLHFCQUFxQixHQUFHLEtBQUs7QUFDaE87Ozs7O0NBS0MsR0FDRCxTQUFTVyxjQUFjQyxHQUFHO0lBQ3RCLElBQUksT0FBT0EsUUFBUSxVQUFVO1FBQ3pCLE1BQU0sSUFBSUMsTUFBTSxDQUFDLDJEQUEyRCxFQUFFLE9BQU9ELElBQUksQ0FBQztJQUM5RjtJQUNBLE9BQU9BLEdBQUcsQ0FBQyxFQUFFLEtBQUssT0FBT0EsR0FBRyxDQUFDLEVBQUUsS0FBSztBQUN4QztBQUNBWixxQkFBcUIsR0FBR1c7QUFDeEI7Ozs7Q0FJQyxHQUNELE1BQU1ELGlCQUFpQixDQUFDRTtJQUNwQixJQUFJLE9BQU9BLFFBQVEsVUFDZixNQUFNLElBQUlDLE1BQU0sQ0FBQyx1REFBdUQsRUFBRSxPQUFPRCxJQUFJLENBQUM7SUFDMUYsT0FBT0QsY0FBY0MsT0FBT0EsSUFBSUUsS0FBSyxDQUFDLEtBQUtGO0FBQy9DO0FBQ0FaLHNCQUFzQixHQUFHVTtBQUN6Qjs7OztDQUlDLEdBQ0QsU0FBU0QsVUFBVVIsS0FBSztJQUNwQixJQUFJYyxJQUFJZDtJQUNSLElBQUksT0FBT2MsTUFBTSxVQUFVO1FBQ3ZCLE1BQU0sSUFBSUYsTUFBTSxDQUFDLGtEQUFrRCxFQUFFLE9BQU9FLEVBQUUsQ0FBQztJQUNuRjtJQUNBLElBQUlBLEVBQUVDLE1BQU0sR0FB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QUFNLENBQUNkLEVBQUUsQ0FBQ2UsSUFBSTtRQUMxQixJQUFJQyxjQUFjLENBQUN6QyxPQUFPO1lBQ3RCQSxRQUFRO1FBQ1osT0FDSyxJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUNoQyxNQUFNLElBQUlZLE1BQU0sQ0FBQywrQ0FBK0MsRUFBRSxPQUFPWixNQUFNLENBQUM7UUFDcEY7UUFDQTBDLE9BQU9DLElBQUksQ0FBQzNDO0lBQ2hCO0lBQ0EsT0FBTzBDO0FBQ1g7QUFDQTNDLGVBQWUsR0FBR0c7QUFDbEI7Ozs7OztDQU1DLEdBQ0QsU0FBU0QsWUFBWUQsS0FBSyxFQUFFZSxNQUFNO0lBQzlCLElBQUksT0FBT2YsVUFBVSxZQUFZLENBQUNBLE1BQU00QyxLQUFLLENBQUMscUJBQzFDLE9BQU87SUFDWCxJQUFJN0IsVUFBVWYsTUFBTWUsTUFBTSxLQUFLLElBQUksSUFBSUEsUUFDbkMsT0FBTztJQUNYLE9BQU87QUFDWDtBQUNBaEIsbUJBQW1CLEdBQUdFLGFBQ3RCLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcmV1bWpzLXV0aWxANy4xLjUvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2ludGVybmFsLmpzPzA5MzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuVGhlIE1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAxNiBOaWNrIERvZHNvbi4gbmlja2RvZHNvbi5jb21cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNIZXhTdHJpbmcgPSBleHBvcnRzLmdldEtleXMgPSBleHBvcnRzLmZyb21Bc2NpaSA9IGV4cG9ydHMuZnJvbVV0ZjggPSBleHBvcnRzLnRvQXNjaWkgPSBleHBvcnRzLmFycmF5Q29udGFpbnNBcnJheSA9IGV4cG9ydHMuZ2V0QmluYXJ5U2l6ZSA9IGV4cG9ydHMucGFkVG9FdmVuID0gZXhwb3J0cy5zdHJpcEhleFByZWZpeCA9IGV4cG9ydHMuaXNIZXhQcmVmaXhlZCA9IHZvaWQgMDtcbi8qKlxuICogUmV0dXJucyBhIGBCb29sZWFuYCBvbiB3aGV0aGVyIG9yIG5vdCB0aGUgYSBgU3RyaW5nYCBzdGFydHMgd2l0aCAnMHgnXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgaW5wdXQgdmFsdWVcbiAqIEByZXR1cm4gYSBib29sZWFuIGlmIGl0IGlzIG9yIGlzIG5vdCBoZXggcHJlZml4ZWRcbiAqIEB0aHJvd3MgaWYgdGhlIHN0ciBpbnB1dCBpcyBub3QgYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNIZXhQcmVmaXhlZChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbaXNIZXhQcmVmaXhlZF0gaW5wdXQgbXVzdCBiZSB0eXBlICdzdHJpbmcnLCByZWNlaXZlZCB0eXBlICR7dHlwZW9mIHN0cn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0clswXSA9PT0gJzAnICYmIHN0clsxXSA9PT0gJ3gnO1xufVxuZXhwb3J0cy5pc0hleFByZWZpeGVkID0gaXNIZXhQcmVmaXhlZDtcbi8qKlxuICogUmVtb3ZlcyAnMHgnIGZyb20gYSBnaXZlbiBgU3RyaW5nYCBpZiBwcmVzZW50XG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdmFsdWVcbiAqIEByZXR1cm5zIHRoZSBzdHJpbmcgd2l0aG91dCAweCBwcmVmaXhcbiAqL1xuY29uc3Qgc3RyaXBIZXhQcmVmaXggPSAoc3RyKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtzdHJpcEhleFByZWZpeF0gaW5wdXQgbXVzdCBiZSB0eXBlICdzdHJpbmcnLCByZWNlaXZlZCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIGlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ci5zbGljZSgyKSA6IHN0cjtcbn07XG5leHBvcnRzLnN0cmlwSGV4UHJlZml4ID0gc3RyaXBIZXhQcmVmaXg7XG4vKipcbiAqIFBhZHMgYSBgU3RyaW5nYCB0byBoYXZlIGFuIGV2ZW4gbGVuZ3RoXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm4gb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIHBhZFRvRXZlbih2YWx1ZSkge1xuICAgIGxldCBhID0gdmFsdWU7XG4gICAgaWYgKHR5cGVvZiBhICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtwYWRUb0V2ZW5dIHZhbHVlIG11c3QgYmUgdHlwZSAnc3RyaW5nJywgcmVjZWl2ZWQgJHt0eXBlb2YgYX1gKTtcbiAgICB9XG4gICAgaWYgKGEubGVuZ3RoICUgMilcbiAgICAgICAgYSA9IGAwJHthfWA7XG4gICAgcmV0dXJuIGE7XG59XG5leHBvcnRzLnBhZFRvRXZlbiA9IHBhZFRvRXZlbjtcbi8qKlxuICogR2V0IHRoZSBiaW5hcnkgc2l6ZSBvZiBhIHN0cmluZ1xuICogQHBhcmFtIHN0clxuICogQHJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyBjb250YWluZWQgd2l0aGluIHRoZSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0QmluYXJ5U2l6ZShzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbZ2V0QmluYXJ5U2l6ZV0gbWV0aG9kIHJlcXVpcmVzIGlucHV0IHR5cGUgJ3N0cmluZycsIHJlY2lldmVkICR7dHlwZW9mIHN0cn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKHN0ciwgJ3V0ZjgnKTtcbn1cbmV4cG9ydHMuZ2V0QmluYXJ5U2l6ZSA9IGdldEJpbmFyeVNpemU7XG4vKipcbiAqIFJldHVybnMgVFJVRSBpZiB0aGUgZmlyc3Qgc3BlY2lmaWVkIGFycmF5IGNvbnRhaW5zIGFsbCBlbGVtZW50c1xuICogZnJvbSB0aGUgc2Vjb25kIG9uZS4gRkFMU0Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSBzdXBlcnNldFxuICogQHBhcmFtIHN1YnNldFxuICpcbiAqL1xuZnVuY3Rpb24gYXJyYXlDb250YWluc0FycmF5KHN1cGVyc2V0LCBzdWJzZXQsIHNvbWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdXBlcnNldCkgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbYXJyYXlDb250YWluc0FycmF5XSBtZXRob2QgcmVxdWlyZXMgaW5wdXQgJ3N1cGVyc2V0JyB0byBiZSBhbiBhcnJheSwgZ290IHR5cGUgJyR7dHlwZW9mIHN1cGVyc2V0fSdgKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic2V0KSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFthcnJheUNvbnRhaW5zQXJyYXldIG1ldGhvZCByZXF1aXJlcyBpbnB1dCAnc3Vic2V0JyB0byBiZSBhbiBhcnJheSwgZ290IHR5cGUgJyR7dHlwZW9mIHN1YnNldH0nYCk7XG4gICAgfVxuICAgIHJldHVybiBzdWJzZXRbc29tZSA/ICdzb21lJyA6ICdldmVyeSddKCh2YWx1ZSkgPT4gc3VwZXJzZXQuaW5kZXhPZih2YWx1ZSkgPj0gMCk7XG59XG5leHBvcnRzLmFycmF5Q29udGFpbnNBcnJheSA9IGFycmF5Q29udGFpbnNBcnJheTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgYXNjaWkgZnJvbSBpdHMgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9Bc2NpaShoZXgpIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGwgPSBoZXgubGVuZ3RoO1xuICAgIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKVxuICAgICAgICBpID0gMjtcbiAgICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgICBjb25zdCBjb2RlID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmV4cG9ydHMudG9Bc2NpaSA9IHRvQXNjaWk7XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIHV0Zjggc3RyaW5nXG4gKlxuICogQHBhcmFtIHN0cmluZ1xuICogQHBhcmFtIG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbVV0Zjgoc3RyaW5nVmFsdWUpIHtcbiAgICBjb25zdCBzdHIgPSBCdWZmZXIuZnJvbShzdHJpbmdWYWx1ZSwgJ3V0ZjgnKTtcbiAgICByZXR1cm4gYDB4JHtwYWRUb0V2ZW4oc3RyLnRvU3RyaW5nKCdoZXgnKSkucmVwbGFjZSgvXjArfDArJC9nLCAnJyl9YDtcbn1cbmV4cG9ydHMuZnJvbVV0ZjggPSBmcm9tVXRmODtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgYXNjaWkgc3RyaW5nXG4gKlxuICogQHBhcmFtICBzdHJpbmdcbiAqIEBwYXJhbSAgb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMgIGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbUFzY2lpKHN0cmluZ1ZhbHVlKSB7XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHN0cmluZ1ZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGNvbnN0IG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/IGAwJHtufWAgOiBuO1xuICAgIH1cbiAgICByZXR1cm4gYDB4JHtoZXh9YDtcbn1cbmV4cG9ydHMuZnJvbUFzY2lpID0gZnJvbUFzY2lpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZXlzIGZyb20gYW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogZ2V0S2V5cyhbe2E6ICcxJywgYjogJzInfSwge2E6ICczJywgYjogJzQnfV0sICdhJykgPT4gWycxJywgJzMnXVxuICpgYGBgXG4gKiBAcGFyYW0gIHBhcmFtc1xuICogQHBhcmFtICBrZXlcbiAqIEBwYXJhbSAgYWxsb3dFbXB0eVxuICogQHJldHVybnMgb3V0cHV0IGp1c3QgYSBzaW1wbGUgYXJyYXkgb2Ygb3V0cHV0IGtleXNcbiAqL1xuZnVuY3Rpb24gZ2V0S2V5cyhwYXJhbXMsIGtleSwgYWxsb3dFbXB0eSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2dldEtleXNdIG1ldGhvZCBleHBlY3RzIGlucHV0ICdwYXJhbXMnIHRvIGJlIGFuIGFycmF5LCBnb3QgJHt0eXBlb2YgcGFyYW1zfWApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbZ2V0S2V5c10gbWV0aG9kIGV4cGVjdHMgaW5wdXQgJ2tleScgdG8gYmUgdHlwZSAnc3RyaW5nJywgZ290ICR7dHlwZW9mIHBhcmFtc31gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1zW2ldW2tleV07XG4gICAgICAgIGlmIChhbGxvd0VtcHR5ICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYWJpIC0gZXhwZWN0ZWQgdHlwZSAnc3RyaW5nJywgcmVjZWl2ZWQgJHt0eXBlb2YgdmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5nZXRLZXlzID0gZ2V0S2V5cztcbi8qKlxuICogSXMgdGhlIHN0cmluZyBhIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB2YWx1ZVxuICogQHBhcmFtICBsZW5ndGhcbiAqIEByZXR1cm5zICBvdXRwdXQgdGhlIHN0cmluZyBpcyBhIGhleCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gaXNIZXhTdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcm5hbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpc0hleFN0cmluZyIsImdldEtleXMiLCJmcm9tQXNjaWkiLCJmcm9tVXRmOCIsInRvQXNjaWkiLCJhcnJheUNvbnRhaW5zQXJyYXkiLCJnZXRCaW5hcnlTaXplIiwicGFkVG9FdmVuIiwic3RyaXBIZXhQcmVmaXgiLCJpc0hleFByZWZpeGVkIiwic3RyIiwiRXJyb3IiLCJzbGljZSIsImEiLCJsZW5ndGgiLCJCdWZmZXIiLCJieXRlTGVuZ3RoIiwic3VwZXJzZXQiLCJzdWJzZXQiLCJzb21lIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5kZXhPZiIsImhleCIsImkiLCJsIiwic3Vic3RyaW5nIiwiY29kZSIsInBhcnNlSW50Iiwic3Vic3RyIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwic3RyaW5nVmFsdWUiLCJmcm9tIiwidG9TdHJpbmciLCJyZXBsYWNlIiwiY2hhckNvZGVBdCIsIm4iLCJwYXJhbXMiLCJrZXkiLCJhbGxvd0VtcHR5IiwicmVzdWx0IiwicHVzaCIsIm1hdGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/internal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/object.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/object.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.defineProperties = void 0;\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/internal.js\");\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/externals.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/bytes.js\");\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param self the `Object` to define properties on\n * @param fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param data data to be validated against the definitions\n * @deprecated\n */ const defineProperties = function(self, fields, data) {\n    self.raw = [];\n    self._fields = [];\n    // attach the `toJSON`\n    self.toJSON = function(label = false) {\n        if (label) {\n            const obj = {};\n            self._fields.forEach((field)=>{\n                obj[field] = `0x${self[field].toString(\"hex\")}`;\n            });\n            return obj;\n        }\n        return (0, bytes_1.baToJSON)(self.raw);\n    };\n    self.serialize = function serialize() {\n        return externals_1.rlp.encode(self.raw);\n    };\n    fields.forEach((field, i)=>{\n        self._fields.push(field.name);\n        function getter() {\n            return self.raw[i];\n        }\n        function setter(v) {\n            v = (0, bytes_1.toBuffer)(v);\n            if (v.toString(\"hex\") === \"00\" && !field.allowZero) {\n                v = Buffer.allocUnsafe(0);\n            }\n            if (field.allowLess && field.length) {\n                v = (0, bytes_1.unpadBuffer)(v);\n                (0, assert_1.default)(field.length >= v.length, `The field ${field.name} must not have more ${field.length} bytes`);\n            } else if (!(field.allowZero && v.length === 0) && field.length) {\n                (0, assert_1.default)(field.length === v.length, `The field ${field.name} must have byte length of ${field.length}`);\n            }\n            self.raw[i] = v;\n        }\n        Object.defineProperty(self, field.name, {\n            enumerable: true,\n            configurable: true,\n            get: getter,\n            set: setter\n        });\n        if (field.default) {\n            self[field.name] = field.default;\n        }\n        // attach alias\n        if (field.alias) {\n            Object.defineProperty(self, field.alias, {\n                enumerable: false,\n                configurable: true,\n                set: setter,\n                get: getter\n            });\n        }\n    });\n    // if the constuctor is passed data\n    if (data) {\n        if (typeof data === \"string\") {\n            data = Buffer.from((0, internal_1.stripHexPrefix)(data), \"hex\");\n        }\n        if (Buffer.isBuffer(data)) {\n            data = externals_1.rlp.decode(data);\n        }\n        if (Array.isArray(data)) {\n            if (data.length > self._fields.length) {\n                throw new Error(\"wrong number of fields in data\");\n            }\n            // make sure all the items are buffers\n            data.forEach((d, i)=>{\n                self[self._fields[i]] = (0, bytes_1.toBuffer)(d);\n            });\n        } else if (typeof data === \"object\") {\n            const keys = Object.keys(data);\n            fields.forEach((field)=>{\n                if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];\n                if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];\n            });\n        } else {\n            throw new Error(\"invalid data\");\n        }\n    }\n};\nexports.defineProperties = defineProperties; //# sourceMappingURL=object.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW1qcy11dGlsQDcuMS41L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9vYmplY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHdCQUF3QixHQUFHLEtBQUs7QUFDaEMsTUFBTUcsV0FBV1IsZ0JBQWdCUyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqRCxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxrSEFBWTtBQUN2QyxNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyxvSEFBYTtBQUN6QyxNQUFNRyxVQUFVSCxtQkFBT0EsQ0FBQyw0R0FBUztBQUNqQzs7Ozs7Ozs7OztDQVVDLEdBQ0QsTUFBTUYsbUJBQW1CLFNBQVVNLElBQUksRUFBRUMsTUFBTSxFQUFFQyxJQUFJO0lBQ2pERixLQUFLRyxHQUFHLEdBQUcsRUFBRTtJQUNiSCxLQUFLSSxPQUFPLEdBQUcsRUFBRTtJQUNqQixzQkFBc0I7SUFDdEJKLEtBQUtLLE1BQU0sR0FBRyxTQUFVQyxRQUFRLEtBQUs7UUFDakMsSUFBSUEsT0FBTztZQUNQLE1BQU1DLE1BQU0sQ0FBQztZQUNiUCxLQUFLSSxPQUFPLENBQUNJLE9BQU8sQ0FBQyxDQUFDQztnQkFDbEJGLEdBQUcsQ0FBQ0UsTUFBTSxHQUFHLENBQUMsRUFBRSxFQUFFVCxJQUFJLENBQUNTLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDLE9BQU8sQ0FBQztZQUNuRDtZQUNBLE9BQU9IO1FBQ1g7UUFDQSxPQUFPLENBQUMsR0FBR1IsUUFBUVksUUFBUSxFQUFFWCxLQUFLRyxHQUFHO0lBQ3pDO0lBQ0FILEtB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QUNsQyxNQUFNUSxJQUFJLE1BQU0sQ0FBQyxHQUM5QmpCLElBQUksQ0FBQ1MsTUFBTVEsSUFBSSxDQUFDLEdBQUdmLElBQUksQ0FBQ08sTUFBTVEsSUFBSSxDQUFDO2dCQUN2QyxJQUFJeUIsS0FBS0MsT0FBTyxDQUFDbEMsTUFBTXdCLEtBQUssTUFBTSxDQUFDLEdBQy9CakMsSUFBSSxDQUFDUyxNQUFNd0IsS0FBSyxDQUFDLEdBQUcvQixJQUFJLENBQUNPLE1BQU13QixLQUFLLENBQUM7WUFDN0M7UUFDSixPQUNLO1lBQ0QsTUFBTSxJQUFJTyxNQUFNO1FBQ3BCO0lBQ0o7QUFDSjtBQUNBaEQsd0JBQXdCLEdBQUdFLGtCQUMzQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW1qcy11dGlsQDcuMS41L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9vYmplY3QuanM/MzNmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IHZvaWQgMDtcbmNvbnN0IGFzc2VydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xuY29uc3QgZXh0ZXJuYWxzXzEgPSByZXF1aXJlKFwiLi9leHRlcm5hbHNcIik7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG4vKipcbiAqIERlZmluZXMgcHJvcGVydGllcyBvbiBhIGBPYmplY3RgLiBJdCBtYWtlIHRoZSBhc3N1bXB0aW9uIHRoYXQgdW5kZXJseWluZyBkYXRhIGlzIGJpbmFyeS5cbiAqIEBwYXJhbSBzZWxmIHRoZSBgT2JqZWN0YCB0byBkZWZpbmUgcHJvcGVydGllcyBvblxuICogQHBhcmFtIGZpZWxkcyBhbiBhcnJheSBmaWVsZHMgdG8gZGVmaW5lLiBGaWVsZHMgY2FuIGNvbnRhaW46XG4gKiAqIGBuYW1lYCAtIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0aWVzXG4gKiAqIGBsZW5ndGhgIC0gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgZmllbGQgY2FuIGhhdmVcbiAqICogYGFsbG93TGVzc2AgLSBpZiB0aGUgZmllbGQgY2FuIGJlIGxlc3MgdGhhbiB0aGUgbGVuZ3RoXG4gKiAqIGBhbGxvd0VtcHR5YFxuICogQHBhcmFtIGRhdGEgZGF0YSB0byBiZSB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgZGVmaW5pdGlvbnNcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmNvbnN0IGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoc2VsZiwgZmllbGRzLCBkYXRhKSB7XG4gICAgc2VsZi5yYXcgPSBbXTtcbiAgICBzZWxmLl9maWVsZHMgPSBbXTtcbiAgICAvLyBhdHRhY2ggdGhlIGB0b0pTT05gXG4gICAgc2VsZi50b0pTT04gPSBmdW5jdGlvbiAobGFiZWwgPSBmYWxzZSkge1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICAgICAgc2VsZi5fZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgb2JqW2ZpZWxkXSA9IGAweCR7c2VsZltmaWVsZF0udG9TdHJpbmcoJ2hleCcpfWA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBieXRlc18xLmJhVG9KU09OKShzZWxmLnJhdyk7XG4gICAgfTtcbiAgICBzZWxmLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVybmFsc18xLnJscC5lbmNvZGUoc2VsZi5yYXcpO1xuICAgIH07XG4gICAgZmllbGRzLmZvckVhY2goKGZpZWxkLCBpKSA9PiB7XG4gICAgICAgIHNlbGYuX2ZpZWxkcy5wdXNoKGZpZWxkLm5hbWUpO1xuICAgICAgICBmdW5jdGlvbiBnZXR0ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5yYXdbaV07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dGVyKHYpIHtcbiAgICAgICAgICAgIHYgPSAoMCwgYnl0ZXNfMS50b0J1ZmZlcikodik7XG4gICAgICAgICAgICBpZiAodi50b1N0cmluZygnaGV4JykgPT09ICcwMCcgJiYgIWZpZWxkLmFsbG93WmVybykge1xuICAgICAgICAgICAgICAgIHYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmllbGQuYWxsb3dMZXNzICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHYgPSAoMCwgYnl0ZXNfMS51bnBhZEJ1ZmZlcikodik7XG4gICAgICAgICAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKGZpZWxkLmxlbmd0aCA+PSB2Lmxlbmd0aCwgYFRoZSBmaWVsZCAke2ZpZWxkLm5hbWV9IG11c3Qgbm90IGhhdmUgbW9yZSAke2ZpZWxkLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEoZmllbGQuYWxsb3daZXJvICYmIHYubGVuZ3RoID09PSAwKSAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoZmllbGQubGVuZ3RoID09PSB2Lmxlbmd0aCwgYFRoZSBmaWVsZCAke2ZpZWxkLm5hbWV9IG11c3QgaGF2ZSBieXRlIGxlbmd0aCBvZiAke2ZpZWxkLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmF3W2ldID0gdjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgZmllbGQubmFtZSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZ2V0dGVyLFxuICAgICAgICAgICAgc2V0OiBzZXR0ZXIsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZmllbGQuZGVmYXVsdCkge1xuICAgICAgICAgICAgc2VsZltmaWVsZC5uYW1lXSA9IGZpZWxkLmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXR0YWNoIGFsaWFzXG4gICAgICAgIGlmIChmaWVsZC5hbGlhcykge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLmFsaWFzLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNldDogc2V0dGVyLFxuICAgICAgICAgICAgICAgIGdldDogZ2V0dGVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBpZiB0aGUgY29uc3R1Y3RvciBpcyBwYXNzZWQgZGF0YVxuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbSgoMCwgaW50ZXJuYWxfMS5zdHJpcEhleFByZWZpeCkoZGF0YSksICdoZXgnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICBkYXRhID0gZXh0ZXJuYWxzXzEucmxwLmRlY29kZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gc2VsZi5fZmllbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgbnVtYmVyIG9mIGZpZWxkcyBpbiBkYXRhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgYWxsIHRoZSBpdGVtcyBhcmUgYnVmZmVyc1xuICAgICAgICAgICAgZGF0YS5mb3JFYWNoKChkLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZltzZWxmLl9maWVsZHNbaV1dID0gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICAgICAgICBmaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGZpZWxkLm5hbWUpICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZltmaWVsZC5uYW1lXSA9IGRhdGFbZmllbGQubmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGtleXMuaW5kZXhPZihmaWVsZC5hbGlhcykgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzZWxmW2ZpZWxkLmFsaWFzXSA9IGRhdGFbZmllbGQuYWxpYXNdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGF0YScpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IGRlZmluZVByb3BlcnRpZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmplY3QuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmluZVByb3BlcnRpZXMiLCJhc3NlcnRfMSIsInJlcXVpcmUiLCJpbnRlcm5hbF8xIiwiZXh0ZXJuYWxzXzEiLCJieXRlc18xIiwic2VsZiIsImZpZWxkcyIsImRhdGEiLCJyYXciLCJfZmllbGRzIiwidG9KU09OIiwibGFiZWwiLCJvYmoiLCJmb3JFYWNoIiwiZmllbGQiLCJ0b1N0cmluZyIsImJhVG9KU09OIiwic2VyaWFsaXplIiwicmxwIiwiZW5jb2RlIiwiaSIsInB1c2giLCJuYW1lIiwiZ2V0dGVyIiwic2V0dGVyIiwidiIsInRvQnVmZmVyIiwiYWxsb3daZXJvIiwiQnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJhbGxvd0xlc3MiLCJsZW5ndGgiLCJ1bnBhZEJ1ZmZlciIsImRlZmF1bHQiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwiZ2V0Iiwic2V0IiwiYWxpYXMiLCJmcm9tIiwic3RyaXBIZXhQcmVmaXgiLCJpc0J1ZmZlciIsImRlY29kZSIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yIiwiZCIsImtleXMiLCJpbmRleE9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/object.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/signature.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/signature.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\nconst secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(ssr)/./node_modules/.pnpm/ethereum-cryptography@0.1.3/node_modules/ethereum-cryptography/secp256k1.js\");\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/externals.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/bytes.js\");\nconst hash_1 = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/hash.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/helpers.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/types.js\");\nfunction ecsign(msgHash, privateKey, chainId) {\n    const { signature, recid: recovery } = (0, secp256k1_1.ecdsaSign)(msgHash, privateKey);\n    const r = Buffer.from(signature.slice(0, 32));\n    const s = Buffer.from(signature.slice(32, 64));\n    if (!chainId || typeof chainId === \"number\") {\n        // return legacy type ECDSASignature (deprecated in favor of ECDSASignatureBuffer to handle large chainIds)\n        if (chainId && !Number.isSafeInteger(chainId)) {\n            throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)\");\n        }\n        const v = chainId ? recovery + (chainId * 2 + 35) : recovery + 27;\n        return {\n            r,\n            s,\n            v\n        };\n    }\n    const chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);\n    const v = chainIdBN.muln(2).addn(35).addn(recovery).toArrayLike(Buffer);\n    return {\n        r,\n        s,\n        v\n    };\n}\nexports.ecsign = ecsign;\nfunction calculateSigRecovery(v, chainId) {\n    const vBN = (0, types_1.toType)(v, types_1.TypeOutput.BN);\n    if (vBN.eqn(0) || vBN.eqn(1)) return (0, types_1.toType)(v, types_1.TypeOutput.BN);\n    if (!chainId) {\n        return vBN.subn(27);\n    }\n    const chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);\n    return vBN.sub(chainIdBN.muln(2).addn(35));\n}\nfunction isValidSigRecovery(recovery) {\n    const rec = new externals_1.BN(recovery);\n    return rec.eqn(0) || rec.eqn(1);\n}\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @returns Recovered public key\n */ const ecrecover = function(msgHash, v, r, s, chainId) {\n    const signature = Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(s, 32)\n    ], 64);\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    const senderPubKey = (0, secp256k1_1.ecdsaRecover)(signature, recovery.toNumber(), msgHash);\n    return Buffer.from((0, secp256k1_1.publicKeyConvert)(senderPubKey, false).slice(1));\n};\nexports.ecrecover = ecrecover;\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @returns Signature\n */ const toRpcSig = function(v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n    return (0, bytes_1.bufferToHex)(Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(s, 32),\n        (0, bytes_1.toBuffer)(v)\n    ]));\n};\nexports.toRpcSig = toRpcSig;\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @returns Signature\n */ const toCompactSig = function(v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    const vn = (0, types_1.toType)(v, types_1.TypeOutput.Number);\n    let ss = s;\n    if (vn > 28 && vn % 2 === 1 || vn === 1 || vn === 28) {\n        ss = Buffer.from(s);\n        ss[0] |= 0x80;\n    }\n    return (0, bytes_1.bufferToHex)(Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(ss, 32)\n    ]));\n};\nexports.toCompactSig = toCompactSig;\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\n * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes\n * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.\n */ const fromRpcSig = function(sig) {\n    const buf = (0, bytes_1.toBuffer)(sig);\n    let r;\n    let s;\n    let v;\n    if (buf.length >= 65) {\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = (0, bytes_1.bufferToInt)(buf.slice(64));\n    } else if (buf.length === 64) {\n        // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = (0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7;\n        s[0] &= 0x7f;\n    } else {\n        throw new Error(\"Invalid signature length\");\n    }\n    // support both versions of `eth_sign` responses\n    if (v < 27) {\n        v += 27;\n    }\n    return {\n        v,\n        r,\n        s\n    };\n};\nexports.fromRpcSig = fromRpcSig;\n/**\n * Validate a ECDSA signature.\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */ const isValidSignature = function(v, r, s, homesteadOrLater = true, chainId) {\n    const SECP256K1_N_DIV_2 = new externals_1.BN(\"7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0\", 16);\n    const SECP256K1_N = new externals_1.BN(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", 16);\n    if (r.length !== 32 || s.length !== 32) {\n        return false;\n    }\n    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n        return false;\n    }\n    const rBN = new externals_1.BN(r);\n    const sBN = new externals_1.BN(s);\n    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {\n        return false;\n    }\n    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {\n        return false;\n    }\n    return true;\n};\nexports.isValidSignature = isValidSignature;\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */ const hashPersonalMessage = function(message) {\n    (0, helpers_1.assertIsBuffer)(message);\n    const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${message.length}`, \"utf-8\");\n    return (0, hash_1.keccak)(Buffer.concat([\n        prefix,\n        message\n    ]));\n};\nexports.hashPersonalMessage = hashPersonalMessage; //# sourceMappingURL=signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW1qcy11dGlsQDcuMS41L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zaWduYXR1cmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHQSx3QkFBd0IsR0FBR0Esa0JBQWtCLEdBQUdBLG9CQUFvQixHQUFHQSxnQkFBZ0IsR0FBR0EsaUJBQWlCLEdBQUdBLGNBQWMsR0FBRyxLQUFLO0FBQ2xLLE1BQU1TLGNBQWNDLG1CQUFPQSxDQUFDLCtJQUFpQztBQUM3RCxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyxvSEFBYTtBQUN6QyxNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQyw0R0FBUztBQUNqQyxNQUFNRyxTQUFTSCxtQkFBT0EsQ0FBQywwR0FBUTtBQUMvQixNQUFNSSxZQUFZSixtQkFBT0EsQ0FBQyxnSEFBVztBQUNyQyxNQUFNSyxVQUFVTCxtQkFBT0EsQ0FBQyw0R0FBUztBQUNqQyxTQUFTRixPQUFPUSxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsT0FBTztJQUN4QyxNQUFNLEVBQUVDLFNBQVMsRUFBRUMsT0FBT0MsUUFBUSxFQUFFLEdBQUcsQ0FBQyxHQUFHWixZQUFZYSxTQUFTLEVBQUVOLFNBQVNDO0lBQzNFLE1BQU1NLElBQUlDLE9BQU9DLElBQUksQ0FBQ04sVUFBVU8sS0FBSyxDQUFDLEdBQUc7SUFDekMsTUFBTUMsSUFBSUgsT0FBT0MsSUFBSSxDQUFDTixVQUFVTyxLQUFLLENBQUMsSUFBSTtJQUMxQyxJQUFJLENBQUNSLFdBQVcsT0FBT0EsWUFBWSxVQUFVO1FBQ3pDLDJHQUEyRztRQUMzRyxJQUFJQSxXQUFXLENBQUNVLE9BQU9DLGFBQWEsQ0FBQ1gsVUFBVTtZQUMzQyxNQUFNLElBQUlZLE1BQU07UUFDcEI7UUFDQSxNQUFNQyxJQUFJYixVQUFVRyxXQUFZSCxDQUFBQSxVQUFVLElBQUks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OUMsT0FBT0MsSUFBSSxDQUFDLENBQUMsZ0NBQWdDLEVBQUUyQyxRQUFRVixNQUFNLENBQUMsQ0FBQyxFQUFFO0lBQ2hGLE9BQU8sQ0FBQyxHQUFHN0MsT0FBTzBELE1BQU0sRUFBRS9DLE9BQU9zQixNQUFNLENBQUM7UUFBQ3dCO1FBQVFGO0tBQVE7QUFDN0Q7QUFDQXBFLDJCQUEyQixHQUFHRSxxQkFDOUIscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyZXVtanMtdXRpbEA3LjEuNS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2lnbmF0dXJlLmpzPzg5NWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc2hQZXJzb25hbE1lc3NhZ2UgPSBleHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBleHBvcnRzLmZyb21ScGNTaWcgPSBleHBvcnRzLnRvQ29tcGFjdFNpZyA9IGV4cG9ydHMudG9ScGNTaWcgPSBleHBvcnRzLmVjcmVjb3ZlciA9IGV4cG9ydHMuZWNzaWduID0gdm9pZCAwO1xuY29uc3Qgc2VjcDI1NmsxXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3NlY3AyNTZrMVwiKTtcbmNvbnN0IGV4dGVybmFsc18xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxzXCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuY29uc3QgaGFzaF8xID0gcmVxdWlyZShcIi4vaGFzaFwiKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5mdW5jdGlvbiBlY3NpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSwgY2hhaW5JZCkge1xuICAgIGNvbnN0IHsgc2lnbmF0dXJlLCByZWNpZDogcmVjb3ZlcnkgfSA9ICgwLCBzZWNwMjU2azFfMS5lY2RzYVNpZ24pKG1zZ0hhc2gsIHByaXZhdGVLZXkpO1xuICAgIGNvbnN0IHIgPSBCdWZmZXIuZnJvbShzaWduYXR1cmUuc2xpY2UoMCwgMzIpKTtcbiAgICBjb25zdCBzID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCkpO1xuICAgIGlmICghY2hhaW5JZCB8fCB0eXBlb2YgY2hhaW5JZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gcmV0dXJuIGxlZ2FjeSB0eXBlIEVDRFNBU2lnbmF0dXJlIChkZXByZWNhdGVkIGluIGZhdm9yIG9mIEVDRFNBU2lnbmF0dXJlQnVmZmVyIHRvIGhhbmRsZSBsYXJnZSBjaGFpbklkcylcbiAgICAgICAgaWYgKGNoYWluSWQgJiYgIU51bWJlci5pc1NhZmVJbnRlZ2VyKGNoYWluSWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBudW1iZXIgaXMgZ3JlYXRlciB0aGFuIE1BWF9TQUZFX0lOVEVHRVIgKHBsZWFzZSB1c2UgYW4gYWx0ZXJuYXRpdmUgaW5wdXQgdHlwZSknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ID0gY2hhaW5JZCA/IHJlY292ZXJ5ICsgKGNoYWluSWQgKiAyICsgMzUpIDogcmVjb3ZlcnkgKyAyNztcbiAgICAgICAgcmV0dXJuIHsgciwgcywgdiB9O1xuICAgIH1cbiAgICBjb25zdCBjaGFpbklkQk4gPSAoMCwgdHlwZXNfMS50b1R5cGUpKGNoYWluSWQsIHR5cGVzXzEuVHlwZU91dHB1dC5CTik7XG4gICAgY29uc3QgdiA9IGNoYWluSWRCTi5tdWxuKDIpLmFkZG4oMzUpLmFkZG4ocmVjb3ZlcnkpLnRvQXJyYXlMaWtlKEJ1ZmZlcik7XG4gICAgcmV0dXJuIHsgciwgcywgdiB9O1xufVxuZXhwb3J0cy5lY3NpZ24gPSBlY3NpZ247XG5mdW5jdGlvbiBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKSB7XG4gICAgY29uc3QgdkJOID0gKDAsIHR5cGVzXzEudG9UeXBlKSh2LCB0eXBlc18xLlR5cGVPdXRwdXQuQk4pO1xuICAgIGlmICh2Qk4uZXFuKDApIHx8IHZCTi5lcW4oMSkpXG4gICAgICAgIHJldHVybiAoMCwgdHlwZXNfMS50b1R5cGUpKHYsIHR5cGVzXzEuVHlwZU91dHB1dC5CTik7XG4gICAgaWYgKCFjaGFpbklkKSB7XG4gICAgICAgIHJldHVybiB2Qk4uc3VibigyNyk7XG4gICAgfVxuICAgIGNvbnN0IGNoYWluSWRCTiA9ICgwLCB0eXBlc18xLnRvVHlwZSkoY2hhaW5JZCwgdHlwZXNfMS5UeXBlT3V0cHV0LkJOKTtcbiAgICByZXR1cm4gdkJOLnN1YihjaGFpbklkQk4ubXVsbigyKS5hZGRuKDM1KSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkU2lnUmVjb3ZlcnkocmVjb3ZlcnkpIHtcbiAgICBjb25zdCByZWMgPSBuZXcgZXh0ZXJuYWxzXzEuQk4ocmVjb3ZlcnkpO1xuICAgIHJldHVybiByZWMuZXFuKDApIHx8IHJlYy5lcW4oMSk7XG59XG4vKipcbiAqIEVDRFNBIHB1YmxpYyBrZXkgcmVjb3ZlcnkgZnJvbSBzaWduYXR1cmUuXG4gKiBOT1RFOiBBY2NlcHRzIGB2ID09IDAgfCB2ID09IDFgIGZvciBFSVAxNTU5IHRyYW5zYWN0aW9uc1xuICogQHJldHVybnMgUmVjb3ZlcmVkIHB1YmxpYyBrZXlcbiAqL1xuY29uc3QgZWNyZWNvdmVyID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHYsIHIsIHMsIGNoYWluSWQpIHtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBCdWZmZXIuY29uY2F0KFsoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShyLCAzMiksICgwLCBieXRlc18xLnNldExlbmd0aExlZnQpKHMsIDMyKV0sIDY0KTtcbiAgICBjb25zdCByZWNvdmVyeSA9IGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpO1xuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcbiAgICB9XG4gICAgY29uc3Qgc2VuZGVyUHViS2V5ID0gKDAsIHNlY3AyNTZrMV8xLmVjZHNhUmVjb3Zlcikoc2lnbmF0dXJlLCByZWNvdmVyeS50b051bWJlcigpLCBtc2dIYXNoKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIHNlY3AyNTZrMV8xLnB1YmxpY0tleUNvbnZlcnQpKHNlbmRlclB1YktleSwgZmFsc2UpLnNsaWNlKDEpKTtcbn07XG5leHBvcnRzLmVjcmVjb3ZlciA9IGVjcmVjb3Zlcjtcbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgcGFyYW1ldGVycyBpbnRvIHRoZSBmb3JtYXQgb2YgYGV0aF9zaWduYCBSUEMgbWV0aG9kLlxuICogTk9URTogQWNjZXB0cyBgdiA9PSAwIHwgdiA9PSAxYCBmb3IgRUlQMTU1OSB0cmFuc2FjdGlvbnNcbiAqIEByZXR1cm5zIFNpZ25hdHVyZVxuICovXG5jb25zdCB0b1JwY1NpZyA9IGZ1bmN0aW9uICh2LCByLCBzLCBjaGFpbklkKSB7XG4gICAgY29uc3QgcmVjb3ZlcnkgPSBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKTtcbiAgICBpZiAoIWlzVmFsaWRTaWdSZWNvdmVyeShyZWNvdmVyeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gICAgfVxuICAgIC8vIGdldGggKGFuZCB0aGUgUlBDIGV0aF9zaWduIG1ldGhvZCkgdXNlcyB0aGUgNjUgYnl0ZSBmb3JtYXQgdXNlZCBieSBCaXRjb2luXG4gICAgcmV0dXJuICgwLCBieXRlc18xLmJ1ZmZlclRvSGV4KShCdWZmZXIuY29uY2F0KFsoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShyLCAzMiksICgwLCBieXRlc18xLnNldExlbmd0aExlZnQpKHMsIDMyKSwgKDAsIGJ5dGVzXzEudG9CdWZmZXIpKHYpXSkpO1xufTtcbmV4cG9ydHMudG9ScGNTaWcgPSB0b1JwY1NpZztcbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgcGFyYW1ldGVycyBpbnRvIHRoZSBmb3JtYXQgb2YgQ29tcGFjdCBTaWduYXR1cmUgUmVwcmVzZW50YXRpb24gKEVJUC0yMDk4KS5cbiAqIE5PVEU6IEFjY2VwdHMgYHYgPT0gMCB8IHYgPT0gMWAgZm9yIEVJUDE1NTkgdHJhbnNhY3Rpb25zXG4gKiBAcmV0dXJucyBTaWduYXR1cmVcbiAqL1xuY29uc3QgdG9Db21wYWN0U2lnID0gZnVuY3Rpb24gKHYsIHIsIHMsIGNoYWluSWQpIHtcbiAgICBjb25zdCByZWNvdmVyeSA9IGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpO1xuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcbiAgICB9XG4gICAgY29uc3Qgdm4gPSAoMCwgdHlwZXNfMS50b1R5cGUpKHYsIHR5cGVzXzEuVHlwZU91dHB1dC5OdW1iZXIpO1xuICAgIGxldCBzcyA9IHM7XG4gICAgaWYgKCh2biA+IDI4ICYmIHZuICUgMiA9PT0gMSkgfHwgdm4gPT09IDEgfHwgdm4gPT09IDI4KSB7XG4gICAgICAgIHNzID0gQnVmZmVyLmZyb20ocyk7XG4gICAgICAgIHNzWzBdIHw9IDB4ODA7XG4gICAgfVxuICAgIHJldHVybiAoMCwgYnl0ZXNfMS5idWZmZXJUb0hleCkoQnVmZmVyLmNvbmNhdChbKDAsIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdCkociwgMzIpLCAoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShzcywgMzIpXSkpO1xufTtcbmV4cG9ydHMudG9Db21wYWN0U2lnID0gdG9Db21wYWN0U2lnO1xuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBmb3JtYXQgb2YgdGhlIGBldGhfc2lnbmAgUlBDIG1ldGhvZCB0byBzaWduYXR1cmUgcGFyYW1ldGVyc1xuICogTk9URTogYWxsIGJlY2F1c2Ugb2YgYSBidWcgaW4gZ2V0aDogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8yMDUzXG4gKiBOT1RFOiBBZnRlciBFSVAxNTU5LCBgdmAgY291bGQgYmUgYDBgIG9yIGAxYCBidXQgdGhpcyBmdW5jdGlvbiBhc3N1bWVzXG4gKiBpdCdzIGEgc2lnbmVkIG1lc3NhZ2UgKEVJUC0xOTEgb3IgRUlQLTcxMikgYWRkaW5nIGAyN2AgYXQgdGhlIGVuZC4gUmVtb3ZlIGlmIG5lZWRlZC5cbiAqL1xuY29uc3QgZnJvbVJwY1NpZyA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICBjb25zdCBidWYgPSAoMCwgYnl0ZXNfMS50b0J1ZmZlcikoc2lnKTtcbiAgICBsZXQgcjtcbiAgICBsZXQgcztcbiAgICBsZXQgdjtcbiAgICBpZiAoYnVmLmxlbmd0aCA+PSA2NSkge1xuICAgICAgICByID0gYnVmLnNsaWNlKDAsIDMyKTtcbiAgICAgICAgcyA9IGJ1Zi5zbGljZSgzMiwgNjQpO1xuICAgICAgICB2ID0gKDAsIGJ5dGVzXzEuYnVmZmVyVG9JbnQpKGJ1Zi5zbGljZSg2NCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChidWYubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAvLyBDb21wYWN0IFNpZ25hdHVyZSBSZXByZXNlbnRhdGlvbiAoaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0yMDk4KVxuICAgICAgICByID0gYnVmLnNsaWNlKDAsIDMyKTtcbiAgICAgICAgcyA9IGJ1Zi5zbGljZSgzMiwgNjQpO1xuICAgICAgICB2ID0gKDAsIGJ5dGVzXzEuYnVmZmVyVG9JbnQpKGJ1Zi5zbGljZSgzMiwgMzMpKSA+PiA3O1xuICAgICAgICBzWzBdICY9IDB4N2Y7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aCcpO1xuICAgIH1cbiAgICAvLyBzdXBwb3J0IGJvdGggdmVyc2lvbnMgb2YgYGV0aF9zaWduYCByZXNwb25zZXNcbiAgICBpZiAodiA8IDI3KSB7XG4gICAgICAgIHYgKz0gMjc7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHYsXG4gICAgICAgIHIsXG4gICAgICAgIHMsXG4gICAgfTtcbn07XG5leHBvcnRzLmZyb21ScGNTaWcgPSBmcm9tUnBjU2lnO1xuLyoqXG4gKiBWYWxpZGF0ZSBhIEVDRFNBIHNpZ25hdHVyZS5cbiAqIE5PVEU6IEFjY2VwdHMgYHYgPT0gMCB8IHYgPT0gMWAgZm9yIEVJUDE1NTkgdHJhbnNhY3Rpb25zXG4gKiBAcGFyYW0gaG9tZXN0ZWFkT3JMYXRlciBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGJlaW5nIHVzZWQgb24gZWl0aGVyIHRoZSBob21lc3RlYWQgaGFyZGZvcmsgb3IgYSBsYXRlciBvbmVcbiAqL1xuY29uc3QgaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uICh2LCByLCBzLCBob21lc3RlYWRPckxhdGVyID0gdHJ1ZSwgY2hhaW5JZCkge1xuICAgIGNvbnN0IFNFQ1AyNTZLMV9OX0RJVl8yID0gbmV3IGV4dGVybmFsc18xLkJOKCc3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjVkNTc2ZTczNTdhNDUwMWRkZmU5MmY0NjY4MWIyMGEwJywgMTYpO1xuICAgIGNvbnN0IFNFQ1AyNTZLMV9OID0gbmV3IGV4dGVybmFsc18xLkJOKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJywgMTYpO1xuICAgIGlmIChyLmxlbmd0aCAhPT0gMzIgfHwgcy5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkU2lnUmVjb3ZlcnkoY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgckJOID0gbmV3IGV4dGVybmFsc18xLkJOKHIpO1xuICAgIGNvbnN0IHNCTiA9IG5ldyBleHRlcm5hbHNfMS5CTihzKTtcbiAgICBpZiAockJOLmlzWmVybygpIHx8IHJCTi5ndChTRUNQMjU2SzFfTikgfHwgc0JOLmlzWmVybygpIHx8IHNCTi5ndChTRUNQMjU2SzFfTikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaG9tZXN0ZWFkT3JMYXRlciAmJiBzQk4uY21wKFNFQ1AyNTZLMV9OX0RJVl8yKSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbmV4cG9ydHMuaXNWYWxpZFNpZ25hdHVyZSA9IGlzVmFsaWRTaWduYXR1cmU7XG4vKipcbiAqIFJldHVybnMgdGhlIGtlY2Nhay0yNTYgaGFzaCBvZiBgbWVzc2FnZWAsIHByZWZpeGVkIHdpdGggdGhlIGhlYWRlciB1c2VkIGJ5IHRoZSBgZXRoX3NpZ25gIFJQQyBjYWxsLlxuICogVGhlIG91dHB1dCBvZiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBmZWQgaW50byBgZWNzaWduYCB0byBwcm9kdWNlIHRoZSBzYW1lIHNpZ25hdHVyZSBhcyB0aGUgYGV0aF9zaWduYFxuICogY2FsbCBmb3IgYSBnaXZlbiBgbWVzc2FnZWAsIG9yIGZlZCB0byBgZWNyZWNvdmVyYCBhbG9uZyB3aXRoIGEgc2lnbmF0dXJlIHRvIHJlY292ZXIgdGhlIHB1YmxpYyBrZXlcbiAqIHVzZWQgdG8gcHJvZHVjZSB0aGUgc2lnbmF0dXJlLlxuICovXG5jb25zdCBoYXNoUGVyc29uYWxNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShtZXNzYWdlKTtcbiAgICBjb25zdCBwcmVmaXggPSBCdWZmZXIuZnJvbShgXFx1MDAxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcbiR7bWVzc2FnZS5sZW5ndGh9YCwgJ3V0Zi04Jyk7XG4gICAgcmV0dXJuICgwLCBoYXNoXzEua2VjY2FrKShCdWZmZXIuY29uY2F0KFtwcmVmaXgsIG1lc3NhZ2VdKSk7XG59O1xuZXhwb3J0cy5oYXNoUGVyc29uYWxNZXNzYWdlID0gaGFzaFBlcnNvbmFsTWVzc2FnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25hdHVyZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJoYXNoUGVyc29uYWxNZXNzYWdlIiwiaXNWYWxpZFNpZ25hdHVyZSIsImZyb21ScGNTaWciLCJ0b0NvbXBhY3RTaWciLCJ0b1JwY1NpZyIsImVjcmVjb3ZlciIsImVjc2lnbiIsInNlY3AyNTZrMV8xIiwicmVxdWlyZSIsImV4dGVybmFsc18xIiwiYnl0ZXNfMSIsImhhc2hfMSIsImhlbHBlcnNfMSIsInR5cGVzXzEiLCJtc2dIYXNoIiwicHJpdmF0ZUtleSIsImNoYWluSWQiLCJzaWduYXR1cmUiLCJyZWNpZCIsInJlY292ZXJ5IiwiZWNkc2FTaWduIiwiciIsIkJ1ZmZlciIsImZyb20iLCJzbGljZSIsInMiLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiRXJyb3IiLCJ2IiwiY2hhaW5JZEJOIiwidG9UeXBlIiwiVHlwZU91dHB1dCIsIkJOIiwibXVsbiIsImFkZG4iLCJ0b0FycmF5TGlrZSIsImNhbGN1bGF0ZVNpZ1JlY292ZXJ5IiwidkJOIiwiZXFuIiwic3VibiIsInN1YiIsImlzVmFsaWRTaWdSZWNvdmVyeSIsInJlYyIsImNvbmNhdCIsInNldExlbmd0aExlZnQiLCJzZW5kZXJQdWJLZXkiLCJlY2RzYVJlY292ZXIiLCJ0b051bWJlciIsInB1YmxpY0tleUNvbnZlcnQiLCJidWZmZXJUb0hleCIsInRvQnVmZmVyIiwidm4iLCJzcyIsInNpZyIsImJ1ZiIsImxlbmd0aCIsImJ1ZmZlclRvSW50IiwiaG9tZXN0ZWFkT3JMYXRlciIsIlNFQ1AyNTZLMV9OX0RJVl8yIiwiU0VDUDI1NksxX04iLCJyQk4iLCJzQk4iLCJpc1plcm8iLCJndCIsImNtcCIsIm1lc3NhZ2UiLCJhc3NlcnRJc0J1ZmZlciIsInByZWZpeCIsImtlY2NhayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/types.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/types.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToUnpaddedBuffer = exports.bnToHex = void 0;\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/externals.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/internal.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/bytes.js\");\n/**\n * Convert BN to 0x-prefixed hex string.\n */ function bnToHex(value) {\n    return `0x${value.toString(16)}`;\n}\nexports.bnToHex = bnToHex;\n/**\n * Convert value from BN to an unpadded Buffer\n * (useful for RLP transport)\n * @param value value to convert\n */ function bnToUnpaddedBuffer(value) {\n    // Using `bn.toArrayLike(Buffer)` instead of `bn.toBuffer()`\n    // for compatibility with browserify and similar tools\n    return (0, bytes_1.unpadBuffer)(value.toArrayLike(Buffer));\n}\nexports.bnToUnpaddedBuffer = bnToUnpaddedBuffer;\n/**\n * Deprecated alias for {@link bnToUnpaddedBuffer}\n * @deprecated\n */ function bnToRlp(value) {\n    return bnToUnpaddedBuffer(value);\n}\nexports.bnToRlp = bnToRlp;\n/**\n * Type output options\n */ var TypeOutput;\n(function(TypeOutput) {\n    TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n    TypeOutput[TypeOutput[\"BN\"] = 1] = \"BN\";\n    TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n    TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\nfunction toType(input, outputType) {\n    if (input === null) {\n        return null;\n    }\n    if (input === undefined) {\n        return undefined;\n    }\n    if (typeof input === \"string\" && !(0, internal_1.isHexString)(input)) {\n        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);\n    } else if (typeof input === \"number\" && !Number.isSafeInteger(input)) {\n        throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)\");\n    }\n    const output = (0, bytes_1.toBuffer)(input);\n    if (outputType === TypeOutput.Buffer) {\n        return output;\n    } else if (outputType === TypeOutput.BN) {\n        return new externals_1.BN(output);\n    } else if (outputType === TypeOutput.Number) {\n        const bn = new externals_1.BN(output);\n        const max = new externals_1.BN(Number.MAX_SAFE_INTEGER.toString());\n        if (bn.gt(max)) {\n            throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)\");\n        }\n        return bn.toNumber();\n    } else {\n        // outputType === TypeOutput.PrefixedHexString\n        return `0x${output.toString(\"hex\")}`;\n    }\n}\nexports.toType = toType; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW1qcy11dGlsQDcuMS41L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHQSxrQkFBa0IsR0FBR0EsZUFBZSxHQUFHQSwwQkFBMEIsR0FBR0EsZUFBZSxHQUFHLEtBQUs7QUFDNUcsTUFBTU8sY0FBY0MsbUJBQU9BLENBQUMsb0hBQWE7QUFDekMsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsa0hBQVk7QUFDdkMsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsNEdBQVM7QUFDakM7O0NBRUMsR0FDRCxTQUFTRixRQUFRTCxLQUFLO0lBQ2xCLE9BQU8sQ0FBQyxFQUFFLEVBQUVBLE1BQU1VLFFBQVEsQ0FBQyxJQUFJLENBQUM7QUFDcEM7QUFDQVgsZUFBZSxHQUFHTTtBQUNsQjs7OztDQUlDLEdBQ0QsU0FBU0QsbUJBQW1CSixLQUFLO0lBQzdCLDREQUE0RDtJQUM1RCxzREFBc0Q7SUFDdEQsT0FBTyxDQUFDLEdBQUdTLFFBQVFFLFdBQVcsRUFBRVgsTUFBTVksV0FBVyxDQUFDQztBQUN0RDtBQUNBZCwwQkFBMEIsR0FBR0s7QUFDN0I7OztDQUdDLEdBQ0QsU0FBU0QsUUFBUUgsS0FBSztJQUNsQixPQUFPSSxtQkFBbUJKO0FBQzlCO0FBQ0FELGVBQWUsR0FBR0k7QUFDbEI7O0NBRUMsR0FDRCxJQUFJRDtBQUNILFVBQVVBLFVBQVU7SUFDakJBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDdkNBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLEtBQUssR0FBRyxFQUFFLEdBQUc7SUFDbkNBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDdkNBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLG9CQUFvQixHQUFHLEVBQUUsR0FBRztBQUN0RCxHQUFHQSxhQUFhSCxRQUFRRyxVQUFVLElBQUtILENBQUFBLGtCQUFrQixHQUFHLENBQUM7QUFDN0QsU0FBU0UsT0FBT2EsS0FBSyxFQUFFQyxVQUFVO0lBQzdCLElBQUlELFVBQVUsTUFBTTtRQUNoQixPQUFPO0lBQ1g7SUFDQSxJQUFJQSxVQUFVRSxXQUFXO1FBQ3JCLE9BQU9BO0lBQ1g7SUFDQSxJQUFJLE9BQU9GLFVBQVUsWUFBWSxDQUFDLENBQUMsR0FBR04sV0FBV1MsV0FBVyxFQUFFSCxRQUFRO1FBQ2xFLE1BQU0sSUFBSUksTUFBTSxDQUFDLG1EQUFtRCxFQUFFSixNQUFNLENBQUM7SUFDakYsT0FDSyxJQUFJLE9BQU9BLFVBQVUsWUFBWSxDQUFDSyxPQUFPQyxhQUFhLENBQUNOLFFBQVE7UUFDaEUsTUFBTSxJQUFJSSxNQUFNO0lBQ3BCO0lBQ0EsTUFBTUcsU0FBUyxDQUFDLEdBQUdaLFFBQVFhLFFBQVEsRUFBRVI7SUFDckMsSUFBSUMsZUFBZWIsV0FBV1csTUFBTSxFQUFFO1FBQ2xDLE9BQU9RO0lBQ1gsT0FDSyxJQUFJTixlQUFlYixXQUFXcUIsRUFBRSxFQUFFO1FBQ25DLE9BQU8sSUFBSWpCLFlBQVlpQixFQUFFLENBQUNGO0lBQzlCLE9BQ0ssSUFBSU4sZUFBZWIsV0FBV2lCLE1BQU0sRUFBRTtRQUN2QyxNQUFNSyxLQUFLLElBQUlsQixZQUFZaUIsRUFBRSxDQUFDRjtRQUM5QixNQUFNSSxNQUFNLElBQUluQixZQUFZaUIsRUFBRSxDQUFDSixPQUFPTyxnQkFBZ0IsQ0FBQ2hCLFFBQVE7UUFDL0QsSUFBSWMsR0FBR0csRUFBRSxDQUFDRixNQUFNO1lBQ1osTUFBTSxJQUFJUCxNQUFNO1FBQ3BCO1FBQ0EsT0FBT00sR0FBR0ksUUFBUTtJQUN0QixPQUNLO1FBQ0QsOENBQThDO1FBQzlDLE9BQU8sQ0FBQyxFQUFFLEVBQUVQLE9BQU9YLFFBQVEsQ0FBQyxPQUFPLENBQUM7SUFDeEM7QUFDSjtBQUNBWCxjQUFjLEdBQUdFLFFBQ2pCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy8ucG5wbS9ldGhlcmV1bWpzLXV0aWxANy4xLjUvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3R5cGVzLmpzPzg0YzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvVHlwZSA9IGV4cG9ydHMuVHlwZU91dHB1dCA9IGV4cG9ydHMuYm5Ub1JscCA9IGV4cG9ydHMuYm5Ub1VucGFkZGVkQnVmZmVyID0gZXhwb3J0cy5iblRvSGV4ID0gdm9pZCAwO1xuY29uc3QgZXh0ZXJuYWxzXzEgPSByZXF1aXJlKFwiLi9leHRlcm5hbHNcIik7XG5jb25zdCBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG4vKipcbiAqIENvbnZlcnQgQk4gdG8gMHgtcHJlZml4ZWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYm5Ub0hleCh2YWx1ZSkge1xuICAgIHJldHVybiBgMHgke3ZhbHVlLnRvU3RyaW5nKDE2KX1gO1xufVxuZXhwb3J0cy5iblRvSGV4ID0gYm5Ub0hleDtcbi8qKlxuICogQ29udmVydCB2YWx1ZSBmcm9tIEJOIHRvIGFuIHVucGFkZGVkIEJ1ZmZlclxuICogKHVzZWZ1bCBmb3IgUkxQIHRyYW5zcG9ydClcbiAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSB0byBjb252ZXJ0XG4gKi9cbmZ1bmN0aW9uIGJuVG9VbnBhZGRlZEJ1ZmZlcih2YWx1ZSkge1xuICAgIC8vIFVzaW5nIGBibi50b0FycmF5TGlrZShCdWZmZXIpYCBpbnN0ZWFkIG9mIGBibi50b0J1ZmZlcigpYFxuICAgIC8vIGZvciBjb21wYXRpYmlsaXR5IHdpdGggYnJvd3NlcmlmeSBhbmQgc2ltaWxhciB0b29sc1xuICAgIHJldHVybiAoMCwgYnl0ZXNfMS51bnBhZEJ1ZmZlcikodmFsdWUudG9BcnJheUxpa2UoQnVmZmVyKSk7XG59XG5leHBvcnRzLmJuVG9VbnBhZGRlZEJ1ZmZlciA9IGJuVG9VbnBhZGRlZEJ1ZmZlcjtcbi8qKlxuICogRGVwcmVjYXRlZCBhbGlhcyBmb3Ige0BsaW5rIGJuVG9VbnBhZGRlZEJ1ZmZlcn1cbiAqIEBkZXByZWNhdGVkXG4gKi9cbmZ1bmN0aW9uIGJuVG9SbHAodmFsdWUpIHtcbiAgICByZXR1cm4gYm5Ub1VucGFkZGVkQnVmZmVyKHZhbHVlKTtcbn1cbmV4cG9ydHMuYm5Ub1JscCA9IGJuVG9SbHA7XG4vKipcbiAqIFR5cGUgb3V0cHV0IG9wdGlvbnNcbiAqL1xudmFyIFR5cGVPdXRwdXQ7XG4oZnVuY3Rpb24gKFR5cGVPdXRwdXQpIHtcbiAgICBUeXBlT3V0cHV0W1R5cGVPdXRwdXRbXCJOdW1iZXJcIl0gPSAwXSA9IFwiTnVtYmVyXCI7XG4gICAgVHlwZU91dHB1dFtUeXBlT3V0cHV0W1wiQk5cIl0gPSAxXSA9IFwiQk5cIjtcbiAgICBUeXBlT3V0cHV0W1R5cGVPdXRwdXRbXCJCdWZmZXJcIl0gPSAyXSA9IFwiQnVmZmVyXCI7XG4gICAgVHlwZU91dHB1dFtUeXBlT3V0cHV0W1wiUHJlZml4ZWRIZXhTdHJpbmdcIl0gPSAzXSA9IFwiUHJlZml4ZWRIZXhTdHJpbmdcIjtcbn0pKFR5cGVPdXRwdXQgPSBleHBvcnRzLlR5cGVPdXRwdXQgfHwgKGV4cG9ydHMuVHlwZU91dHB1dCA9IHt9KSk7XG5mdW5jdGlvbiB0b1R5cGUoaW5wdXQsIG91dHB1dFR5cGUpIHtcbiAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnICYmICEoMCwgaW50ZXJuYWxfMS5pc0hleFN0cmluZykoaW5wdXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBzdHJpbmcgbXVzdCBiZSBwcm92aWRlZCB3aXRoIGEgMHgtcHJlZml4LCBnaXZlbjogJHtpbnB1dH1gKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyAmJiAhTnVtYmVyLmlzU2FmZUludGVnZXIoaW5wdXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIG51bWJlciBpcyBncmVhdGVyIHRoYW4gTUFYX1NBRkVfSU5URUdFUiAocGxlYXNlIHVzZSBhbiBhbHRlcm5hdGl2ZSBpbnB1dCB0eXBlKScpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSAoMCwgYnl0ZXNfMS50b0J1ZmZlcikoaW5wdXQpO1xuICAgIGlmIChvdXRwdXRUeXBlID09PSBUeXBlT3V0cHV0LkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBlbHNlIGlmIChvdXRwdXRUeXBlID09PSBUeXBlT3V0cHV0LkJOKSB7XG4gICAgICAgIHJldHVybiBuZXcgZXh0ZXJuYWxzXzEuQk4ob3V0cHV0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3V0cHV0VHlwZSA9PT0gVHlwZU91dHB1dC5OdW1iZXIpIHtcbiAgICAgICAgY29uc3QgYm4gPSBuZXcgZXh0ZXJuYWxzXzEuQk4ob3V0cHV0KTtcbiAgICAgICAgY29uc3QgbWF4ID0gbmV3IGV4dGVybmFsc18xLkJOKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoYm4uZ3QobWF4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBNQVhfU0FGRV9JTlRFR0VSIChwbGVhc2UgdXNlIGFuIGFsdGVybmF0aXZlIG91dHB1dCB0eXBlKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibi50b051bWJlcigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gb3V0cHV0VHlwZSA9PT0gVHlwZU91dHB1dC5QcmVmaXhlZEhleFN0cmluZ1xuICAgICAgICByZXR1cm4gYDB4JHtvdXRwdXQudG9TdHJpbmcoJ2hleCcpfWA7XG4gICAgfVxufVxuZXhwb3J0cy50b1R5cGUgPSB0b1R5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0b1R5cGUiLCJUeXBlT3V0cHV0IiwiYm5Ub1JscCIsImJuVG9VbnBhZGRlZEJ1ZmZlciIsImJuVG9IZXgiLCJleHRlcm5hbHNfMSIsInJlcXVpcmUiLCJpbnRlcm5hbF8xIiwiYnl0ZXNfMSIsInRvU3RyaW5nIiwidW5wYWRCdWZmZXIiLCJ0b0FycmF5TGlrZSIsIkJ1ZmZlciIsImlucHV0Iiwib3V0cHV0VHlwZSIsInVuZGVmaW5lZCIsImlzSGV4U3RyaW5nIiwiRXJyb3IiLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwib3V0cHV0IiwidG9CdWZmZXIiLCJCTiIsImJuIiwibWF4IiwiTUFYX1NBRkVfSU5URUdFUiIsImd0IiwidG9OdW1iZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/types.js\n");

/***/ })

};
;