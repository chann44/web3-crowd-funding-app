"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web3-utils@1.10.3";
exports.ids = ["vendor-chunks/web3-utils@1.10.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/web3-utils@1.10.3/node_modules/web3-utils/lib/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/web3-utils@1.10.3/node_modules/web3-utils/lib/index.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */ /**\n * @file utils.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */ \nvar ethjsUnit = __webpack_require__(/*! ethjs-unit */ \"(ssr)/./node_modules/.pnpm/ethjs-unit@0.1.6/node_modules/ethjs-unit/lib/index.js\");\nvar utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/web3-utils@1.10.3/node_modules/web3-utils/lib/utils.js\");\nvar soliditySha3 = __webpack_require__(/*! ./soliditySha3.js */ \"(ssr)/./node_modules/.pnpm/web3-utils@1.10.3/node_modules/web3-utils/lib/soliditySha3.js\");\nvar randombytes = __webpack_require__(/*! randombytes */ \"(ssr)/./node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/index.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\");\n/**\n * Fires an error in an event emitter and callback and returns the eventemitter\n *\n * @method _fireError\n * @param {Object} error a string, a error, or an object with {message, data}\n * @param {Object} emitter\n * @param {Function} reject\n * @param {Function} callback\n * @param {any} optionalData\n * @return {Object} the emitter\n */ var _fireError = function(error, emitter, reject, callback, optionalData) {\n    /*jshint maxcomplexity: 10 */ // add data if given\n    if (!!error && typeof error === \"object\" && !(error instanceof Error) && error.data) {\n        if (!!error.data && typeof error.data === \"object\" || Array.isArray(error.data)) {\n            error.data = JSON.stringify(error.data, null, 2);\n        }\n        error = error.message + \"\\n\" + error.data;\n    }\n    if (typeof error === \"string\") {\n        error = new Error(error);\n    }\n    if (typeof callback === \"function\") {\n        callback(error, optionalData);\n    }\n    if (typeof reject === \"function\") {\n        // suppress uncatched error if an error listener is present\n        // OR suppress uncatched error if an callback listener is present\n        if (emitter && typeof emitter.listeners === \"function\" && emitter.listeners(\"error\").length || typeof callback === \"function\") {\n            emitter.catch(function() {});\n        }\n        // reject later, to be able to return emitter\n        setTimeout(function() {\n            reject(error);\n        }, 1);\n    }\n    if (emitter && typeof emitter.emit === \"function\") {\n        // emit later, to be able to return emitter\n        setTimeout(function() {\n            emitter.emit(\"error\", error, optionalData);\n            emitter.removeAllListeners();\n        }, 1);\n    }\n    return emitter;\n};\n/**\n * Should be used to create full function/event name from json abi\n *\n * @method _jsonInterfaceMethodToString\n * @param {Object} json\n * @return {String} full function/event name\n */ var _jsonInterfaceMethodToString = function(json) {\n    if (!!json && typeof json === \"object\" && json.name && json.name.indexOf(\"(\") !== -1) {\n        return json.name;\n    }\n    return json.name + \"(\" + _flattenTypes(false, json.inputs).join(\",\") + \")\";\n};\n/**\n * Should be used to flatten json abi inputs/outputs into an array of type-representing-strings\n *\n * @method _flattenTypes\n * @param {bool} includeTuple\n * @param {Object} puts\n * @return {Array} parameters as strings\n */ var _flattenTypes = function(includeTuple, puts) {\n    // console.log(\"entered _flattenTypes. inputs/outputs: \" + puts)\n    var types = [];\n    puts.forEach(function(param) {\n        if (typeof param.components === \"object\") {\n            if (param.type.substring(0, 5) !== \"tuple\") {\n                throw new Error(\"components found but type is not tuple; report on GitHub\");\n            }\n            var suffix = \"\";\n            var arrayBracket = param.type.indexOf(\"[\");\n            if (arrayBracket >= 0) {\n                suffix = param.type.substring(arrayBracket);\n            }\n            var result = _flattenTypes(includeTuple, param.components);\n            // console.log(\"result should have things: \" + result)\n            if (Array.isArray(result) && includeTuple) {\n                // console.log(\"include tuple word, and its an array. joining...: \" + result.types)\n                types.push(\"tuple(\" + result.join(\",\") + \")\" + suffix);\n            } else if (!includeTuple) {\n                // console.log(\"don't include tuple, but its an array. joining...: \" + result)\n                types.push(\"(\" + result.join(\",\") + \")\" + suffix);\n            } else {\n                // console.log(\"its a single type within a tuple: \" + result.types)\n                types.push(\"(\" + result + \")\");\n            }\n        } else {\n            // console.log(\"its a type and not directly in a tuple: \" + param.type)\n            types.push(param.type);\n        }\n    });\n    return types;\n};\n/**\n * Returns a random hex string by the given bytes size\n *\n * @param {Number} size\n * @returns {string}\n */ var randomHex = function(size) {\n    return \"0x\" + randombytes(size).toString(\"hex\");\n};\n/**\n * Should be called to get ascii from it's hex representation\n *\n * @method hexToAscii\n * @param {String} hex\n * @returns {String} ascii string representation of hex value\n */ var hexToAscii = function(hex) {\n    if (!utils.isHexStrict(hex)) throw new Error(\"The parameter must be a valid HEX string.\");\n    var str = \"\";\n    var i = 0, l = hex.length;\n    if (hex.substring(0, 2) === \"0x\") {\n        i = 2;\n    }\n    for(; i < l; i += 2){\n        var code = parseInt(hex.slice(i, i + 2), 16);\n        str += String.fromCharCode(code);\n    }\n    return str;\n};\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @method asciiToHex\n * @param {String} str\n * @returns {String} hex representation of input string\n */ var asciiToHex = function(str) {\n    if (!str) return \"0x00\";\n    var hex = \"\";\n    for(var i = 0; i < str.length; i++){\n        var code = str.charCodeAt(i);\n        var n = code.toString(16);\n        hex += n.length < 2 ? \"0\" + n : n;\n    }\n    return \"0x\" + hex;\n};\n/**\n * Returns value of unit in Wei\n *\n * @method getUnitValue\n * @param {String} unit the unit to convert to, default ether\n * @returns {BN} value of the unit (in Wei)\n * @throws error if the unit is not correct:w\n */ var getUnitValue = function(unit) {\n    unit = unit ? unit.toLowerCase() : \"ether\";\n    if (!ethjsUnit.unitMap[unit]) {\n        throw new Error('This unit \"' + unit + \"\\\" doesn't exist, please use the one of the following units\" + JSON.stringify(ethjsUnit.unitMap, null, 2));\n    }\n    return unit;\n};\n/**\n * Takes a number of wei and converts it to any other ether unit.\n *\n * Possible units are:\n *   SI Short   SI Full        Effigy       Other\n * - kwei       femtoether     babbage\n * - mwei       picoether      lovelace\n * - gwei       nanoether      shannon      nano\n * - --         microether     szabo        micro\n * - --         milliether     finney       milli\n * - ether      --             --\n * - kether                    --           grand\n * - mether\n * - gether\n * - tether\n *\n * @method fromWei\n * @param {Number|String} number can be a number, number string or a HEX of a decimal\n * @param {String} unit the unit to convert to, default ether\n * @return {String|Object} When given a BN object it returns one as well, otherwise a number\n */ var fromWei = function(number, unit) {\n    unit = getUnitValue(unit);\n    if (!utils.isBN(number) && !(typeof number === \"string\")) {\n        throw new Error(\"Please pass numbers as strings or BN objects to avoid precision errors.\");\n    }\n    return utils.isBN(number) ? ethjsUnit.fromWei(number, unit) : ethjsUnit.fromWei(number, unit).toString(10);\n};\n/**\n * Takes a number of a unit and converts it to wei.\n *\n * Possible units are:\n *   SI Short   SI Full        Effigy       Other\n * - kwei       femtoether     babbage\n * - mwei       picoether      lovelace\n * - gwei       nanoether      shannon      nano\n * - --         microether     szabo        micro\n * - --         microether     szabo        micro\n * - --         milliether     finney       milli\n * - ether      --             --\n * - kether                    --           grand\n * - mether\n * - gether\n * - tether\n *\n * @method toWei\n * @param {Number|String|BN} number can be a number, number string or a HEX of a decimal\n * @param {String} unit the unit to convert from, default ether\n * @return {String|Object} When given a BN object it returns one as well, otherwise a number\n */ var toWei = function(number, unit) {\n    unit = getUnitValue(unit);\n    if (!utils.isBN(number) && !(typeof number === \"string\")) {\n        throw new Error(\"Please pass numbers as strings or BN objects to avoid precision errors.\");\n    }\n    return utils.isBN(number) ? ethjsUnit.toWei(number, unit) : ethjsUnit.toWei(number, unit).toString(10);\n};\n/**\n * Converts to a checksum address\n *\n * @method toChecksumAddress\n * @param {String} address the given HEX address\n * @return {String}\n */ var toChecksumAddress = function(address) {\n    if (typeof address === \"undefined\") return \"\";\n    if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) throw new Error('Given address \"' + address + '\" is not a valid Ethereum address.');\n    address = address.toLowerCase().replace(/^0x/i, \"\");\n    var addressHash = utils.sha3(address).replace(/^0x/i, \"\");\n    var checksumAddress = \"0x\";\n    for(var i = 0; i < address.length; i++){\n        // If ith character is 8 to f then make it uppercase\n        if (parseInt(addressHash[i], 16) > 7) {\n            checksumAddress += address[i].toUpperCase();\n        } else {\n            checksumAddress += address[i];\n        }\n    }\n    return checksumAddress;\n};\n/**\n * Returns -1 if a<b, 1 if a>b; 0 if a == b.\n * For more details on this type of function, see\n * developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n * Block tag `safe` and `block number` combination param is not supported\n * @method compareBlockNumbers\n *\n * @param {String|Number|BN} a\n *\n * @param {String|Number|BN} b\n *\n * @returns {Number} -1, 0, or 1\n */ var compareBlockNumbers = function(a, b) {\n    // Increasing order: (genesis = earliest), safe, (finalized ~ latest), pending\n    // safe vs block-num cant be compared as block number provided can be on left or right side of safe tag, until safe tag block number is extracted and compared\n    if (a === b) {\n        return 0;\n    } else if ((\"genesis\" === a || \"earliest\" === a || 0 === a) && (\"genesis\" === b || \"earliest\" === b || 0 === b)) {\n        return 0;\n    } else if (\"genesis\" === a || \"earliest\" === a || a === 0) {\n        // b !== a, thus a < b\n        return -1;\n    } else if (\"genesis\" === b || \"earliest\" === b || b === 0) {\n        // b !== a, thus a > b\n        return 1;\n    } else if (a === \"latest\" || a === \"finalized\") {\n        if (b === \"pending\") {\n            return -1;\n        } else {\n            // b !== (\"pending\" OR \"latest\"), thus a > b\n            return 1;\n        }\n    } else if (b === \"latest\" || b === \"finalized\") {\n        if (a === \"pending\") {\n            return 1;\n        } else {\n            // b !== (\"pending\" OR \"latest\"), thus a > b\n            return -1;\n        }\n    } else if (a === \"pending\") {\n        // b (== OR <) \"latest\", thus a > b\n        return 1;\n    } else if (b === \"pending\") {\n        return -1;\n    } else if (a === \"safe\" || b === \"safe\") {\n        // either a or b is \"safe\" and the other one did not fall into any of the conditions above, so the other one is a number\n        return undefined;\n    } else {\n        let bnA = new BN(a);\n        let bnB = new BN(b);\n        if (bnA.lt(bnB)) {\n            return -1;\n        } else if (bnA.eq(bnB)) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n};\nmodule.exports = {\n    _fireError: _fireError,\n    _jsonInterfaceMethodToString: _jsonInterfaceMethodToString,\n    _flattenTypes: _flattenTypes,\n    // extractDisplayName: extractDisplayName,\n    // extractTypeName: extractTypeName,\n    randomHex: randomHex,\n    BN: utils.BN,\n    isBN: utils.isBN,\n    isBigNumber: utils.isBigNumber,\n    isHex: utils.isHex,\n    isHexStrict: utils.isHexStrict,\n    sha3: utils.sha3,\n    sha3Raw: utils.sha3Raw,\n    keccak256: utils.sha3,\n    soliditySha3: soliditySha3.soliditySha3,\n    soliditySha3Raw: soliditySha3.soliditySha3Raw,\n    encodePacked: soliditySha3.encodePacked,\n    isAddress: utils.isAddress,\n    checkAddressChecksum: utils.checkAddressChecksum,\n    toChecksumAddress: toChecksumAddress,\n    toHex: utils.toHex,\n    toBN: utils.toBN,\n    bytesToHex: utils.bytesToHex,\n    hexToBytes: utils.hexToBytes,\n    hexToNumberString: utils.hexToNumberString,\n    hexToNumber: utils.hexToNumber,\n    toDecimal: utils.hexToNumber,\n    numberToHex: utils.numberToHex,\n    fromDecimal: utils.numberToHex,\n    hexToUtf8: utils.hexToUtf8,\n    hexToString: utils.hexToUtf8,\n    toUtf8: utils.hexToUtf8,\n    stripHexPrefix: utils.stripHexPrefix,\n    utf8ToHex: utils.utf8ToHex,\n    stringToHex: utils.utf8ToHex,\n    fromUtf8: utils.utf8ToHex,\n    hexToAscii: hexToAscii,\n    toAscii: hexToAscii,\n    asciiToHex: asciiToHex,\n    fromAscii: asciiToHex,\n    unitMap: ethjsUnit.unitMap,\n    toWei: toWei,\n    fromWei: fromWei,\n    padLeft: utils.leftPad,\n    leftPad: utils.leftPad,\n    padRight: utils.rightPad,\n    rightPad: utils.rightPad,\n    toTwosComplement: utils.toTwosComplement,\n    isBloom: utils.isBloom,\n    isUserEthereumAddressInBloom: utils.isUserEthereumAddressInBloom,\n    isContractAddressInBloom: utils.isContractAddressInBloom,\n    isTopic: utils.isTopic,\n    isTopicInBloom: utils.isTopicInBloom,\n    isInBloom: utils.isInBloom,\n    compareBlockNumbers: compareBlockNumbers,\n    toNumber: utils.toNumber\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViMy11dGlsc0AxLjEwLjMvbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEOzs7OztDQUtDO0FBQ0QsSUFBSUEsWUFBWUMsbUJBQU9BLENBQUM7QUFDeEIsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsZUFBZUYsbUJBQU9BLENBQUM7QUFDM0IsSUFBSUcsY0FBY0gsbUJBQU9BLENBQUM7QUFDMUIsSUFBSUksS0FBS0osbUJBQU9BLENBQUM7QUFDakI7Ozs7Ozs7Ozs7Q0FVQyxHQUNELElBQUlLLGFBQWEsU0FBVUMsS0FBSyxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxZQUFZO0lBQ3JFLDJCQUEyQixHQUMzQixvQkFBb0I7SUFDcEIsSUFBSSxDQUFDLENBQUNKLFNBQVMsT0FBT0EsVUFBVSxZQUFZLENBQUVBLENBQUFBLGlCQUFpQkssS0FBSSxLQUFNTCxNQUFNTSxJQUFJLEVBQUU7UUFDakYsSUFBSSxDQUFDLENBQUNOLE1BQU1NLElBQUksSUFBSSxPQUFPTixNQUFNTSxJQUFJLEtBQUssWUFBWUMsTUFBTUMsT0FBTyxDQUFDUixNQUFNTSxJQUFJLEdBQUc7WUFDN0VOLE1BQU1NLElBQUksR0FBR0csS0FBS0MsU0FBUyxDQUFDVixNQUFNTSxJQUFJLEVBQUUsTUFBTTtRQUNsRDtRQUNBTixRQUFRQSxNQUFNVyxPQUFPLEdBQUcsT0FBT1gsTUFBTU0sSUFBSTtJQUM3QztJQUNBLElBQUksT0FBT04sVUFBVSxVQUFVO1FBQzNCQSxRQUFRLElBQUlLLE1BQU1MO0lBQ3RCO0lBQ0EsSUFBSSxPQUFPRyxhQUFhLFlBQVk7UUFDaENBLFNBQVNILE9BQU9JO0lBQ3BCO0lBQ0EsSUFBSSxPQUFPRixXQUFXLFlBQVk7UUFDOUIsMkRBQTJEO1FBQzNELGlFQUFpRTtRQUNqRSxJQUFJRCxX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SUFDVGdELFNBQVMvRyxNQUFNZ0gsT0FBTztJQUN0QkEsU0FBU2hILE1BQU1nSCxPQUFPO0lBQ3RCQyxVQUFVakgsTUFBTWtILFFBQVE7SUFDeEJBLFVBQVVsSCxNQUFNa0gsUUFBUTtJQUN4QkMsa0JBQWtCbkgsTUFBTW1ILGdCQUFnQjtJQUN4Q0MsU0FBU3BILE1BQU1vSCxPQUFPO0lBQ3RCQyw4QkFBOEJySCxNQUFNcUgsNEJBQTRCO0lBQ2hFQywwQkFBMEJ0SCxNQUFNc0gsd0JBQXdCO0lBQ3hEQyxTQUFTdkgsTUFBTXVILE9BQU87SUFDdEJDLGdCQUFnQnhILE1BQU13SCxjQUFjO0lBQ3BDQyxXQUFXekgsTUFBTXlILFNBQVM7SUFDMUI5QyxxQkFBcUJBO0lBQ3JCK0MsVUFBVTFILE1BQU0wSCxRQUFRO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYjMtdXRpbHNAMS4xMC4zL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9pbmRleC5qcz9hNTM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuLyoqXG4gKiBAZmlsZSB1dGlscy5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAcGFyaXR5LmlvPlxuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxN1xuICovXG52YXIgZXRoanNVbml0ID0gcmVxdWlyZSgnZXRoanMtdW5pdCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy5qcycpO1xudmFyIHNvbGlkaXR5U2hhMyA9IHJlcXVpcmUoJy4vc29saWRpdHlTaGEzLmpzJyk7XG52YXIgcmFuZG9tYnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbi8qKlxuICogRmlyZXMgYW4gZXJyb3IgaW4gYW4gZXZlbnQgZW1pdHRlciBhbmQgY2FsbGJhY2sgYW5kIHJldHVybnMgdGhlIGV2ZW50ZW1pdHRlclxuICpcbiAqIEBtZXRob2QgX2ZpcmVFcnJvclxuICogQHBhcmFtIHtPYmplY3R9IGVycm9yIGEgc3RyaW5nLCBhIGVycm9yLCBvciBhbiBvYmplY3Qgd2l0aCB7bWVzc2FnZSwgZGF0YX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbWl0dGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueX0gb3B0aW9uYWxEYXRhXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBlbWl0dGVyXG4gKi9cbnZhciBfZmlyZUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBlbWl0dGVyLCByZWplY3QsIGNhbGxiYWNrLCBvcHRpb25hbERhdGEpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OiAxMCAqL1xuICAgIC8vIGFkZCBkYXRhIGlmIGdpdmVuXG4gICAgaWYgKCEhZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpICYmIGVycm9yLmRhdGEpIHtcbiAgICAgICAgaWYgKCEhZXJyb3IuZGF0YSAmJiB0eXBlb2YgZXJyb3IuZGF0YSA9PT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShlcnJvci5kYXRhKSkge1xuICAgICAgICAgICAgZXJyb3IuZGF0YSA9IEpTT04uc3RyaW5naWZ5KGVycm9yLmRhdGEsIG51bGwsIDIpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yID0gZXJyb3IubWVzc2FnZSArIFwiXFxuXCIgKyBlcnJvci5kYXRhO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIG9wdGlvbmFsRGF0YSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVqZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIHN1cHByZXNzIHVuY2F0Y2hlZCBlcnJvciBpZiBhbiBlcnJvciBsaXN0ZW5lciBpcyBwcmVzZW50XG4gICAgICAgIC8vIE9SIHN1cHByZXNzIHVuY2F0Y2hlZCBlcnJvciBpZiBhbiBjYWxsYmFjayBsaXN0ZW5lciBpcyBwcmVzZW50XG4gICAgICAgIGlmIChlbWl0dGVyICYmXG4gICAgICAgICAgICAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgZW1pdHRlci5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoKSB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIuY2F0Y2goZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWplY3QgbGF0ZXIsIHRvIGJlIGFibGUgdG8gcmV0dXJuIGVtaXR0ZXJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9LCAxKTtcbiAgICB9XG4gICAgaWYgKGVtaXR0ZXIgJiYgdHlwZW9mIGVtaXR0ZXIuZW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBlbWl0IGxhdGVyLCB0byBiZSBhYmxlIHRvIHJldHVybiBlbWl0dGVyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdlcnJvcicsIGVycm9yLCBvcHRpb25hbERhdGEpO1xuICAgICAgICAgICAgZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgfSwgMSk7XG4gICAgfVxuICAgIHJldHVybiBlbWl0dGVyO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGZ1bGwgZnVuY3Rpb24vZXZlbnQgbmFtZSBmcm9tIGpzb24gYWJpXG4gKlxuICogQG1ldGhvZCBfanNvbkludGVyZmFjZU1ldGhvZFRvU3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0ganNvblxuICogQHJldHVybiB7U3RyaW5nfSBmdWxsIGZ1bmN0aW9uL2V2ZW50IG5hbWVcbiAqL1xudmFyIF9qc29uSW50ZXJmYWNlTWV0aG9kVG9TdHJpbmcgPSBmdW5jdGlvbiAoanNvbikge1xuICAgIGlmICghIWpzb24gJiYgdHlwZW9mIGpzb24gPT09ICdvYmplY3QnICYmIGpzb24ubmFtZSAmJiBqc29uLm5hbWUuaW5kZXhPZignKCcpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ganNvbi5uYW1lO1xuICAgIH1cbiAgICByZXR1cm4ganNvbi5uYW1lICsgJygnICsgX2ZsYXR0ZW5UeXBlcyhmYWxzZSwganNvbi5pbnB1dHMpLmpvaW4oJywnKSArICcpJztcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGZsYXR0ZW4ganNvbiBhYmkgaW5wdXRzL291dHB1dHMgaW50byBhbiBhcnJheSBvZiB0eXBlLXJlcHJlc2VudGluZy1zdHJpbmdzXG4gKlxuICogQG1ldGhvZCBfZmxhdHRlblR5cGVzXG4gKiBAcGFyYW0ge2Jvb2x9IGluY2x1ZGVUdXBsZVxuICogQHBhcmFtIHtPYmplY3R9IHB1dHNcbiAqIEByZXR1cm4ge0FycmF5fSBwYXJhbWV0ZXJzIGFzIHN0cmluZ3NcbiAqL1xudmFyIF9mbGF0dGVuVHlwZXMgPSBmdW5jdGlvbiAoaW5jbHVkZVR1cGxlLCBwdXRzKSB7XG4gICAgLy8gY29uc29sZS5sb2coXCJlbnRlcmVkIF9mbGF0dGVuVHlwZXMuIGlucHV0cy9vdXRwdXRzOiBcIiArIHB1dHMpXG4gICAgdmFyIHR5cGVzID0gW107XG4gICAgcHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtLmNvbXBvbmVudHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZS5zdWJzdHJpbmcoMCwgNSkgIT09ICd0dXBsZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBvbmVudHMgZm91bmQgYnV0IHR5cGUgaXMgbm90IHR1cGxlOyByZXBvcnQgb24gR2l0SHViJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gJyc7XG4gICAgICAgICAgICB2YXIgYXJyYXlCcmFja2V0ID0gcGFyYW0udHlwZS5pbmRleE9mKCdbJyk7XG4gICAgICAgICAgICBpZiAoYXJyYXlCcmFja2V0ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdWZmaXggPSBwYXJhbS50eXBlLnN1YnN0cmluZyhhcnJheUJyYWNrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9mbGF0dGVuVHlwZXMoaW5jbHVkZVR1cGxlLCBwYXJhbS5jb21wb25lbnRzKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicmVzdWx0IHNob3VsZCBoYXZlIHRoaW5nczogXCIgKyByZXN1bHQpXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpICYmIGluY2x1ZGVUdXBsZSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiaW5jbHVkZSB0dXBsZSB3b3JkLCBhbmQgaXRzIGFuIGFycmF5LiBqb2luaW5nLi4uOiBcIiArIHJlc3VsdC50eXBlcylcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKCd0dXBsZSgnICsgcmVzdWx0LmpvaW4oJywnKSArICcpJyArIHN1ZmZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaW5jbHVkZVR1cGxlKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJkb24ndCBpbmNsdWRlIHR1cGxlLCBidXQgaXRzIGFuIGFycmF5LiBqb2luaW5nLi4uOiBcIiArIHJlc3VsdClcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKCcoJyArIHJlc3VsdC5qb2luKCcsJykgKyAnKScgKyBzdWZmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJpdHMgYSBzaW5nbGUgdHlwZSB3aXRoaW4gYSB0dXBsZTogXCIgKyByZXN1bHQudHlwZXMpXG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgnKCcgKyByZXN1bHQgKyAnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJpdHMgYSB0eXBlIGFuZCBub3QgZGlyZWN0bHkgaW4gYSB0dXBsZTogXCIgKyBwYXJhbS50eXBlKVxuICAgICAgICAgICAgdHlwZXMucHVzaChwYXJhbS50eXBlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0eXBlcztcbn07XG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaGV4IHN0cmluZyBieSB0aGUgZ2l2ZW4gYnl0ZXMgc2l6ZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaXplXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG52YXIgcmFuZG9tSGV4ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICByZXR1cm4gJzB4JyArIHJhbmRvbWJ5dGVzKHNpemUpLnRvU3RyaW5nKCdoZXgnKTtcbn07XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGFzY2lpIGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIGhleFRvQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xudmFyIGhleFRvQXNjaWkgPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgaWYgKCF1dGlscy5pc0hleFN0cmljdChoZXgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwYXJhbWV0ZXIgbXVzdCBiZSBhIHZhbGlkIEhFWCBzdHJpbmcuJyk7XG4gICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgdmFyIGkgPSAwLCBsID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgICAgICBpID0gMjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBwYXJzZUludChoZXguc2xpY2UoaSwgaSArIDIpLCAxNik7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgYXNjaWkgc3RyaW5nXG4gKlxuICogQG1ldGhvZCBhc2NpaVRvSGV4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbnZhciBhc2NpaVRvSGV4ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmICghc3RyKVxuICAgICAgICByZXR1cm4gXCIweDAwXCI7XG4gICAgdmFyIGhleCA9IFwiXCI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgaGV4O1xufTtcbi8qKlxuICogUmV0dXJucyB2YWx1ZSBvZiB1bml0IGluIFdlaVxuICpcbiAqIEBtZXRob2QgZ2V0VW5pdFZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gdW5pdCB0aGUgdW5pdCB0byBjb252ZXJ0IHRvLCBkZWZhdWx0IGV0aGVyXG4gKiBAcmV0dXJucyB7Qk59IHZhbHVlIG9mIHRoZSB1bml0IChpbiBXZWkpXG4gKiBAdGhyb3dzIGVycm9yIGlmIHRoZSB1bml0IGlzIG5vdCBjb3JyZWN0OndcbiAqL1xudmFyIGdldFVuaXRWYWx1ZSA9IGZ1bmN0aW9uICh1bml0KSB7XG4gICAgdW5pdCA9IHVuaXQgPyB1bml0LnRvTG93ZXJDYXNlKCkgOiAnZXRoZXInO1xuICAgIGlmICghZXRoanNVbml0LnVuaXRNYXBbdW5pdF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHVuaXQgXCInICsgdW5pdCArICdcIiBkb2VzblxcJ3QgZXhpc3QsIHBsZWFzZSB1c2UgdGhlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHVuaXRzJyArIEpTT04uc3RyaW5naWZ5KGV0aGpzVW5pdC51bml0TWFwLCBudWxsLCAyKSk7XG4gICAgfVxuICAgIHJldHVybiB1bml0O1xufTtcbi8qKlxuICogVGFrZXMgYSBudW1iZXIgb2Ygd2VpIGFuZCBjb252ZXJ0cyBpdCB0byBhbnkgb3RoZXIgZXRoZXIgdW5pdC5cbiAqXG4gKiBQb3NzaWJsZSB1bml0cyBhcmU6XG4gKiAgIFNJIFNob3J0ICAgU0kgRnVsbCAgICAgICAgRWZmaWd5ICAgICAgIE90aGVyXG4gKiAtIGt3ZWkgICAgICAgZmVtdG9ldGhlciAgICAgYmFiYmFnZVxuICogLSBtd2VpICAgICAgIHBpY29ldGhlciAgICAgIGxvdmVsYWNlXG4gKiAtIGd3ZWkgICAgICAgbmFub2V0aGVyICAgICAgc2hhbm5vbiAgICAgIG5hbm9cbiAqIC0gLS0gICAgICAgICBtaWNyb2V0aGVyICAgICBzemFibyAgICAgICAgbWljcm9cbiAqIC0gLS0gICAgICAgICBtaWxsaWV0aGVyICAgICBmaW5uZXkgICAgICAgbWlsbGlcbiAqIC0gZXRoZXIgICAgICAtLSAgICAgICAgICAgICAtLVxuICogLSBrZXRoZXIgICAgICAgICAgICAgICAgICAgIC0tICAgICAgICAgICBncmFuZFxuICogLSBtZXRoZXJcbiAqIC0gZ2V0aGVyXG4gKiAtIHRldGhlclxuICpcbiAqIEBtZXRob2QgZnJvbVdlaVxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBudW1iZXIgY2FuIGJlIGEgbnVtYmVyLCBudW1iZXIgc3RyaW5nIG9yIGEgSEVYIG9mIGEgZGVjaW1hbFxuICogQHBhcmFtIHtTdHJpbmd9IHVuaXQgdGhlIHVuaXQgdG8gY29udmVydCB0bywgZGVmYXVsdCBldGhlclxuICogQHJldHVybiB7U3RyaW5nfE9iamVjdH0gV2hlbiBnaXZlbiBhIEJOIG9iamVjdCBpdCByZXR1cm5zIG9uZSBhcyB3ZWxsLCBvdGhlcndpc2UgYSBudW1iZXJcbiAqL1xudmFyIGZyb21XZWkgPSBmdW5jdGlvbiAobnVtYmVyLCB1bml0KSB7XG4gICAgdW5pdCA9IGdldFVuaXRWYWx1ZSh1bml0KTtcbiAgICBpZiAoIXV0aWxzLmlzQk4obnVtYmVyKSAmJiAhKHR5cGVvZiBudW1iZXIgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwYXNzIG51bWJlcnMgYXMgc3RyaW5ncyBvciBCTiBvYmplY3RzIHRvIGF2b2lkIHByZWNpc2lvbiBlcnJvcnMuJyk7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5pc0JOKG51bWJlcikgPyBldGhqc1VuaXQuZnJvbVdlaShudW1iZXIsIHVuaXQpIDogZXRoanNVbml0LmZyb21XZWkobnVtYmVyLCB1bml0KS50b1N0cmluZygxMCk7XG59O1xuLyoqXG4gKiBUYWtlcyBhIG51bWJlciBvZiBhIHVuaXQgYW5kIGNvbnZlcnRzIGl0IHRvIHdlaS5cbiAqXG4gKiBQb3NzaWJsZSB1bml0cyBhcmU6XG4gKiAgIFNJIFNob3J0ICAgU0kgRnVsbCAgICAgICAgRWZmaWd5ICAgICAgIE90aGVyXG4gKiAtIGt3ZWkgICAgICAgZmVtdG9ldGhlciAgICAgYmFiYmFnZVxuICogLSBtd2VpICAgICAgIHBpY29ldGhlciAgICAgIGxvdmVsYWNlXG4gKiAtIGd3ZWkgICAgICAgbmFub2V0aGVyICAgICAgc2hhbm5vbiAgICAgIG5hbm9cbiAqIC0gLS0gICAgICAgICBtaWNyb2V0aGVyICAgICBzemFibyAgICAgICAgbWljcm9cbiAqIC0gLS0gICAgICAgICBtaWNyb2V0aGVyICAgICBzemFibyAgICAgICAgbWljcm9cbiAqIC0gLS0gICAgICAgICBtaWxsaWV0aGVyICAgICBmaW5uZXkgICAgICAgbWlsbGlcbiAqIC0gZXRoZXIgICAgICAtLSAgICAgICAgICAgICAtLVxuICogLSBrZXRoZXIgICAgICAgICAgICAgICAgICAgIC0tICAgICAgICAgICBncmFuZFxuICogLSBtZXRoZXJcbiAqIC0gZ2V0aGVyXG4gKiAtIHRldGhlclxuICpcbiAqIEBtZXRob2QgdG9XZWlcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xCTn0gbnVtYmVyIGNhbiBiZSBhIG51bWJlciwgbnVtYmVyIHN0cmluZyBvciBhIEhFWCBvZiBhIGRlY2ltYWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB1bml0IHRoZSB1bml0IHRvIGNvbnZlcnQgZnJvbSwgZGVmYXVsdCBldGhlclxuICogQHJldHVybiB7U3RyaW5nfE9iamVjdH0gV2hlbiBnaXZlbiBhIEJOIG9iamVjdCBpdCByZXR1cm5zIG9uZSBhcyB3ZWxsLCBvdGhlcndpc2UgYSBudW1iZXJcbiAqL1xudmFyIHRvV2VpID0gZnVuY3Rpb24gKG51bWJlciwgdW5pdCkge1xuICAgIHVuaXQgPSBnZXRVbml0VmFsdWUodW5pdCk7XG4gICAgaWYgKCF1dGlscy5pc0JOKG51bWJlcikgJiYgISh0eXBlb2YgbnVtYmVyID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcGFzcyBudW1iZXJzIGFzIHN0cmluZ3Mgb3IgQk4gb2JqZWN0cyB0byBhdm9pZCBwcmVjaXNpb24gZXJyb3JzLicpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuaXNCTihudW1iZXIpID8gZXRoanNVbml0LnRvV2VpKG51bWJlciwgdW5pdCkgOiBldGhqc1VuaXQudG9XZWkobnVtYmVyLCB1bml0KS50b1N0cmluZygxMCk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB0byBhIGNoZWNrc3VtIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIHRvQ2hlY2tzdW1BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB0aGUgZ2l2ZW4gSEVYIGFkZHJlc3NcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIHRvQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICBpZiAodHlwZW9mIGFkZHJlc3MgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgaWYgKCEvXigweCk/WzAtOWEtZl17NDB9JC9pLnRlc3QoYWRkcmVzcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gYWRkcmVzcyBcIicgKyBhZGRyZXNzICsgJ1wiIGlzIG5vdCBhIHZhbGlkIEV0aGVyZXVtIGFkZHJlc3MuJyk7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eMHgvaSwgJycpO1xuICAgIHZhciBhZGRyZXNzSGFzaCA9IHV0aWxzLnNoYTMoYWRkcmVzcykucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICB2YXIgY2hlY2tzdW1BZGRyZXNzID0gJzB4JztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFkZHJlc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gSWYgaXRoIGNoYXJhY3RlciBpcyA4IHRvIGYgdGhlbiBtYWtlIGl0IHVwcGVyY2FzZVxuICAgICAgICBpZiAocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA+IDcpIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyArPSBhZGRyZXNzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MgKz0gYWRkcmVzc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hlY2tzdW1BZGRyZXNzO1xufTtcbi8qKlxuICogUmV0dXJucyAtMSBpZiBhPGIsIDEgaWYgYT5iOyAwIGlmIGEgPT0gYi5cbiAqIEZvciBtb3JlIGRldGFpbHMgb24gdGhpcyB0eXBlIG9mIGZ1bmN0aW9uLCBzZWVcbiAqIGRldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0XG4gKiBCbG9jayB0YWcgYHNhZmVgIGFuZCBgYmxvY2sgbnVtYmVyYCBjb21iaW5hdGlvbiBwYXJhbSBpcyBub3Qgc3VwcG9ydGVkXG4gKiBAbWV0aG9kIGNvbXBhcmVCbG9ja051bWJlcnNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8Qk59IGFcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8Qk59IGJcbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfSAtMSwgMCwgb3IgMVxuICovXG52YXIgY29tcGFyZUJsb2NrTnVtYmVycyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgLy8gSW5jcmVhc2luZyBvcmRlcjogKGdlbmVzaXMgPSBlYXJsaWVzdCksIHNhZmUsIChmaW5hbGl6ZWQgfiBsYXRlc3QpLCBwZW5kaW5nXG4gICAgLy8gc2FmZSB2cyBibG9jay1udW0gY2FudCBiZSBjb21wYXJlZCBhcyBibG9jayBudW1iZXIgcHJvdmlkZWQgY2FuIGJlIG9uIGxlZnQgb3IgcmlnaHQgc2lkZSBvZiBzYWZlIHRhZywgdW50aWwgc2FmZSB0YWcgYmxvY2sgbnVtYmVyIGlzIGV4dHJhY3RlZCBhbmQgY29tcGFyZWRcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoKFwiZ2VuZXNpc1wiID09PSBhIHx8IFwiZWFybGllc3RcIiA9PT0gYSB8fCAwID09PSBhKSAmJiAoXCJnZW5lc2lzXCIgPT09IGIgfHwgXCJlYXJsaWVzdFwiID09PSBiIHx8IDAgPT09IGIpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChcImdlbmVzaXNcIiA9PT0gYSB8fCBcImVhcmxpZXN0XCIgPT09IGEgfHwgYSA9PT0gMCkge1xuICAgICAgICAvLyBiICE9PSBhLCB0aHVzIGEgPCBiXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJnZW5lc2lzXCIgPT09IGIgfHwgXCJlYXJsaWVzdFwiID09PSBiIHx8IGIgPT09IDApIHtcbiAgICAgICAgLy8gYiAhPT0gYSwgdGh1cyBhID4gYlxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSA9PT0gXCJsYXRlc3RcIiB8fCBhID09PSBcImZpbmFsaXplZFwiKSB7XG4gICAgICAgIGlmIChiID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYiAhPT0gKFwicGVuZGluZ1wiIE9SIFwibGF0ZXN0XCIpLCB0aHVzIGEgPiBiXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChiID09PSBcImxhdGVzdFwiIHx8IGIgPT09IFwiZmluYWxpemVkXCIpIHtcbiAgICAgICAgaWYgKGEgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGIgIT09IChcInBlbmRpbmdcIiBPUiBcImxhdGVzdFwiKSwgdGh1cyBhID4gYlxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgIC8vIGIgKD09IE9SIDwpIFwibGF0ZXN0XCIsIHRodXMgYSA+IGJcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGIgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSA9PT0gXCJzYWZlXCIgfHwgYiA9PT0gXCJzYWZlXCIpIHtcbiAgICAgICAgLy8gZWl0aGVyIGEgb3IgYiBpcyBcInNhZmVcIiBhbmQgdGhlIG90aGVyIG9uZSBkaWQgbm90IGZhbGwgaW50byBhbnkgb2YgdGhlIGNvbmRpdGlvbnMgYWJvdmUsIHNvIHRoZSBvdGhlciBvbmUgaXMgYSBudW1iZXJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBibkEgPSBuZXcgQk4oYSk7XG4gICAgICAgIGxldCBibkIgPSBuZXcgQk4oYik7XG4gICAgICAgIGlmIChibkEubHQoYm5CKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJuQS5lcShibkIpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIF9maXJlRXJyb3I6IF9maXJlRXJyb3IsXG4gICAgX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZzogX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZyxcbiAgICBfZmxhdHRlblR5cGVzOiBfZmxhdHRlblR5cGVzLFxuICAgIC8vIGV4dHJhY3REaXNwbGF5TmFtZTogZXh0cmFjdERpc3BsYXlOYW1lLFxuICAgIC8vIGV4dHJhY3RUeXBlTmFtZTogZXh0cmFjdFR5cGVOYW1lLFxuICAgIHJhbmRvbUhleDogcmFuZG9tSGV4LFxuICAgIEJOOiB1dGlscy5CTixcbiAgICBpc0JOOiB1dGlscy5pc0JOLFxuICAgIGlzQmlnTnVtYmVyOiB1dGlscy5pc0JpZ051bWJlcixcbiAgICBpc0hleDogdXRpbHMuaXNIZXgsXG4gICAgaXNIZXhTdHJpY3Q6IHV0aWxzLmlzSGV4U3RyaWN0LFxuICAgIHNoYTM6IHV0aWxzLnNoYTMsXG4gICAgc2hhM1JhdzogdXRpbHMuc2hhM1JhdyxcbiAgICBrZWNjYWsyNTY6IHV0aWxzLnNoYTMsXG4gICAgc29saWRpdHlTaGEzOiBzb2xpZGl0eVNoYTMuc29saWRpdHlTaGEzLFxuICAgIHNvbGlkaXR5U2hhM1Jhdzogc29saWRpdHlTaGEzLnNvbGlkaXR5U2hhM1JhdyxcbiAgICBlbmNvZGVQYWNrZWQ6IHNvbGlkaXR5U2hhMy5lbmNvZGVQYWNrZWQsXG4gICAgaXNBZGRyZXNzOiB1dGlscy5pc0FkZHJlc3MsXG4gICAgY2hlY2tBZGRyZXNzQ2hlY2tzdW06IHV0aWxzLmNoZWNrQWRkcmVzc0NoZWNrc3VtLFxuICAgIHRvQ2hlY2tzdW1BZGRyZXNzOiB0b0NoZWNrc3VtQWRkcmVzcyxcbiAgICB0b0hleDogdXRpbHMudG9IZXgsXG4gICAgdG9CTjogdXRpbHMudG9CTixcbiAgICBieXRlc1RvSGV4OiB1dGlscy5ieXRlc1RvSGV4LFxuICAgIGhleFRvQnl0ZXM6IHV0aWxzLmhleFRvQnl0ZXMsXG4gICAgaGV4VG9OdW1iZXJTdHJpbmc6IHV0aWxzLmhleFRvTnVtYmVyU3RyaW5nLFxuICAgIGhleFRvTnVtYmVyOiB1dGlscy5oZXhUb051bWJlcixcbiAgICB0b0RlY2ltYWw6IHV0aWxzLmhleFRvTnVtYmVyLFxuICAgIG51bWJlclRvSGV4OiB1dGlscy5udW1iZXJUb0hleCxcbiAgICBmcm9tRGVjaW1hbDogdXRpbHMubnVtYmVyVG9IZXgsXG4gICAgaGV4VG9VdGY4OiB1dGlscy5oZXhUb1V0ZjgsXG4gICAgaGV4VG9TdHJpbmc6IHV0aWxzLmhleFRvVXRmOCxcbiAgICB0b1V0Zjg6IHV0aWxzLmhleFRvVXRmOCxcbiAgICBzdHJpcEhleFByZWZpeDogdXRpbHMuc3RyaXBIZXhQcmVmaXgsXG4gICAgdXRmOFRvSGV4OiB1dGlscy51dGY4VG9IZXgsXG4gICAgc3RyaW5nVG9IZXg6IHV0aWxzLnV0ZjhUb0hleCxcbiAgICBmcm9tVXRmODogdXRpbHMudXRmOFRvSGV4LFxuICAgIGhleFRvQXNjaWk6IGhleFRvQXNjaWksXG4gICAgdG9Bc2NpaTogaGV4VG9Bc2NpaSxcbiAgICBhc2NpaVRvSGV4OiBhc2NpaVRvSGV4LFxuICAgIGZyb21Bc2NpaTogYXNjaWlUb0hleCxcbiAgICB1bml0TWFwOiBldGhqc1VuaXQudW5pdE1hcCxcbiAgICB0b1dlaTogdG9XZWksXG4gICAgZnJvbVdlaTogZnJvbVdlaSxcbiAgICBwYWRMZWZ0OiB1dGlscy5sZWZ0UGFkLFxuICAgIGxlZnRQYWQ6IHV0aWxzLmxlZnRQYWQsXG4gICAgcGFkUmlnaHQ6IHV0aWxzLnJpZ2h0UGFkLFxuICAgIHJpZ2h0UGFkOiB1dGlscy5yaWdodFBhZCxcbiAgICB0b1R3b3NDb21wbGVtZW50OiB1dGlscy50b1R3b3NDb21wbGVtZW50LFxuICAgIGlzQmxvb206IHV0aWxzLmlzQmxvb20sXG4gICAgaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbTogdXRpbHMuaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbSxcbiAgICBpc0NvbnRyYWN0QWRkcmVzc0luQmxvb206IHV0aWxzLmlzQ29udHJhY3RBZGRyZXNzSW5CbG9vbSxcbiAgICBpc1RvcGljOiB1dGlscy5pc1RvcGljLFxuICAgIGlzVG9waWNJbkJsb29tOiB1dGlscy5pc1RvcGljSW5CbG9vbSxcbiAgICBpc0luQmxvb206IHV0aWxzLmlzSW5CbG9vbSxcbiAgICBjb21wYXJlQmxvY2tOdW1iZXJzOiBjb21wYXJlQmxvY2tOdW1iZXJzLFxuICAgIHRvTnVtYmVyOiB1dGlscy50b051bWJlclxufTtcbiJdLCJuYW1lcyI6WyJldGhqc1VuaXQiLCJyZXF1aXJlIiwidXRpbHMiLCJzb2xpZGl0eVNoYTMiLCJyYW5kb21ieXRlcyIsIkJOIiwiX2ZpcmVFcnJvciIsImVycm9yIiwiZW1pdHRlciIsInJlamVjdCIsImNhbGxiYWNrIiwib3B0aW9uYWxEYXRhIiwiRXJyb3IiLCJkYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1lc3NhZ2UiLCJsaXN0ZW5lcnMiLCJsZW5ndGgiLCJjYXRjaCIsInNldFRpbWVvdXQiLCJlbWl0IiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZyIsImpzb24iLCJuYW1lIiwiaW5kZXhPZiIsIl9mbGF0dGVuVHlwZXMiLCJpbnB1dHMiLCJqb2luIiwiaW5jbHVkZVR1cGxlIiwicHV0cyIsInR5cGVzIiwiZm9yRWFjaCIsInBhcmFtIiwiY29tcG9uZW50cyIsInR5cGUiLCJzdWJzdHJpbmciLCJzdWZmaXgiLCJhcnJheUJyYWNrZXQiLCJyZXN1bHQiLCJwdXNoIiwicmFuZG9tSGV4Iiwic2l6ZSIsInRvU3RyaW5nIiwiaGV4VG9Bc2NpaSIsImhleCIsImlzSGV4U3RyaWN0Iiwic3RyIiwiaSIsImwiLCJjb2RlIiwicGFyc2VJbnQiLCJzbGljZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFzY2lpVG9IZXgiLCJjaGFyQ29kZUF0IiwibiIsImdldFVuaXRWYWx1ZSIsInVuaXQiLCJ0b0xvd2VyQ2FzZSIsInVuaXRNYXAiLCJmcm9tV2VpIiwibnVtYmVyIiwiaXNCTiIsInRvV2VpIiwidG9DaGVja3N1bUFkZHJlc3MiLCJhZGRyZXNzIiwidGVzdCIsInJlcGxhY2UiLCJhZGRyZXNzSGFzaCIsInNoYTMiLCJjaGVja3N1bUFkZHJlc3MiLCJ0b1VwcGVyQ2FzZSIsImNvbXBhcmVCbG9ja051bWJlcnMiLCJhIiwiYiIsInVuZGVmaW5lZCIsImJuQSIsImJuQiIsImx0IiwiZXEiLCJtb2R1bGUiLCJleHBvcnRzIiwiaXNCaWdOdW1iZXIiLCJpc0hleCIsInNoYTNSYXciLCJrZWNjYWsyNTYiLCJzb2xpZGl0eVNoYTNSYXciLCJlbmNvZGVQYWNrZWQiLCJpc0FkZHJlc3MiLCJjaGVja0FkZHJlc3NDaGVja3N1bSIsInRvSGV4IiwidG9CTiIsImJ5dGVzVG9IZXgiLCJoZXhUb0J5dGVzIiwiaGV4VG9OdW1iZXJTdHJpbmciLCJoZXhUb051bWJlciIsInRvRGVjaW1hbCIsIm51bWJlclRvSGV4IiwiZnJvbURlY2ltYWwiLCJoZXhUb1V0ZjgiLCJoZXhUb1N0cmluZyIsInRvVXRmOCIsInN0cmlwSGV4UHJlZml4IiwidXRmOFRvSGV4Iiwic3RyaW5nVG9IZXgiLCJmcm9tVXRmOCIsInRvQXNjaWkiLCJmcm9tQXNjaWkiLCJwYWRMZWZ0IiwibGVmdFBhZCIsInBhZFJpZ2h0IiwicmlnaHRQYWQiLCJ0b1R3b3NDb21wbGVtZW50IiwiaXNCbG9vbSIsImlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb20iLCJpc0NvbnRyYWN0QWRkcmVzc0luQmxvb20iLCJpc1RvcGljIiwiaXNUb3BpY0luQmxvb20iLCJpc0luQmxvb20iLCJ0b051bWJlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/web3-utils@1.10.3/node_modules/web3-utils/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/web3-utils@1.10.3/node_modules/web3-utils/lib/soliditySha3.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/web3-utils@1.10.3/node_modules/web3-utils/lib/soliditySha3.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */ /**\n * @file soliditySha3.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */ \nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\");\nvar utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/web3-utils@1.10.3/node_modules/web3-utils/lib/utils.js\");\nvar _elementaryName = function(name) {\n    /*jshint maxcomplexity:false */ if (name.startsWith(\"int[\")) {\n        return \"int256\" + name.slice(3);\n    } else if (name === \"int\") {\n        return \"int256\";\n    } else if (name.startsWith(\"uint[\")) {\n        return \"uint256\" + name.slice(4);\n    } else if (name === \"uint\") {\n        return \"uint256\";\n    } else if (name.startsWith(\"fixed[\")) {\n        return \"fixed128x128\" + name.slice(5);\n    } else if (name === \"fixed\") {\n        return \"fixed128x128\";\n    } else if (name.startsWith(\"ufixed[\")) {\n        return \"ufixed128x128\" + name.slice(6);\n    } else if (name === \"ufixed\") {\n        return \"ufixed128x128\";\n    }\n    return name;\n};\n// Parse N from type<N>\nvar _parseTypeN = function(type) {\n    var typesize = /^\\D+(\\d+).*$/.exec(type);\n    return typesize ? parseInt(typesize[1], 10) : null;\n};\n// Parse N from type[<N>]\nvar _parseTypeNArray = function(type) {\n    var arraySize = /^\\D+\\d*\\[(\\d+)\\]$/.exec(type);\n    return arraySize ? parseInt(arraySize[1], 10) : null;\n};\nvar _parseNumber = function(arg) {\n    var type = typeof arg;\n    if (type === \"string\") {\n        if (utils.isHexStrict(arg)) {\n            return new BN(arg.replace(/0x/i, \"\"), 16);\n        } else {\n            return new BN(arg, 10);\n        }\n    } else if (type === \"number\") {\n        return new BN(arg);\n    } else if (utils.isBigNumber(arg)) {\n        return new BN(arg.toString(10));\n    } else if (utils.isBN(arg)) {\n        return arg;\n    } else {\n        throw new Error(arg + \" is not a number\");\n    }\n};\nvar _solidityPack = function(type, value, arraySize) {\n    /*jshint maxcomplexity:false */ var size, num;\n    type = _elementaryName(type);\n    if (type === \"bytes\") {\n        if (value.replace(/^0x/i, \"\").length % 2 !== 0) {\n            throw new Error(\"Invalid bytes characters \" + value.length);\n        }\n        return value;\n    } else if (type === \"string\") {\n        return utils.utf8ToHex(value);\n    } else if (type === \"bool\") {\n        return value ? \"01\" : \"00\";\n    } else if (type.startsWith(\"address\")) {\n        if (arraySize) {\n            size = 64;\n        } else {\n            size = 40;\n        }\n        if (!utils.isAddress(value)) {\n            throw new Error(value + \" is not a valid address, or the checksum is invalid.\");\n        }\n        return utils.leftPad(value.toLowerCase(), size);\n    }\n    size = _parseTypeN(type);\n    if (type.startsWith(\"bytes\")) {\n        if (!size) {\n            throw new Error(\"bytes[] not yet supported in solidity\");\n        }\n        // must be 32 byte slices when in an array\n        if (arraySize) {\n            size = 32;\n        }\n        if (size < 1 || size > 32 || size < value.replace(/^0x/i, \"\").length / 2) {\n            throw new Error(\"Invalid bytes\" + size + \" for \" + value);\n        }\n        return utils.rightPad(value, size * 2);\n    } else if (type.startsWith(\"uint\")) {\n        if (size % 8 || size < 8 || size > 256) {\n            throw new Error(\"Invalid uint\" + size + \" size\");\n        }\n        num = _parseNumber(value);\n        if (num.bitLength() > size) {\n            throw new Error(\"Supplied uint exceeds width: \" + size + \" vs \" + num.bitLength());\n        }\n        if (num.lt(new BN(0))) {\n            throw new Error(\"Supplied uint \" + num.toString() + \" is negative\");\n        }\n        return size ? utils.leftPad(num.toString(\"hex\"), size / 8 * 2) : num;\n    } else if (type.startsWith(\"int\")) {\n        if (size % 8 || size < 8 || size > 256) {\n            throw new Error(\"Invalid int\" + size + \" size\");\n        }\n        num = _parseNumber(value);\n        if (num.bitLength() > size) {\n            throw new Error(\"Supplied int exceeds width: \" + size + \" vs \" + num.bitLength());\n        }\n        if (num.lt(new BN(0))) {\n            return num.toTwos(size).toString(\"hex\");\n        } else {\n            return size ? utils.leftPad(num.toString(\"hex\"), size / 8 * 2) : num;\n        }\n    } else {\n        // FIXME: support all other types\n        throw new Error(\"Unsupported or invalid type: \" + type);\n    }\n};\nvar _processSolidityEncodePackedArgs = function(arg) {\n    /*jshint maxcomplexity:false */ if (Array.isArray(arg)) {\n        throw new Error(\"Autodetection of array types is not supported.\");\n    }\n    var type, value = \"\";\n    var hexArg, arraySize;\n    // if type is given\n    if (!!arg && typeof arg === \"object\" && (arg.hasOwnProperty(\"v\") || arg.hasOwnProperty(\"t\") || arg.hasOwnProperty(\"value\") || arg.hasOwnProperty(\"type\"))) {\n        type = arg.hasOwnProperty(\"t\") ? arg.t : arg.type;\n        value = arg.hasOwnProperty(\"v\") ? arg.v : arg.value;\n    // otherwise try to guess the type\n    } else {\n        type = utils.toHex(arg, true);\n        value = utils.toHex(arg);\n        if (!type.startsWith(\"int\") && !type.startsWith(\"uint\")) {\n            type = \"bytes\";\n        }\n    }\n    if ((type.startsWith(\"int\") || type.startsWith(\"uint\")) && typeof value === \"string\" && !/^(-)?0x/i.test(value)) {\n        value = new BN(value);\n    }\n    // get the array size\n    if (Array.isArray(value)) {\n        arraySize = _parseTypeNArray(type);\n        if (arraySize && value.length !== arraySize) {\n            throw new Error(type + \" is not matching the given array \" + JSON.stringify(value));\n        } else {\n            arraySize = value.length;\n        }\n    }\n    if (Array.isArray(value)) {\n        hexArg = value.map(function(val) {\n            return _solidityPack(type, val, arraySize).toString(\"hex\").replace(\"0x\", \"\");\n        });\n        return hexArg.join(\"\");\n    } else {\n        hexArg = _solidityPack(type, value, arraySize);\n        return hexArg.toString(\"hex\").replace(\"0x\", \"\");\n    }\n};\n/**\n * Hashes solidity values to a sha3 hash using keccak 256\n *\n * @method soliditySha3\n * @return {Object} the sha3\n */ var soliditySha3 = function() {\n    /*jshint maxcomplexity:false */ var args = Array.prototype.slice.call(arguments);\n    var hexArgs = args.map(_processSolidityEncodePackedArgs);\n    // console.log(args, hexArgs);\n    // console.log('0x'+ hexArgs.join(''));\n    return utils.sha3(\"0x\" + hexArgs.join(\"\"));\n};\n/**\n * Hashes solidity values to a sha3 hash using keccak 256 but does return the hash of value `null` instead of `null`\n *\n * @method soliditySha3Raw\n * @return {Object} the sha3\n */ var soliditySha3Raw = function() {\n    return utils.sha3Raw(\"0x\" + Array.prototype.slice.call(arguments).map(_processSolidityEncodePackedArgs).join(\"\"));\n};\n/**\n * Encode packed args to hex\n *\n * @method encodePacked\n * @return {String} the hex encoded arguments\n */ var encodePacked = function() {\n    /*jshint maxcomplexity:false */ var args = Array.prototype.slice.call(arguments);\n    var hexArgs = args.map(_processSolidityEncodePackedArgs);\n    return \"0x\" + hexArgs.join(\"\").toLowerCase();\n};\nmodule.exports = {\n    soliditySha3: soliditySha3,\n    soliditySha3Raw: soliditySha3Raw,\n    encodePacked: encodePacked\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViMy11dGlsc0AxLjEwLjMvbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL3NvbGlkaXR5U2hhMy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7OztDQUlDO0FBQ0QsSUFBSUEsS0FBS0MsbUJBQU9BLENBQUM7QUFDakIsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsa0JBQWtCLFNBQVVDLElBQUk7SUFDaEMsNkJBQTZCLEdBQzdCLElBQUlBLEtBQUtDLFVBQVUsQ0FBQyxTQUFTO1FBQ3pCLE9BQU8sV0FBV0QsS0FBS0UsS0FBSyxDQUFDO0lBQ2pDLE9BQ0ssSUFBSUYsU0FBUyxPQUFPO1FBQ3JCLE9BQU87SUFDWCxPQUNLLElBQUlBLEtBQUtDLFVBQVUsQ0FBQyxVQUFVO1FBQy9CLE9BQU8sWUFBWUQsS0FBS0UsS0FBSyxDQUFDO0lBQ2xDLE9BQ0ssSUFBSUYsU0FBUyxRQUFRO1FBQ3RCLE9BQU87SUFDWCxPQUNLLElBQUlBLEtBQUtDLFVBQVUsQ0FBQyxXQUFXO1FBQ2hDLE9BQU8saUJBQWlCRCxLQUFLRSxLQUFLLENBQUM7SUFDdkMsT0FDSyxJQUFJRixTQUFTLFNBQVM7UUFDdkIsT0FBTztJQUNYLE9BQ0ssSUFBSUEsS0FBS0MsVUFBVSxDQUFDLFlBQVk7UUFDakMsT0FBTyxrQkFBa0JELEtBQUtFLEtBQUssQ0FBQztJQUN4QyxPQUNLLElBQUlGLFNBQVMsVUFBVTtRQUN4QixPQUFPO0lBQ1g7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsdUJBQXVCO0FBQ3ZCLElBQUlHLGNBQWMsU0FBVUMsSUFBSTtJQUM1QixJQUFJQyxXQUFXLGVBQWVDLElBQUksQ0FBQ0Y7SUFDbkMsT0FBT0MsV0FBV0UsU0FBU0YsUUFBUSxDQUFDLEVBQUUsRUFBRSxNQUFNO0FBQ2xEO0FBQ0EseUJBQXlCO0FBQ3pCLElBQUlHLG1CQUFtQixTQUFVSixJQUFJO0lBQ2pDLElBQUlLLFlB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QUFDN0MsS0FBSyxDQUFDOEMsSUFBSSxDQUFDQztJQUN0QyxJQUFJQyxVQUFVSixLQUFLSixHQUFHLENBQUNYO0lBQ3ZCLDhCQUE4QjtJQUM5Qix1Q0FBdUM7SUFDdkMsT0FBT2pDLE1BQU1xRCxJQUFJLENBQUMsT0FBT0QsUUFBUU4sSUFBSSxDQUFDO0FBQzFDO0FBQ0E7Ozs7O0NBS0MsR0FDRCxJQUFJUSxrQkFBa0I7SUFDbEIsT0FBT3RELE1BQU11RCxPQUFPLENBQUMsT0FBT3JCLE1BQU1lLFNBQVMsQ0FBQzdDLEtBQUssQ0FBQzhDLElBQUksQ0FBQ0MsV0FBV1AsR0FBRyxDQUFDWCxrQ0FBa0NhLElBQUksQ0FBQztBQUNqSDtBQUNBOzs7OztDQUtDLEdBQ0QsSUFBSVUsZUFBZTtJQUNmLDZCQUE2QixHQUM3QixJQUFJUixPQUFPZCxNQUFNZSxTQUFTLENBQUM3QyxLQUFLLENBQUM4QyxJQUFJLENBQUNDO0lBQ3RDLElBQUlDLFVBQVVKLEtBQUtKLEdBQUcsQ0FBQ1g7SUFDdkIsT0FBTyxPQUFPbUIsUUFBUU4sSUFBSSxDQUFDLElBQUlsQixXQUFXO0FBQzlDO0FBQ0E2QixPQUFPQyxPQUFPLEdBQUc7SUFDYlgsY0FBY0E7SUFDZE8saUJBQWlCQTtJQUNqQkUsY0FBY0E7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViMy11dGlsc0AxLjEwLjMvbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL3NvbGlkaXR5U2hhMy5qcz80YTA4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuLyoqXG4gKiBAZmlsZSBzb2xpZGl0eVNoYTMuanNcbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGVyZXVtLm9yZz5cbiAqIEBkYXRlIDIwMTdcbiAqL1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKTtcbnZhciBfZWxlbWVudGFyeU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6ZmFsc2UgKi9cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdpbnRbJykpIHtcbiAgICAgICAgcmV0dXJuICdpbnQyNTYnICsgbmFtZS5zbGljZSgzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ2ludCcpIHtcbiAgICAgICAgcmV0dXJuICdpbnQyNTYnO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ3VpbnRbJykpIHtcbiAgICAgICAgcmV0dXJuICd1aW50MjU2JyArIG5hbWUuc2xpY2UoNCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICd1aW50Jykge1xuICAgICAgICByZXR1cm4gJ3VpbnQyNTYnO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ2ZpeGVkWycpKSB7XG4gICAgICAgIHJldHVybiAnZml4ZWQxMjh4MTI4JyArIG5hbWUuc2xpY2UoNSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdmaXhlZCcpIHtcbiAgICAgICAgcmV0dXJuICdmaXhlZDEyOHgxMjgnO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ3VmaXhlZFsnKSkge1xuICAgICAgICByZXR1cm4gJ3VmaXhlZDEyOHgxMjgnICsgbmFtZS5zbGljZSg2KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ3VmaXhlZCcpIHtcbiAgICAgICAgcmV0dXJuICd1Zml4ZWQxMjh4MTI4JztcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59O1xuLy8gUGFyc2UgTiBmcm9tIHR5cGU8Tj5cbnZhciBfcGFyc2VUeXBlTiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHR5cGVzaXplID0gL15cXEQrKFxcZCspLiokLy5leGVjKHR5cGUpO1xuICAgIHJldHVybiB0eXBlc2l6ZSA/IHBhcnNlSW50KHR5cGVzaXplWzFdLCAxMCkgOiBudWxsO1xufTtcbi8vIFBhcnNlIE4gZnJvbSB0eXBlWzxOPl1cbnZhciBfcGFyc2VUeXBlTkFycmF5ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgYXJyYXlTaXplID0gL15cXEQrXFxkKlxcWyhcXGQrKVxcXSQvLmV4ZWModHlwZSk7XG4gICAgcmV0dXJuIGFycmF5U2l6ZSA/IHBhcnNlSW50KGFycmF5U2l6ZVsxXSwgMTApIDogbnVsbDtcbn07XG52YXIgX3BhcnNlTnVtYmVyID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGFyZztcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzSGV4U3RyaWN0KGFyZykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQk4oYXJnLnJlcGxhY2UoLzB4L2ksICcnKSwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCTihhcmcsIDEwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbmV3IEJOKGFyZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHV0aWxzLmlzQmlnTnVtYmVyKGFyZykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCTihhcmcudG9TdHJpbmcoMTApKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodXRpbHMuaXNCTihhcmcpKSB7XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXJnICsgJyBpcyBub3QgYSBudW1iZXInKTtcbiAgICB9XG59O1xudmFyIF9zb2xpZGl0eVBhY2sgPSBmdW5jdGlvbiAodHlwZSwgdmFsdWUsIGFycmF5U2l6ZSkge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6ZmFsc2UgKi9cbiAgICB2YXIgc2l6ZSwgbnVtO1xuICAgIHR5cGUgPSBfZWxlbWVudGFyeU5hbWUodHlwZSk7XG4gICAgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgaWYgKHZhbHVlLnJlcGxhY2UoL14weC9pLCAnJykubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGVzIGNoYXJhY3RlcnMgJyArIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdXRpbHMudXRmOFRvSGV4KHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/ICcwMScgOiAnMDAnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2FkZHJlc3MnKSkge1xuICAgICAgICBpZiAoYXJyYXlTaXplKSB7XG4gICAgICAgICAgICBzaXplID0gNjQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaXplID0gNDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1dGlscy5pc0FkZHJlc3ModmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodmFsdWUgKyAnIGlzIG5vdCBhIHZhbGlkIGFkZHJlc3MsIG9yIHRoZSBjaGVja3N1bSBpcyBpbnZhbGlkLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlscy5sZWZ0UGFkKHZhbHVlLnRvTG93ZXJDYXNlKCksIHNpemUpO1xuICAgIH1cbiAgICBzaXplID0gX3BhcnNlVHlwZU4odHlwZSk7XG4gICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSkge1xuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYnl0ZXNbXSBub3QgeWV0IHN1cHBvcnRlZCBpbiBzb2xpZGl0eScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG11c3QgYmUgMzIgYnl0ZSBzbGljZXMgd2hlbiBpbiBhbiBhcnJheVxuICAgICAgICBpZiAoYXJyYXlTaXplKSB7XG4gICAgICAgICAgICBzaXplID0gMzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpemUgPCAxIHx8IHNpemUgPiAzMiB8fCBzaXplIDwgdmFsdWUucmVwbGFjZSgvXjB4L2ksICcnKS5sZW5ndGggLyAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZXMnICsgc2l6ZSArICcgZm9yICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWxzLnJpZ2h0UGFkKHZhbHVlLCBzaXplICogMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgndWludCcpKSB7XG4gICAgICAgIGlmICgoc2l6ZSAlIDgpIHx8IChzaXplIDwgOCkgfHwgKHNpemUgPiAyNTYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdWludCcgKyBzaXplICsgJyBzaXplJyk7XG4gICAgICAgIH1cbiAgICAgICAgbnVtID0gX3BhcnNlTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgaWYgKG51bS5iaXRMZW5ndGgoKSA+IHNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgdWludCBleGNlZWRzIHdpZHRoOiAnICsgc2l6ZSArICcgdnMgJyArIG51bS5iaXRMZW5ndGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bS5sdChuZXcgQk4oMCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIHVpbnQgJyArIG51bS50b1N0cmluZygpICsgJyBpcyBuZWdhdGl2ZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaXplID8gdXRpbHMubGVmdFBhZChudW0udG9TdHJpbmcoJ2hleCcpLCBzaXplIC8gOCAqIDIpIDogbnVtO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpKSB7XG4gICAgICAgIGlmICgoc2l6ZSAlIDgpIHx8IChzaXplIDwgOCkgfHwgKHNpemUgPiAyNTYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50JyArIHNpemUgKyAnIHNpemUnKTtcbiAgICAgICAgfVxuICAgICAgICBudW0gPSBfcGFyc2VOdW1iZXIodmFsdWUpO1xuICAgICAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCBpbnQgZXhjZWVkcyB3aWR0aDogJyArIHNpemUgKyAnIHZzICcgKyBudW0uYml0TGVuZ3RoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW0ubHQobmV3IEJOKDApKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bS50b1R3b3Moc2l6ZSkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNpemUgPyB1dGlscy5sZWZ0UGFkKG51bS50b1N0cmluZygnaGV4JyksIHNpemUgLyA4ICogMikgOiBudW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEZJWE1FOiBzdXBwb3J0IGFsbCBvdGhlciB0eXBlc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG9yIGludmFsaWQgdHlwZTogJyArIHR5cGUpO1xuICAgIH1cbn07XG52YXIgX3Byb2Nlc3NTb2xpZGl0eUVuY29kZVBhY2tlZEFyZ3MgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTpmYWxzZSAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRvZGV0ZWN0aW9uIG9mIGFycmF5IHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIHZhciB0eXBlLCB2YWx1ZSA9ICcnO1xuICAgIHZhciBoZXhBcmcsIGFycmF5U2l6ZTtcbiAgICAvLyBpZiB0eXBlIGlzIGdpdmVuXG4gICAgaWYgKCEhYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIChhcmcuaGFzT3duUHJvcGVydHkoJ3YnKSB8fCBhcmcuaGFzT3duUHJvcGVydHkoJ3QnKSB8fCBhcmcuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgfHwgYXJnLmhhc093blByb3BlcnR5KCd0eXBlJykpKSB7XG4gICAgICAgIHR5cGUgPSBhcmcuaGFzT3duUHJvcGVydHkoJ3QnKSA/IGFyZy50IDogYXJnLnR5cGU7XG4gICAgICAgIHZhbHVlID0gYXJnLmhhc093blByb3BlcnR5KCd2JykgPyBhcmcudiA6IGFyZy52YWx1ZTtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRyeSB0byBndWVzcyB0aGUgdHlwZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHV0aWxzLnRvSGV4KGFyZywgdHJ1ZSk7XG4gICAgICAgIHZhbHVlID0gdXRpbHMudG9IZXgoYXJnKTtcbiAgICAgICAgaWYgKCF0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpICYmICF0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSkge1xuICAgICAgICAgICAgdHlwZSA9ICdieXRlcyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCh0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpIHx8IHR5cGUuc3RhcnRzV2l0aCgndWludCcpKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICEvXigtKT8weC9pLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gbmV3IEJOKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gZ2V0IHRoZSBhcnJheSBzaXplXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGFycmF5U2l6ZSA9IF9wYXJzZVR5cGVOQXJyYXkodHlwZSk7XG4gICAgICAgIGlmIChhcnJheVNpemUgJiYgdmFsdWUubGVuZ3RoICE9PSBhcnJheVNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlICsgJyBpcyBub3QgbWF0Y2hpbmcgdGhlIGdpdmVuIGFycmF5ICcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlTaXplID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBoZXhBcmcgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zb2xpZGl0eVBhY2sodHlwZSwgdmFsLCBhcnJheVNpemUpLnRvU3RyaW5nKCdoZXgnKS5yZXBsYWNlKCcweCcsICcnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoZXhBcmcuam9pbignJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoZXhBcmcgPSBfc29saWRpdHlQYWNrKHR5cGUsIHZhbHVlLCBhcnJheVNpemUpO1xuICAgICAgICByZXR1cm4gaGV4QXJnLnRvU3RyaW5nKCdoZXgnKS5yZXBsYWNlKCcweCcsICcnKTtcbiAgICB9XG59O1xuLyoqXG4gKiBIYXNoZXMgc29saWRpdHkgdmFsdWVzIHRvIGEgc2hhMyBoYXNoIHVzaW5nIGtlY2NhayAyNTZcbiAqXG4gKiBAbWV0aG9kIHNvbGlkaXR5U2hhM1xuICogQHJldHVybiB7T2JqZWN0fSB0aGUgc2hhM1xuICovXG52YXIgc29saWRpdHlTaGEzID0gZnVuY3Rpb24gKCkge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6ZmFsc2UgKi9cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIGhleEFyZ3MgPSBhcmdzLm1hcChfcHJvY2Vzc1NvbGlkaXR5RW5jb2RlUGFja2VkQXJncyk7XG4gICAgLy8gY29uc29sZS5sb2coYXJncywgaGV4QXJncyk7XG4gICAgLy8gY29uc29sZS5sb2coJzB4JysgaGV4QXJncy5qb2luKCcnKSk7XG4gICAgcmV0dXJuIHV0aWxzLnNoYTMoJzB4JyArIGhleEFyZ3Muam9pbignJykpO1xufTtcbi8qKlxuICogSGFzaGVzIHNvbGlkaXR5IHZhbHVlcyB0byBhIHNoYTMgaGFzaCB1c2luZyBrZWNjYWsgMjU2IGJ1dCBkb2VzIHJldHVybiB0aGUgaGFzaCBvZiB2YWx1ZSBgbnVsbGAgaW5zdGVhZCBvZiBgbnVsbGBcbiAqXG4gKiBAbWV0aG9kIHNvbGlkaXR5U2hhM1Jhd1xuICogQHJldHVybiB7T2JqZWN0fSB0aGUgc2hhM1xuICovXG52YXIgc29saWRpdHlTaGEzUmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1dGlscy5zaGEzUmF3KCcweCcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLm1hcChfcHJvY2Vzc1NvbGlkaXR5RW5jb2RlUGFja2VkQXJncykuam9pbignJykpO1xufTtcbi8qKlxuICogRW5jb2RlIHBhY2tlZCBhcmdzIHRvIGhleFxuICpcbiAqIEBtZXRob2QgZW5jb2RlUGFja2VkXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBoZXggZW5jb2RlZCBhcmd1bWVudHNcbiAqL1xudmFyIGVuY29kZVBhY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OmZhbHNlICovXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBoZXhBcmdzID0gYXJncy5tYXAoX3Byb2Nlc3NTb2xpZGl0eUVuY29kZVBhY2tlZEFyZ3MpO1xuICAgIHJldHVybiAnMHgnICsgaGV4QXJncy5qb2luKCcnKS50b0xvd2VyQ2FzZSgpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHNvbGlkaXR5U2hhMzogc29saWRpdHlTaGEzLFxuICAgIHNvbGlkaXR5U2hhM1Jhdzogc29saWRpdHlTaGEzUmF3LFxuICAgIGVuY29kZVBhY2tlZDogZW5jb2RlUGFja2VkXG59O1xuIl0sIm5hbWVzIjpbIkJOIiwicmVxdWlyZSIsInV0aWxzIiwiX2VsZW1lbnRhcnlOYW1lIiwibmFtZSIsInN0YXJ0c1dpdGgiLCJzbGljZSIsIl9wYXJzZVR5cGVOIiwidHlwZSIsInR5cGVzaXplIiwiZXhlYyIsInBhcnNlSW50IiwiX3BhcnNlVHlwZU5BcnJheSIsImFycmF5U2l6ZSIsIl9wYXJzZU51bWJlciIsImFyZyIsImlzSGV4U3RyaWN0IiwicmVwbGFjZSIsImlzQmlnTnVtYmVyIiwidG9TdHJpbmciLCJpc0JOIiwiRXJyb3IiLCJfc29saWRpdHlQYWNrIiwidmFsdWUiLCJzaXplIiwibnVtIiwibGVuZ3RoIiwidXRmOFRvSGV4IiwiaXNBZGRyZXNzIiwibGVmdFBhZCIsInRvTG93ZXJDYXNlIiwicmlnaHRQYWQiLCJiaXRMZW5ndGgiLCJsdCIsInRvVHdvcyIsIl9wcm9jZXNzU29saWRpdHlFbmNvZGVQYWNrZWRBcmdzIiwiQXJyYXkiLCJpc0FycmF5IiwiaGV4QXJnIiwiaGFzT3duUHJvcGVydHkiLCJ0IiwidiIsInRvSGV4IiwidGVzdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJtYXAiLCJ2YWwiLCJqb2luIiwic29saWRpdHlTaGEzIiwiYXJncyIsInByb3RvdHlwZSIsImNhbGwiLCJhcmd1bWVudHMiLCJoZXhBcmdzIiwic2hhMyIsInNvbGlkaXR5U2hhM1JhdyIsInNoYTNSYXciLCJlbmNvZGVQYWNrZWQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/web3-utils@1.10.3/node_modules/web3-utils/lib/soliditySha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/web3-utils@1.10.3/node_modules/web3-utils/lib/utils.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/web3-utils@1.10.3/node_modules/web3-utils/lib/utils.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */ /**\n * @file utils.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */ \nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\");\nvar numberToBN = __webpack_require__(/*! number-to-bn */ \"(ssr)/./node_modules/.pnpm/number-to-bn@1.7.0/node_modules/number-to-bn/src/index.js\");\nvar utf8 = __webpack_require__(/*! utf8 */ \"(ssr)/./node_modules/.pnpm/utf8@3.0.0/node_modules/utf8/utf8.js\");\nvar ethereumjsUtil = __webpack_require__(/*! @ethereumjs/util */ \"(ssr)/./node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/index.js\");\nvar ethereumBloomFilters = __webpack_require__(/*! ethereum-bloom-filters */ \"(ssr)/./node_modules/.pnpm/ethereum-bloom-filters@1.0.10/node_modules/ethereum-bloom-filters/dist/index.js\");\nvar { keccak256 } = __webpack_require__(/*! ethereum-cryptography/keccak.js */ \"(ssr)/./node_modules/.pnpm/ethereum-cryptography@2.1.2/node_modules/ethereum-cryptography/keccak.js\");\n/**\n * Returns true if object is BN, otherwise false\n *\n * @method isBN\n * @param {Object} object\n * @return {Boolean}\n */ var isBN = function(object) {\n    return BN.isBN(object);\n};\n/**\n * Returns true if object is BigNumber, otherwise false\n *\n * @method isBigNumber\n * @param {Object} object\n * @return {Boolean}\n */ var isBigNumber = function(object) {\n    return object && object.constructor && object.constructor.name === \"BigNumber\";\n};\n/**\n * Takes an input and transforms it into an BN\n *\n * @method toBN\n * @param {Number|String|BN} number, string, HEX string or BN\n * @return {BN} BN\n */ var toBN = function(number) {\n    try {\n        return numberToBN.apply(null, arguments);\n    } catch (e) {\n        throw new Error(e + ' Given value: \"' + number + '\"');\n    }\n};\n/**\n * Takes and input transforms it into BN and if it is negative value, into two's complement\n *\n * @method toTwosComplement\n * @param {Number|String|BN} number\n * @return {String}\n */ var toTwosComplement = function(number) {\n    return \"0x\" + toBN(number).toTwos(256).toString(16, 64);\n};\n/**\n * Checks if the given string is an address\n *\n * @method isAddress\n * @param {String} address the given HEX address\n * @return {Boolean}\n */ var isAddress = function(address) {\n    // check if it has the basic requirements of an address\n    if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n        return false;\n    // If it's ALL lowercase or ALL upppercase\n    } else if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {\n        return true;\n    // Otherwise check each case\n    } else {\n        return checkAddressChecksum(address);\n    }\n};\n/**\n * Checks if the given string is a checksummed address\n *\n * @method checkAddressChecksum\n * @param {String} address the given HEX address\n * @return {Boolean}\n */ var checkAddressChecksum = function(address) {\n    // Check each case\n    address = address.replace(/^0x/i, \"\");\n    var addressHash = sha3(address.toLowerCase()).replace(/^0x/i, \"\");\n    for(var i = 0; i < 40; i++){\n        // the nth letter should be uppercase if the nth digit of casemap is 1\n        if (parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i] || parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i]) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Should be called to pad string to expected length\n *\n * @method leftPad\n * @param {String} string to be padded\n * @param {Number} chars that result string should have\n * @param {String} sign, by default 0\n * @returns {String} right aligned string\n */ var leftPad = function(string, chars, sign) {\n    var hasPrefix = /^0x/i.test(string) || typeof string === \"number\";\n    string = string.toString(16).replace(/^0x/i, \"\");\n    var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;\n    return (hasPrefix ? \"0x\" : \"\") + new Array(padding).join(sign ? sign : \"0\") + string;\n};\n/**\n * Should be called to pad string to expected length\n *\n * @method rightPad\n * @param {String} string to be padded\n * @param {Number} chars that result string should have\n * @param {String} sign, by default 0\n * @returns {String} right aligned string\n */ var rightPad = function(string, chars, sign) {\n    var hasPrefix = /^0x/i.test(string) || typeof string === \"number\";\n    string = string.toString(16).replace(/^0x/i, \"\");\n    var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;\n    return (hasPrefix ? \"0x\" : \"\") + string + new Array(padding).join(sign ? sign : \"0\");\n};\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @method utf8ToHex\n * @param {String} str\n * @returns {String} hex representation of input string\n */ var utf8ToHex = function(str) {\n    str = utf8.encode(str);\n    var hex = \"\";\n    // remove \\u0000 padding from either side\n    str = str.replace(/^(?:\\u0000)*/, \"\");\n    str = str.split(\"\").reverse().join(\"\");\n    str = str.replace(/^(?:\\u0000)*/, \"\");\n    str = str.split(\"\").reverse().join(\"\");\n    for(var i = 0; i < str.length; i++){\n        var code = str.charCodeAt(i);\n        // if (code !== 0) {\n        var n = code.toString(16);\n        hex += n.length < 2 ? \"0\" + n : n;\n    // }\n    }\n    return \"0x\" + hex;\n};\n/**\n * Should be called to get utf8 from it's hex representation\n *\n * @method hexToUtf8\n * @param {String} hex\n * @returns {String} ascii string representation of hex value\n */ var hexToUtf8 = function(hex) {\n    if (!isHexStrict(hex)) throw new Error('The parameter \"' + hex + '\" must be a valid HEX string.');\n    var str = \"\";\n    var code = 0;\n    hex = hex.replace(/^0x/i, \"\");\n    // remove 00 padding from either side\n    hex = hex.replace(/^(?:00)*/, \"\");\n    hex = hex.split(\"\").reverse().join(\"\");\n    hex = hex.replace(/^(?:00)*/, \"\");\n    hex = hex.split(\"\").reverse().join(\"\");\n    var l = hex.length;\n    for(var i = 0; i < l; i += 2){\n        code = parseInt(hex.slice(i, i + 2), 16);\n        // if (code !== 0) {\n        str += String.fromCharCode(code);\n    // }\n    }\n    return utf8.decode(str);\n};\n/**\n * Converts value to it's number representation.\n * However, if the value is larger than the maximum safe integer, returns the value as a string.\n *\n * @method hexToNumber\n * @param {String|Number|BN} value\n * @param {Boolean} bigIntOnOverflow - if true, return the hex value in case of overflow\n * @return {Number|String}\n */ var hexToNumber = function(value, bigIntOnOverflow = false) {\n    if (!value) {\n        return value;\n    }\n    if (typeof value === \"string\" && !isHexStrict(value)) {\n        throw new Error('Given value \"' + value + '\" is not a valid hex string.');\n    }\n    const n = toBN(value);\n    if (bigIntOnOverflow && (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER)) {\n        return BigInt(n);\n    }\n    return n.toNumber();\n};\n/**\n * Converts value to it's decimal representation in string\n *\n * @method hexToNumberString\n * @param {String|Number|BN} value\n * @return {String}\n */ var hexToNumberString = function(value) {\n    if (!value) return value;\n    if (typeof value === \"string\" && !isHexStrict(value)) {\n        throw new Error('Given value \"' + value + '\" is not a valid hex string.');\n    }\n    return toBN(value).toString(10);\n};\n/**\n * Converts value to it's hex representation\n *\n * @method numberToHex\n * @param {String|Number|BN} value\n * @return {String}\n */ var numberToHex = function(value) {\n    if (value === null || value === undefined) {\n        return value;\n    }\n    if (!isFinite(value) && !isHexStrict(value)) {\n        throw new Error('Given input \"' + value + '\" is not a number.');\n    }\n    var number = toBN(value);\n    var result = number.toString(16);\n    return number.lt(new BN(0)) ? \"-0x\" + result.slice(1) : \"0x\" + result;\n};\n/**\n * Convert a byte array to a hex string\n *\n * Note: Implementation from crypto-js\n *\n * @method bytesToHex\n * @param {Array} bytes\n * @return {String} the hex string\n */ var bytesToHex = function(bytes) {\n    for(var hex = [], i = 0; i < bytes.length; i++){\n        /* jshint ignore:start */ hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xF).toString(16));\n    /* jshint ignore:end */ }\n    return \"0x\" + hex.join(\"\");\n};\n/**\n * Convert a hex string to a byte array\n *\n * Note: Implementation from crypto-js\n *\n * @method hexToBytes\n * @param {string} hex\n * @return {Array} the byte array\n */ var hexToBytes = function(hex) {\n    hex = hex.toString(16);\n    if (!isHexStrict(hex)) {\n        throw new Error('Given value \"' + hex + '\" is not a valid hex string.');\n    }\n    hex = hex.replace(/^0x/i, \"\");\n    for(var bytes = [], c = 0; c < hex.length; c += 2)bytes.push(parseInt(hex.slice(c, c + 2), 16));\n    return bytes;\n};\n/**\n * Auto converts any given value into it's hex representation.\n *\n * And even stringifys objects before.\n *\n * @method toHex\n * @param {String|Number|BN|Object|Buffer} value\n * @param {Boolean} returnType\n * @return {String}\n */ var toHex = function(value, returnType) {\n    /*jshint maxcomplexity: false */ if (isAddress(value)) {\n        return returnType ? \"address\" : \"0x\" + value.toLowerCase().replace(/^0x/i, \"\");\n    }\n    if (typeof value === \"boolean\") {\n        return returnType ? \"bool\" : value ? \"0x01\" : \"0x00\";\n    }\n    if (Buffer.isBuffer(value)) {\n        return \"0x\" + value.toString(\"hex\");\n    }\n    if (typeof value === \"object\" && !!value && !isBigNumber(value) && !isBN(value)) {\n        return returnType ? \"string\" : utf8ToHex(JSON.stringify(value));\n    }\n    // if its a negative number, pass it through numberToHex\n    if (typeof value === \"string\") {\n        if (value.indexOf(\"-0x\") === 0 || value.indexOf(\"-0X\") === 0) {\n            return returnType ? \"int256\" : numberToHex(value);\n        } else if (value.indexOf(\"0x\") === 0 || value.indexOf(\"0X\") === 0) {\n            return returnType ? \"bytes\" : value;\n        } else if (!isFinite(value)) {\n            return returnType ? \"string\" : utf8ToHex(value);\n        }\n    }\n    return returnType ? value < 0 ? \"int256\" : \"uint256\" : numberToHex(value);\n};\n/**\n * Check if string is HEX, requires a 0x in front\n *\n * @method isHexStrict\n * @param {String} hex to be checked\n * @returns {Boolean}\n */ var isHexStrict = function(hex) {\n    return (typeof hex === \"string\" || typeof hex === \"number\") && /^(-)?0x[0-9a-f]*$/i.test(hex);\n};\n/**\n * Check if string is HEX\n *\n * @method isHex\n * @param {String} hex to be checked\n * @returns {Boolean}\n */ var isHex = function(hex) {\n    return (typeof hex === \"string\" || typeof hex === \"number\") && /^(-0x|0x)?[0-9a-f]*$/i.test(hex);\n};\n/**\n * Remove 0x prefix from string\n *\n * @method stripHexPrefix\n * @param {String} str to be checked\n * @returns {String}\n */ var stripHexPrefix = function(str) {\n    if (str !== 0 && isHex(str)) return str.replace(/^(-)?0x/i, \"$1\");\n    return str;\n};\n/**\n * Returns true if given string is a valid Ethereum block header bloom.\n *\n * @method isBloom\n * @param {String} bloom encoded bloom filter\n * @return {Boolean}\n */ var isBloom = function(bloom) {\n    return ethereumBloomFilters.isBloom(bloom);\n};\n/**\n * Returns true if the ethereum users address is part of the given bloom\n * note: false positives are possible.\n *\n * @method isUserEthereumAddressInBloom\n * @param {String} ethereumAddress encoded bloom filter\n * @param {String} bloom ethereum addresss\n * @return {Boolean}\n */ var isUserEthereumAddressInBloom = function(bloom, ethereumAddress) {\n    return ethereumBloomFilters.isUserEthereumAddressInBloom(bloom, ethereumAddress);\n};\n/**\n * Returns true if the contract address is part of the given bloom\n * note: false positives are possible.\n *\n * @method isUserEthereumAddressInBloom\n * @param {String} bloom encoded bloom filter\n * @param {String} contractAddress contract addresss\n * @return {Boolean}\n */ var isContractAddressInBloom = function(bloom, contractAddress) {\n    return ethereumBloomFilters.isContractAddressInBloom(bloom, contractAddress);\n};\n/**\n * Returns true if given string is a valid log topic.\n *\n * @method isTopic\n * @param {String} topic encoded topic\n * @return {Boolean}\n */ var isTopic = function(topic) {\n    return ethereumBloomFilters.isTopic(topic);\n};\n/**\n * Returns true if the topic is part of the given bloom\n * note: false positives are possible.\n *\n * @method isTopicInBloom\n * @param {String} bloom encoded bloom filter\n * @param {String} topic encoded topic\n * @return {Boolean}\n */ var isTopicInBloom = function(bloom, topic) {\n    return ethereumBloomFilters.isTopicInBloom(bloom, topic);\n};\n/**\n * Returns true if the value is part of the given bloom\n * note: false positives are possible.\n *\n * @method isInBloom\n * @param {String} bloom encoded bloom filter\n * @param {String | Uint8Array} topic encoded value\n * @return {Boolean}\n */ var isInBloom = function(bloom, topic) {\n    return ethereumBloomFilters.isInBloom(bloom, topic);\n};\n/**\n * Hashes values to a sha3 hash using keccak 256\n *\n * To hash a HEX string the hex must have 0x in front.\n *\n * @method sha3\n * @return {String} the sha3 string\n */ var SHA3_NULL_S = \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\";\nvar sha3 = function(value) {\n    if (isBN(value)) {\n        value = value.toString();\n    }\n    if (isHexStrict(value) && /^0x/i.test(value.toString())) {\n        value = ethereumjsUtil.toBuffer(value);\n    } else if (typeof value === \"string\") {\n        // Assume value is an arbitrary string\n        value = Buffer.from(value, \"utf-8\");\n    }\n    var returnValue = ethereumjsUtil.bufferToHex(keccak256(value));\n    if (returnValue === SHA3_NULL_S) {\n        return null;\n    } else {\n        return returnValue;\n    }\n};\n// expose the under the hood keccak256\nsha3._Hash = keccak256;\n/**\n * @method sha3Raw\n *\n * @param value\n *\n * @returns {string}\n */ var sha3Raw = function(value) {\n    value = sha3(value);\n    if (value === null) {\n        return SHA3_NULL_S;\n    }\n    return value;\n};\n/**\n * Auto converts any given value into it's hex representation,\n * then converts hex to number.\n *\n * @method toNumber\n * @param {String|Number|BN} value\n * @param {Boolean} bigIntOnOverflow - if true, return the hex value in case of overflow\n * @return {Number|String}\n */ var toNumber = function(value, bigIntOnOverflow = false) {\n    return typeof value === \"number\" ? value : hexToNumber(toHex(value), bigIntOnOverflow);\n};\n// 1.x currently accepts 0x... strings, bn.js after update doesn't. it would be a breaking change\nvar BNwrapped = function(value) {\n    // check negative\n    if (typeof value == \"string\" && value.includes(\"0x\")) {\n        const [negative, hexValue] = value.toLocaleLowerCase().startsWith(\"-\") ? [\n            \"-\",\n            value.slice(3)\n        ] : [\n            \"\",\n            value.slice(2)\n        ];\n        return new BN(negative + hexValue, 16);\n    } else {\n        return new BN(value);\n    }\n};\nObject.setPrototypeOf(BNwrapped, BN);\nObject.setPrototypeOf(BNwrapped.prototype, BN.prototype);\nmodule.exports = {\n    BN: BNwrapped,\n    isBN: isBN,\n    isBigNumber: isBigNumber,\n    toBN: toBN,\n    isAddress: isAddress,\n    isBloom: isBloom,\n    isUserEthereumAddressInBloom: isUserEthereumAddressInBloom,\n    isContractAddressInBloom: isContractAddressInBloom,\n    isTopic: isTopic,\n    isTopicInBloom: isTopicInBloom,\n    isInBloom: isInBloom,\n    checkAddressChecksum: checkAddressChecksum,\n    utf8ToHex: utf8ToHex,\n    hexToUtf8: hexToUtf8,\n    hexToNumber: hexToNumber,\n    hexToNumberString: hexToNumberString,\n    numberToHex: numberToHex,\n    toHex: toHex,\n    hexToBytes: hexToBytes,\n    bytesToHex: bytesToHex,\n    isHex: isHex,\n    isHexStrict: isHexStrict,\n    stripHexPrefix: stripHexPrefix,\n    leftPad: leftPad,\n    rightPad: rightPad,\n    toTwosComplement: toTwosComplement,\n    sha3: sha3,\n    sha3Raw: sha3Raw,\n    toNumber: toNumber\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViMy11dGlsc0AxLjEwLjMvbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEOzs7O0NBSUM7QUFDRCxJQUFJQSxLQUFLQyxtQkFBT0EsQ0FBQztBQUNqQixJQUFJQyxhQUFhRCxtQkFBT0EsQ0FBQztBQUN6QixJQUFJRSxPQUFPRixtQkFBT0EsQ0FBQztBQUNuQixJQUFJRyxpQkFBaUJILG1CQUFPQSxDQUFDO0FBQzdCLElBQUlJLHVCQUF1QkosbUJBQU9BLENBQUM7QUFDbkMsSUFBSSxFQUFFSyxTQUFTLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFDNUI7Ozs7OztDQU1DLEdBQ0QsSUFBSU0sT0FBTyxTQUFVQyxNQUFNO0lBQ3ZCLE9BQU9SLEdBQUdPLElBQUksQ0FBQ0M7QUFDbkI7QUFDQTs7Ozs7O0NBTUMsR0FDRCxJQUFJQyxjQUFjLFNBQVVELE1BQU07SUFDOUIsT0FBT0EsVUFBVUEsT0FBT0UsV0FBVyxJQUFJRixPQUFPRSxXQUFXLENBQUNDLElBQUksS0FBSztBQUN2RTtBQUNBOzs7Ozs7Q0FNQyxHQUNELElBQUlDLE9BQU8sU0FBVUMsTUFBTTtJQUN2QixJQUFJO1FBQ0EsT0FBT1gsV0FBV1ksS0FBSyxDQUFDLE1BQU1DO0lBQ2xDLEVBQ0EsT0FBT0MsR0FBRztRQUNOLE1BQU0sSUFBSUMsTUFBTUQsSUFBSSxvQkFBb0JILFNBQVM7SUFDckQ7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNELElBQUlLLG1CQUFtQixTQUFVTCxNQUFNO0lBQ25DLE9BQU8sT0FBT0QsS0FBS0MsUUFBUU0sTUFBTSxDQUFDLEtBQUtDLFFBQVEsQ0FBQyxJQUFJO0FBQ3hEO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsSUFBSUMsWUFBWSxTQUFVQyxPQUFPO0lBQzdCLHVEQUF1RDtJQUN2RCxJQUFJLENBQUMsdUJBQXVCQyxJQUFJLENBQUNELFVB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aWVudC8uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWIzLXV0aWxzQDEuMTAuMy9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9saWIvdXRpbHMuanM/ZWYyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4gKi9cbi8qKlxuICogQGZpbGUgdXRpbHMuanNcbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGVyZXVtLm9yZz5cbiAqIEBkYXRlIDIwMTdcbiAqL1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBudW1iZXJUb0JOID0gcmVxdWlyZSgnbnVtYmVyLXRvLWJuJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJ3V0ZjgnKTtcbnZhciBldGhlcmV1bWpzVXRpbCA9IHJlcXVpcmUoJ0BldGhlcmV1bWpzL3V0aWwnKTtcbnZhciBldGhlcmV1bUJsb29tRmlsdGVycyA9IHJlcXVpcmUoJ2V0aGVyZXVtLWJsb29tLWZpbHRlcnMnKTtcbnZhciB7IGtlY2NhazI1NiB9ID0gcmVxdWlyZSgnZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nhay5qcycpO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIEJOLCBvdGhlcndpc2UgZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzQk5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0JOID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBCTi5pc0JOKG9iamVjdCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIEJpZ051bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKlxuICogQG1ldGhvZCBpc0JpZ051bWJlclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQmlnTnVtYmVyID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yICYmIG9iamVjdC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQmlnTnVtYmVyJztcbn07XG4vKipcbiAqIFRha2VzIGFuIGlucHV0IGFuZCB0cmFuc2Zvcm1zIGl0IGludG8gYW4gQk5cbiAqXG4gKiBAbWV0aG9kIHRvQk5cbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xCTn0gbnVtYmVyLCBzdHJpbmcsIEhFWCBzdHJpbmcgb3IgQk5cbiAqIEByZXR1cm4ge0JOfSBCTlxuICovXG52YXIgdG9CTiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CTi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZSArICcgR2l2ZW4gdmFsdWU6IFwiJyArIG51bWJlciArICdcIicpO1xuICAgIH1cbn07XG4vKipcbiAqIFRha2VzIGFuZCBpbnB1dCB0cmFuc2Zvcm1zIGl0IGludG8gQk4gYW5kIGlmIGl0IGlzIG5lZ2F0aXZlIHZhbHVlLCBpbnRvIHR3bydzIGNvbXBsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIHRvVHdvc0NvbXBsZW1lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xCTn0gbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciB0b1R3b3NDb21wbGVtZW50ID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgIHJldHVybiAnMHgnICsgdG9CTihudW1iZXIpLnRvVHdvcygyNTYpLnRvU3RyaW5nKDE2LCA2NCk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhbiBhZGRyZXNzXG4gKlxuICogQG1ldGhvZCBpc0FkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBnaXZlbiBIRVggYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgLy8gY2hlY2sgaWYgaXQgaGFzIHRoZSBiYXNpYyByZXF1aXJlbWVudHMgb2YgYW4gYWRkcmVzc1xuICAgIGlmICghL14oMHgpP1swLTlhLWZdezQwfSQvaS50ZXN0KGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gSWYgaXQncyBBTEwgbG93ZXJjYXNlIG9yIEFMTCB1cHBwZXJjYXNlXG4gICAgfVxuICAgIGVsc2UgaWYgKC9eKDB4fDBYKT9bMC05YS1mXXs0MH0kLy50ZXN0KGFkZHJlc3MpIHx8IC9eKDB4fDBYKT9bMC05QS1GXXs0MH0kLy50ZXN0KGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBPdGhlcndpc2UgY2hlY2sgZWFjaCBjYXNlXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY2hlY2tBZGRyZXNzQ2hlY2tzdW0oYWRkcmVzcyk7XG4gICAgfVxufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYSBjaGVja3N1bW1lZCBhZGRyZXNzXG4gKlxuICogQG1ldGhvZCBjaGVja0FkZHJlc3NDaGVja3N1bVxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgdGhlIGdpdmVuIEhFWCBhZGRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgY2hlY2tBZGRyZXNzQ2hlY2tzdW0gPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIC8vIENoZWNrIGVhY2ggY2FzZVxuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnJlcGxhY2UoL14weC9pLCAnJyk7XG4gICAgdmFyIGFkZHJlc3NIYXNoID0gc2hhMyhhZGRyZXNzLnRvTG93ZXJDYXNlKCkpLnJlcGxhY2UoL14weC9pLCAnJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0MDsgaSsrKSB7XG4gICAgICAgIC8vIHRoZSBudGggbGV0dGVyIHNob3VsZCBiZSB1cHBlcmNhc2UgaWYgdGhlIG50aCBkaWdpdCBvZiBjYXNlbWFwIGlzIDFcbiAgICAgICAgaWYgKChwYXJzZUludChhZGRyZXNzSGFzaFtpXSwgMTYpID4gNyAmJiBhZGRyZXNzW2ldLnRvVXBwZXJDYXNlKCkgIT09IGFkZHJlc3NbaV0pIHx8IChwYXJzZUludChhZGRyZXNzSGFzaFtpXSwgMTYpIDw9IDcgJiYgYWRkcmVzc1tpXS50b0xvd2VyQ2FzZSgpICE9PSBhZGRyZXNzW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBwYWQgc3RyaW5nIHRvIGV4cGVjdGVkIGxlbmd0aFxuICpcbiAqIEBtZXRob2QgbGVmdFBhZFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyB0byBiZSBwYWRkZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBjaGFycyB0aGF0IHJlc3VsdCBzdHJpbmcgc2hvdWxkIGhhdmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduLCBieSBkZWZhdWx0IDBcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHJpZ2h0IGFsaWduZWQgc3RyaW5nXG4gKi9cbnZhciBsZWZ0UGFkID0gZnVuY3Rpb24gKHN0cmluZywgY2hhcnMsIHNpZ24pIHtcbiAgICB2YXIgaGFzUHJlZml4ID0gL14weC9pLnRlc3Qoc3RyaW5nKSB8fCB0eXBlb2Ygc3RyaW5nID09PSAnbnVtYmVyJztcbiAgICBzdHJpbmcgPSBzdHJpbmcudG9TdHJpbmcoMTYpLnJlcGxhY2UoL14weC9pLCAnJyk7XG4gICAgdmFyIHBhZGRpbmcgPSAoY2hhcnMgLSBzdHJpbmcubGVuZ3RoICsgMSA+PSAwKSA/IGNoYXJzIC0gc3RyaW5nLmxlbmd0aCArIDEgOiAwO1xuICAgIHJldHVybiAoaGFzUHJlZml4ID8gJzB4JyA6ICcnKSArIG5ldyBBcnJheShwYWRkaW5nKS5qb2luKHNpZ24gPyBzaWduIDogXCIwXCIpICsgc3RyaW5nO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBwYWQgc3RyaW5nIHRvIGV4cGVjdGVkIGxlbmd0aFxuICpcbiAqIEBtZXRob2QgcmlnaHRQYWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgdG8gYmUgcGFkZGVkXG4gKiBAcGFyYW0ge051bWJlcn0gY2hhcnMgdGhhdCByZXN1bHQgc3RyaW5nIHNob3VsZCBoYXZlXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbiwgYnkgZGVmYXVsdCAwXG4gKiBAcmV0dXJucyB7U3RyaW5nfSByaWdodCBhbGlnbmVkIHN0cmluZ1xuICovXG52YXIgcmlnaHRQYWQgPSBmdW5jdGlvbiAoc3RyaW5nLCBjaGFycywgc2lnbikge1xuICAgIHZhciBoYXNQcmVmaXggPSAvXjB4L2kudGVzdChzdHJpbmcpIHx8IHR5cGVvZiBzdHJpbmcgPT09ICdudW1iZXInO1xuICAgIHN0cmluZyA9IHN0cmluZy50b1N0cmluZygxNikucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICB2YXIgcGFkZGluZyA9IChjaGFycyAtIHN0cmluZy5sZW5ndGggKyAxID49IDApID8gY2hhcnMgLSBzdHJpbmcubGVuZ3RoICsgMSA6IDA7XG4gICAgcmV0dXJuIChoYXNQcmVmaXggPyAnMHgnIDogJycpICsgc3RyaW5nICsgKG5ldyBBcnJheShwYWRkaW5nKS5qb2luKHNpZ24gPyBzaWduIDogXCIwXCIpKTtcbn07XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIHV0Zjggc3RyaW5nXG4gKlxuICogQG1ldGhvZCB1dGY4VG9IZXhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xudmFyIHV0ZjhUb0hleCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBzdHIgPSB1dGY4LmVuY29kZShzdHIpO1xuICAgIHZhciBoZXggPSBcIlwiO1xuICAgIC8vIHJlbW92ZSBcXHUwMDAwIHBhZGRpbmcgZnJvbSBlaXRoZXIgc2lkZVxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eKD86XFx1MDAwMCkqLywgJycpO1xuICAgIHN0ciA9IHN0ci5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvXig/OlxcdTAwMDApKi8sICcnKTtcbiAgICBzdHIgPSBzdHIuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8gaWYgKGNvZGUgIT09IDApIHtcbiAgICAgICAgdmFyIG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICAgICAgICAvLyB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBoZXg7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCB1dGY4IGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIGhleFRvVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG52YXIgaGV4VG9VdGY4ID0gZnVuY3Rpb24gKGhleCkge1xuICAgIGlmICghaXNIZXhTdHJpY3QoaGV4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcGFyYW1ldGVyIFwiJyArIGhleCArICdcIiBtdXN0IGJlIGEgdmFsaWQgSEVYIHN0cmluZy4nKTtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgY29kZSA9IDA7XG4gICAgaGV4ID0gaGV4LnJlcGxhY2UoL14weC9pLCAnJyk7XG4gICAgLy8gcmVtb3ZlIDAwIHBhZGRpbmcgZnJvbSBlaXRoZXIgc2lkZVxuICAgIGhleCA9IGhleC5yZXBsYWNlKC9eKD86MDApKi8sICcnKTtcbiAgICBoZXggPSBoZXguc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG4gICAgaGV4ID0gaGV4LnJlcGxhY2UoL14oPzowMCkqLywgJycpO1xuICAgIGhleCA9IGhleC5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICB2YXIgbCA9IGhleC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgICAgY29kZSA9IHBhcnNlSW50KGhleC5zbGljZShpLCBpICsgMiksIDE2KTtcbiAgICAgICAgLy8gaWYgKGNvZGUgIT09IDApIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgcmV0dXJuIHV0ZjguZGVjb2RlKHN0cik7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB2YWx1ZSB0byBpdCdzIG51bWJlciByZXByZXNlbnRhdGlvbi5cbiAqIEhvd2V2ZXIsIGlmIHRoZSB2YWx1ZSBpcyBsYXJnZXIgdGhhbiB0aGUgbWF4aW11bSBzYWZlIGludGVnZXIsIHJldHVybnMgdGhlIHZhbHVlIGFzIGEgc3RyaW5nLlxuICpcbiAqIEBtZXRob2QgaGV4VG9OdW1iZXJcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCTn0gdmFsdWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYmlnSW50T25PdmVyZmxvdyAtIGlmIHRydWUsIHJldHVybiB0aGUgaGV4IHZhbHVlIGluIGNhc2Ugb2Ygb3ZlcmZsb3dcbiAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9XG4gKi9cbnZhciBoZXhUb051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSwgYmlnSW50T25PdmVyZmxvdyA9IGZhbHNlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICFpc0hleFN0cmljdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLicpO1xuICAgIH1cbiAgICBjb25zdCBuID0gdG9CTih2YWx1ZSk7XG4gICAgaWYgKGJpZ0ludE9uT3ZlcmZsb3cgJiYgKG4gPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBuIDwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQobik7XG4gICAgfVxuICAgIHJldHVybiBuLnRvTnVtYmVyKCk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB2YWx1ZSB0byBpdCdzIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gaW4gc3RyaW5nXG4gKlxuICogQG1ldGhvZCBoZXhUb051bWJlclN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJOfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgaGV4VG9OdW1iZXJTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIWlzSGV4U3RyaWN0KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGlzIG5vdCBhIHZhbGlkIGhleCBzdHJpbmcuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b0JOKHZhbHVlKS50b1N0cmluZygxMCk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB2YWx1ZSB0byBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgbnVtYmVyVG9IZXhcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCTn0gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIG51bWJlclRvSGV4ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICghaXNGaW5pdGUodmFsdWUpICYmICFpc0hleFN0cmljdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiBpbnB1dCBcIicgKyB2YWx1ZSArICdcIiBpcyBub3QgYSBudW1iZXIuJyk7XG4gICAgfVxuICAgIHZhciBudW1iZXIgPSB0b0JOKHZhbHVlKTtcbiAgICB2YXIgcmVzdWx0ID0gbnVtYmVyLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gbnVtYmVyLmx0KG5ldyBCTigwKSkgPyAnLTB4JyArIHJlc3VsdC5zbGljZSgxKSA6ICcweCcgKyByZXN1bHQ7XG59O1xuLyoqXG4gKiBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIGhleCBzdHJpbmdcbiAqXG4gKiBOb3RlOiBJbXBsZW1lbnRhdGlvbiBmcm9tIGNyeXB0by1qc1xuICpcbiAqIEBtZXRob2QgYnl0ZXNUb0hleFxuICogQHBhcmFtIHtBcnJheX0gYnl0ZXNcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGhleCBzdHJpbmdcbiAqL1xudmFyIGJ5dGVzVG9IZXggPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICBmb3IgKHZhciBoZXggPSBbXSwgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICAgICAgIGhleC5wdXNoKChieXRlc1tpXSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgaGV4LnB1c2goKGJ5dGVzW2ldICYgMHhGKS50b1N0cmluZygxNikpO1xuICAgICAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuICAgIH1cbiAgICByZXR1cm4gJzB4JyArIGhleC5qb2luKFwiXCIpO1xufTtcbi8qKlxuICogQ29udmVydCBhIGhleCBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gKlxuICogTm90ZTogSW1wbGVtZW50YXRpb24gZnJvbSBjcnlwdG8tanNcbiAqXG4gKiBAbWV0aG9kIGhleFRvQnl0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZXhcbiAqIEByZXR1cm4ge0FycmF5fSB0aGUgYnl0ZSBhcnJheVxuICovXG52YXIgaGV4VG9CeXRlcyA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICBoZXggPSBoZXgudG9TdHJpbmcoMTYpO1xuICAgIGlmICghaXNIZXhTdHJpY3QoaGV4KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIHZhbHVlIFwiJyArIGhleCArICdcIiBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLicpO1xuICAgIH1cbiAgICBoZXggPSBoZXgucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBjID0gMDsgYyA8IGhleC5sZW5ndGg7IGMgKz0gMilcbiAgICAgICAgYnl0ZXMucHVzaChwYXJzZUludChoZXguc2xpY2UoYywgYyArIDIpLCAxNikpO1xuICAgIHJldHVybiBieXRlcztcbn07XG4vKipcbiAqIEF1dG8gY29udmVydHMgYW55IGdpdmVuIHZhbHVlIGludG8gaXQncyBoZXggcmVwcmVzZW50YXRpb24uXG4gKlxuICogQW5kIGV2ZW4gc3RyaW5naWZ5cyBvYmplY3RzIGJlZm9yZS5cbiAqXG4gKiBAbWV0aG9kIHRvSGV4XG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8Qk58T2JqZWN0fEJ1ZmZlcn0gdmFsdWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuVHlwZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgdG9IZXggPSBmdW5jdGlvbiAodmFsdWUsIHJldHVyblR5cGUpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OiBmYWxzZSAqL1xuICAgIGlmIChpc0FkZHJlc3ModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiByZXR1cm5UeXBlID8gJ2FkZHJlc3MnIDogJzB4JyArIHZhbHVlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiByZXR1cm5UeXBlID8gJ2Jvb2wnIDogdmFsdWUgPyAnMHgwMScgOiAnMHgwMCc7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnMHgnICsgdmFsdWUudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhIXZhbHVlICYmICFpc0JpZ051bWJlcih2YWx1ZSkgJiYgIWlzQk4odmFsdWUpKSB7XG4gICAgICAgIHJldHVybiByZXR1cm5UeXBlID8gJ3N0cmluZycgOiB1dGY4VG9IZXgoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG4gICAgLy8gaWYgaXRzIGEgbmVnYXRpdmUgbnVtYmVyLCBwYXNzIGl0IHRocm91Z2ggbnVtYmVyVG9IZXhcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodmFsdWUuaW5kZXhPZignLTB4JykgPT09IDAgfHwgdmFsdWUuaW5kZXhPZignLTBYJykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlID8gJ2ludDI1NicgOiBudW1iZXJUb0hleCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUuaW5kZXhPZignMHgnKSA9PT0gMCB8fCB2YWx1ZS5pbmRleE9mKCcwWCcpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVHlwZSA/ICdieXRlcycgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVHlwZSA/ICdzdHJpbmcnIDogdXRmOFRvSGV4KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVHlwZSA/ICh2YWx1ZSA8IDAgPyAnaW50MjU2JyA6ICd1aW50MjU2JykgOiBudW1iZXJUb0hleCh2YWx1ZSk7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBzdHJpbmcgaXMgSEVYLCByZXF1aXJlcyBhIDB4IGluIGZyb250XG4gKlxuICogQG1ldGhvZCBpc0hleFN0cmljdFxuICogQHBhcmFtIHtTdHJpbmd9IGhleCB0byBiZSBjaGVja2VkXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzSGV4U3RyaWN0ID0gZnVuY3Rpb24gKGhleCkge1xuICAgIHJldHVybiAoKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBoZXggPT09ICdudW1iZXInKSAmJiAvXigtKT8weFswLTlhLWZdKiQvaS50ZXN0KGhleCkpO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgc3RyaW5nIGlzIEhFWFxuICpcbiAqIEBtZXRob2QgaXNIZXhcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZXggdG8gYmUgY2hlY2tlZFxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbnZhciBpc0hleCA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICByZXR1cm4gKCh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgaGV4ID09PSAnbnVtYmVyJykgJiYgL14oLTB4fDB4KT9bMC05YS1mXSokL2kudGVzdChoZXgpKTtcbn07XG4vKipcbiAqIFJlbW92ZSAweCBwcmVmaXggZnJvbSBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIHN0cmlwSGV4UHJlZml4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRvIGJlIGNoZWNrZWRcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbnZhciBzdHJpcEhleFByZWZpeCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoc3RyICE9PSAwICYmIGlzSGV4KHN0cikpXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXigtKT8weC9pLCAnJDEnKTtcbiAgICByZXR1cm4gc3RyO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGdpdmVuIHN0cmluZyBpcyBhIHZhbGlkIEV0aGVyZXVtIGJsb2NrIGhlYWRlciBibG9vbS5cbiAqXG4gKiBAbWV0aG9kIGlzQmxvb21cbiAqIEBwYXJhbSB7U3RyaW5nfSBibG9vbSBlbmNvZGVkIGJsb29tIGZpbHRlclxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQmxvb20gPSBmdW5jdGlvbiAoYmxvb20pIHtcbiAgICByZXR1cm4gZXRoZXJldW1CbG9vbUZpbHRlcnMuaXNCbG9vbShibG9vbSk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGV0aGVyZXVtIHVzZXJzIGFkZHJlc3MgaXMgcGFydCBvZiB0aGUgZ2l2ZW4gYmxvb21cbiAqIG5vdGU6IGZhbHNlIHBvc2l0aXZlcyBhcmUgcG9zc2libGUuXG4gKlxuICogQG1ldGhvZCBpc1VzZXJFdGhlcmV1bUFkZHJlc3NJbkJsb29tXG4gKiBAcGFyYW0ge1N0cmluZ30gZXRoZXJldW1BZGRyZXNzIGVuY29kZWQgYmxvb20gZmlsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gYmxvb20gZXRoZXJldW0gYWRkcmVzc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc1VzZXJFdGhlcmV1bUFkZHJlc3NJbkJsb29tID0gZnVuY3Rpb24gKGJsb29tLCBldGhlcmV1bUFkZHJlc3MpIHtcbiAgICByZXR1cm4gZXRoZXJldW1CbG9vbUZpbHRlcnMuaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbShibG9vbSwgZXRoZXJldW1BZGRyZXNzKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udHJhY3QgYWRkcmVzcyBpcyBwYXJ0IG9mIHRoZSBnaXZlbiBibG9vbVxuICogbm90ZTogZmFsc2UgcG9zaXRpdmVzIGFyZSBwb3NzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIGlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb21cbiAqIEBwYXJhbSB7U3RyaW5nfSBibG9vbSBlbmNvZGVkIGJsb29tIGZpbHRlclxuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRyYWN0QWRkcmVzcyBjb250cmFjdCBhZGRyZXNzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQ29udHJhY3RBZGRyZXNzSW5CbG9vbSA9IGZ1bmN0aW9uIChibG9vbSwgY29udHJhY3RBZGRyZXNzKSB7XG4gICAgcmV0dXJuIGV0aGVyZXVtQmxvb21GaWx0ZXJzLmlzQ29udHJhY3RBZGRyZXNzSW5CbG9vbShibG9vbSwgY29udHJhY3RBZGRyZXNzKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBnaXZlbiBzdHJpbmcgaXMgYSB2YWxpZCBsb2cgdG9waWMuXG4gKlxuICogQG1ldGhvZCBpc1RvcGljXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9waWMgZW5jb2RlZCB0b3BpY1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzVG9waWMgPSBmdW5jdGlvbiAodG9waWMpIHtcbiAgICByZXR1cm4gZXRoZXJldW1CbG9vbUZpbHRlcnMuaXNUb3BpYyh0b3BpYyk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRvcGljIGlzIHBhcnQgb2YgdGhlIGdpdmVuIGJsb29tXG4gKiBub3RlOiBmYWxzZSBwb3NpdGl2ZXMgYXJlIHBvc3NpYmxlLlxuICpcbiAqIEBtZXRob2QgaXNUb3BpY0luQmxvb21cbiAqIEBwYXJhbSB7U3RyaW5nfSBibG9vbSBlbmNvZGVkIGJsb29tIGZpbHRlclxuICogQHBhcmFtIHtTdHJpbmd9IHRvcGljIGVuY29kZWQgdG9waWNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc1RvcGljSW5CbG9vbSA9IGZ1bmN0aW9uIChibG9vbSwgdG9waWMpIHtcbiAgICByZXR1cm4gZXRoZXJldW1CbG9vbUZpbHRlcnMuaXNUb3BpY0luQmxvb20oYmxvb20sIHRvcGljKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgcGFydCBvZiB0aGUgZ2l2ZW4gYmxvb21cbiAqIG5vdGU6IGZhbHNlIHBvc2l0aXZlcyBhcmUgcG9zc2libGUuXG4gKlxuICogQG1ldGhvZCBpc0luQmxvb21cbiAqIEBwYXJhbSB7U3RyaW5nfSBibG9vbSBlbmNvZGVkIGJsb29tIGZpbHRlclxuICogQHBhcmFtIHtTdHJpbmcgfCBVaW50OEFycmF5fSB0b3BpYyBlbmNvZGVkIHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNJbkJsb29tID0gZnVuY3Rpb24gKGJsb29tLCB0b3BpYykge1xuICAgIHJldHVybiBldGhlcmV1bUJsb29tRmlsdGVycy5pc0luQmxvb20oYmxvb20sIHRvcGljKTtcbn07XG4vKipcbiAqIEhhc2hlcyB2YWx1ZXMgdG8gYSBzaGEzIGhhc2ggdXNpbmcga2VjY2FrIDI1NlxuICpcbiAqIFRvIGhhc2ggYSBIRVggc3RyaW5nIHRoZSBoZXggbXVzdCBoYXZlIDB4IGluIGZyb250LlxuICpcbiAqIEBtZXRob2Qgc2hhM1xuICogQHJldHVybiB7U3RyaW5nfSB0aGUgc2hhMyBzdHJpbmdcbiAqL1xudmFyIFNIQTNfTlVMTF9TID0gJzB4YzVkMjQ2MDE4NmY3MjMzYzkyN2U3ZGIyZGNjNzAzYzBlNTAwYjY1M2NhODIyNzNiN2JmYWQ4MDQ1ZDg1YTQ3MCc7XG52YXIgc2hhMyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChpc0JOKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChpc0hleFN0cmljdCh2YWx1ZSkgJiYgL14weC9pLnRlc3QoKHZhbHVlKS50b1N0cmluZygpKSkge1xuICAgICAgICB2YWx1ZSA9IGV0aGVyZXVtanNVdGlsLnRvQnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBc3N1bWUgdmFsdWUgaXMgYW4gYXJiaXRyYXJ5IHN0cmluZ1xuICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmLTgnKTtcbiAgICB9XG4gICAgdmFyIHJldHVyblZhbHVlID0gZXRoZXJldW1qc1V0aWwuYnVmZmVyVG9IZXgoa2VjY2FrMjU2KHZhbHVlKSk7XG4gICAgaWYgKHJldHVyblZhbHVlID09PSBTSEEzX05VTExfUykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9XG59O1xuLy8gZXhwb3NlIHRoZSB1bmRlciB0aGUgaG9vZCBrZWNjYWsyNTZcbnNoYTMuX0hhc2ggPSBrZWNjYWsyNTY7XG4vKipcbiAqIEBtZXRob2Qgc2hhM1Jhd1xuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbnZhciBzaGEzUmF3ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBzaGEzKHZhbHVlKTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFNIQTNfTlVMTF9TO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuLyoqXG4gKiBBdXRvIGNvbnZlcnRzIGFueSBnaXZlbiB2YWx1ZSBpbnRvIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uLFxuICogdGhlbiBjb252ZXJ0cyBoZXggdG8gbnVtYmVyLlxuICpcbiAqIEBtZXRob2QgdG9OdW1iZXJcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCTn0gdmFsdWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYmlnSW50T25PdmVyZmxvdyAtIGlmIHRydWUsIHJldHVybiB0aGUgaGV4IHZhbHVlIGluIGNhc2Ugb2Ygb3ZlcmZsb3dcbiAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9XG4gKi9cbnZhciB0b051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSwgYmlnSW50T25PdmVyZmxvdyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSA6IGhleFRvTnVtYmVyKHRvSGV4KHZhbHVlKSwgYmlnSW50T25PdmVyZmxvdyk7XG59O1xuLy8gMS54IGN1cnJlbnRseSBhY2NlcHRzIDB4Li4uIHN0cmluZ3MsIGJuLmpzIGFmdGVyIHVwZGF0ZSBkb2Vzbid0LiBpdCB3b3VsZCBiZSBhIGJyZWFraW5nIGNoYW5nZVxudmFyIEJOd3JhcHBlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIGNoZWNrIG5lZ2F0aXZlXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiICYmIHZhbHVlLmluY2x1ZGVzKFwiMHhcIikpIHtcbiAgICAgICAgY29uc3QgW25lZ2F0aXZlLCBoZXhWYWx1ZV0gPSB2YWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJy0nKSA/IFtcIi1cIiwgdmFsdWUuc2xpY2UoMyldIDogW1wiXCIsIHZhbHVlLnNsaWNlKDIpXTtcbiAgICAgICAgcmV0dXJuIG5ldyBCTihuZWdhdGl2ZSArIGhleFZhbHVlLCAxNik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IEJOKHZhbHVlKTtcbiAgICB9XG59O1xuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJOd3JhcHBlZCwgQk4pO1xuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJOd3JhcHBlZC5wcm90b3R5cGUsIEJOLnByb3RvdHlwZSk7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBCTjogQk53cmFwcGVkLFxuICAgIGlzQk46IGlzQk4sXG4gICAgaXNCaWdOdW1iZXI6IGlzQmlnTnVtYmVyLFxuICAgIHRvQk46IHRvQk4sXG4gICAgaXNBZGRyZXNzOiBpc0FkZHJlc3MsXG4gICAgaXNCbG9vbTogaXNCbG9vbSxcbiAgICBpc1VzZXJFdGhlcmV1bUFkZHJlc3NJbkJsb29tOiBpc1VzZXJFdGhlcmV1bUFkZHJlc3NJbkJsb29tLFxuICAgIGlzQ29udHJhY3RBZGRyZXNzSW5CbG9vbTogaXNDb250cmFjdEFkZHJlc3NJbkJsb29tLFxuICAgIGlzVG9waWM6IGlzVG9waWMsXG4gICAgaXNUb3BpY0luQmxvb206IGlzVG9waWNJbkJsb29tLFxuICAgIGlzSW5CbG9vbTogaXNJbkJsb29tLFxuICAgIGNoZWNrQWRkcmVzc0NoZWNrc3VtOiBjaGVja0FkZHJlc3NDaGVja3N1bSxcbiAgICB1dGY4VG9IZXg6IHV0ZjhUb0hleCxcbiAgICBoZXhUb1V0Zjg6IGhleFRvVXRmOCxcbiAgICBoZXhUb051bWJlcjogaGV4VG9OdW1iZXIsXG4gICAgaGV4VG9OdW1iZXJTdHJpbmc6IGhleFRvTnVtYmVyU3RyaW5nLFxuICAgIG51bWJlclRvSGV4OiBudW1iZXJUb0hleCxcbiAgICB0b0hleDogdG9IZXgsXG4gICAgaGV4VG9CeXRlczogaGV4VG9CeXRlcyxcbiAgICBieXRlc1RvSGV4OiBieXRlc1RvSGV4LFxuICAgIGlzSGV4OiBpc0hleCxcbiAgICBpc0hleFN0cmljdDogaXNIZXhTdHJpY3QsXG4gICAgc3RyaXBIZXhQcmVmaXg6IHN0cmlwSGV4UHJlZml4LFxuICAgIGxlZnRQYWQ6IGxlZnRQYWQsXG4gICAgcmlnaHRQYWQ6IHJpZ2h0UGFkLFxuICAgIHRvVHdvc0NvbXBsZW1lbnQ6IHRvVHdvc0NvbXBsZW1lbnQsXG4gICAgc2hhMzogc2hhMyxcbiAgICBzaGEzUmF3OiBzaGEzUmF3LFxuICAgIHRvTnVtYmVyOiB0b051bWJlclxufTtcbiJdLCJuYW1lcyI6WyJCTiIsInJlcXVpcmUiLCJudW1iZXJUb0JOIiwidXRmOCIsImV0aGVyZXVtanNVdGlsIiwiZXRoZXJldW1CbG9vbUZpbHRlcnMiLCJrZWNjYWsyNTYiLCJpc0JOIiwib2JqZWN0IiwiaXNCaWdOdW1iZXIiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJ0b0JOIiwibnVtYmVyIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJlIiwiRXJyb3IiLCJ0b1R3b3NDb21wbGVtZW50IiwidG9Ud29zIiwidG9TdHJpbmciLCJpc0FkZHJlc3MiLCJhZGRyZXNzIiwidGVzdCIsImNoZWNrQWRkcmVzc0NoZWNrc3VtIiwicmVwbGFjZSIsImFkZHJlc3NIYXNoIiwic2hhMyIsInRvTG93ZXJDYXNlIiwiaSIsInBhcnNlSW50IiwidG9VcHBlckNhc2UiLCJsZWZ0UGFkIiwic3RyaW5nIiwiY2hhcnMiLCJzaWduIiwiaGFzUHJlZml4IiwicGFkZGluZyIsImxlbmd0aCIsIkFycmF5Iiwiam9pbiIsInJpZ2h0UGFkIiwidXRmOFRvSGV4Iiwic3RyIiwiZW5jb2RlIiwiaGV4Iiwic3BsaXQiLCJyZXZlcnNlIiwiY29kZSIsImNoYXJDb2RlQXQiLCJuIiwiaGV4VG9VdGY4IiwiaXNIZXhTdHJpY3QiLCJsIiwic2xpY2UiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJkZWNvZGUiLCJoZXhUb051bWJlciIsInZhbHVlIiwiYmlnSW50T25PdmVyZmxvdyIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJNSU5fU0FGRV9JTlRFR0VSIiwiQmlnSW50IiwidG9OdW1iZXIiLCJoZXhUb051bWJlclN0cmluZyIsIm51bWJlclRvSGV4IiwidW5kZWZpbmVkIiwiaXNGaW5pdGUiLCJyZXN1bHQiLCJsdCIsImJ5dGVzVG9IZXgiLCJieXRlcyIsInB1c2giLCJoZXhUb0J5dGVzIiwiYyIsInRvSGV4IiwicmV0dXJuVHlwZSIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiSlNPTiIsInN0cmluZ2lmeSIsImluZGV4T2YiLCJpc0hleCIsInN0cmlwSGV4UHJlZml4IiwiaXNCbG9vbSIsImJsb29tIiwiaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbSIsImV0aGVyZXVtQWRkcmVzcyIsImlzQ29udHJhY3RBZGRyZXNzSW5CbG9vbSIsImNvbnRyYWN0QWRkcmVzcyIsImlzVG9waWMiLCJ0b3BpYyIsImlzVG9waWNJbkJsb29tIiwiaXNJbkJsb29tIiwiU0hBM19OVUxMX1MiLCJ0b0J1ZmZlciIsImZyb20iLCJyZXR1cm5WYWx1ZSIsImJ1ZmZlclRvSGV4IiwiX0hhc2giLCJzaGEzUmF3IiwiQk53cmFwcGVkIiwiaW5jbHVkZXMiLCJuZWdhdGl2ZSIsImhleFZhbHVlIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJzdGFydHNXaXRoIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/web3-utils@1.10.3/node_modules/web3-utils/lib/utils.js\n");

/***/ })

};
;