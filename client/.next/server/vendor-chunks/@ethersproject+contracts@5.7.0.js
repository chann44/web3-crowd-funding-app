"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ethersproject+contracts@5.7.0";
exports.ids = ["vendor-chunks/@ethersproject+contracts@5.7.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@ethersproject+contracts@5.7.0/node_modules/@ethersproject/contracts/lib.esm/_version.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ethersproject+contracts@5.7.0/node_modules/@ethersproject/contracts/lib.esm/_version.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"contracts/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGV0aGVyc3Byb2plY3QrY29udHJhY3RzQDUuNy4wL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb250cmFjdHMvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSxrQkFBa0IsQ0FDekMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K2NvbnRyYWN0c0A1LjcuMC9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvY29udHJhY3RzL2xpYi5lc20vX3ZlcnNpb24uanM/NTRmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiY29udHJhY3RzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@ethersproject+contracts@5.7.0/node_modules/@ethersproject/contracts/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@ethersproject+contracts@5.7.0/node_modules/@ethersproject/contracts/lib.esm/index.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ethersproject+contracts@5.7.0/node_modules/@ethersproject/contracts/lib.esm/index.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseContract: () => (/* binding */ BaseContract),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   ContractFactory: () => (/* binding */ ContractFactory)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/abi */ \"(ssr)/./node_modules/.pnpm/@ethersproject+abi@5.7.0/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/abi */ \"(ssr)/./node_modules/.pnpm/@ethersproject+abi@5.7.0/node_modules/@ethersproject/abi/lib.esm/interface.js\");\n/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/./node_modules/.pnpm/@ethersproject+abstract-provider@5.7.0/node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/abstract-signer */ \"(ssr)/./node_modules/.pnpm/@ethersproject+abstract-signer@5.7.0/node_modules/@ethersproject/abstract-signer/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/.pnpm/@ethersproject+address@5.7.0/node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/./node_modules/.pnpm/@ethersproject+transactions@5.7.0/node_modules/@ethersproject/transactions/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/.pnpm/@ethersproject+contracts@5.7.0/node_modules/@ethersproject/contracts/lib.esm/_version.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n;\n;\n///////////////////////////////\nconst allowedTransactionKeys = {\n    chainId: true,\n    data: true,\n    from: true,\n    gasLimit: true,\n    gasPrice: true,\n    nonce: true,\n    to: true,\n    value: true,\n    type: true,\n    accessList: true,\n    maxFeePerGas: true,\n    maxPriorityFeePerGas: true,\n    customData: true,\n    ccipReadEnabled: true\n};\nfunction resolveName(resolver, nameOrPromise) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const name = yield nameOrPromise;\n        if (typeof name !== \"string\") {\n            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\n        }\n        // If it is already an address, just use it (after adding checksum)\n        try {\n            return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(name);\n        } catch (error) {}\n        if (!resolver) {\n            logger.throwError(\"a provider or signer is needed to resolve ENS names\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"resolveName\"\n            });\n        }\n        const address = yield resolver.resolveName(name);\n        if (address == null) {\n            logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\n        }\n        return address;\n    });\n}\n// Recursively replaces ENS names with promises to resolve the name and resolves all properties\nfunction resolveAddresses(resolver, value, paramType) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (Array.isArray(paramType)) {\n            return yield Promise.all(paramType.map((paramType, index)=>{\n                return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType.name], paramType);\n            }));\n        }\n        if (paramType.type === \"address\") {\n            return yield resolveName(resolver, value);\n        }\n        if (paramType.type === \"tuple\") {\n            return yield resolveAddresses(resolver, value, paramType.components);\n        }\n        if (paramType.baseType === \"array\") {\n            if (!Array.isArray(value)) {\n                return Promise.reject(logger.makeError(\"invalid value for array\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"value\",\n                    value\n                }));\n            }\n            return yield Promise.all(value.map((v)=>resolveAddresses(resolver, v, paramType.arrayChildren)));\n        }\n        return value;\n    });\n}\nfunction populateTransaction(contract, fragment, args) {\n    return __awaiter(this, void 0, void 0, function*() {\n        // If an extra argument is given, it is overrides\n        let overrides = {};\n        if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === \"object\") {\n            overrides = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(args.pop());\n        }\n        // Make sure the parameter count matches\n        logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\n        // Populate \"from\" override (allow promises)\n        if (contract.signer) {\n            if (overrides.from) {\n                // Contracts with a Signer are from the Signer's frame-of-reference;\n                // but we allow overriding \"from\" if it matches the signer\n                overrides.from = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)({\n                    override: resolveName(contract.signer, overrides.from),\n                    signer: contract.signer.getAddress()\n                }).then((check)=>__awaiter(this, void 0, void 0, function*() {\n                        if ((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(check.signer) !== check.override) {\n                            logger.throwError(\"Contract with a Signer cannot override from\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                                operation: \"overrides.from\"\n                            });\n                        }\n                        return check.override;\n                    }));\n            } else {\n                overrides.from = contract.signer.getAddress();\n            }\n        } else if (overrides.from) {\n            overrides.from = resolveName(contract.provider, overrides.from);\n        //} else {\n        // Contracts without a signer can override \"from\", and if\n        // unspecified the zero address is used\n        //overrides.from = AddressZero;\n        }\n        // Wait for all dependencies to be resolved (prefer the signer over the provider)\n        const resolved = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)({\n            args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n            address: contract.resolvedAddress,\n            overrides: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)(overrides) || {}\n        });\n        // The ABI coded transaction\n        const data = contract.interface.encodeFunctionData(fragment, resolved.args);\n        const tx = {\n            data: data,\n            to: resolved.address\n        };\n        // Resolved Overrides\n        const ro = resolved.overrides;\n        // Populate simple overrides\n        if (ro.nonce != null) {\n            tx.nonce = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.nonce).toNumber();\n        }\n        if (ro.gasLimit != null) {\n            tx.gasLimit = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.gasLimit);\n        }\n        if (ro.gasPrice != null) {\n            tx.gasPrice = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.gasPrice);\n        }\n        if (ro.maxFeePerGas != null) {\n            tx.maxFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.maxFeePerGas);\n        }\n        if (ro.maxPriorityFeePerGas != null) {\n            tx.maxPriorityFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.maxPriorityFeePerGas);\n        }\n        if (ro.from != null) {\n            tx.from = ro.from;\n        }\n        if (ro.type != null) {\n            tx.type = ro.type;\n        }\n        if (ro.accessList != null) {\n            tx.accessList = (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_5__.accessListify)(ro.accessList);\n        }\n        // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n        if (tx.gasLimit == null && fragment.gas != null) {\n            // Compute the intrinsic gas cost for this transaction\n            // @TODO: This is based on the yellow paper as of Petersburg; this is something\n            // we may wish to parameterize in v6 as part of the Network object. Since this\n            // is always a non-nil to address, we can ignore G_create, but may wish to add\n            // similar logic to the ContractFactory.\n            let intrinsic = 21000;\n            const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(data);\n            for(let i = 0; i < bytes.length; i++){\n                intrinsic += 4;\n                if (bytes[i]) {\n                    intrinsic += 64;\n                }\n            }\n            tx.gasLimit = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(fragment.gas).add(intrinsic);\n        }\n        // Populate \"value\" override\n        if (ro.value) {\n            const roValue = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.value);\n            if (!roValue.isZero() && !fragment.payable) {\n                logger.throwError(\"non-payable method cannot override value\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: overrides.value\n                });\n            }\n            tx.value = roValue;\n        }\n        if (ro.customData) {\n            tx.customData = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(ro.customData);\n        }\n        if (ro.ccipReadEnabled) {\n            tx.ccipReadEnabled = !!ro.ccipReadEnabled;\n        }\n        // Remove the overrides\n        delete overrides.nonce;\n        delete overrides.gasLimit;\n        delete overrides.gasPrice;\n        delete overrides.from;\n        delete overrides.value;\n        delete overrides.type;\n        delete overrides.accessList;\n        delete overrides.maxFeePerGas;\n        delete overrides.maxPriorityFeePerGas;\n        delete overrides.customData;\n        delete overrides.ccipReadEnabled;\n        // Make sure there are no stray overrides, which may indicate a\n        // typo or using an unsupported key.\n        const leftovers = Object.keys(overrides).filter((key)=>overrides[key] != null);\n        if (leftovers.length) {\n            logger.throwError(`cannot override ${leftovers.map((l)=>JSON.stringify(l)).join(\",\")}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"overrides\",\n                overrides: leftovers\n            });\n        }\n        return tx;\n    });\n}\nfunction buildPopulate(contract, fragment) {\n    return function(...args) {\n        return populateTransaction(contract, fragment, args);\n    };\n}\nfunction buildEstimate(contract, fragment) {\n    const signerOrProvider = contract.signer || contract.provider;\n    return function(...args) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!signerOrProvider) {\n                logger.throwError(\"estimate require a provider or signer\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"estimateGas\"\n                });\n            }\n            const tx = yield populateTransaction(contract, fragment, args);\n            return yield signerOrProvider.estimateGas(tx);\n        });\n    };\n}\nfunction addContractWait(contract, tx) {\n    const wait = tx.wait.bind(tx);\n    tx.wait = (confirmations)=>{\n        return wait(confirmations).then((receipt)=>{\n            receipt.events = receipt.logs.map((log)=>{\n                let event = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(log);\n                let parsed = null;\n                try {\n                    parsed = contract.interface.parseLog(log);\n                } catch (e) {}\n                // Successfully parsed the event log; include it\n                if (parsed) {\n                    event.args = parsed.args;\n                    event.decode = (data, topics)=>{\n                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n                    };\n                    event.event = parsed.name;\n                    event.eventSignature = parsed.signature;\n                }\n                // Useful operations\n                event.removeListener = ()=>{\n                    return contract.provider;\n                };\n                event.getBlock = ()=>{\n                    return contract.provider.getBlock(receipt.blockHash);\n                };\n                event.getTransaction = ()=>{\n                    return contract.provider.getTransaction(receipt.transactionHash);\n                };\n                event.getTransactionReceipt = ()=>{\n                    return Promise.resolve(receipt);\n                };\n                return event;\n            });\n            return receipt;\n        });\n    };\n}\nfunction buildCall(contract, fragment, collapseSimple) {\n    const signerOrProvider = contract.signer || contract.provider;\n    return function(...args) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Extract the \"blockTag\" override if present\n            let blockTag = undefined;\n            if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === \"object\") {\n                const overrides = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(args.pop());\n                if (overrides.blockTag != null) {\n                    blockTag = yield overrides.blockTag;\n                }\n                delete overrides.blockTag;\n                args.push(overrides);\n            }\n            // If the contract was just deployed, wait until it is mined\n            if (contract.deployTransaction != null) {\n                yield contract._deployed(blockTag);\n            }\n            // Call a node and get the result\n            const tx = yield populateTransaction(contract, fragment, args);\n            const result = yield signerOrProvider.call(tx, blockTag);\n            try {\n                let value = contract.interface.decodeFunctionResult(fragment, result);\n                if (collapseSimple && fragment.outputs.length === 1) {\n                    value = value[0];\n                }\n                return value;\n            } catch (error) {\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION) {\n                    error.address = contract.address;\n                    error.args = args;\n                    error.transaction = tx;\n                }\n                throw error;\n            }\n        });\n    };\n}\nfunction buildSend(contract, fragment) {\n    return function(...args) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!contract.signer) {\n                logger.throwError(\"sending a transaction requires a signer\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"sendTransaction\"\n                });\n            }\n            // If the contract was just deployed, wait until it is mined\n            if (contract.deployTransaction != null) {\n                yield contract._deployed();\n            }\n            const txRequest = yield populateTransaction(contract, fragment, args);\n            const tx = yield contract.signer.sendTransaction(txRequest);\n            // Tweak the tx.wait so the receipt has extra properties\n            addContractWait(contract, tx);\n            return tx;\n        });\n    };\n}\nfunction buildDefault(contract, fragment, collapseSimple) {\n    if (fragment.constant) {\n        return buildCall(contract, fragment, collapseSimple);\n    }\n    return buildSend(contract, fragment);\n}\nfunction getEventTag(filter) {\n    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n        return \"*\";\n    }\n    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map((topic)=>{\n        if (Array.isArray(topic)) {\n            return topic.join(\"|\");\n        }\n        return topic;\n    }).join(\":\") : \"\");\n}\nclass RunningEvent {\n    constructor(tag, filter){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"tag\", tag);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"filter\", filter);\n        this._listeners = [];\n    }\n    addListener(listener, once) {\n        this._listeners.push({\n            listener: listener,\n            once: once\n        });\n    }\n    removeListener(listener) {\n        let done = false;\n        this._listeners = this._listeners.filter((item)=>{\n            if (done || item.listener !== listener) {\n                return true;\n            }\n            done = true;\n            return false;\n        });\n    }\n    removeAllListeners() {\n        this._listeners = [];\n    }\n    listeners() {\n        return this._listeners.map((i)=>i.listener);\n    }\n    listenerCount() {\n        return this._listeners.length;\n    }\n    run(args) {\n        const listenerCount = this.listenerCount();\n        this._listeners = this._listeners.filter((item)=>{\n            const argsCopy = args.slice();\n            // Call the callback in the next event loop\n            setTimeout(()=>{\n                item.listener.apply(this, argsCopy);\n            }, 0);\n            // Reschedule it if it not \"once\"\n            return !item.once;\n        });\n        return listenerCount;\n    }\n    prepareEvent(event) {}\n    // Returns the array that will be applied to an emit\n    getEmit(event) {\n        return [\n            event\n        ];\n    }\n}\nclass ErrorRunningEvent extends RunningEvent {\n    constructor(){\n        super(\"error\", null);\n    }\n}\n// @TODO Fragment should inherit Wildcard? and just override getEmit?\n//       or have a common abstract super class, with enough constructor\n//       options to configure both.\n// A Fragment Event will populate all the properties that Wildcard\n// will, and additionally dereference the arguments when emitting\nclass FragmentRunningEvent extends RunningEvent {\n    constructor(address, contractInterface, fragment, topics){\n        const filter = {\n            address: address\n        };\n        let topic = contractInterface.getEventTopic(fragment);\n        if (topics) {\n            if (topic !== topics[0]) {\n                logger.throwArgumentError(\"topic mismatch\", \"topics\", topics);\n            }\n            filter.topics = topics.slice();\n        } else {\n            filter.topics = [\n                topic\n            ];\n        }\n        super(getEventTag(filter), filter);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"address\", address);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"interface\", contractInterface);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"fragment\", fragment);\n    }\n    prepareEvent(event) {\n        super.prepareEvent(event);\n        event.event = this.fragment.name;\n        event.eventSignature = this.fragment.format();\n        event.decode = (data, topics)=>{\n            return this.interface.decodeEventLog(this.fragment, data, topics);\n        };\n        try {\n            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n        } catch (error) {\n            event.args = null;\n            event.decodeError = error;\n        }\n    }\n    getEmit(event) {\n        const errors = (0,_ethersproject_abi__WEBPACK_IMPORTED_MODULE_7__.checkResultErrors)(event.args);\n        if (errors.length) {\n            throw errors[0].error;\n        }\n        const args = (event.args || []).slice();\n        args.push(event);\n        return args;\n    }\n}\n// A Wildcard Event will attempt to populate:\n//  - event            The name of the event name\n//  - eventSignature   The full signature of the event\n//  - decode           A function to decode data and topics\n//  - args             The decoded data and topics\nclass WildcardRunningEvent extends RunningEvent {\n    constructor(address, contractInterface){\n        super(\"*\", {\n            address: address\n        });\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"address\", address);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"interface\", contractInterface);\n    }\n    prepareEvent(event) {\n        super.prepareEvent(event);\n        try {\n            const parsed = this.interface.parseLog(event);\n            event.event = parsed.name;\n            event.eventSignature = parsed.signature;\n            event.decode = (data, topics)=>{\n                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n            };\n            event.args = parsed.args;\n        } catch (error) {\n        // No matching event\n        }\n    }\n}\nclass BaseContract {\n    constructor(addressOrName, contractInterface, signerOrProvider){\n        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n        //address = getAddress(address);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"interface\", (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getInterface\")(contractInterface));\n        if (signerOrProvider == null) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"provider\", null);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"signer\", null);\n        } else if (_ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__.Signer.isSigner(signerOrProvider)) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"provider\", signerOrProvider.provider || null);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"signer\", signerOrProvider);\n        } else if (_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_9__.Provider.isProvider(signerOrProvider)) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"provider\", signerOrProvider);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"signer\", null);\n        } else {\n            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"callStatic\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"estimateGas\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"functions\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"populateTransaction\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"filters\", {});\n        {\n            const uniqueFilters = {};\n            Object.keys(this.interface.events).forEach((eventSignature)=>{\n                const event = this.interface.events[eventSignature];\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.filters, eventSignature, (...args)=>{\n                    return {\n                        address: this.address,\n                        topics: this.interface.encodeFilterTopics(event, args)\n                    };\n                });\n                if (!uniqueFilters[event.name]) {\n                    uniqueFilters[event.name] = [];\n                }\n                uniqueFilters[event.name].push(eventSignature);\n            });\n            Object.keys(uniqueFilters).forEach((name)=>{\n                const filters = uniqueFilters[name];\n                if (filters.length === 1) {\n                    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.filters, name, this.filters[filters[0]]);\n                } else {\n                    logger.warn(`Duplicate definition of ${name} (${filters.join(\", \")})`);\n                }\n            });\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_runningEvents\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_wrappedEmits\", {});\n        if (addressOrName == null) {\n            logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"address\", addressOrName);\n        if (this.provider) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\n        } else {\n            try {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"resolvedAddress\", Promise.resolve((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(addressOrName)));\n            } catch (error) {\n                // Without a provider, we cannot use ENS names\n                logger.throwError(\"provider is required to use ENS name as contract address\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"new Contract\"\n                });\n            }\n        }\n        // Swallow bad ENS names to prevent Unhandled Exceptions\n        this.resolvedAddress.catch((e)=>{});\n        const uniqueNames = {};\n        const uniqueSignatures = {};\n        Object.keys(this.interface.functions).forEach((signature)=>{\n            const fragment = this.interface.functions[signature];\n            // Check that the signature is unique; if not the ABI generation has\n            // not been cleaned or may be incorrectly generated\n            if (uniqueSignatures[signature]) {\n                logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);\n                return;\n            }\n            uniqueSignatures[signature] = true;\n            // Track unique names; we only expose bare named functions if they\n            // are ambiguous\n            {\n                const name = fragment.name;\n                if (!uniqueNames[`%${name}`]) {\n                    uniqueNames[`%${name}`] = [];\n                }\n                uniqueNames[`%${name}`].push(signature);\n            }\n            if (this[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, signature, buildDefault(this, fragment, true));\n            }\n            // We do not collapse simple calls on this bucket, which allows\n            // frameworks to safely use this without introspection as well as\n            // allows decoding error recovery.\n            if (this.functions[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.functions, signature, buildDefault(this, fragment, false));\n            }\n            if (this.callStatic[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.callStatic, signature, buildCall(this, fragment, true));\n            }\n            if (this.populateTransaction[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.populateTransaction, signature, buildPopulate(this, fragment));\n            }\n            if (this.estimateGas[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.estimateGas, signature, buildEstimate(this, fragment));\n            }\n        });\n        Object.keys(uniqueNames).forEach((name)=>{\n            // Ambiguous names to not get attached as bare names\n            const signatures = uniqueNames[name];\n            if (signatures.length > 1) {\n                return;\n            }\n            // Strip off the leading \"%\" used for prototype protection\n            name = name.substring(1);\n            const signature = signatures[0];\n            // If overwriting a member property that is null, swallow the error\n            try {\n                if (this[name] == null) {\n                    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, name, this[signature]);\n                }\n            } catch (e) {}\n            if (this.functions[name] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.functions, name, this.functions[signature]);\n            }\n            if (this.callStatic[name] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.callStatic, name, this.callStatic[signature]);\n            }\n            if (this.populateTransaction[name] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.populateTransaction, name, this.populateTransaction[signature]);\n            }\n            if (this.estimateGas[name] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.estimateGas, name, this.estimateGas[signature]);\n            }\n        });\n    }\n    static getContractAddress(transaction) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getContractAddress)(transaction);\n    }\n    static getInterface(contractInterface) {\n        if (_ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.Interface.isInterface(contractInterface)) {\n            return contractInterface;\n        }\n        return new _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.Interface(contractInterface);\n    }\n    // @TODO: Allow timeout?\n    deployed() {\n        return this._deployed();\n    }\n    _deployed(blockTag) {\n        if (!this._deployedPromise) {\n            // If we were just deployed, we know the transaction we should occur in\n            if (this.deployTransaction) {\n                this._deployedPromise = this.deployTransaction.wait().then(()=>{\n                    return this;\n                });\n            } else {\n                // @TODO: Once we allow a timeout to be passed in, we will wait\n                // up to that many blocks for getCode\n                // Otherwise, poll for our code to be deployed\n                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code)=>{\n                    if (code === \"0x\") {\n                        logger.throwError(\"contract not deployed\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                            contractAddress: this.address,\n                            operation: \"getDeployed\"\n                        });\n                    }\n                    return this;\n                });\n            }\n        }\n        return this._deployedPromise;\n    }\n    // @TODO:\n    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n    // @TODO:\n    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n    fallback(overrides) {\n        if (!this.signer) {\n            logger.throwError(\"sending a transactions require a signer\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"sendTransaction(fallback)\"\n            });\n        }\n        const tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(overrides || {});\n        [\n            \"from\",\n            \"to\"\n        ].forEach(function(key) {\n            if (tx[key] == null) {\n                return;\n            }\n            logger.throwError(\"cannot override \" + key, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: key\n            });\n        });\n        tx.to = this.resolvedAddress;\n        return this.deployed().then(()=>{\n            return this.signer.sendTransaction(tx);\n        });\n    }\n    // Reconnect to a different signer or provider\n    connect(signerOrProvider) {\n        if (typeof signerOrProvider === \"string\") {\n            signerOrProvider = new _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__.VoidSigner(signerOrProvider, this.provider);\n        }\n        const contract = new this.constructor(this.address, this.interface, signerOrProvider);\n        if (this.deployTransaction) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(contract, \"deployTransaction\", this.deployTransaction);\n        }\n        return contract;\n    }\n    // Re-attach to a different on-chain instance of this contract\n    attach(addressOrName) {\n        return new this.constructor(addressOrName, this.interface, this.signer || this.provider);\n    }\n    static isIndexed(value) {\n        return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.Indexed.isIndexed(value);\n    }\n    _normalizeRunningEvent(runningEvent) {\n        // Already have an instance of this event running; we can re-use it\n        if (this._runningEvents[runningEvent.tag]) {\n            return this._runningEvents[runningEvent.tag];\n        }\n        return runningEvent;\n    }\n    _getRunningEvent(eventName) {\n        if (typeof eventName === \"string\") {\n            // Listen for \"error\" events (if your contract has an error event, include\n            // the full signature to bypass this special event keyword)\n            if (eventName === \"error\") {\n                return this._normalizeRunningEvent(new ErrorRunningEvent());\n            }\n            // Listen for any event that is registered\n            if (eventName === \"event\") {\n                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n            }\n            // Listen for any event\n            if (eventName === \"*\") {\n                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n            }\n            // Get the event Fragment (throws if ambiguous/unknown event)\n            const fragment = this.interface.getEvent(eventName);\n            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n        }\n        // We have topics to filter by...\n        if (eventName.topics && eventName.topics.length > 0) {\n            // Is it a known topichash? (throws if no matching topichash)\n            try {\n                const topic = eventName.topics[0];\n                if (typeof topic !== \"string\") {\n                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n                }\n                const fragment = this.interface.getEvent(topic);\n                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n            } catch (error) {}\n            // Filter by the unknown topichash\n            const filter = {\n                address: this.address,\n                topics: eventName.topics\n            };\n            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n        }\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n    }\n    _checkRunningEvents(runningEvent) {\n        if (runningEvent.listenerCount() === 0) {\n            delete this._runningEvents[runningEvent.tag];\n            // If we have a poller for this, remove it\n            const emit = this._wrappedEmits[runningEvent.tag];\n            if (emit && runningEvent.filter) {\n                this.provider.off(runningEvent.filter, emit);\n                delete this._wrappedEmits[runningEvent.tag];\n            }\n        }\n    }\n    // Subclasses can override this to gracefully recover\n    // from parse errors if they wish\n    _wrapEvent(runningEvent, log, listener) {\n        const event = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(log);\n        event.removeListener = ()=>{\n            if (!listener) {\n                return;\n            }\n            runningEvent.removeListener(listener);\n            this._checkRunningEvents(runningEvent);\n        };\n        event.getBlock = ()=>{\n            return this.provider.getBlock(log.blockHash);\n        };\n        event.getTransaction = ()=>{\n            return this.provider.getTransaction(log.transactionHash);\n        };\n        event.getTransactionReceipt = ()=>{\n            return this.provider.getTransactionReceipt(log.transactionHash);\n        };\n        // This may throw if the topics and data mismatch the signature\n        runningEvent.prepareEvent(event);\n        return event;\n    }\n    _addEventListener(runningEvent, listener, once) {\n        if (!this.provider) {\n            logger.throwError(\"events require a provider or a signer with a provider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"once\"\n            });\n        }\n        runningEvent.addListener(listener, once);\n        // Track this running event and its listeners (may already be there; but no hard in updating)\n        this._runningEvents[runningEvent.tag] = runningEvent;\n        // If we are not polling the provider, start polling\n        if (!this._wrappedEmits[runningEvent.tag]) {\n            const wrappedEmit = (log)=>{\n                let event = this._wrapEvent(runningEvent, log, listener);\n                // Try to emit the result for the parameterized event...\n                if (event.decodeError == null) {\n                    try {\n                        const args = runningEvent.getEmit(event);\n                        this.emit(runningEvent.filter, ...args);\n                    } catch (error) {\n                        event.decodeError = error.error;\n                    }\n                }\n                // Always emit \"event\" for fragment-base events\n                if (runningEvent.filter != null) {\n                    this.emit(\"event\", event);\n                }\n                // Emit \"error\" if there was an error\n                if (event.decodeError != null) {\n                    this.emit(\"error\", event.decodeError, event);\n                }\n            };\n            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n            // Special events, like \"error\" do not have a filter\n            if (runningEvent.filter != null) {\n                this.provider.on(runningEvent.filter, wrappedEmit);\n            }\n        }\n    }\n    queryFilter(event, fromBlockOrBlockhash, toBlock) {\n        const runningEvent = this._getRunningEvent(event);\n        const filter = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(runningEvent.filter);\n        if (typeof fromBlockOrBlockhash === \"string\" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isHexString)(fromBlockOrBlockhash, 32)) {\n            if (toBlock != null) {\n                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n            }\n            filter.blockHash = fromBlockOrBlockhash;\n        } else {\n            filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;\n            filter.toBlock = toBlock != null ? toBlock : \"latest\";\n        }\n        return this.provider.getLogs(filter).then((logs)=>{\n            return logs.map((log)=>this._wrapEvent(runningEvent, log, null));\n        });\n    }\n    on(event, listener) {\n        this._addEventListener(this._getRunningEvent(event), listener, false);\n        return this;\n    }\n    once(event, listener) {\n        this._addEventListener(this._getRunningEvent(event), listener, true);\n        return this;\n    }\n    emit(eventName, ...args) {\n        if (!this.provider) {\n            return false;\n        }\n        const runningEvent = this._getRunningEvent(eventName);\n        const result = runningEvent.run(args) > 0;\n        // May have drained all the \"once\" events; check for living events\n        this._checkRunningEvents(runningEvent);\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!this.provider) {\n            return 0;\n        }\n        if (eventName == null) {\n            return Object.keys(this._runningEvents).reduce((accum, key)=>{\n                return accum + this._runningEvents[key].listenerCount();\n            }, 0);\n        }\n        return this._getRunningEvent(eventName).listenerCount();\n    }\n    listeners(eventName) {\n        if (!this.provider) {\n            return [];\n        }\n        if (eventName == null) {\n            const result = [];\n            for(let tag in this._runningEvents){\n                this._runningEvents[tag].listeners().forEach((listener)=>{\n                    result.push(listener);\n                });\n            }\n            return result;\n        }\n        return this._getRunningEvent(eventName).listeners();\n    }\n    removeAllListeners(eventName) {\n        if (!this.provider) {\n            return this;\n        }\n        if (eventName == null) {\n            for(const tag in this._runningEvents){\n                const runningEvent = this._runningEvents[tag];\n                runningEvent.removeAllListeners();\n                this._checkRunningEvents(runningEvent);\n            }\n            return this;\n        }\n        // Delete any listeners\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeAllListeners();\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n    off(eventName, listener) {\n        if (!this.provider) {\n            return this;\n        }\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeListener(listener);\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n    removeListener(eventName, listener) {\n        return this.off(eventName, listener);\n    }\n}\nclass Contract extends BaseContract {\n}\nclass ContractFactory {\n    constructor(contractInterface, bytecode, signer){\n        let bytecodeHex = null;\n        if (typeof bytecode === \"string\") {\n            bytecodeHex = bytecode;\n        } else if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isBytes)(bytecode)) {\n            bytecodeHex = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(bytecode);\n        } else if (bytecode && typeof bytecode.object === \"string\") {\n            // Allow the bytecode object from the Solidity compiler\n            bytecodeHex = bytecode.object;\n        } else {\n            // Crash in the next verification step\n            bytecodeHex = \"!\";\n        }\n        // Make sure it is 0x prefixed\n        if (bytecodeHex.substring(0, 2) !== \"0x\") {\n            bytecodeHex = \"0x\" + bytecodeHex;\n        }\n        // Make sure the final result is valid bytecode\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isHexString)(bytecodeHex) || bytecodeHex.length % 2) {\n            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n        }\n        // If we have a signer, make sure it is valid\n        if (signer && !_ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__.Signer.isSigner(signer)) {\n            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"bytecode\", bytecodeHex);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"interface\", (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getInterface\")(contractInterface));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"signer\", signer || null);\n    }\n    // @TODO: Future; rename to populateTransaction?\n    getDeployTransaction(...args) {\n        let tx = {};\n        // If we have 1 additional argument, we allow transaction overrides\n        if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === \"object\") {\n            tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(args.pop());\n            for(const key in tx){\n                if (!allowedTransactionKeys[key]) {\n                    throw new Error(\"unknown transaction override \" + key);\n                }\n            }\n        }\n        // Do not allow these to be overridden in a deployment transaction\n        [\n            \"data\",\n            \"from\",\n            \"to\"\n        ].forEach((key)=>{\n            if (tx[key] == null) {\n                return;\n            }\n            logger.throwError(\"cannot override \" + key, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: key\n            });\n        });\n        if (tx.value) {\n            const value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(tx.value);\n            if (!value.isZero() && !this.interface.deploy.payable) {\n                logger.throwError(\"non-payable constructor cannot override value\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: tx.value\n                });\n            }\n        }\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n        // Set the data to the bytecode + the encoded constructor arguments\n        tx.data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.concat)([\n            this.bytecode,\n            this.interface.encodeDeploy(args)\n        ]));\n        return tx;\n    }\n    deploy(...args) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let overrides = {};\n            // If 1 extra parameter was passed in, it contains overrides\n            if (args.length === this.interface.deploy.inputs.length + 1) {\n                overrides = args.pop();\n            }\n            // Make sure the call matches the constructor signature\n            logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n            // Resolve ENS names and promises in the arguments\n            const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);\n            params.push(overrides);\n            // Get the deployment transaction (with optional overrides)\n            const unsignedTx = this.getDeployTransaction(...params);\n            // Send the deployment transaction\n            const tx = yield this.signer.sendTransaction(unsignedTx);\n            const address = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, \"getContractAddress\")(tx);\n            const contract = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, \"getContract\")(address, this.interface, this.signer);\n            // Add the modified wait that wraps events\n            addContractWait(contract, tx);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(contract, \"deployTransaction\", tx);\n            return contract;\n        });\n    }\n    attach(address) {\n        return this.constructor.getContract(address, this.interface, this.signer);\n    }\n    connect(signer) {\n        return new this.constructor(this.interface, this.bytecode, signer);\n    }\n    static fromSolidity(compilerOutput, signer) {\n        if (compilerOutput == null) {\n            logger.throwError(\"missing compiler output\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.MISSING_ARGUMENT, {\n                argument: \"compilerOutput\"\n            });\n        }\n        if (typeof compilerOutput === \"string\") {\n            compilerOutput = JSON.parse(compilerOutput);\n        }\n        const abi = compilerOutput.abi;\n        let bytecode = null;\n        if (compilerOutput.bytecode) {\n            bytecode = compilerOutput.bytecode;\n        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n            bytecode = compilerOutput.evm.bytecode;\n        }\n        return new this(abi, bytecode, signer);\n    }\n    static getInterface(contractInterface) {\n        return Contract.getInterface(contractInterface);\n    }\n    static getContractAddress(tx) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getContractAddress)(tx);\n    }\n    static getContract(address, contractInterface, signer) {\n        return new Contract(address, contractInterface, signer);\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGV0aGVyc3Byb2plY3QrY29udHJhY3RzQDUuNy4wL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb250cmFjdHMvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQzJFO0FBQ2Y7QUFDUTtBQUNJO0FBQ25CO0FBQ2tDO0FBQ3lCO0FBQ3BEO0FBQ2I7QUFD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RSxJQUFJLENBQUN0RSxTQUFTLEVBQUUsSUFBSSxDQUFDK0ksUUFBUSxFQUFFcko7SUFDakU7SUFDQSxPQUFPOEosYUFBYUMsY0FBYyxFQUFFL0osTUFBTSxFQUFFO1FBQ3hDLElBQUkrSixrQkFBa0IsTUFBTTtZQUN4QmhOLE9BQU9xQixVQUFVLENBQUMsMkJBQTJCdkIseURBQU1BLENBQUN3QixNQUFNLENBQUMyTCxnQkFBZ0IsRUFBRTtnQkFBRTVLLFVBQVU7WUFBaUI7UUFDOUc7UUFDQSxJQUFJLE9BQVEySyxtQkFBb0IsVUFBVTtZQUN0Q0EsaUJBQWlCdEksS0FBS3dJLEtBQUssQ0FBQ0Y7UUFDaEM7UUFDQSxNQUFNRyxNQUFNSCxlQUFlRyxHQUFHO1FBQzlCLElBQUliLFdBQVc7UUFDZixJQUFJVSxlQUFlVixRQUFRLEVBQUU7WUFDekJBLFdBQVdVLGVBQWVWLFFBQVE7UUFDdEMsT0FDSyxJQUFJVSxlQUFlSSxHQUFHLElBQUlKLGVBQWVJLEdBQUcsQ0FBQ2QsUUFBUSxFQUFFO1lBQ3hEQSxXQUFXVSxlQUFlSSxHQUFHLENBQUNkLFFBQVE7UUFDMUM7UUFDQSxPQUFPLElBQUksSUFBSSxDQUFDYSxLQUFLYixVQUFVcko7SUFDbkM7SUFDQSxPQUFPbUgsYUFBYXJCLGlCQUFpQixFQUFFO1FBQ25DLE9BQU9xRCxTQUFTaEMsWUFBWSxDQUFDckI7SUFDakM7SUFDQSxPQUFPOUosbUJBQW1Cd0UsRUFBRSxFQUFFO1FBQzFCLE9BQU94RSwwRUFBa0JBLENBQUN3RTtJQUM5QjtJQUNBLE9BQU9xSixZQUFZckwsT0FBTyxFQUFFc0gsaUJBQWlCLEVBQUU5RixNQUFNLEVBQUU7UUFDbkQsT0FBTyxJQUFJbUosU0FBUzNLLFNBQVNzSCxtQkFBbUI5RjtJQUNwRDtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K2NvbnRyYWN0c0A1LjcuMC9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvY29udHJhY3RzL2xpYi5lc20vaW5kZXguanM/YmZhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgY2hlY2tSZXN1bHRFcnJvcnMsIEluZGV4ZWQsIEludGVyZmFjZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hYmlcIjtcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBTaWduZXIsIFZvaWRTaWduZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWJzdHJhY3Qtc2lnbmVyXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzLCBnZXRDb250cmFjdEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGNvbmNhdCwgaGV4bGlmeSwgaXNCeXRlcywgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5LCBkZWVwQ29weSwgZ2V0U3RhdGljLCByZXNvbHZlUHJvcGVydGllcywgc2hhbGxvd0NvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbjtcbjtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmNvbnN0IGFsbG93ZWRUcmFuc2FjdGlvbktleXMgPSB7XG4gICAgY2hhaW5JZDogdHJ1ZSwgZGF0YTogdHJ1ZSwgZnJvbTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBub25jZTogdHJ1ZSwgdG86IHRydWUsIHZhbHVlOiB0cnVlLFxuICAgIHR5cGU6IHRydWUsIGFjY2Vzc0xpc3Q6IHRydWUsXG4gICAgbWF4RmVlUGVyR2FzOiB0cnVlLCBtYXhQcmlvcml0eUZlZVBlckdhczogdHJ1ZSxcbiAgICBjdXN0b21EYXRhOiB0cnVlLFxuICAgIGNjaXBSZWFkRW5hYmxlZDogdHJ1ZVxufTtcbmZ1bmN0aW9uIHJlc29sdmVOYW1lKHJlc29sdmVyLCBuYW1lT3JQcm9taXNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHlpZWxkIG5hbWVPclByb21pc2U7XG4gICAgICAgIGlmICh0eXBlb2YgKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzIG9yIEVOUyBuYW1lXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBpdCBpcyBhbHJlYWR5IGFuIGFkZHJlc3MsIGp1c3QgdXNlIGl0IChhZnRlciBhZGRpbmcgY2hlY2tzdW0pXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyhuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICBpZiAoIXJlc29sdmVyKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImEgcHJvdmlkZXIgb3Igc2lnbmVyIGlzIG5lZWRlZCB0byByZXNvbHZlIEVOUyBuYW1lc1wiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXNvbHZlTmFtZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgcmVzb2x2ZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJyZXNvbHZlciBvciBhZGRyIGlzIG5vdCBjb25maWd1cmVkIGZvciBFTlMgbmFtZVwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgfSk7XG59XG4vLyBSZWN1cnNpdmVseSByZXBsYWNlcyBFTlMgbmFtZXMgd2l0aCBwcm9taXNlcyB0byByZXNvbHZlIHRoZSBuYW1lIGFuZCByZXNvbHZlcyBhbGwgcHJvcGVydGllc1xuZnVuY3Rpb24gcmVzb2x2ZUFkZHJlc3NlcyhyZXNvbHZlciwgdmFsdWUsIHBhcmFtVHlwZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBQcm9taXNlLmFsbChwYXJhbVR5cGUubWFwKChwYXJhbVR5cGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsICgoQXJyYXkuaXNBcnJheSh2YWx1ZSkpID8gdmFsdWVbaW5kZXhdIDogdmFsdWVbcGFyYW1UeXBlLm5hbWVdKSwgcGFyYW1UeXBlKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1UeXBlLnR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzb2x2ZU5hbWUocmVzb2x2ZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1UeXBlLnR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsIHZhbHVlLCBwYXJhbVR5cGUuY29tcG9uZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtVHlwZS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGxvZ2dlci5tYWtlRXJyb3IoXCJpbnZhbGlkIHZhbHVlIGZvciBhcnJheVwiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgUHJvbWlzZS5hbGwodmFsdWUubWFwKCh2KSA9PiByZXNvbHZlQWRkcmVzc2VzKHJlc29sdmVyLCB2LCBwYXJhbVR5cGUuYXJyYXlDaGlsZHJlbikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIC8vIElmIGFuIGV4dHJhIGFyZ3VtZW50IGlzIGdpdmVuLCBpdCBpcyBvdmVycmlkZXNcbiAgICAgICAgbGV0IG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IGZyYWdtZW50LmlucHV0cy5sZW5ndGggKyAxICYmIHR5cGVvZiAoYXJnc1thcmdzLmxlbmd0aCAtIDFdKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgb3ZlcnJpZGVzID0gc2hhbGxvd0NvcHkoYXJncy5wb3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwYXJhbWV0ZXIgY291bnQgbWF0Y2hlc1xuICAgICAgICBsb2dnZXIuY2hlY2tBcmd1bWVudENvdW50KGFyZ3MubGVuZ3RoLCBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBcInBhc3NlZCB0byBjb250cmFjdFwiKTtcbiAgICAgICAgLy8gUG9wdWxhdGUgXCJmcm9tXCIgb3ZlcnJpZGUgKGFsbG93IHByb21pc2VzKVxuICAgICAgICBpZiAoY29udHJhY3Quc2lnbmVyKSB7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVzLmZyb20pIHtcbiAgICAgICAgICAgICAgICAvLyBDb250cmFjdHMgd2l0aCBhIFNpZ25lciBhcmUgZnJvbSB0aGUgU2lnbmVyJ3MgZnJhbWUtb2YtcmVmZXJlbmNlO1xuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBhbGxvdyBvdmVycmlkaW5nIFwiZnJvbVwiIGlmIGl0IG1hdGNoZXMgdGhlIHNpZ25lclxuICAgICAgICAgICAgICAgIG92ZXJyaWRlcy5mcm9tID0gcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZTogcmVzb2x2ZU5hbWUoY29udHJhY3Quc2lnbmVyLCBvdmVycmlkZXMuZnJvbSksXG4gICAgICAgICAgICAgICAgICAgIHNpZ25lcjogY29udHJhY3Quc2lnbmVyLmdldEFkZHJlc3MoKVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKGNoZWNrKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRBZGRyZXNzKGNoZWNrLnNpZ25lcikgIT09IGNoZWNrLm92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNvbnRyYWN0IHdpdGggYSBTaWduZXIgY2Fubm90IG92ZXJyaWRlIGZyb21cIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwib3ZlcnJpZGVzLmZyb21cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrLm92ZXJyaWRlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG92ZXJyaWRlcy5mcm9tID0gY29udHJhY3Quc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdmVycmlkZXMuZnJvbSkge1xuICAgICAgICAgICAgb3ZlcnJpZGVzLmZyb20gPSByZXNvbHZlTmFtZShjb250cmFjdC5wcm92aWRlciwgb3ZlcnJpZGVzLmZyb20pO1xuICAgICAgICAgICAgLy99IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ29udHJhY3RzIHdpdGhvdXQgYSBzaWduZXIgY2FuIG92ZXJyaWRlIFwiZnJvbVwiLCBhbmQgaWZcbiAgICAgICAgICAgIC8vIHVuc3BlY2lmaWVkIHRoZSB6ZXJvIGFkZHJlc3MgaXMgdXNlZFxuICAgICAgICAgICAgLy9vdmVycmlkZXMuZnJvbSA9IEFkZHJlc3NaZXJvO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdhaXQgZm9yIGFsbCBkZXBlbmRlbmNpZXMgdG8gYmUgcmVzb2x2ZWQgKHByZWZlciB0aGUgc2lnbmVyIG92ZXIgdGhlIHByb3ZpZGVyKVxuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIGFyZ3M6IHJlc29sdmVBZGRyZXNzZXMoY29udHJhY3Quc2lnbmVyIHx8IGNvbnRyYWN0LnByb3ZpZGVyLCBhcmdzLCBmcmFnbWVudC5pbnB1dHMpLFxuICAgICAgICAgICAgYWRkcmVzczogY29udHJhY3QucmVzb2x2ZWRBZGRyZXNzLFxuICAgICAgICAgICAgb3ZlcnJpZGVzOiAocmVzb2x2ZVByb3BlcnRpZXMob3ZlcnJpZGVzKSB8fCB7fSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoZSBBQkkgY29kZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgY29uc3QgZGF0YSA9IGNvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHJlc29sdmVkLmFyZ3MpO1xuICAgICAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICB0bzogcmVzb2x2ZWQuYWRkcmVzc1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZXNvbHZlZCBPdmVycmlkZXNcbiAgICAgICAgY29uc3Qgcm8gPSByZXNvbHZlZC5vdmVycmlkZXM7XG4gICAgICAgIC8vIFBvcHVsYXRlIHNpbXBsZSBvdmVycmlkZXNcbiAgICAgICAgaWYgKHJvLm5vbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4Lm5vbmNlID0gQmlnTnVtYmVyLmZyb20ocm8ubm9uY2UpLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvLmdhc0xpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4Lmdhc0xpbWl0ID0gQmlnTnVtYmVyLmZyb20ocm8uZ2FzTGltaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5nYXNQcmljZSA9IEJpZ051bWJlci5mcm9tKHJvLmdhc1ByaWNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8ubWF4RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4Lm1heEZlZVBlckdhcyA9IEJpZ051bWJlci5mcm9tKHJvLm1heEZlZVBlckdhcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnTnVtYmVyLmZyb20ocm8ubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSByby5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby50eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4LnR5cGUgPSByby50eXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5hY2Nlc3NMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4LmFjY2Vzc0xpc3QgPSBhY2Nlc3NMaXN0aWZ5KHJvLmFjY2Vzc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBubyBcImdhc0xpbWl0XCIgb3ZlcnJpZGUsIGJ1dCB0aGUgQUJJIHNwZWNpZmllcyBhIGRlZmF1bHQsIHVzZSBpdFxuICAgICAgICBpZiAodHguZ2FzTGltaXQgPT0gbnVsbCAmJiBmcmFnbWVudC5nYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgaW50cmluc2ljIGdhcyBjb3N0IGZvciB0aGlzIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAvLyBAVE9ETzogVGhpcyBpcyBiYXNlZCBvbiB0aGUgeWVsbG93IHBhcGVyIGFzIG9mIFBldGVyc2J1cmc7IHRoaXMgaXMgc29tZXRoaW5nXG4gICAgICAgICAgICAvLyB3ZSBtYXkgd2lzaCB0byBwYXJhbWV0ZXJpemUgaW4gdjYgYXMgcGFydCBvZiB0aGUgTmV0d29yayBvYmplY3QuIFNpbmNlIHRoaXNcbiAgICAgICAgICAgIC8vIGlzIGFsd2F5cyBhIG5vbi1uaWwgdG8gYWRkcmVzcywgd2UgY2FuIGlnbm9yZSBHX2NyZWF0ZSwgYnV0IG1heSB3aXNoIHRvIGFkZFxuICAgICAgICAgICAgLy8gc2ltaWxhciBsb2dpYyB0byB0aGUgQ29udHJhY3RGYWN0b3J5LlxuICAgICAgICAgICAgbGV0IGludHJpbnNpYyA9IDIxMDAwO1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeShkYXRhKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbnRyaW5zaWMgKz0gNDtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW50cmluc2ljICs9IDY0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR4Lmdhc0xpbWl0ID0gQmlnTnVtYmVyLmZyb20oZnJhZ21lbnQuZ2FzKS5hZGQoaW50cmluc2ljKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3B1bGF0ZSBcInZhbHVlXCIgb3ZlcnJpZGVcbiAgICAgICAgaWYgKHJvLnZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCByb1ZhbHVlID0gQmlnTnVtYmVyLmZyb20ocm8udmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFyb1ZhbHVlLmlzWmVybygpICYmICFmcmFnbWVudC5wYXlhYmxlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub24tcGF5YWJsZSBtZXRob2QgY2Fubm90IG92ZXJyaWRlIHZhbHVlXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJvdmVycmlkZXMudmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG92ZXJyaWRlcy52YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHgudmFsdWUgPSByb1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5jdXN0b21EYXRhKSB7XG4gICAgICAgICAgICB0eC5jdXN0b21EYXRhID0gc2hhbGxvd0NvcHkocm8uY3VzdG9tRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvLmNjaXBSZWFkRW5hYmxlZCkge1xuICAgICAgICAgICAgdHguY2NpcFJlYWRFbmFibGVkID0gISFyby5jY2lwUmVhZEVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBvdmVycmlkZXNcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5ub25jZTtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5nYXNMaW1pdDtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5nYXNQcmljZTtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5mcm9tO1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLnZhbHVlO1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLnR5cGU7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuYWNjZXNzTGlzdDtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5tYXhGZWVQZXJHYXM7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuY3VzdG9tRGF0YTtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5jY2lwUmVhZEVuYWJsZWQ7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBhcmUgbm8gc3RyYXkgb3ZlcnJpZGVzLCB3aGljaCBtYXkgaW5kaWNhdGUgYVxuICAgICAgICAvLyB0eXBvIG9yIHVzaW5nIGFuIHVuc3VwcG9ydGVkIGtleS5cbiAgICAgICAgY29uc3QgbGVmdG92ZXJzID0gT2JqZWN0LmtleXMob3ZlcnJpZGVzKS5maWx0ZXIoKGtleSkgPT4gKG92ZXJyaWRlc1trZXldICE9IG51bGwpKTtcbiAgICAgICAgaWYgKGxlZnRvdmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKGBjYW5ub3Qgb3ZlcnJpZGUgJHtsZWZ0b3ZlcnMubWFwKChsKSA9PiBKU09OLnN0cmluZ2lmeShsKSkuam9pbihcIixcIil9YCwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwib3ZlcnJpZGVzXCIsXG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVzOiBsZWZ0b3ZlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUG9wdWxhdGUoY29udHJhY3QsIGZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXN0aW1hdGUoY29udHJhY3QsIGZyYWdtZW50KSB7XG4gICAgY29uc3Qgc2lnbmVyT3JQcm92aWRlciA9IChjb250cmFjdC5zaWduZXIgfHwgY29udHJhY3QucHJvdmlkZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCFzaWduZXJPclByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJlc3RpbWF0ZSByZXF1aXJlIGEgcHJvdmlkZXIgb3Igc2lnbmVyXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJlc3RpbWF0ZUdhc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHBvcHVsYXRlVHJhbnNhY3Rpb24oY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBzaWduZXJPclByb3ZpZGVyLmVzdGltYXRlR2FzKHR4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFkZENvbnRyYWN0V2FpdChjb250cmFjdCwgdHgpIHtcbiAgICBjb25zdCB3YWl0ID0gdHgud2FpdC5iaW5kKHR4KTtcbiAgICB0eC53YWl0ID0gKGNvbmZpcm1hdGlvbnMpID0+IHtcbiAgICAgICAgcmV0dXJuIHdhaXQoY29uZmlybWF0aW9ucykudGhlbigocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgcmVjZWlwdC5ldmVudHMgPSByZWNlaXB0LmxvZ3MubWFwKChsb2cpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnQgPSBkZWVwQ29weShsb2cpO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IGNvbnRyYWN0LmludGVyZmFjZS5wYXJzZUxvZyhsb2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICAgICAgLy8gU3VjY2Vzc2Z1bGx5IHBhcnNlZCB0aGUgZXZlbnQgbG9nOyBpbmNsdWRlIGl0XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5hcmdzID0gcGFyc2VkLmFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRlY29kZSA9IChkYXRhLCB0b3BpY3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2cocGFyc2VkLmV2ZW50RnJhZ21lbnQsIGRhdGEsIHRvcGljcyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmV2ZW50ID0gcGFyc2VkLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmV2ZW50U2lnbmF0dXJlID0gcGFyc2VkLnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVXNlZnVsIG9wZXJhdGlvbnNcbiAgICAgICAgICAgICAgICBldmVudC5yZW1vdmVMaXN0ZW5lciA9ICgpID0+IHsgcmV0dXJuIGNvbnRyYWN0LnByb3ZpZGVyOyB9O1xuICAgICAgICAgICAgICAgIGV2ZW50LmdldEJsb2NrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJhY3QucHJvdmlkZXIuZ2V0QmxvY2socmVjZWlwdC5ibG9ja0hhc2gpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZXZlbnQuZ2V0VHJhbnNhY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cmFjdC5wcm92aWRlci5nZXRUcmFuc2FjdGlvbihyZWNlaXB0LnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBldmVudC5nZXRUcmFuc2FjdGlvblJlY2VpcHQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRDYWxsKGNvbnRyYWN0LCBmcmFnbWVudCwgY29sbGFwc2VTaW1wbGUpIHtcbiAgICBjb25zdCBzaWduZXJPclByb3ZpZGVyID0gKGNvbnRyYWN0LnNpZ25lciB8fCBjb250cmFjdC5wcm92aWRlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBcImJsb2NrVGFnXCIgb3ZlcnJpZGUgaWYgcHJlc2VudFxuICAgICAgICAgICAgbGV0IGJsb2NrVGFnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoICsgMSAmJiB0eXBlb2YgKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdmVycmlkZXMgPSBzaGFsbG93Q29weShhcmdzLnBvcCgpKTtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVzLmJsb2NrVGFnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tUYWcgPSB5aWVsZCBvdmVycmlkZXMuYmxvY2tUYWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuYmxvY2tUYWc7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKG92ZXJyaWRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgY29udHJhY3Qgd2FzIGp1c3QgZGVwbG95ZWQsIHdhaXQgdW50aWwgaXQgaXMgbWluZWRcbiAgICAgICAgICAgIGlmIChjb250cmFjdC5kZXBsb3lUcmFuc2FjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY29udHJhY3QuX2RlcGxveWVkKGJsb2NrVGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhbGwgYSBub2RlIGFuZCBnZXQgdGhlIHJlc3VsdFxuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBzaWduZXJPclByb3ZpZGVyLmNhbGwodHgsIGJsb2NrVGFnKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChjb2xsYXBzZVNpbXBsZSAmJiBmcmFnbWVudC5vdXRwdXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRyZXNzID0gY29udHJhY3QuYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYXJncyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnRyYW5zYWN0aW9uID0gdHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRTZW5kKGNvbnRyYWN0LCBmcmFnbWVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCFjb250cmFjdC5zaWduZXIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInNlbmRpbmcgYSB0cmFuc2FjdGlvbiByZXF1aXJlcyBhIHNpZ25lclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBjb250cmFjdCB3YXMganVzdCBkZXBsb3llZCwgd2FpdCB1bnRpbCBpdCBpcyBtaW5lZFxuICAgICAgICAgICAgaWYgKGNvbnRyYWN0LmRlcGxveVRyYW5zYWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBjb250cmFjdC5fZGVwbG95ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR4UmVxdWVzdCA9IHlpZWxkIHBvcHVsYXRlVHJhbnNhY3Rpb24oY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgY29udHJhY3Quc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih0eFJlcXVlc3QpO1xuICAgICAgICAgICAgLy8gVHdlYWsgdGhlIHR4LndhaXQgc28gdGhlIHJlY2VpcHQgaGFzIGV4dHJhIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGFkZENvbnRyYWN0V2FpdChjb250cmFjdCwgdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGREZWZhdWx0KGNvbnRyYWN0LCBmcmFnbWVudCwgY29sbGFwc2VTaW1wbGUpIHtcbiAgICBpZiAoZnJhZ21lbnQuY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkQ2FsbChjb250cmFjdCwgZnJhZ21lbnQsIGNvbGxhcHNlU2ltcGxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkU2VuZChjb250cmFjdCwgZnJhZ21lbnQpO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRUYWcoZmlsdGVyKSB7XG4gICAgaWYgKGZpbHRlci5hZGRyZXNzICYmIChmaWx0ZXIudG9waWNzID09IG51bGwgfHwgZmlsdGVyLnRvcGljcy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIHJldHVybiBcIipcIjtcbiAgICB9XG4gICAgcmV0dXJuIChmaWx0ZXIuYWRkcmVzcyB8fCBcIipcIikgKyBcIkBcIiArIChmaWx0ZXIudG9waWNzID8gZmlsdGVyLnRvcGljcy5tYXAoKHRvcGljKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRvcGljKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvcGljLmpvaW4oXCJ8XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3BpYztcbiAgICB9KS5qb2luKFwiOlwiKSA6IFwiXCIpO1xufVxuY2xhc3MgUnVubmluZ0V2ZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcsIGZpbHRlcikge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInRhZ1wiLCB0YWcpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImZpbHRlclwiLCBmaWx0ZXIpO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgYWRkTGlzdGVuZXIobGlzdGVuZXIsIG9uY2UpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lcjogbGlzdGVuZXIsIG9uY2U6IG9uY2UgfSk7XG4gICAgfVxuICAgIHJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycy5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChkb25lIHx8IGl0ZW0ubGlzdGVuZXIgIT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIGxpc3RlbmVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVycy5tYXAoKGkpID0+IGkubGlzdGVuZXIpO1xuICAgIH1cbiAgICBsaXN0ZW5lckNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzLmxlbmd0aDtcbiAgICB9XG4gICAgcnVuKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJDb3VudCA9IHRoaXMubGlzdGVuZXJDb3VudCgpO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhcmdzQ29weSA9IGFyZ3Muc2xpY2UoKTtcbiAgICAgICAgICAgIC8vIENhbGwgdGhlIGNhbGxiYWNrIGluIHRoZSBuZXh0IGV2ZW50IGxvb3BcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0ubGlzdGVuZXIuYXBwbHkodGhpcywgYXJnc0NvcHkpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAvLyBSZXNjaGVkdWxlIGl0IGlmIGl0IG5vdCBcIm9uY2VcIlxuICAgICAgICAgICAgcmV0dXJuICEoaXRlbS5vbmNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lckNvdW50O1xuICAgIH1cbiAgICBwcmVwYXJlRXZlbnQoZXZlbnQpIHtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgYXJyYXkgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYW4gZW1pdFxuICAgIGdldEVtaXQoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIFtldmVudF07XG4gICAgfVxufVxuY2xhc3MgRXJyb3JSdW5uaW5nRXZlbnQgZXh0ZW5kcyBSdW5uaW5nRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImVycm9yXCIsIG51bGwpO1xuICAgIH1cbn1cbi8vIEBUT0RPIEZyYWdtZW50IHNob3VsZCBpbmhlcml0IFdpbGRjYXJkPyBhbmQganVzdCBvdmVycmlkZSBnZXRFbWl0P1xuLy8gICAgICAgb3IgaGF2ZSBhIGNvbW1vbiBhYnN0cmFjdCBzdXBlciBjbGFzcywgd2l0aCBlbm91Z2ggY29uc3RydWN0b3Jcbi8vICAgICAgIG9wdGlvbnMgdG8gY29uZmlndXJlIGJvdGguXG4vLyBBIEZyYWdtZW50IEV2ZW50IHdpbGwgcG9wdWxhdGUgYWxsIHRoZSBwcm9wZXJ0aWVzIHRoYXQgV2lsZGNhcmRcbi8vIHdpbGwsIGFuZCBhZGRpdGlvbmFsbHkgZGVyZWZlcmVuY2UgdGhlIGFyZ3VtZW50cyB3aGVuIGVtaXR0aW5nXG5jbGFzcyBGcmFnbWVudFJ1bm5pbmdFdmVudCBleHRlbmRzIFJ1bm5pbmdFdmVudCB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgY29udHJhY3RJbnRlcmZhY2UsIGZyYWdtZW50LCB0b3BpY3MpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzc1xuICAgICAgICB9O1xuICAgICAgICBsZXQgdG9waWMgPSBjb250cmFjdEludGVyZmFjZS5nZXRFdmVudFRvcGljKGZyYWdtZW50KTtcbiAgICAgICAgaWYgKHRvcGljcykge1xuICAgICAgICAgICAgaWYgKHRvcGljICE9PSB0b3BpY3NbMF0pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidG9waWMgbWlzbWF0Y2hcIiwgXCJ0b3BpY3NcIiwgdG9waWNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbHRlci50b3BpY3MgPSB0b3BpY3Muc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbHRlci50b3BpY3MgPSBbdG9waWNdO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGdldEV2ZW50VGFnKGZpbHRlciksIGZpbHRlcik7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJpbnRlcmZhY2VcIiwgY29udHJhY3RJbnRlcmZhY2UpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICB9XG4gICAgcHJlcGFyZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHN1cGVyLnByZXBhcmVFdmVudChldmVudCk7XG4gICAgICAgIGV2ZW50LmV2ZW50ID0gdGhpcy5mcmFnbWVudC5uYW1lO1xuICAgICAgICBldmVudC5ldmVudFNpZ25hdHVyZSA9IHRoaXMuZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgIGV2ZW50LmRlY29kZSA9IChkYXRhLCB0b3BpY3MpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVyZmFjZS5kZWNvZGVFdmVudExvZyh0aGlzLmZyYWdtZW50LCBkYXRhLCB0b3BpY3MpO1xuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXZlbnQuYXJncyA9IHRoaXMuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKHRoaXMuZnJhZ21lbnQsIGV2ZW50LmRhdGEsIGV2ZW50LnRvcGljcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBldmVudC5hcmdzID0gbnVsbDtcbiAgICAgICAgICAgIGV2ZW50LmRlY29kZUVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RW1pdChldmVudCkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBjaGVja1Jlc3VsdEVycm9ycyhldmVudC5hcmdzKTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yc1swXS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gKGV2ZW50LmFyZ3MgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGFyZ3MucHVzaChldmVudCk7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cbn1cbi8vIEEgV2lsZGNhcmQgRXZlbnQgd2lsbCBhdHRlbXB0IHRvIHBvcHVsYXRlOlxuLy8gIC0gZXZlbnQgICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgbmFtZVxuLy8gIC0gZXZlbnRTaWduYXR1cmUgICBUaGUgZnVsbCBzaWduYXR1cmUgb2YgdGhlIGV2ZW50XG4vLyAgLSBkZWNvZGUgICAgICAgICAgIEEgZnVuY3Rpb24gdG8gZGVjb2RlIGRhdGEgYW5kIHRvcGljc1xuLy8gIC0gYXJncyAgICAgICAgICAgICBUaGUgZGVjb2RlZCBkYXRhIGFuZCB0b3BpY3NcbmNsYXNzIFdpbGRjYXJkUnVubmluZ0V2ZW50IGV4dGVuZHMgUnVubmluZ0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBjb250cmFjdEludGVyZmFjZSkge1xuICAgICAgICBzdXBlcihcIipcIiwgeyBhZGRyZXNzOiBhZGRyZXNzIH0pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiaW50ZXJmYWNlXCIsIGNvbnRyYWN0SW50ZXJmYWNlKTtcbiAgICB9XG4gICAgcHJlcGFyZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHN1cGVyLnByZXBhcmVFdmVudChldmVudCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmludGVyZmFjZS5wYXJzZUxvZyhldmVudCk7XG4gICAgICAgICAgICBldmVudC5ldmVudCA9IHBhcnNlZC5uYW1lO1xuICAgICAgICAgICAgZXZlbnQuZXZlbnRTaWduYXR1cmUgPSBwYXJzZWQuc2lnbmF0dXJlO1xuICAgICAgICAgICAgZXZlbnQuZGVjb2RlID0gKGRhdGEsIHRvcGljcykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhwYXJzZWQuZXZlbnRGcmFnbWVudCwgZGF0YSwgdG9waWNzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBldmVudC5hcmdzID0gcGFyc2VkLmFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBObyBtYXRjaGluZyBldmVudFxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJhc2VDb250cmFjdCB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzc09yTmFtZSwgY29udHJhY3RJbnRlcmZhY2UsIHNpZ25lck9yUHJvdmlkZXIpIHtcbiAgICAgICAgLy8gQFRPRE86IE1heWJlIHN0aWxsIGNoZWNrIHRoZSBhZGRyZXNzT3JOYW1lIGxvb2tzIGxpa2UgYSB2YWxpZCBhZGRyZXNzIG9yIG5hbWU/XG4gICAgICAgIC8vYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiaW50ZXJmYWNlXCIsIGdldFN0YXRpYyhuZXcudGFyZ2V0LCBcImdldEludGVyZmFjZVwiKShjb250cmFjdEludGVyZmFjZSkpO1xuICAgICAgICBpZiAoc2lnbmVyT3JQcm92aWRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIG51bGwpO1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJzaWduZXJcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoU2lnbmVyLmlzU2lnbmVyKHNpZ25lck9yUHJvdmlkZXIpKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIHNpZ25lck9yUHJvdmlkZXIucHJvdmlkZXIgfHwgbnVsbCk7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInNpZ25lclwiLCBzaWduZXJPclByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChQcm92aWRlci5pc1Byb3ZpZGVyKHNpZ25lck9yUHJvdmlkZXIpKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIHNpZ25lck9yUHJvdmlkZXIpO1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJzaWduZXJcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBzaWduZXIgb3IgcHJvdmlkZXJcIiwgXCJzaWduZXJPclByb3ZpZGVyXCIsIHNpZ25lck9yUHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY2FsbFN0YXRpY1wiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZXN0aW1hdGVHYXNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImZ1bmN0aW9uc1wiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicG9wdWxhdGVUcmFuc2FjdGlvblwiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZmlsdGVyc1wiLCB7fSk7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZUZpbHRlcnMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuaW50ZXJmYWNlLmV2ZW50cykuZm9yRWFjaCgoZXZlbnRTaWduYXR1cmUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHRoaXMuaW50ZXJmYWNlLmV2ZW50c1tldmVudFNpZ25hdHVyZV07XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5maWx0ZXJzLCBldmVudFNpZ25hdHVyZSwgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljczogdGhpcy5pbnRlcmZhY2UuZW5jb2RlRmlsdGVyVG9waWNzKGV2ZW50LCBhcmdzKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghdW5pcXVlRmlsdGVyc1tldmVudC5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVGaWx0ZXJzW2V2ZW50Lm5hbWVdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuaXF1ZUZpbHRlcnNbZXZlbnQubmFtZV0ucHVzaChldmVudFNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHVuaXF1ZUZpbHRlcnMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJzID0gdW5pcXVlRmlsdGVyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5maWx0ZXJzLCBuYW1lLCB0aGlzLmZpbHRlcnNbZmlsdGVyc1swXV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYER1cGxpY2F0ZSBkZWZpbml0aW9uIG9mICR7bmFtZX0gKCR7ZmlsdGVycy5qb2luKFwiLCBcIil9KWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3J1bm5pbmdFdmVudHNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl93cmFwcGVkRW1pdHNcIiwge30pO1xuICAgICAgICBpZiAoYWRkcmVzc09yTmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb250cmFjdCBhZGRyZXNzIG9yIEVOUyBuYW1lXCIsIFwiYWRkcmVzc09yTmFtZVwiLCBhZGRyZXNzT3JOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFkZHJlc3NcIiwgYWRkcmVzc09yTmFtZSk7XG4gICAgICAgIGlmICh0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInJlc29sdmVkQWRkcmVzc1wiLCByZXNvbHZlTmFtZSh0aGlzLnByb3ZpZGVyLCBhZGRyZXNzT3JOYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicmVzb2x2ZWRBZGRyZXNzXCIsIFByb21pc2UucmVzb2x2ZShnZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBXaXRob3V0IGEgcHJvdmlkZXIsIHdlIGNhbm5vdCB1c2UgRU5TIG5hbWVzXG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJwcm92aWRlciBpcyByZXF1aXJlZCB0byB1c2UgRU5TIG5hbWUgYXMgY29udHJhY3QgYWRkcmVzc1wiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IENvbnRyYWN0XCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTd2FsbG93IGJhZCBFTlMgbmFtZXMgdG8gcHJldmVudCBVbmhhbmRsZWQgRXhjZXB0aW9uc1xuICAgICAgICB0aGlzLnJlc29sdmVkQWRkcmVzcy5jYXRjaCgoZSkgPT4geyB9KTtcbiAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSB7fTtcbiAgICAgICAgY29uc3QgdW5pcXVlU2lnbmF0dXJlcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmludGVyZmFjZS5mdW5jdGlvbnMpLmZvckVhY2goKHNpZ25hdHVyZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmludGVyZmFjZS5mdW5jdGlvbnNbc2lnbmF0dXJlXTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHNpZ25hdHVyZSBpcyB1bmlxdWU7IGlmIG5vdCB0aGUgQUJJIGdlbmVyYXRpb24gaGFzXG4gICAgICAgICAgICAvLyBub3QgYmVlbiBjbGVhbmVkIG9yIG1heSBiZSBpbmNvcnJlY3RseSBnZW5lcmF0ZWRcbiAgICAgICAgICAgIGlmICh1bmlxdWVTaWduYXR1cmVzW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgRHVwbGljYXRlIEFCSSBlbnRyeSBmb3IgJHtKU09OLnN0cmluZ2lmeShzaWduYXR1cmUpfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVuaXF1ZVNpZ25hdHVyZXNbc2lnbmF0dXJlXSA9IHRydWU7XG4gICAgICAgICAgICAvLyBUcmFjayB1bmlxdWUgbmFtZXM7IHdlIG9ubHkgZXhwb3NlIGJhcmUgbmFtZWQgZnVuY3Rpb25zIGlmIHRoZXlcbiAgICAgICAgICAgIC8vIGFyZSBhbWJpZ3VvdXNcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIXVuaXF1ZU5hbWVzW2AlJHtuYW1lfWBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzW2AlJHtuYW1lfWBdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzW2AlJHtuYW1lfWBdLnB1c2goc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzW3NpZ25hdHVyZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIHNpZ25hdHVyZSwgYnVpbGREZWZhdWx0KHRoaXMsIGZyYWdtZW50LCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBkbyBub3QgY29sbGFwc2Ugc2ltcGxlIGNhbGxzIG9uIHRoaXMgYnVja2V0LCB3aGljaCBhbGxvd3NcbiAgICAgICAgICAgIC8vIGZyYW1ld29ya3MgdG8gc2FmZWx5IHVzZSB0aGlzIHdpdGhvdXQgaW50cm9zcGVjdGlvbiBhcyB3ZWxsIGFzXG4gICAgICAgICAgICAvLyBhbGxvd3MgZGVjb2RpbmcgZXJyb3IgcmVjb3ZlcnkuXG4gICAgICAgICAgICBpZiAodGhpcy5mdW5jdGlvbnNbc2lnbmF0dXJlXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5mdW5jdGlvbnMsIHNpZ25hdHVyZSwgYnVpbGREZWZhdWx0KHRoaXMsIGZyYWdtZW50LCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbFN0YXRpY1tzaWduYXR1cmVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLmNhbGxTdGF0aWMsIHNpZ25hdHVyZSwgYnVpbGRDYWxsKHRoaXMsIGZyYWdtZW50LCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uW3NpZ25hdHVyZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbiwgc2lnbmF0dXJlLCBidWlsZFBvcHVsYXRlKHRoaXMsIGZyYWdtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lc3RpbWF0ZUdhc1tzaWduYXR1cmVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLmVzdGltYXRlR2FzLCBzaWduYXR1cmUsIGJ1aWxkRXN0aW1hdGUodGhpcywgZnJhZ21lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHVuaXF1ZU5hbWVzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAvLyBBbWJpZ3VvdXMgbmFtZXMgdG8gbm90IGdldCBhdHRhY2hlZCBhcyBiYXJlIG5hbWVzXG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmVzID0gdW5pcXVlTmFtZXNbbmFtZV07XG4gICAgICAgICAgICBpZiAoc2lnbmF0dXJlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBsZWFkaW5nIFwiJVwiIHVzZWQgZm9yIHByb3RvdHlwZSBwcm90ZWN0aW9uXG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduYXR1cmVzWzBdO1xuICAgICAgICAgICAgLy8gSWYgb3ZlcndyaXRpbmcgYSBtZW1iZXIgcHJvcGVydHkgdGhhdCBpcyBudWxsLCBzd2FsbG93IHRoZSBlcnJvclxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIG5hbWUsIHRoaXNbc2lnbmF0dXJlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25zW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLmZ1bmN0aW9ucywgbmFtZSwgdGhpcy5mdW5jdGlvbnNbc2lnbmF0dXJlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxsU3RhdGljW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLmNhbGxTdGF0aWMsIG5hbWUsIHRoaXMuY2FsbFN0YXRpY1tzaWduYXR1cmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb25bbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbiwgbmFtZSwgdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uW3NpZ25hdHVyZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZXN0aW1hdGVHYXNbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMuZXN0aW1hdGVHYXMsIG5hbWUsIHRoaXMuZXN0aW1hdGVHYXNbc2lnbmF0dXJlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q29udHJhY3RBZGRyZXNzKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBnZXRDb250cmFjdEFkZHJlc3ModHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0SW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKSB7XG4gICAgICAgIGlmIChJbnRlcmZhY2UuaXNJbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJhY3RJbnRlcmZhY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogQWxsb3cgdGltZW91dD9cbiAgICBkZXBsb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcGxveWVkKCk7XG4gICAgfVxuICAgIF9kZXBsb3llZChibG9ja1RhZykge1xuICAgICAgICBpZiAoIXRoaXMuX2RlcGxveWVkUHJvbWlzZSkge1xuICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSBqdXN0IGRlcGxveWVkLCB3ZSBrbm93IHRoZSB0cmFuc2FjdGlvbiB3ZSBzaG91bGQgb2NjdXIgaW5cbiAgICAgICAgICAgIGlmICh0aGlzLmRlcGxveVRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVwbG95ZWRQcm9taXNlID0gdGhpcy5kZXBsb3lUcmFuc2FjdGlvbi53YWl0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQFRPRE86IE9uY2Ugd2UgYWxsb3cgYSB0aW1lb3V0IHRvIGJlIHBhc3NlZCBpbiwgd2Ugd2lsbCB3YWl0XG4gICAgICAgICAgICAgICAgLy8gdXAgdG8gdGhhdCBtYW55IGJsb2NrcyBmb3IgZ2V0Q29kZVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgcG9sbCBmb3Igb3VyIGNvZGUgdG8gYmUgZGVwbG95ZWRcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXBsb3llZFByb21pc2UgPSB0aGlzLnByb3ZpZGVyLmdldENvZGUodGhpcy5hZGRyZXNzLCBibG9ja1RhZykudGhlbigoY29kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNvbnRyYWN0IG5vdCBkZXBsb3llZFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXREZXBsb3llZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVwbG95ZWRQcm9taXNlO1xuICAgIH1cbiAgICAvLyBAVE9ETzpcbiAgICAvLyBlc3RpbWF0ZUZhbGxiYWNrKG92ZXJyaWRlcz86IFRyYW5zYWN0aW9uUmVxdWVzdCk6IFByb21pc2U8QmlnTnVtYmVyPlxuICAgIC8vIEBUT0RPOlxuICAgIC8vIGVzdGltYXRlRGVwbG95KGJ5dGVjb2RlOiBzdHJpbmcsIC4uLmFyZ3MpOiBQcm9taXNlPEJpZ051bWJlcj5cbiAgICBmYWxsYmFjayhvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpZ25lcikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJzZW5kaW5nIGEgdHJhbnNhY3Rpb25zIHJlcXVpcmUgYSBzaWduZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvbihmYWxsYmFjaylcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eCA9IHNoYWxsb3dDb3B5KG92ZXJyaWRlcyB8fCB7fSk7XG4gICAgICAgIFtcImZyb21cIiwgXCJ0b1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBvdmVycmlkZSBcIiArIGtleSwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBrZXkgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0eC50byA9IHRoaXMucmVzb2x2ZWRBZGRyZXNzO1xuICAgICAgICByZXR1cm4gdGhpcy5kZXBsb3llZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBSZWNvbm5lY3QgdG8gYSBkaWZmZXJlbnQgc2lnbmVyIG9yIHByb3ZpZGVyXG4gICAgY29ubmVjdChzaWduZXJPclByb3ZpZGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHNpZ25lck9yUHJvdmlkZXIpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBzaWduZXJPclByb3ZpZGVyID0gbmV3IFZvaWRTaWduZXIoc2lnbmVyT3JQcm92aWRlciwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgKHRoaXMuY29uc3RydWN0b3IpKHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UsIHNpZ25lck9yUHJvdmlkZXIpO1xuICAgICAgICBpZiAodGhpcy5kZXBsb3lUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkoY29udHJhY3QsIFwiZGVwbG95VHJhbnNhY3Rpb25cIiwgdGhpcy5kZXBsb3lUcmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0O1xuICAgIH1cbiAgICAvLyBSZS1hdHRhY2ggdG8gYSBkaWZmZXJlbnQgb24tY2hhaW4gaW5zdGFuY2Ugb2YgdGhpcyBjb250cmFjdFxuICAgIGF0dGFjaChhZGRyZXNzT3JOYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgKHRoaXMuY29uc3RydWN0b3IpKGFkZHJlc3NPck5hbWUsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnNpZ25lciB8fCB0aGlzLnByb3ZpZGVyKTtcbiAgICB9XG4gICAgc3RhdGljIGlzSW5kZXhlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSW5kZXhlZC5pc0luZGV4ZWQodmFsdWUpO1xuICAgIH1cbiAgICBfbm9ybWFsaXplUnVubmluZ0V2ZW50KHJ1bm5pbmdFdmVudCkge1xuICAgICAgICAvLyBBbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBldmVudCBydW5uaW5nOyB3ZSBjYW4gcmUtdXNlIGl0XG4gICAgICAgIGlmICh0aGlzLl9ydW5uaW5nRXZlbnRzW3J1bm5pbmdFdmVudC50YWddKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVubmluZ0V2ZW50O1xuICAgIH1cbiAgICBfZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIChldmVudE5hbWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIFwiZXJyb3JcIiBldmVudHMgKGlmIHlvdXIgY29udHJhY3QgaGFzIGFuIGVycm9yIGV2ZW50LCBpbmNsdWRlXG4gICAgICAgICAgICAvLyB0aGUgZnVsbCBzaWduYXR1cmUgdG8gYnlwYXNzIHRoaXMgc3BlY2lhbCBldmVudCBrZXl3b3JkKVxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgRXJyb3JSdW5uaW5nRXZlbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIGFueSBldmVudCB0aGF0IGlzIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiZXZlbnRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IFJ1bm5pbmdFdmVudChcImV2ZW50XCIsIG51bGwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExpc3RlbiBmb3IgYW55IGV2ZW50XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IFdpbGRjYXJkUnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgZXZlbnQgRnJhZ21lbnQgKHRocm93cyBpZiBhbWJpZ3VvdXMvdW5rbm93biBldmVudClcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZ2V0RXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IEZyYWdtZW50UnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UsIGZyYWdtZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSB0b3BpY3MgdG8gZmlsdGVyIGJ5Li4uXG4gICAgICAgIGlmIChldmVudE5hbWUudG9waWNzICYmIGV2ZW50TmFtZS50b3BpY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gSXMgaXQgYSBrbm93biB0b3BpY2hhc2g/ICh0aHJvd3MgaWYgbm8gbWF0Y2hpbmcgdG9waWNoYXNoKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3BpYyA9IGV2ZW50TmFtZS50b3BpY3NbMF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodG9waWMpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdG9waWNcIik7IC8vIEBUT0RPOiBNYXkgaGFwcGVuIGZvciBhbm9ueW1vdXMgZXZlbnRzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZ2V0RXZlbnQodG9waWMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IEZyYWdtZW50UnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UsIGZyYWdtZW50LCBldmVudE5hbWUudG9waWNzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgLy8gRmlsdGVyIGJ5IHRoZSB1bmtub3duIHRvcGljaGFzaFxuICAgICAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICB0b3BpY3M6IGV2ZW50TmFtZS50b3BpY3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBSdW5uaW5nRXZlbnQoZ2V0RXZlbnRUYWcoZmlsdGVyKSwgZmlsdGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgV2lsZGNhcmRSdW5uaW5nRXZlbnQodGhpcy5hZGRyZXNzLCB0aGlzLmludGVyZmFjZSkpO1xuICAgIH1cbiAgICBfY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCkge1xuICAgICAgICBpZiAocnVubmluZ0V2ZW50Lmxpc3RlbmVyQ291bnQoKSA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3J1bm5pbmdFdmVudHNbcnVubmluZ0V2ZW50LnRhZ107XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9sbGVyIGZvciB0aGlzLCByZW1vdmUgaXRcbiAgICAgICAgICAgIGNvbnN0IGVtaXQgPSB0aGlzLl93cmFwcGVkRW1pdHNbcnVubmluZ0V2ZW50LnRhZ107XG4gICAgICAgICAgICBpZiAoZW1pdCAmJiBydW5uaW5nRXZlbnQuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vZmYocnVubmluZ0V2ZW50LmZpbHRlciwgZW1pdCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3dyYXBwZWRFbWl0c1tydW5uaW5nRXZlbnQudGFnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHRvIGdyYWNlZnVsbHkgcmVjb3ZlclxuICAgIC8vIGZyb20gcGFyc2UgZXJyb3JzIGlmIHRoZXkgd2lzaFxuICAgIF93cmFwRXZlbnQocnVubmluZ0V2ZW50LCBsb2csIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gZGVlcENvcHkobG9nKTtcbiAgICAgICAgZXZlbnQucmVtb3ZlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVubmluZ0V2ZW50LnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBldmVudC5nZXRCbG9jayA9ICgpID0+IHsgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0QmxvY2sobG9nLmJsb2NrSGFzaCk7IH07XG4gICAgICAgIGV2ZW50LmdldFRyYW5zYWN0aW9uID0gKCkgPT4geyByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbihsb2cudHJhbnNhY3Rpb25IYXNoKTsgfTtcbiAgICAgICAgZXZlbnQuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0ID0gKCkgPT4geyByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQobG9nLnRyYW5zYWN0aW9uSGFzaCk7IH07XG4gICAgICAgIC8vIFRoaXMgbWF5IHRocm93IGlmIHRoZSB0b3BpY3MgYW5kIGRhdGEgbWlzbWF0Y2ggdGhlIHNpZ25hdHVyZVxuICAgICAgICBydW5uaW5nRXZlbnQucHJlcGFyZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgICBfYWRkRXZlbnRMaXN0ZW5lcihydW5uaW5nRXZlbnQsIGxpc3RlbmVyLCBvbmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJldmVudHMgcmVxdWlyZSBhIHByb3ZpZGVyIG9yIGEgc2lnbmVyIHdpdGggYSBwcm92aWRlclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBvcGVyYXRpb246IFwib25jZVwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJ1bm5pbmdFdmVudC5hZGRMaXN0ZW5lcihsaXN0ZW5lciwgb25jZSk7XG4gICAgICAgIC8vIFRyYWNrIHRoaXMgcnVubmluZyBldmVudCBhbmQgaXRzIGxpc3RlbmVycyAobWF5IGFscmVhZHkgYmUgdGhlcmU7IGJ1dCBubyBoYXJkIGluIHVwZGF0aW5nKVxuICAgICAgICB0aGlzLl9ydW5uaW5nRXZlbnRzW3J1bm5pbmdFdmVudC50YWddID0gcnVubmluZ0V2ZW50O1xuICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IHBvbGxpbmcgdGhlIHByb3ZpZGVyLCBzdGFydCBwb2xsaW5nXG4gICAgICAgIGlmICghdGhpcy5fd3JhcHBlZEVtaXRzW3J1bm5pbmdFdmVudC50YWddKSB7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVkRW1pdCA9IChsb2cpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnQgPSB0aGlzLl93cmFwRXZlbnQocnVubmluZ0V2ZW50LCBsb2csIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZW1pdCB0aGUgcmVzdWx0IGZvciB0aGUgcGFyYW1ldGVyaXplZCBldmVudC4uLlxuICAgICAgICAgICAgICAgIGlmIChldmVudC5kZWNvZGVFcnJvciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gcnVubmluZ0V2ZW50LmdldEVtaXQoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHJ1bm5pbmdFdmVudC5maWx0ZXIsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGVjb2RlRXJyb3IgPSBlcnJvci5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgZW1pdCBcImV2ZW50XCIgZm9yIGZyYWdtZW50LWJhc2UgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdFdmVudC5maWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJldmVudFwiLCBldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVtaXQgXCJlcnJvclwiIGlmIHRoZXJlIHdhcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5kZWNvZGVFcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGV2ZW50LmRlY29kZUVycm9yLCBldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3dyYXBwZWRFbWl0c1tydW5uaW5nRXZlbnQudGFnXSA9IHdyYXBwZWRFbWl0O1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBldmVudHMsIGxpa2UgXCJlcnJvclwiIGRvIG5vdCBoYXZlIGEgZmlsdGVyXG4gICAgICAgICAgICBpZiAocnVubmluZ0V2ZW50LmZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbihydW5uaW5nRXZlbnQuZmlsdGVyLCB3cmFwcGVkRW1pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVlcnlGaWx0ZXIoZXZlbnQsIGZyb21CbG9ja09yQmxvY2toYXNoLCB0b0Jsb2NrKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5pbmdFdmVudCA9IHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudCk7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHNoYWxsb3dDb3B5KHJ1bm5pbmdFdmVudC5maWx0ZXIpO1xuICAgICAgICBpZiAodHlwZW9mIChmcm9tQmxvY2tPckJsb2NraGFzaCkgPT09IFwic3RyaW5nXCIgJiYgaXNIZXhTdHJpbmcoZnJvbUJsb2NrT3JCbG9ja2hhc2gsIDMyKSkge1xuICAgICAgICAgICAgaWYgKHRvQmxvY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3Qgc3BlY2lmeSB0b0Jsb2NrIHdpdGggYmxvY2toYXNoXCIsIFwidG9CbG9ja1wiLCB0b0Jsb2NrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbHRlci5ibG9ja0hhc2ggPSBmcm9tQmxvY2tPckJsb2NraGFzaDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSAoKGZyb21CbG9ja09yQmxvY2toYXNoICE9IG51bGwpID8gZnJvbUJsb2NrT3JCbG9ja2hhc2ggOiAwKTtcbiAgICAgICAgICAgIGZpbHRlci50b0Jsb2NrID0gKCh0b0Jsb2NrICE9IG51bGwpID8gdG9CbG9jayA6IFwibGF0ZXN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldExvZ3MoZmlsdGVyKS50aGVuKChsb2dzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbG9ncy5tYXAoKGxvZykgPT4gdGhpcy5fd3JhcEV2ZW50KHJ1bm5pbmdFdmVudCwgbG9nLCBudWxsKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnQpLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnQpLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlbWl0KGV2ZW50TmFtZSwgLi4uYXJncykge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5uaW5nRXZlbnQgPSB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKHJ1bm5pbmdFdmVudC5ydW4oYXJncykgPiAwKTtcbiAgICAgICAgLy8gTWF5IGhhdmUgZHJhaW5lZCBhbGwgdGhlIFwib25jZVwiIGV2ZW50czsgY2hlY2sgZm9yIGxpdmluZyBldmVudHNcbiAgICAgICAgdGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fcnVubmluZ0V2ZW50cykucmVkdWNlKChhY2N1bSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtICsgdGhpcy5fcnVubmluZ0V2ZW50c1trZXldLmxpc3RlbmVyQ291bnQoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKS5saXN0ZW5lckNvdW50KCk7XG4gICAgfVxuICAgIGxpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHRhZyBpbiB0aGlzLl9ydW5uaW5nRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcnVubmluZ0V2ZW50c1t0YWddLmxpc3RlbmVycygpLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpLmxpc3RlbmVycygpO1xuICAgIH1cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhZyBpbiB0aGlzLl9ydW5uaW5nRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVubmluZ0V2ZW50ID0gdGhpcy5fcnVubmluZ0V2ZW50c1t0YWddO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmdFdmVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlbGV0ZSBhbnkgbGlzdGVuZXJzXG4gICAgICAgIGNvbnN0IHJ1bm5pbmdFdmVudCA9IHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpO1xuICAgICAgICBydW5uaW5nRXZlbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5uaW5nRXZlbnQgPSB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgcnVubmluZ0V2ZW50LnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ29udHJhY3QgZXh0ZW5kcyBCYXNlQ29udHJhY3Qge1xufVxuZXhwb3J0IGNsYXNzIENvbnRyYWN0RmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoY29udHJhY3RJbnRlcmZhY2UsIGJ5dGVjb2RlLCBzaWduZXIpIHtcbiAgICAgICAgbGV0IGJ5dGVjb2RlSGV4ID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiAoYnl0ZWNvZGUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBieXRlY29kZUhleCA9IGJ5dGVjb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQnl0ZXMoYnl0ZWNvZGUpKSB7XG4gICAgICAgICAgICBieXRlY29kZUhleCA9IGhleGxpZnkoYnl0ZWNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ5dGVjb2RlICYmIHR5cGVvZiAoYnl0ZWNvZGUub2JqZWN0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gQWxsb3cgdGhlIGJ5dGVjb2RlIG9iamVjdCBmcm9tIHRoZSBTb2xpZGl0eSBjb21waWxlclxuICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBieXRlY29kZS5vYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDcmFzaCBpbiB0aGUgbmV4dCB2ZXJpZmljYXRpb24gc3RlcFxuICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBcIiFcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgaXQgaXMgMHggcHJlZml4ZWRcbiAgICAgICAgaWYgKGJ5dGVjb2RlSGV4LnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgICAgICAgICBieXRlY29kZUhleCA9IFwiMHhcIiArIGJ5dGVjb2RlSGV4O1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZmluYWwgcmVzdWx0IGlzIHZhbGlkIGJ5dGVjb2RlXG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcoYnl0ZWNvZGVIZXgpIHx8IChieXRlY29kZUhleC5sZW5ndGggJSAyKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYnl0ZWNvZGVcIiwgXCJieXRlY29kZVwiLCBieXRlY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHNpZ25lciwgbWFrZSBzdXJlIGl0IGlzIHZhbGlkXG4gICAgICAgIGlmIChzaWduZXIgJiYgIVNpZ25lci5pc1NpZ25lcihzaWduZXIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBzaWduZXJcIiwgXCJzaWduZXJcIiwgc2lnbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImJ5dGVjb2RlXCIsIGJ5dGVjb2RlSGV4KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJpbnRlcmZhY2VcIiwgZ2V0U3RhdGljKG5ldy50YXJnZXQsIFwiZ2V0SW50ZXJmYWNlXCIpKGNvbnRyYWN0SW50ZXJmYWNlKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwic2lnbmVyXCIsIHNpZ25lciB8fCBudWxsKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IEZ1dHVyZTsgcmVuYW1lIHRvIHBvcHVsYXRlVHJhbnNhY3Rpb24/XG4gICAgZ2V0RGVwbG95VHJhbnNhY3Rpb24oLi4uYXJncykge1xuICAgICAgICBsZXQgdHggPSB7fTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSAxIGFkZGl0aW9uYWwgYXJndW1lbnQsIHdlIGFsbG93IHRyYW5zYWN0aW9uIG92ZXJyaWRlc1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoICsgMSAmJiB0eXBlb2YgKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHR4ID0gc2hhbGxvd0NvcHkoYXJncy5wb3AoKSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0eCkge1xuICAgICAgICAgICAgICAgIGlmICghYWxsb3dlZFRyYW5zYWN0aW9uS2V5c1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHJhbnNhY3Rpb24gb3ZlcnJpZGUgXCIgKyBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3QgYWxsb3cgdGhlc2UgdG8gYmUgb3ZlcnJpZGRlbiBpbiBhIGRlcGxveW1lbnQgdHJhbnNhY3Rpb25cbiAgICAgICAgW1wiZGF0YVwiLCBcImZyb21cIiwgXCJ0b1wiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBvdmVycmlkZSBcIiArIGtleSwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBrZXkgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHgudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gQmlnTnVtYmVyLmZyb20odHgudmFsdWUpO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZS5pc1plcm8oKSAmJiAhdGhpcy5pbnRlcmZhY2UuZGVwbG95LnBheWFibGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vbi1wYXlhYmxlIGNvbnN0cnVjdG9yIGNhbm5vdCBvdmVycmlkZSB2YWx1ZVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwib3ZlcnJpZGVzLnZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eC52YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgY2FsbCBtYXRjaGVzIHRoZSBjb25zdHJ1Y3RvciBzaWduYXR1cmVcbiAgICAgICAgbG9nZ2VyLmNoZWNrQXJndW1lbnRDb3VudChhcmdzLmxlbmd0aCwgdGhpcy5pbnRlcmZhY2UuZGVwbG95LmlucHV0cy5sZW5ndGgsIFwiIGluIENvbnRyYWN0IGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAvLyBTZXQgdGhlIGRhdGEgdG8gdGhlIGJ5dGVjb2RlICsgdGhlIGVuY29kZWQgY29uc3RydWN0b3IgYXJndW1lbnRzXG4gICAgICAgIHR4LmRhdGEgPSBoZXhsaWZ5KGNvbmNhdChbXG4gICAgICAgICAgICB0aGlzLmJ5dGVjb2RlLFxuICAgICAgICAgICAgdGhpcy5pbnRlcmZhY2UuZW5jb2RlRGVwbG95KGFyZ3MpXG4gICAgICAgIF0pKTtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICBkZXBsb3koLi4uYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICAgICAgLy8gSWYgMSBleHRyYSBwYXJhbWV0ZXIgd2FzIHBhc3NlZCBpbiwgaXQgY29udGFpbnMgb3ZlcnJpZGVzXG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgICAgIG92ZXJyaWRlcyA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNhbGwgbWF0Y2hlcyB0aGUgY29uc3RydWN0b3Igc2lnbmF0dXJlXG4gICAgICAgICAgICBsb2dnZXIuY2hlY2tBcmd1bWVudENvdW50KGFyZ3MubGVuZ3RoLCB0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCwgXCIgaW4gQ29udHJhY3QgY29uc3RydWN0b3JcIik7XG4gICAgICAgICAgICAvLyBSZXNvbHZlIEVOUyBuYW1lcyBhbmQgcHJvbWlzZXMgaW4gdGhlIGFyZ3VtZW50c1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geWllbGQgcmVzb2x2ZUFkZHJlc3Nlcyh0aGlzLnNpZ25lciwgYXJncywgdGhpcy5pbnRlcmZhY2UuZGVwbG95LmlucHV0cyk7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChvdmVycmlkZXMpO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uICh3aXRoIG9wdGlvbmFsIG92ZXJyaWRlcylcbiAgICAgICAgICAgIGNvbnN0IHVuc2lnbmVkVHggPSB0aGlzLmdldERlcGxveVRyYW5zYWN0aW9uKC4uLnBhcmFtcyk7XG4gICAgICAgICAgICAvLyBTZW5kIHRoZSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHRoaXMuc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih1bnNpZ25lZFR4KTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRDb250cmFjdEFkZHJlc3NcIikodHgpO1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRDb250cmFjdFwiKShhZGRyZXNzLCB0aGlzLmludGVyZmFjZSwgdGhpcy5zaWduZXIpO1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBtb2RpZmllZCB3YWl0IHRoYXQgd3JhcHMgZXZlbnRzXG4gICAgICAgICAgICBhZGRDb250cmFjdFdhaXQoY29udHJhY3QsIHR4KTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KGNvbnRyYWN0LCBcImRlcGxveVRyYW5zYWN0aW9uXCIsIHR4KTtcbiAgICAgICAgICAgIHJldHVybiBjb250cmFjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF0dGFjaChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5jb25zdHJ1Y3RvcikuZ2V0Q29udHJhY3QoYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UsIHRoaXMuc2lnbmVyKTtcbiAgICB9XG4gICAgY29ubmVjdChzaWduZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAodGhpcy5jb25zdHJ1Y3RvcikodGhpcy5pbnRlcmZhY2UsIHRoaXMuYnl0ZWNvZGUsIHNpZ25lcik7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU29saWRpdHkoY29tcGlsZXJPdXRwdXQsIHNpZ25lcikge1xuICAgICAgICBpZiAoY29tcGlsZXJPdXRwdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIGNvbXBpbGVyIG91dHB1dFwiLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfQVJHVU1FTlQsIHsgYXJndW1lbnQ6IFwiY29tcGlsZXJPdXRwdXRcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChjb21waWxlck91dHB1dCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbXBpbGVyT3V0cHV0ID0gSlNPTi5wYXJzZShjb21waWxlck91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWJpID0gY29tcGlsZXJPdXRwdXQuYWJpO1xuICAgICAgICBsZXQgYnl0ZWNvZGUgPSBudWxsO1xuICAgICAgICBpZiAoY29tcGlsZXJPdXRwdXQuYnl0ZWNvZGUpIHtcbiAgICAgICAgICAgIGJ5dGVjb2RlID0gY29tcGlsZXJPdXRwdXQuYnl0ZWNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcGlsZXJPdXRwdXQuZXZtICYmIGNvbXBpbGVyT3V0cHV0LmV2bS5ieXRlY29kZSkge1xuICAgICAgICAgICAgYnl0ZWNvZGUgPSBjb21waWxlck91dHB1dC5ldm0uYnl0ZWNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGFiaSwgYnl0ZWNvZGUsIHNpZ25lcik7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRJbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpIHtcbiAgICAgICAgcmV0dXJuIENvbnRyYWN0LmdldEludGVyZmFjZShjb250cmFjdEludGVyZmFjZSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRDb250cmFjdEFkZHJlc3ModHgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbnRyYWN0QWRkcmVzcyh0eCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRDb250cmFjdChhZGRyZXNzLCBjb250cmFjdEludGVyZmFjZSwgc2lnbmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3QoYWRkcmVzcywgY29udHJhY3RJbnRlcmZhY2UsIHNpZ25lcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsImNoZWNrUmVzdWx0RXJyb3JzIiwiSW5kZXhlZCIsIkludGVyZmFjZSIsIlByb3ZpZGVyIiwiU2lnbmVyIiwiVm9pZFNpZ25lciIsImdldEFkZHJlc3MiLCJnZXRDb250cmFjdEFkZHJlc3MiLCJCaWdOdW1iZXIiLCJhcnJheWlmeSIsImNvbmNhdCIsImhleGxpZnkiLCJpc0J5dGVzIiwiaXNIZXhTdHJpbmciLCJkZWZpbmVSZWFkT25seSIsImRlZXBDb3B5IiwiZ2V0U3RhdGljIiwicmVzb2x2ZVByb3BlcnRpZXMiLCJzaGFsbG93Q29weSIsImFjY2Vzc0xpc3RpZnkiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyIsImNoYWluSWQiLCJkYXRhIiwiZnJvbSIsImdhc0xpbWl0IiwiZ2FzUHJpY2UiLCJub25jZSIsInRvIiwidHlwZSIsImFjY2Vzc0xpc3QiLCJtYXhGZWVQZXJHYXMiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsImN1c3RvbURhdGEiLCJjY2lwUmVhZEVuYWJsZWQiLCJyZXNvbHZlTmFtZSIsInJlc29sdmVyIiwibmFtZU9yUHJvbWlzZSIsIm5hbWUiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJlcnJvciIsInRocm93RXJyb3IiLCJlcnJvcnMiLCJVTlNVUFBPUlRFRF9PUEVSQVRJT04iLCJvcGVyYXRpb24iLCJhZGRyZXNzIiwicmVzb2x2ZUFkZHJlc3NlcyIsInBhcmFtVHlwZSIsIkFycmF5IiwiaXNBcnJheSIsImFsbCIsIm1hcCIsImluZGV4IiwiY29tcG9uZW50cyIsImJhc2VUeXBlIiwibWFrZUVycm9yIiwiSU5WQUxJRF9BUkdVTUVOVCIsImFyZ3VtZW50IiwidiIsImFycmF5Q2hpbGRyZW4iLCJwb3B1bGF0ZVRyYW5zYWN0aW9uIiwiY29udHJhY3QiLCJmcmFnbWVudCIsImFyZ3MiLCJvdmVycmlkZXMiLCJsZW5ndGgiLCJpbnB1dHMiLCJwb3AiLCJjaGVja0FyZ3VtZW50Q291bnQiLCJzaWduZXIiLCJvdmVycmlkZSIsImNoZWNrIiwicHJvdmlkZXIiLCJyZXNvbHZlZCIsInJlc29sdmVkQWRkcmVzcyIsImludGVyZmFjZSIsImVuY29kZUZ1bmN0aW9uRGF0YSIsInR4Iiwicm8iLCJ0b051bWJlciIsImdhcyIsImludHJpbnNpYyIsImJ5dGVzIiwiaSIsImFkZCIsInJvVmFsdWUiLCJpc1plcm8iLCJwYXlhYmxlIiwibGVmdG92ZXJzIiwiT2JqZWN0Iiwia2V5cyIsImZpbHRlciIsImtleSIsImwiLCJKU09OIiwic3RyaW5naWZ5Iiwiam9pbiIsImJ1aWxkUG9wdWxhdGUiLCJidWlsZEVzdGltYXRlIiwic2lnbmVyT3JQcm92aWRlciIsImVzdGltYXRlR2FzIiwiYWRkQ29udHJhY3RXYWl0Iiwid2FpdCIsImJpbmQiLCJjb25maXJtYXRpb25zIiwicmVjZWlwdCIsImV2ZW50cyIsImxvZ3MiLCJsb2ciLCJldmVudCIsInBhcnNlZCIsInBhcnNlTG9nIiwiZGVjb2RlIiwidG9waWNzIiwiZGVjb2RlRXZlbnRMb2ciLCJldmVudEZyYWdtZW50IiwiZXZlbnRTaWduYXR1cmUiLCJzaWduYXR1cmUiLCJyZW1vdmVMaXN0ZW5lciIsImdldEJsb2NrIiwiYmxvY2tIYXNoIiwiZ2V0VHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbkhhc2giLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJidWlsZENhbGwiLCJjb2xsYXBzZVNpbXBsZSIsImJsb2NrVGFnIiwidW5kZWZpbmVkIiwicHVzaCIsImRlcGxveVRyYW5zYWN0aW9uIiwiX2RlcGxveWVkIiwiY2FsbCIsImRlY29kZUZ1bmN0aW9uUmVzdWx0Iiwib3V0cHV0cyIsImNvZGUiLCJDQUxMX0VYQ0VQVElPTiIsInRyYW5zYWN0aW9uIiwiYnVpbGRTZW5kIiwidHhSZXF1ZXN0Iiwic2VuZFRyYW5zYWN0aW9uIiwiYnVpbGREZWZhdWx0IiwiY29uc3RhbnQiLCJnZXRFdmVudFRhZyIsInRvcGljIiwiUnVubmluZ0V2ZW50IiwiY29uc3RydWN0b3IiLCJ0YWciLCJfbGlzdGVuZXJzIiwiYWRkTGlzdGVuZXIiLCJsaXN0ZW5lciIsIm9uY2UiLCJpdGVtIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwibGlzdGVuZXJzIiwibGlzdGVuZXJDb3VudCIsInJ1biIsImFyZ3NDb3B5Iiwic2xpY2UiLCJzZXRUaW1lb3V0IiwicHJlcGFyZUV2ZW50IiwiZ2V0RW1pdCIsIkVycm9yUnVubmluZ0V2ZW50IiwiRnJhZ21lbnRSdW5uaW5nRXZlbnQiLCJjb250cmFjdEludGVyZmFjZSIsImdldEV2ZW50VG9waWMiLCJmb3JtYXQiLCJkZWNvZGVFcnJvciIsIldpbGRjYXJkUnVubmluZ0V2ZW50IiwiQmFzZUNvbnRyYWN0IiwiYWRkcmVzc09yTmFtZSIsImlzU2lnbmVyIiwiaXNQcm92aWRlciIsInVuaXF1ZUZpbHRlcnMiLCJmb3JFYWNoIiwiZmlsdGVycyIsImVuY29kZUZpbHRlclRvcGljcyIsIndhcm4iLCJjYXRjaCIsInVuaXF1ZU5hbWVzIiwidW5pcXVlU2lnbmF0dXJlcyIsImZ1bmN0aW9ucyIsImNhbGxTdGF0aWMiLCJzaWduYXR1cmVzIiwic3Vic3RyaW5nIiwiZ2V0SW50ZXJmYWNlIiwiaXNJbnRlcmZhY2UiLCJkZXBsb3llZCIsIl9kZXBsb3llZFByb21pc2UiLCJnZXRDb2RlIiwiY29udHJhY3RBZGRyZXNzIiwiZmFsbGJhY2siLCJjb25uZWN0IiwiYXR0YWNoIiwiaXNJbmRleGVkIiwiX25vcm1hbGl6ZVJ1bm5pbmdFdmVudCIsInJ1bm5pbmdFdmVudCIsIl9ydW5uaW5nRXZlbnRzIiwiX2dldFJ1bm5pbmdFdmVudCIsImV2ZW50TmFtZSIsImdldEV2ZW50IiwiRXJyb3IiLCJfY2hlY2tSdW5uaW5nRXZlbnRzIiwiZW1pdCIsIl93cmFwcGVkRW1pdHMiLCJvZmYiLCJfd3JhcEV2ZW50IiwiX2FkZEV2ZW50TGlzdGVuZXIiLCJ3cmFwcGVkRW1pdCIsIm9uIiwicXVlcnlGaWx0ZXIiLCJmcm9tQmxvY2tPckJsb2NraGFzaCIsInRvQmxvY2siLCJmcm9tQmxvY2siLCJnZXRMb2dzIiwicmVkdWNlIiwiYWNjdW0iLCJDb250cmFjdCIsIkNvbnRyYWN0RmFjdG9yeSIsImJ5dGVjb2RlIiwiYnl0ZWNvZGVIZXgiLCJvYmplY3QiLCJnZXREZXBsb3lUcmFuc2FjdGlvbiIsImRlcGxveSIsImVuY29kZURlcGxveSIsInBhcmFtcyIsInVuc2lnbmVkVHgiLCJnZXRDb250cmFjdCIsImZyb21Tb2xpZGl0eSIsImNvbXBpbGVyT3V0cHV0IiwiTUlTU0lOR19BUkdVTUVOVCIsInBhcnNlIiwiYWJpIiwiZXZtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@ethersproject+contracts@5.7.0/node_modules/@ethersproject/contracts/lib.esm/index.js\n");

/***/ })

};
;