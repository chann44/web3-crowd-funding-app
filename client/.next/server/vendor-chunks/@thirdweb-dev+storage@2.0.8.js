"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@thirdweb-dev+storage@2.0.8";
exports.ids = ["vendor-chunks/@thirdweb-dev+storage@2.0.8"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@thirdweb-dev+storage@2.0.8/node_modules/@thirdweb-dev/storage/dist/thirdweb-dev-storage.esm.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@thirdweb-dev+storage@2.0.8/node_modules/@thirdweb-dev/storage/dist/thirdweb-dev-storage.esm.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_GATEWAY_URLS: () => (/* binding */ DEFAULT_GATEWAY_URLS),\n/* harmony export */   IpfsUploader: () => (/* binding */ IpfsUploader),\n/* harmony export */   MockDownloader: () => (/* binding */ MockDownloader),\n/* harmony export */   MockUploader: () => (/* binding */ MockUploader),\n/* harmony export */   PINATA_IPFS_URL: () => (/* binding */ PINATA_IPFS_URL),\n/* harmony export */   StorageDownloader: () => (/* binding */ StorageDownloader),\n/* harmony export */   TW_UPLOAD_SERVER_URL: () => (/* binding */ TW_UPLOAD_SERVER_URL),\n/* harmony export */   ThirdwebStorage: () => (/* binding */ ThirdwebStorage),\n/* harmony export */   convertCidToV1: () => (/* binding */ convertCidToV1),\n/* harmony export */   extractObjectFiles: () => (/* binding */ extractObjectFiles),\n/* harmony export */   getGatewayUrlForCid: () => (/* binding */ getGatewayUrlForCid),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isBufferInstance: () => (/* binding */ isBufferInstance),\n/* harmony export */   isBufferOrStringWithName: () => (/* binding */ isBufferOrStringWithName),\n/* harmony export */   isFileBufferOrStringEqual: () => (/* binding */ isFileBufferOrStringEqual),\n/* harmony export */   isFileInstance: () => (/* binding */ isFileInstance),\n/* harmony export */   isFileOrBuffer: () => (/* binding */ isFileOrBuffer),\n/* harmony export */   isTwGatewayUrl: () => (/* binding */ isTwGatewayUrl),\n/* harmony export */   parseGatewayUrls: () => (/* binding */ parseGatewayUrls),\n/* harmony export */   prepareGatewayUrls: () => (/* binding */ prepareGatewayUrls),\n/* harmony export */   replaceGatewayUrlWithScheme: () => (/* binding */ replaceGatewayUrlWithScheme),\n/* harmony export */   replaceObjectFilesWithUris: () => (/* binding */ replaceObjectFilesWithUris),\n/* harmony export */   replaceObjectGatewayUrlsWithSchemes: () => (/* binding */ replaceObjectGatewayUrlsWithSchemes),\n/* harmony export */   replaceObjectSchemesWithGatewayUrls: () => (/* binding */ replaceObjectSchemesWithGatewayUrls),\n/* harmony export */   replaceSchemeWithGatewayUrl: () => (/* binding */ replaceSchemeWithGatewayUrl)\n/* harmony export */ });\n/* harmony import */ var cid_tool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cid-tool */ \"(ssr)/./node_modules/.pnpm/cid-tool@3.0.0/node_modules/cid-tool/src/index.js\");\n/* harmony import */ var _thirdweb_dev_crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @thirdweb-dev/crypto */ \"(ssr)/./node_modules/.pnpm/@thirdweb-dev+crypto@0.2.0/node_modules/@thirdweb-dev/crypto/dist/thirdweb-dev-crypto.esm.js\");\n/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! form-data */ \"(ssr)/./node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/form_data.js\");\n/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(form_data__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-node/v4.js\");\n\n\n\n\nfunction getProcessEnv(key) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    if (typeof process !== \"undefined\") {\n        if (process.env[key]) {\n            return process.env[key];\n        }\n    }\n    return defaultValue;\n}\nconst TW_HOSTNAME_SUFFIX = \".ipfscdn.io\";\nconst TW_STAGINGHOSTNAME_SUFFIX = \".thirdwebstorage-staging.com\";\nconst TW_GATEWAY_URLS = [\n    `https://{clientId}${TW_HOSTNAME_SUFFIX}/ipfs/{cid}/{path}`\n];\n/**\n * @internal\n * @param url - the url to check\n * @returns\n */ function isTwGatewayUrl(url) {\n    const hostname = new URL(url).hostname;\n    const isProd = hostname.endsWith(TW_HOSTNAME_SUFFIX);\n    if (isProd) {\n        return true;\n    }\n    // fall back to also handle staging urls\n    return hostname.endsWith(TW_STAGINGHOSTNAME_SUFFIX);\n}\nconst PUBLIC_GATEWAY_URLS = [\n    \"https://{cid}.ipfs.cf-ipfs.com/{path}\",\n    \"https://{cid}.ipfs.dweb.link/{path}\",\n    \"https://ipfs.io/ipfs/{cid}/{path}\",\n    \"https://cloudflare-ipfs.com/ipfs/{cid}/{path}\",\n    \"https://{cid}.ipfs.w3s.link/{path}\",\n    \"https://w3s.link/ipfs/{cid}/{path}\",\n    \"https://nftstorage.link/ipfs/{cid}/{path}\",\n    \"https://gateway.pinata.cloud/ipfs/{cid}/{path}\"\n];\n/**\n * @internal\n */ const DEFAULT_GATEWAY_URLS = {\n    // Note: Gateway URLs should have trailing slashes (we clean this on user input)\n    \"ipfs://\": [\n        ...TW_GATEWAY_URLS,\n        ...PUBLIC_GATEWAY_URLS\n    ]\n};\n/**\n * @internal\n */ const TW_UPLOAD_SERVER_URL = getProcessEnv(\"CUSTOM_UPLOAD_SERVER_URL\", \"https://storage.thirdweb.com\");\n/**\n * @internal\n */ const PINATA_IPFS_URL = `https://api.pinata.cloud/pinning/pinFileToIPFS`;\n/**\n * @internal\n */ function parseGatewayUrls(gatewayUrls) {\n    if (Array.isArray(gatewayUrls)) {\n        return {\n            \"ipfs://\": gatewayUrls\n        };\n    }\n    return gatewayUrls || {};\n}\n/**\n * @internal\n */ function getGatewayUrlForCid(gatewayUrl, cid, clientId) {\n    const parts = cid.split(\"/\");\n    const hash = convertCidToV1(parts[0]);\n    const filePath = parts.slice(1).join(\"/\");\n    let url = gatewayUrl;\n    // If the URL contains {cid} or {path} tokens, replace them with the CID and path\n    // Both tokens must be present for the URL to be valid\n    if (gatewayUrl.includes(\"{cid}\") && gatewayUrl.includes(\"{path}\")) {\n        url = url.replace(\"{cid}\", hash).replace(\"{path}\", filePath);\n    } else if (gatewayUrl.includes(\"{cid}\")) {\n        url = url.replace(\"{cid}\", hash);\n    } else {\n        url += `${hash}/${filePath}`;\n    }\n    // if the URL contains the {clientId} token, replace it with the client ID\n    if (gatewayUrl.includes(\"{clientId}\")) {\n        if (!clientId) {\n            throw new Error(\"Cannot use {clientId} in gateway URL without providing a client ID\");\n        }\n        url = url.replace(\"{clientId}\", clientId);\n    }\n    return url;\n}\n/**\n * @internal\n */ function prepareGatewayUrls(gatewayUrls, clientId, secretKey) {\n    const allGatewayUrls = {\n        ...DEFAULT_GATEWAY_URLS,\n        ...gatewayUrls\n    };\n    for (const key of Object.keys(allGatewayUrls)){\n        const cleanedGatewayUrls = allGatewayUrls[key].map((url)=>{\n            // inject clientId when present\n            if (clientId && url.includes(\"{clientId}\")) {\n                return url.replace(\"{clientId}\", clientId);\n            } else if (secretKey && url.includes(\"{clientId}\")) {\n                // should only be used on Node.js in a backend/script context\n                if (false) {}\n                const hashedSecretKey = (0,_thirdweb_dev_crypto__WEBPACK_IMPORTED_MODULE_2__.sha256HexSync)(secretKey);\n                const derivedClientId = hashedSecretKey.slice(0, 32);\n                return url.replace(\"{clientId}\", derivedClientId);\n            } else if (url.includes(\"{clientId}\")) {\n                // if no client id passed, filter out the url\n                return undefined;\n            } else {\n                return url;\n            }\n        }).filter((url)=>url !== undefined);\n        allGatewayUrls[key] = cleanedGatewayUrls;\n    }\n    return allGatewayUrls;\n}\n/**\n * @internal\n */ function convertCidToV1(cid) {\n    let normalized;\n    try {\n        const hash = cid.split(\"/\")[0];\n        normalized = cid_tool__WEBPACK_IMPORTED_MODULE_0__.base32(hash);\n    } catch (e) {\n        throw new Error(`The CID ${cid} is not valid.`);\n    }\n    return normalized;\n}\n/**\n * @internal\n */ function isBrowser() {\n    return \"undefined\" !== \"undefined\";\n}\n/**\n * @internal\n */ function isFileInstance(data) {\n    return global.File && data instanceof File;\n}\n/**\n * @internal\n */ function isBufferInstance(data) {\n    return global.Buffer && data instanceof Buffer;\n}\n/**\n * @internal\n */ function isBufferOrStringWithName(data) {\n    return !!(data && data.name && data.data && typeof data.name === \"string\" && (typeof data.data === \"string\" || isBufferInstance(data.data)));\n}\nfunction isFileOrBuffer(data) {\n    return isFileInstance(data) || isBufferInstance(data) || isBufferOrStringWithName(data);\n}\n/**\n * @internal\n */ function isFileBufferOrStringEqual(input1, input2) {\n    if (isFileInstance(input1) && isFileInstance(input2)) {\n        // if both are File types, compare the name, size, and last modified date (best guess that these are the same files)\n        if (input1.name === input2.name && input1.lastModified === input2.lastModified && input1.size === input2.size) {\n            return true;\n        }\n    } else if (isBufferInstance(input1) && isBufferInstance(input2)) {\n        // buffer gives us an easy way to compare the contents!\n        return input1.equals(input2);\n    } else if (isBufferOrStringWithName(input1) && isBufferOrStringWithName(input2)) {\n        // first check the names\n        if (input1.name === input2.name) {\n            // if the data for both is a string, compare the strings\n            if (typeof input1.data === \"string\" && typeof input2.data === \"string\") {\n                return input1.data === input2.data;\n            } else if (isBufferInstance(input1.data) && isBufferInstance(input2.data)) {\n                // otherwise we know it's buffers, so compare the buffers\n                return input1.data.equals(input2.data);\n            }\n        }\n    }\n    // otherwise if we have not found a match, return false\n    return false;\n}\n/**\n * @internal\n */ function parseCidAndPath(gatewayUrl, uri) {\n    const regexString = gatewayUrl.replace(\"{cid}\", \"(?<hash>[^/]+)\").replace(\"{path}\", \"(?<path>[^?#]+)\");\n    const regex = new RegExp(regexString);\n    const match = uri.match(regex);\n    if (match) {\n        const hash = match.groups?.hash;\n        const path = match.groups?.path;\n        const queryString = uri.includes(\"?\") ? uri.substring(uri.indexOf(\"?\") + 1) : \"\";\n        return {\n            hash,\n            path,\n            query: queryString\n        };\n    }\n}\n/**\n * @internal\n */ function replaceGatewayUrlWithScheme(uri, gatewayUrls) {\n    for (const scheme of Object.keys(gatewayUrls)){\n        for (const gatewayUrl of gatewayUrls[scheme]){\n            // If the url is a tokenized url, we need to convert it to a canonical url\n            // Otherwise, we just need to check if the url is a prefix of the uri\n            if (gatewayUrl.includes(\"{cid}\")) {\n                // Given the url is a tokenized url, we need to lift the cid and the path from the uri\n                const parsed = parseCidAndPath(gatewayUrl, uri);\n                if (parsed?.hash && parsed?.path) {\n                    const queryString = parsed?.query ? `?${parsed?.query}` : \"\";\n                    return `${scheme}${parsed?.hash}/${parsed?.path}${queryString}`;\n                } else {\n                    // If we can't lift the cid and path from the uri, we can't replace the gateway url, return the orig string\n                    return uri;\n                }\n            } else if (uri.startsWith(gatewayUrl)) {\n                return uri.replace(gatewayUrl, scheme);\n            }\n        }\n    }\n    return uri;\n}\n/**\n * @internal\n */ function replaceSchemeWithGatewayUrl(uri, gatewayUrls) {\n    let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let clientId = arguments.length > 3 ? arguments[3] : undefined;\n    const scheme = Object.keys(gatewayUrls).find((s)=>uri.startsWith(s));\n    const schemeGatewayUrls = scheme ? gatewayUrls[scheme] : [];\n    if (!scheme && index > 0 || scheme && index >= schemeGatewayUrls.length) {\n        return undefined;\n    }\n    if (!scheme) {\n        return uri;\n    }\n    const path = uri.replace(scheme, \"\");\n    try {\n        const gatewayUrl = getGatewayUrlForCid(schemeGatewayUrls[index], path, clientId);\n        return gatewayUrl;\n    } catch (err) {\n        console.warn(`The IPFS uri: ${path} is not valid.`);\n        return undefined;\n    }\n}\n/**\n * @internal\n */ function replaceObjectGatewayUrlsWithSchemes(data, gatewayUrls) {\n    if (typeof data === \"string\") {\n        return replaceGatewayUrlWithScheme(data, gatewayUrls);\n    }\n    if (typeof data === \"object\") {\n        if (!data) {\n            return data;\n        }\n        if (isFileOrBuffer(data)) {\n            return data;\n        }\n        if (Array.isArray(data)) {\n            return data.map((entry)=>replaceObjectGatewayUrlsWithSchemes(entry, gatewayUrls));\n        }\n        return Object.fromEntries(Object.entries(data).map((_ref)=>{\n            let [key, value] = _ref;\n            return [\n                key,\n                replaceObjectGatewayUrlsWithSchemes(value, gatewayUrls)\n            ];\n        }));\n    }\n    return data;\n}\n/**\n * @internal\n */ function replaceObjectSchemesWithGatewayUrls(data, gatewayUrls, clientId) {\n    if (typeof data === \"string\") {\n        return replaceSchemeWithGatewayUrl(data, gatewayUrls, 0, clientId);\n    }\n    if (typeof data === \"object\") {\n        if (!data) {\n            return data;\n        }\n        if (isFileOrBuffer(data)) {\n            return data;\n        }\n        if (Array.isArray(data)) {\n            return data.map((entry)=>replaceObjectSchemesWithGatewayUrls(entry, gatewayUrls, clientId));\n        }\n        return Object.fromEntries(Object.entries(data).map((_ref2)=>{\n            let [key, value] = _ref2;\n            return [\n                key,\n                replaceObjectSchemesWithGatewayUrls(value, gatewayUrls, clientId)\n            ];\n        }));\n    }\n    return data;\n}\n/**\n * @internal\n */ function extractObjectFiles(data) {\n    let files = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    // If item is a FileOrBuffer add it to our list of files\n    if (isFileOrBuffer(data)) {\n        files.push(data);\n        return files;\n    }\n    if (typeof data === \"object\") {\n        if (!data) {\n            return files;\n        }\n        if (Array.isArray(data)) {\n            data.forEach((entry)=>extractObjectFiles(entry, files));\n        } else {\n            Object.keys(data).map((key)=>extractObjectFiles(data[key], files));\n        }\n    }\n    return files;\n}\n/**\n * @internal\n */ function replaceObjectFilesWithUris(data, uris) {\n    if (isFileOrBuffer(data)) {\n        if (uris.length) {\n            data = uris.shift();\n            return data;\n        } else {\n            console.warn(\"Not enough URIs to replace all files in object.\");\n        }\n    }\n    if (typeof data === \"object\") {\n        if (!data) {\n            return data;\n        }\n        if (Array.isArray(data)) {\n            return data.map((entry)=>replaceObjectFilesWithUris(entry, uris));\n        } else {\n            return Object.fromEntries(Object.entries(data).map((_ref3)=>{\n                let [key, value] = _ref3;\n                return [\n                    key,\n                    replaceObjectFilesWithUris(value, uris)\n                ];\n            }));\n        }\n    }\n    return data;\n}\nvar pkg = {\n    name: \"@thirdweb-dev/storage\",\n    version: \"2.0.8\",\n    main: \"dist/thirdweb-dev-storage.cjs.js\",\n    module: \"dist/thirdweb-dev-storage.esm.js\",\n    exports: {\n        \".\": {\n            module: \"./dist/thirdweb-dev-storage.esm.js\",\n            \"default\": \"./dist/thirdweb-dev-storage.cjs.js\"\n        },\n        \"./package.json\": \"./package.json\"\n    },\n    repository: \"https://github.com/thirdweb-dev/js/tree/main/packages/storage\",\n    author: \"thirdweb eng <eng@thirdweb.com>\",\n    license: \"Apache-2.0\",\n    sideEffects: false,\n    scripts: {\n        format: \"prettier --write 'src/**/*'\",\n        lint: \"eslint src/ && bunx publint --strict --level warning\",\n        fix: \"eslint src/ --fix\",\n        \"generate-docs\": \"api-extractor run --local && api-documenter markdown -i ./temp -o ./docs\",\n        clean: \"rm -rf dist/\",\n        build: \"tsc && preconstruct build\",\n        \"test:all\": \"NODE_ENV=test SWC_NODE_PROJECT=./tsconfig.test.json mocha --timeout 30000 --parallel './test/**/*.test.ts'\",\n        test: \"pnpm test:all\",\n        \"test:single\": \"NODE_ENV=test SWC_NODE_PROJECT=./tsconfig.test.json mocha --timeout 30000\",\n        push: \"yalc push\",\n        typedoc: \"node scripts/typedoc.mjs\"\n    },\n    files: [\n        \"dist/\"\n    ],\n    preconstruct: {\n        exports: true\n    },\n    devDependencies: {\n        \"@babel/preset-env\": \"^7.22.9\",\n        \"@babel/preset-typescript\": \"^7.22.5\",\n        \"@microsoft/api-documenter\": \"^7.22.30\",\n        \"@microsoft/api-extractor\": \"^7.36.3\",\n        \"@microsoft/tsdoc\": \"^0.14.1\",\n        \"@preconstruct/cli\": \"2.7.0\",\n        \"@swc-node/register\": \"^1.6.6\",\n        \"@thirdweb-dev/tsconfig\": \"workspace:*\",\n        \"@types/chai\": \"^4.3.5\",\n        \"@types/mocha\": \"^10.0.0\",\n        \"@types/uuid\": \"^9.0.5\",\n        \"@typescript-eslint/eslint-plugin\": \"^6.2.0\",\n        \"@typescript-eslint/parser\": \"^6.2.0\",\n        chai: \"^4.3.6\",\n        eslint: \"^8.45.0\",\n        \"eslint-config-thirdweb\": \"workspace:*\",\n        \"eslint-plugin-tsdoc\": \"^0.2.16\",\n        esm: \"^3.2.25\",\n        mocha: \"^10.2.0\",\n        rimraf: \"^3.0.2\",\n        typescript: \"^5.1.6\",\n        \"typedoc-gen\": \"workspace:*\"\n    },\n    dependencies: {\n        \"cid-tool\": \"^3.0.0\",\n        \"form-data\": \"^4.0.0\",\n        uuid: \"^9.0.1\",\n        \"@thirdweb-dev/crypto\": \"workspace:*\"\n    },\n    engines: {\n        node: \">=18\"\n    }\n};\n/**\n * Default downloader used - handles downloading from all schemes specified in the gateway URLs configuration.\n *\n * @example\n * ```jsx\n * // Can instantiate the downloader with the default gateway URLs\n * const downloader = new StorageDownloader();\n *\n * // client id if used in client-side applications\n * const clientId = \"your-client-id\";\n * const storage = new ThirdwebStorage({ clientId, downloader });\n *\n * // secret key if used in server-side applications\n * const secretKey = \"your-secret-key\";\n * const storage = new ThirdwebStorage({ secretKey, downloader });\n * ```\n *\n * @public\n */ class StorageDownloader {\n    constructor(options){\n        this.DEFAULT_TIMEOUT_IN_SECONDS = 60;\n        this.DEFAULT_MAX_RETRIES = 3;\n        this.secretKey = options.secretKey;\n        this.clientId = options.clientId;\n        this.defaultTimeout = options.timeoutInSeconds || this.DEFAULT_TIMEOUT_IN_SECONDS;\n    }\n    async download(uri, gatewayUrls, options) {\n        let attempts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        const maxRetries = options?.maxRetries || this.DEFAULT_MAX_RETRIES;\n        if (attempts > maxRetries) {\n            console.error(\"[FAILED_TO_DOWNLOAD_ERROR] Failed to download from URI - too many attempts failed.\");\n            // return a 404 response to avoid retrying\n            return new Response(JSON.stringify({\n                error: \"Not Found\"\n            }), {\n                status: 404,\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n        }\n        // Replace recognized scheme with the highest priority gateway URL that hasn't already been attempted\n        let resolvedUri = replaceSchemeWithGatewayUrl(uri, gatewayUrls, attempts, this.clientId);\n        // If every gateway URL we know about for the designated scheme has been tried (via recursion) and failed, throw an error\n        if (!resolvedUri) {\n            console.error(\"[FAILED_TO_DOWNLOAD_ERROR] Unable to download from URI - all gateway URLs failed to respond.\");\n            return new Response(JSON.stringify({\n                error: \"Not Found\"\n            }), {\n                status: 404,\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n        } else if (attempts > 0) {\n            console.warn(`Retrying download with backup gateway URL: ${resolvedUri}`);\n        }\n        let headers = {};\n        if (isTwGatewayUrl(resolvedUri)) {\n            const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n            if (this.secretKey) {\n                headers = {\n                    \"x-secret-key\": this.secretKey\n                };\n            } else if (this.clientId) {\n                if (!resolvedUri.includes(\"bundleId\")) {\n                    resolvedUri = resolvedUri + (bundleId ? `?bundleId=${bundleId}` : \"\");\n                }\n                headers[\"x-client-Id\"] = this.clientId;\n            }\n            // if we have a authorization token on global context then add that to the headers\n            if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n                headers = {\n                    ...headers,\n                    authorization: `Bearer ${globalThis.TW_AUTH_TOKEN}`\n                };\n            }\n            if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n                headers = {\n                    ...headers,\n                    authorization: `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`\n                };\n                headers[\"x-authorize-wallet\"] = \"true\";\n            }\n            headers[\"x-sdk-version\"] = pkg.version;\n            headers[\"x-sdk-name\"] = pkg.name;\n            headers[\"x-sdk-platform\"] = bundleId ? \"react-native\" : isBrowser() ? window.bridge !== undefined ? \"webGL\" : \"browser\" : \"node\";\n        }\n        if (isTooManyRequests(resolvedUri)) {\n            // skip the request if we're getting too many request error from the gateway\n            return this.download(uri, gatewayUrls, options, attempts + 1);\n        }\n        const controller = new AbortController();\n        const timeoutInSeconds = options?.timeoutInSeconds || this.defaultTimeout;\n        const timeout = setTimeout(()=>controller.abort(), timeoutInSeconds * 1000);\n        const resOrErr = await fetch(resolvedUri, {\n            headers,\n            signal: controller.signal\n        }).catch((err)=>err);\n        // if we get here clear the timeout\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n        if (!(\"status\" in resOrErr)) {\n            // early exit if we don't have a status code\n            throw new Error(`Request timed out after ${timeoutInSeconds} seconds. ${isTwGatewayUrl(resolvedUri) ? \"You can update the timeoutInSeconds option to increase the timeout.\" : \"You're using a public IPFS gateway, pass in a clientId or secretKey for a reliable IPFS gateway.\"}`);\n        }\n        // if the request is good we can skip everything else\n        if (resOrErr.ok) {\n            return resOrErr;\n        }\n        if (resOrErr.status === 429) {\n            // track that we got a too many requests error\n            tooManyRequestsBackOff(resolvedUri, resOrErr);\n            // Since the current gateway failed, recursively try the next one we know about\n            return this.download(uri, gatewayUrls, options, attempts + 1);\n        }\n        if (resOrErr.status === 410) {\n            // Don't retry if the content is blocklisted\n            console.error(`Request to ${resolvedUri} failed because this content seems to be blocklisted. Search VirusTotal for this URL to confirm: ${resolvedUri} `);\n            return resOrErr;\n        }\n        console.warn(`Request to ${resolvedUri} failed with status ${resOrErr.status} - ${resOrErr.statusText}`);\n        // if the status is 404 and we're using a thirdweb gateway url, return the response as is\n        if (resOrErr.status === 404 && isTwGatewayUrl(resolvedUri)) {\n            return resOrErr;\n        }\n        // these are the only errors that we want to retry, everything else we should just return the error as is\n        // 408 - Request Timeout\n        // 429 - Too Many Requests\n        // 5xx - Server Errors\n        if (resOrErr.status !== 408 && resOrErr.status !== 429 && resOrErr.status < 500) {\n            return resOrErr;\n        }\n        // Since the current gateway failed, recursively try the next one we know about\n        return this.download(uri, gatewayUrls, options, attempts + 1);\n    }\n}\nconst TOO_MANY_REQUESTS_TRACKER = new Map();\nfunction isTooManyRequests(gatewayUrl) {\n    return TOO_MANY_REQUESTS_TRACKER.has(gatewayUrl);\n}\nconst TIMEOUT_MAP = new Map();\nfunction tooManyRequestsBackOff(gatewayUrl, response) {\n    // if we already have a timeout for this gateway url, clear it\n    if (TIMEOUT_MAP.has(gatewayUrl)) {\n        clearTimeout(TIMEOUT_MAP.get(gatewayUrl));\n    }\n    const retryAfter = response.headers.get(\"Retry-After\");\n    let backOff = 5000;\n    if (retryAfter) {\n        const retryAfterSeconds = parseInt(retryAfter);\n        if (!isNaN(retryAfterSeconds)) {\n            backOff = retryAfterSeconds * 1000;\n        }\n    }\n    // track that we got a too many requests error\n    TOO_MANY_REQUESTS_TRACKER.set(gatewayUrl, true);\n    TIMEOUT_MAP.set(gatewayUrl, setTimeout(()=>TOO_MANY_REQUESTS_TRACKER.delete(gatewayUrl), backOff));\n}\n/**\n * Default uploader used - handles uploading arbitrary data to IPFS\n *\n * @example\n * ```jsx\n * // Can instantiate the uploader with default configuration and your client ID when used in client-side applications\n * const uploader = new StorageUploader();\n * const clientId = \"your-client-id\";\n * const storage = new ThirdwebStorage({ clientId, uploader });\n *\n * // Can instantiate the uploader with default configuration and your secret key when used in server-side applications\n * const uploader = new StorageUploader();\n * const secretKey = \"your-secret-key\";\n * const storage = new ThirdwebStorage({ secretKey, uploader });\n *\n * // Or optionally, can pass configuration\n * const options = {\n *   // Upload objects with resolvable URLs\n *   uploadWithGatewayUrl: true,\n * }\n * const uploader = new StorageUploader(options);\n * const clientId = \"your-client-id\";\n * const storage = new ThirdwebStorage({ clientId, uploader });\n * ```\n *\n * @public\n */ class IpfsUploader {\n    constructor(options){\n        this.uploadWithGatewayUrl = options?.uploadWithGatewayUrl || false;\n        this.uploadServerUrl = options?.uploadServerUrl || TW_UPLOAD_SERVER_URL;\n        this.clientId = options?.clientId;\n        this.secretKey = options?.secretKey;\n    }\n    async uploadBatch(data, options) {\n        if (options?.uploadWithoutDirectory && data.length > 1) {\n            throw new Error(\"[UPLOAD_WITHOUT_DIRECTORY_ERROR] Cannot upload more than one file or object without directory!\");\n        }\n        const formData = new (form_data__WEBPACK_IMPORTED_MODULE_1___default())();\n        const { form, fileNames } = this.buildFormData(formData, data, options);\n        if (isBrowser()) {\n            return this.uploadBatchBrowser(form, fileNames, options);\n        } else {\n            return this.uploadBatchNode(form, fileNames, options);\n        }\n    }\n    buildFormData(form, files, options) {\n        const fileNameToFileMap = new Map();\n        const fileNames = [];\n        for(let i = 0; i < files.length; i++){\n            const file = files[i];\n            let fileName = \"\";\n            let fileData = file;\n            if (isFileInstance(file)) {\n                if (options?.rewriteFileNames) {\n                    let extensions = \"\";\n                    if (file.name) {\n                        const extensionStartIndex = file.name.lastIndexOf(\".\");\n                        if (extensionStartIndex > -1) {\n                            extensions = file.name.substring(extensionStartIndex);\n                        }\n                    }\n                    fileName = `${i + options.rewriteFileNames.fileStartNumber}${extensions}`;\n                } else {\n                    fileName = `${file.name}`;\n                }\n            } else if (isBufferOrStringWithName(file)) {\n                fileData = file.data;\n                if (options?.rewriteFileNames) {\n                    fileName = `${i + options.rewriteFileNames.fileStartNumber}`;\n                } else {\n                    fileName = `${file.name}`;\n                }\n            } else {\n                if (options?.rewriteFileNames) {\n                    fileName = `${i + options.rewriteFileNames.fileStartNumber}`;\n                } else {\n                    fileName = `${i}`;\n                }\n            }\n            // If we don't want to wrap with directory, adjust the filepath\n            const filepath = options?.uploadWithoutDirectory ? `files` : `files/${fileName}`;\n            if (fileNameToFileMap.has(fileName)) {\n                // if the file in the map is the same as the file we are already looking at then just skip and continue\n                if (isFileBufferOrStringEqual(fileNameToFileMap.get(fileName), file)) {\n                    // we add it to the filenames array so that we can return the correct number of urls,\n                    fileNames.push(fileName);\n                    continue;\n                }\n                // otherwise if file names are the same but they are not the same file then we should throw an error (trying to upload to differnt files but with the same names)\n                throw new Error(`[DUPLICATE_FILE_NAME_ERROR] File name ${fileName} was passed for more than one different file.`);\n            }\n            // add it to the map so that we can check for duplicates\n            fileNameToFileMap.set(fileName, file);\n            // add it to the filenames array so that we can return the correct number of urls\n            fileNames.push(fileName);\n            if (!isBrowser()) {\n                form.append(\"file\", fileData, {\n                    filepath\n                });\n            } else {\n                // browser does blob things, filepath is parsed differently on browser vs node.\n                // pls pinata?\n                form.append(\"file\", new Blob([\n                    fileData\n                ]), filepath);\n            }\n        }\n        const metadata = {\n            name: `Storage SDK`,\n            keyvalues: {\n                ...options?.metadata\n            }\n        };\n        form.append(\"pinataMetadata\", JSON.stringify(metadata));\n        if (options?.uploadWithoutDirectory) {\n            form.append(\"pinataOptions\", JSON.stringify({\n                wrapWithDirectory: false\n            }));\n        }\n        return {\n            form,\n            // encode the file names on the way out (which is what the upload backend expects)\n            fileNames: fileNames.map((fName)=>encodeURIComponent(fName))\n        };\n    }\n    async uploadBatchBrowser(form, fileNames, options) {\n        return new Promise((resolve, reject)=>{\n            const xhr = new XMLHttpRequest();\n            let timer = setTimeout(()=>{\n                xhr.abort();\n                reject(new Error(\"Request to upload timed out! No upload progress received in 30s\"));\n            }, 30000);\n            xhr.upload.addEventListener(\"loadstart\", ()=>{\n                console.log(`[${Date.now()}] [IPFS] Started`);\n            });\n            xhr.upload.addEventListener(\"progress\", (event)=>{\n                console.log(`[IPFS] Progress Event ${event.loaded}/${event.total}`);\n                clearTimeout(timer);\n                if (event.loaded < event.total) {\n                    timer = setTimeout(()=>{\n                        xhr.abort();\n                        reject(new Error(\"Request to upload timed out! No upload progress received in 30s\"));\n                    }, 30000);\n                } else {\n                    console.log(`[${Date.now()}] [IPFS] Uploaded files. Waiting for response.`);\n                }\n                if (event.lengthComputable && options?.onProgress) {\n                    options?.onProgress({\n                        progress: event.loaded,\n                        total: event.total\n                    });\n                }\n            });\n            xhr.addEventListener(\"load\", ()=>{\n                console.log(`[${Date.now()}] [IPFS] Load`);\n                clearTimeout(timer);\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    let body;\n                    try {\n                        body = JSON.parse(xhr.responseText);\n                    } catch (err) {\n                        return reject(new Error(\"Failed to parse JSON from upload response\"));\n                    }\n                    const cid = body.IpfsHash;\n                    if (!cid) {\n                        throw new Error(\"Failed to get IPFS hash from upload response\");\n                    }\n                    if (options?.uploadWithoutDirectory) {\n                        return resolve([\n                            `ipfs://${cid}`\n                        ]);\n                    } else {\n                        return resolve(fileNames.map((n)=>`ipfs://${cid}/${n}`));\n                    }\n                }\n                return reject(new Error(`Upload failed with status ${xhr.status} - ${xhr.responseText}`));\n            });\n            xhr.addEventListener(\"error\", ()=>{\n                console.log(\"[IPFS] Load\");\n                clearTimeout(timer);\n                if (xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0) {\n                    return reject(new Error(\"Upload failed due to a network error.\"));\n                }\n                return reject(new Error(\"Unknown upload error occured\"));\n            });\n            xhr.open(\"POST\", `${this.uploadServerUrl}/ipfs/upload`);\n            if (this.secretKey) {\n                xhr.setRequestHeader(\"x-secret-key\", this.secretKey);\n            } else if (this.clientId) {\n                xhr.setRequestHeader(\"x-client-id\", this.clientId);\n            }\n            const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n            if (bundleId) {\n                xhr.setRequestHeader(\"x-bundle-id\", bundleId);\n            }\n            xhr.setRequestHeader(\"x-sdk-version\", pkg.version);\n            xhr.setRequestHeader(\"x-sdk-name\", pkg.name);\n            xhr.setRequestHeader(\"x-sdk-platform\", bundleId ? \"react-native\" : isBrowser() ? window.bridge !== undefined ? \"webGL\" : \"browser\" : \"node\");\n            // if we have a authorization token on global context then add that to the headers, this is for the dashboard.\n            if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n                xhr.setRequestHeader(\"authorization\", `Bearer ${globalThis.TW_AUTH_TOKEN}`);\n            }\n            // CLI auth token\n            if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n                xhr.setRequestHeader(\"authorization\", `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`);\n                xhr.setRequestHeader(\"x-authorize-wallet\", `true`);\n            }\n            xhr.send(form);\n        });\n    }\n    async uploadBatchNode(form, fileNames, options) {\n        if (options?.onProgress) {\n            console.warn(\"The onProgress option is only supported in the browser\");\n        }\n        const headers = {};\n        if (this.secretKey) {\n            headers[\"x-secret-key\"] = this.secretKey;\n        } else if (this.clientId) {\n            headers[\"x-client-id\"] = this.clientId;\n        }\n        // if we have a bundle id on global context then add that to the headers\n        if (typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis) {\n            headers[\"x-bundle-id\"] = globalThis.APP_BUNDLE_ID;\n        }\n        // if we have a authorization token on global context then add that to the headers, this is for the dashboard.\n        if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n            headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n        }\n        // CLI auth token\n        if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n            headers[\"authorization\"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;\n            headers[\"x-authorize-wallet\"] = \"true\";\n        }\n        const res = await fetch(`${this.uploadServerUrl}/ipfs/upload`, {\n            method: \"POST\",\n            headers: {\n                ...headers,\n                ...form.getHeaders()\n            },\n            body: form.getBuffer()\n        });\n        if (!res.ok) {\n            if (res.status === 401) {\n                throw new Error(\"Unauthorized - You don't have permission to use this service.\");\n            }\n            throw new Error(`Failed to upload files to IPFS - ${res.status} - ${res.statusText} - ${await res.text()}`);\n        }\n        const body = await res.json();\n        const cid = body.IpfsHash;\n        if (!cid) {\n            throw new Error(\"Failed to upload files to IPFS - Bad CID\");\n        }\n        if (options?.uploadWithoutDirectory) {\n            return [\n                `ipfs://${cid}`\n            ];\n        } else {\n            return fileNames.map((name)=>`ipfs://${cid}/${name}`);\n        }\n    }\n}\n/**\n * Upload and download files from decentralized storage systems.\n *\n * @example\n * ```jsx\n * // Create a default storage class with a client ID when used in client-side applications\n * const storage = new ThirdwebStorage({ clientId: \"your-client-id\" });\n *\n * // Create a default storage class with a secret key when used in server-side applications\n * const storage = new ThirdwebStorage({ secretKey: \"your-secret-key\" });\n *\n * You can get a clientId and secretKey from https://thirdweb.com/create-api-key\n *\n * // Upload any file or JSON object\n * const uri = await storage.upload(data);\n * const result = await storage.download(uri);\n *\n * // Or configure a custom uploader, downloader, and gateway URLs\n * const gatewayUrls = {\n *   // We define a mapping of schemes to gateway URLs\n *   \"ipfs://\": [\n *     \"https://ipfs.thirdwebcdn.com/ipfs/\",\n *     \"https://cloudflare-ipfs.com/ipfs/\",\n *     \"https://ipfs.io/ipfs/\",\n *   ],\n * };\n * const downloader = new StorageDownloader();\n * const uploader = new IpfsUploader();\n * const clientId = \"your-client-id\";\n * const storage = new ThirdwebStorage({ clientId, uploader, downloader, gatewayUrls });\n * ```\n *\n * @public\n */ class ThirdwebStorage {\n    constructor(options){\n        this.uploader = options?.uploader || new IpfsUploader({\n            clientId: options?.clientId,\n            secretKey: options?.secretKey,\n            uploadServerUrl: options?.uploadServerUrl\n        });\n        this.downloader = options?.downloader || new StorageDownloader({\n            secretKey: options?.secretKey,\n            clientId: options?.clientId\n        });\n        this.gatewayUrls = prepareGatewayUrls(parseGatewayUrls(options?.gatewayUrls), options?.clientId, options?.secretKey);\n        this.clientId = options?.clientId;\n    }\n    /**\n   * Resolve any scheme on a URL to get a retrievable URL for the data\n   *\n   * @param url - The URL to resolve the scheme of\n   * @returns The URL with its scheme resolved\n   *\n   * @example\n   * ```jsx\n   * const uri = \"ipfs://example\";\n   * const url = storage.resolveScheme(uri);\n   * console.log(url);\n   * ```\n   */ resolveScheme(url) {\n        return replaceSchemeWithGatewayUrl(url, this.gatewayUrls, 0, this.clientId);\n    }\n    /**\n   * Downloads arbitrary data from any URL scheme.\n   *\n   * @param url - The URL of the data to download\n   * @returns The response object fetched from the resolved URL\n   *\n   * @example\n   * ```jsx\n   * const uri = \"ipfs://example\";\n   * const data = await storage.download(uri);\n   * ```\n   */ async download(url, options) {\n        return this.downloader.download(url, this.gatewayUrls, options);\n    }\n    /**\n   * Downloads JSON data from any URL scheme.\n   * Resolves any URLs with schemes to retrievable gateway URLs.\n   *\n   * @param url - The URL of the JSON data to download\n   * @returns The JSON data fetched from the resolved URL\n   *\n   * @example\n   * ```jsx\n   * const uri = \"ipfs://example\";\n   * const json = await storage.downloadJSON(uri);\n   * ```\n   */ async downloadJSON(url, options) {\n        const res = await this.download(url, options);\n        // If we get a JSON object, recursively replace any schemes with gatewayUrls\n        const json = await res.json();\n        return replaceObjectSchemesWithGatewayUrls(json, this.gatewayUrls, this.clientId);\n    }\n    /**\n   * Upload arbitrary file or JSON data using the configured decentralized storage system.\n   * Automatically uploads any file data within JSON objects and replaces them with hashes.\n   *\n   * @param data - Arbitrary file or JSON data to upload\n   * @param options - Options to pass through to the storage uploader class\n   * @returns  The URI of the uploaded data\n   *\n   * @example\n   * ```jsx\n   * // Upload file data\n   * const file = readFileSync(\"../file.jpg\");\n   * const fileUri = await storage.upload(file);\n   *\n   * // Or upload a JSON object\n   * const json = { name: \"JSON\", image: file };\n   * const jsonUri = await storage.upload(json);\n   * ```\n   */ async upload(data, options) {\n        const [uri] = await this.uploadBatch([\n            data\n        ], options);\n        return uri;\n    }\n    /**\n   * Batch upload arbitrary file or JSON data using the configured decentralized storage system.\n   * Automatically uploads any file data within JSON objects and replaces them with hashes.\n   *\n   * @param data - Array of arbitrary file or JSON data to upload\n   * @param options - Options to pass through to the storage uploader class\n   * @returns  The URIs of the uploaded data\n   *\n   * @example\n   * ```jsx\n   * // Upload an array of file data\n   * const files = [\n   *  readFileSync(\"../file1.jpg\"),\n   *  readFileSync(\"../file2.jpg\"),\n   * ];\n   * const fileUris = await storage.uploadBatch(files);\n   *\n   * // Upload an array of JSON objects\n   * const objects = [\n   *  { name: \"JSON 1\", image: files[0] },\n   *  { name: \"JSON 2\", image: files[1] },\n   * ];\n   * const jsonUris = await storage.uploadBatch(objects);\n   * ```\n   */ async uploadBatch(data, options) {\n        data = data.filter((item)=>item !== undefined);\n        if (!data.length) {\n            return [];\n        }\n        const isFileArray = data.map((item)=>isFileOrBuffer(item) || typeof item === \"string\").every((item)=>!!item);\n        let uris = [];\n        // If data is an array of files, pass it through to upload directly\n        if (isFileArray) {\n            uris = await this.uploader.uploadBatch(data, options);\n        } else {\n            // Otherwise it is an array of JSON objects, so we have to prepare it first\n            const metadata = (await this.uploadAndReplaceFilesWithHashes(data, options)).map((item)=>{\n                if (typeof item === \"string\") {\n                    return item;\n                }\n                return JSON.stringify(item);\n            });\n            uris = await this.uploader.uploadBatch(metadata, options);\n        }\n        if (options?.uploadWithGatewayUrl || this.uploader.uploadWithGatewayUrl) {\n            return uris.map((uri)=>this.resolveScheme(uri));\n        } else {\n            return uris;\n        }\n    }\n    getGatewayUrls() {\n        return this.gatewayUrls;\n    }\n    async uploadAndReplaceFilesWithHashes(data, options) {\n        let cleaned = data;\n        // Replace any gateway URLs with their hashes\n        cleaned = replaceObjectGatewayUrlsWithSchemes(cleaned, this.gatewayUrls);\n        // Recurse through data and extract files to upload\n        const files = extractObjectFiles(cleaned);\n        if (files.length) {\n            // Upload all files that came from the object\n            const uris = await this.uploader.uploadBatch(files, options);\n            // Recurse through data and replace files with hashes\n            cleaned = replaceObjectFilesWithUris(cleaned, uris);\n        }\n        if (options?.uploadWithGatewayUrl || this.uploader.uploadWithGatewayUrl) {\n            // If flag is set, replace all schemes with their preferred gateway URL\n            // Ex: used for Solana, where services don't resolve schemes for you, so URLs must be usable by default\n            cleaned = replaceObjectSchemesWithGatewayUrls(cleaned, this.gatewayUrls, this.clientId);\n        }\n        return cleaned;\n    }\n}\n/**\n * @internal\n */ class MockDownloader {\n    constructor(storage){\n        this.gatewayUrls = DEFAULT_GATEWAY_URLS;\n        this.storage = storage;\n    }\n    async download(url) {\n        const [cid, name] = url.includes(\"mock://\") ? url.replace(\"mock://\", \"\").split(\"/\") : url.replace(\"ipfs://\", \"\").split(\"/\");\n        const data = name ? this.storage[cid][name] : this.storage[cid];\n        return {\n            async json () {\n                return Promise.resolve(JSON.parse(data));\n            },\n            async text () {\n                return Promise.resolve(data);\n            }\n        };\n    }\n}\n/**\n * @internal\n */ class MockUploader {\n    constructor(storage){\n        this.storage = storage;\n    }\n    async uploadBatch(data, options) {\n        const cid = (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n        const uris = [];\n        this.storage[cid] = {};\n        let index = options?.rewriteFileNames?.fileStartNumber || 0;\n        for (const file of data){\n            let contents;\n            if (isFileInstance(file)) {\n                contents = await file.text();\n            } else if (isBufferInstance(file)) {\n                contents = file.toString();\n            } else if (typeof file === \"string\") {\n                contents = file;\n            } else {\n                contents = isBufferInstance(file.data) ? file.data.toString() : file.data;\n                const name = file.name ? file.name : `file_${index}`;\n                this.storage[cid][name] = contents;\n                uris.push(`mock://${cid}/${name}`);\n                continue;\n            }\n            this.storage[cid][index.toString()] = contents;\n            uris.push(`mock://${cid}/${index}`);\n            index += 1;\n        }\n        return uris;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRoaXJkd2ViLWRlditzdG9yYWdlQDIuMC44L25vZGVfbW9kdWxlcy9AdGhpcmR3ZWItZGV2L3N0b3JhZ2UvZGlzdC90aGlyZHdlYi1kZXYtc3RvcmFnZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ3NCO0FBQ3BCO0FBQ1A7QUFFMUIsU0FBU0ksY0FBY0MsR0FBRztJQUN4QixJQUFJQyxlQUFlQyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUN2RixJQUFJLE9BQU9HLFlBQVksYUFBYTtRQUNsQyxJQUFJQSxRQUFRQyxHQUFHLENBQUNOLElBQUksRUFBRTtZQUNwQixPQUFPSyxRQUFRQyxHQUFHLENBQUNOLElBQUk7UUFDekI7SUFDRjtJQUNBLE9BQU9DO0FBQ1Q7QUFFQSxNQUFNTSxxQkFBcUI7QUFDM0IsTUFBTUMsNEJBQTRCO0FBQ2xDLE1BQU1DLGtCQUFrQjtJQUFDLENBQUMsa0JBQWtCLEVBQUVGLG1CQUFtQixrQkFBa0IsQ0FBQztDQUFDO0FBRXJGOzs7O0NBSUMsR0FDRCxTQUFTRyxlQUFlQyxHQUFHO0lBQ3pCLE1BQU1DLFdBQVcsSUFBSUMsSUFBSUYsS0FBS0MsUUFBUTtJQUN0QyxNQUFNRSxTQUFTRixTQUFTRyxRQUFRLENBQUNSO0lBQ2pDLElBQUlPLFFBQVE7UUFDVixPQUFPO0lBQ1Q7SUFDQSx3Q0FBd0M7SUFDeEMsT0FBT0YsU0FBU0csUUFBUSxDQUFDUDtBQUMzQjtBQUNBLE1BQU1RLHNCQUFzQjtJQUFDO0lBQXlDO0lBQXVDO0lBQXFDO0lBQWlEO0lBQXNDO0lBQXNDO0lBQTZDO0NBQWlEO0FBRTdXOztDQUVDLEdBQ0QsTUFBTUMsdUJBQXVCO0lBQzNCLGdGQUFnRjtJQUNoRixXQUFXO1dBQUlSO1dBQW9CTztLQUFvQjtBQUN6RDtBQUVBOztD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QUksQ0FBQyxDQUFDLE9BQU8sRUFBRTNFLElBQUksQ0FBQyxFQUFFMEQsTUFBTSxDQUFDO1lBQ2xDQSxTQUFTO1FBQ1g7UUFDQSxPQUFPb0I7SUFDVDtBQUNGO0FBRXdoQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGhpcmR3ZWItZGV2K3N0b3JhZ2VAMi4wLjgvbm9kZV9tb2R1bGVzL0B0aGlyZHdlYi1kZXYvc3RvcmFnZS9kaXN0L3RoaXJkd2ViLWRldi1zdG9yYWdlLmVzbS5qcz82OTM4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDSURUb29sIGZyb20gJ2NpZC10b29sJztcbmltcG9ydCB7IHNoYTI1NkhleFN5bmMgfSBmcm9tICdAdGhpcmR3ZWItZGV2L2NyeXB0byc7XG5pbXBvcnQgRm9ybURhdGEgZnJvbSAnZm9ybS1kYXRhJztcbmltcG9ydCB7IHY0IH0gZnJvbSAndXVpZCc7XG5cbmZ1bmN0aW9uIGdldFByb2Nlc3NFbnYoa2V5KSB7XG4gIGxldCBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGlmIChwcm9jZXNzLmVudltrZXldKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzcy5lbnZba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn1cblxuY29uc3QgVFdfSE9TVE5BTUVfU1VGRklYID0gXCIuaXBmc2Nkbi5pb1wiO1xuY29uc3QgVFdfU1RBR0lOR0hPU1ROQU1FX1NVRkZJWCA9IFwiLnRoaXJkd2Vic3RvcmFnZS1zdGFnaW5nLmNvbVwiO1xuY29uc3QgVFdfR0FURVdBWV9VUkxTID0gW2BodHRwczovL3tjbGllbnRJZH0ke1RXX0hPU1ROQU1FX1NVRkZJWH0vaXBmcy97Y2lkfS97cGF0aH1gXTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB1cmwgLSB0aGUgdXJsIHRvIGNoZWNrXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpc1R3R2F0ZXdheVVybCh1cmwpIHtcbiAgY29uc3QgaG9zdG5hbWUgPSBuZXcgVVJMKHVybCkuaG9zdG5hbWU7XG4gIGNvbnN0IGlzUHJvZCA9IGhvc3RuYW1lLmVuZHNXaXRoKFRXX0hPU1ROQU1FX1NVRkZJWCk7XG4gIGlmIChpc1Byb2QpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBmYWxsIGJhY2sgdG8gYWxzbyBoYW5kbGUgc3RhZ2luZyB1cmxzXG4gIHJldHVybiBob3N0bmFtZS5lbmRzV2l0aChUV19TVEFHSU5HSE9TVE5BTUVfU1VGRklYKTtcbn1cbmNvbnN0IFBVQkxJQ19HQVRFV0FZX1VSTFMgPSBbXCJodHRwczovL3tjaWR9LmlwZnMuY2YtaXBmcy5jb20ve3BhdGh9XCIsIFwiaHR0cHM6Ly97Y2lkfS5pcGZzLmR3ZWIubGluay97cGF0aH1cIiwgXCJodHRwczovL2lwZnMuaW8vaXBmcy97Y2lkfS97cGF0aH1cIiwgXCJodHRwczovL2Nsb3VkZmxhcmUtaXBmcy5jb20vaXBmcy97Y2lkfS97cGF0aH1cIiwgXCJodHRwczovL3tjaWR9LmlwZnMudzNzLmxpbmsve3BhdGh9XCIsIFwiaHR0cHM6Ly93M3MubGluay9pcGZzL3tjaWR9L3twYXRofVwiLCBcImh0dHBzOi8vbmZ0c3RvcmFnZS5saW5rL2lwZnMve2NpZH0ve3BhdGh9XCIsIFwiaHR0cHM6Ly9nYXRld2F5LnBpbmF0YS5jbG91ZC9pcGZzL3tjaWR9L3twYXRofVwiXTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgREVGQVVMVF9HQVRFV0FZX1VSTFMgPSB7XG4gIC8vIE5vdGU6IEdhdGV3YXkgVVJMcyBzaG91bGQgaGF2ZSB0cmFpbGluZyBzbGFzaGVzICh3ZSBjbGVhbiB0aGlzIG9uIHVzZXIgaW5wdXQpXG4gIFwiaXBmczovL1wiOiBbLi4uVFdfR0FURVdBWV9VUkxTLCAuLi5QVUJMSUNfR0FURVdBWV9VUkxTXVxufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgVFdfVVBMT0FEX1NFUlZFUl9VUkwgPSBnZXRQcm9jZXNzRW52KFwiQ1VTVE9NX1VQTE9BRF9TRVJWRVJfVVJMXCIsIFwiaHR0cHM6Ly9zdG9yYWdlLnRoaXJkd2ViLmNvbVwiKTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUElOQVRBX0lQRlNfVVJMID0gYGh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZC9waW5uaW5nL3BpbkZpbGVUb0lQRlNgO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBwYXJzZUdhdGV3YXlVcmxzKGdhdGV3YXlVcmxzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGdhdGV3YXlVcmxzKSkge1xuICAgIHJldHVybiB7XG4gICAgICBcImlwZnM6Ly9cIjogZ2F0ZXdheVVybHNcbiAgICB9O1xuICB9XG4gIHJldHVybiBnYXRld2F5VXJscyB8fCB7fTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0R2F0ZXdheVVybEZvckNpZChnYXRld2F5VXJsLCBjaWQsIGNsaWVudElkKSB7XG4gIGNvbnN0IHBhcnRzID0gY2lkLnNwbGl0KFwiL1wiKTtcbiAgY29uc3QgaGFzaCA9IGNvbnZlcnRDaWRUb1YxKHBhcnRzWzBdKTtcbiAgY29uc3QgZmlsZVBhdGggPSBwYXJ0cy5zbGljZSgxKS5qb2luKFwiL1wiKTtcbiAgbGV0IHVybCA9IGdhdGV3YXlVcmw7XG5cbiAgLy8gSWYgdGhlIFVSTCBjb250YWlucyB7Y2lkfSBvciB7cGF0aH0gdG9rZW5zLCByZXBsYWNlIHRoZW0gd2l0aCB0aGUgQ0lEIGFuZCBwYXRoXG4gIC8vIEJvdGggdG9rZW5zIG11c3QgYmUgcHJlc2VudCBmb3IgdGhlIFVSTCB0byBiZSB2YWxpZFxuICBpZiAoZ2F0ZXdheVVybC5pbmNsdWRlcyhcIntjaWR9XCIpICYmIGdhdGV3YXlVcmwuaW5jbHVkZXMoXCJ7cGF0aH1cIikpIHtcbiAgICB1cmwgPSB1cmwucmVwbGFjZShcIntjaWR9XCIsIGhhc2gpLnJlcGxhY2UoXCJ7cGF0aH1cIiwgZmlsZVBhdGgpO1xuICB9XG4gIC8vIElmIHRoZSBVUkwgY29udGFpbnMgb25seSB0aGUge2NpZH0gdG9rZW4sIHJlcGxhY2UgaXQgd2l0aCB0aGUgQ0lEXG4gIGVsc2UgaWYgKGdhdGV3YXlVcmwuaW5jbHVkZXMoXCJ7Y2lkfVwiKSkge1xuICAgIHVybCA9IHVybC5yZXBsYWNlKFwie2NpZH1cIiwgaGFzaCk7XG4gIH1cbiAgLy8gSWYgdGhvc2UgdG9rZW5zIGRvbid0IGV4aXN0LCB1c2UgdGhlIGNhbm9uaWNhbCBnYXRld2F5IFVSTCBmb3JtYXRcbiAgZWxzZSB7XG4gICAgdXJsICs9IGAke2hhc2h9LyR7ZmlsZVBhdGh9YDtcbiAgfVxuICAvLyBpZiB0aGUgVVJMIGNvbnRhaW5zIHRoZSB7Y2xpZW50SWR9IHRva2VuLCByZXBsYWNlIGl0IHdpdGggdGhlIGNsaWVudCBJRFxuICBpZiAoZ2F0ZXdheVVybC5pbmNsdWRlcyhcIntjbGllbnRJZH1cIikpIHtcbiAgICBpZiAoIWNsaWVudElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIHtjbGllbnRJZH0gaW4gZ2F0ZXdheSBVUkwgd2l0aG91dCBwcm92aWRpbmcgYSBjbGllbnQgSURcIik7XG4gICAgfVxuICAgIHVybCA9IHVybC5yZXBsYWNlKFwie2NsaWVudElkfVwiLCBjbGllbnRJZCk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcHJlcGFyZUdhdGV3YXlVcmxzKGdhdGV3YXlVcmxzLCBjbGllbnRJZCwgc2VjcmV0S2V5KSB7XG4gIGNvbnN0IGFsbEdhdGV3YXlVcmxzID0ge1xuICAgIC4uLkRFRkFVTFRfR0FURVdBWV9VUkxTLFxuICAgIC4uLmdhdGV3YXlVcmxzXG4gIH07XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGFsbEdhdGV3YXlVcmxzKSkge1xuICAgIGNvbnN0IGNsZWFuZWRHYXRld2F5VXJscyA9IGFsbEdhdGV3YXlVcmxzW2tleV0ubWFwKHVybCA9PiB7XG4gICAgICAvLyBpbmplY3QgY2xpZW50SWQgd2hlbiBwcmVzZW50XG4gICAgICBpZiAoY2xpZW50SWQgJiYgdXJsLmluY2x1ZGVzKFwie2NsaWVudElkfVwiKSkge1xuICAgICAgICByZXR1cm4gdXJsLnJlcGxhY2UoXCJ7Y2xpZW50SWR9XCIsIGNsaWVudElkKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VjcmV0S2V5ICYmIHVybC5pbmNsdWRlcyhcIntjbGllbnRJZH1cIikpIHtcbiAgICAgICAgLy8gc2hvdWxkIG9ubHkgYmUgdXNlZCBvbiBOb2RlLmpzIGluIGEgYmFja2VuZC9zY3JpcHQgY29udGV4dFxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2Ugc2VjcmV0S2V5IGluIGJyb3dzZXIgY29udGV4dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNoZWRTZWNyZXRLZXkgPSBzaGEyNTZIZXhTeW5jKHNlY3JldEtleSk7XG4gICAgICAgIGNvbnN0IGRlcml2ZWRDbGllbnRJZCA9IGhhc2hlZFNlY3JldEtleS5zbGljZSgwLCAzMik7XG4gICAgICAgIHJldHVybiB1cmwucmVwbGFjZShcIntjbGllbnRJZH1cIiwgZGVyaXZlZENsaWVudElkKTtcbiAgICAgIH0gZWxzZSBpZiAodXJsLmluY2x1ZGVzKFwie2NsaWVudElkfVwiKSkge1xuICAgICAgICAvLyBpZiBubyBjbGllbnQgaWQgcGFzc2VkLCBmaWx0ZXIgb3V0IHRoZSB1cmxcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgICB9XG4gICAgfSkuZmlsdGVyKHVybCA9PiB1cmwgIT09IHVuZGVmaW5lZCk7XG4gICAgYWxsR2F0ZXdheVVybHNba2V5XSA9IGNsZWFuZWRHYXRld2F5VXJscztcbiAgfVxuICByZXR1cm4gYWxsR2F0ZXdheVVybHM7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRDaWRUb1YxKGNpZCkge1xuICBsZXQgbm9ybWFsaXplZDtcbiAgdHJ5IHtcbiAgICBjb25zdCBoYXNoID0gY2lkLnNwbGl0KFwiL1wiKVswXTtcbiAgICBub3JtYWxpemVkID0gQ0lEVG9vbC5iYXNlMzIoaGFzaCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBDSUQgJHtjaWR9IGlzIG5vdCB2YWxpZC5gKTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNGaWxlSW5zdGFuY2UoZGF0YSkge1xuICByZXR1cm4gZ2xvYmFsLkZpbGUgJiYgZGF0YSBpbnN0YW5jZW9mIEZpbGU7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVySW5zdGFuY2UoZGF0YSkge1xuICByZXR1cm4gZ2xvYmFsLkJ1ZmZlciAmJiBkYXRhIGluc3RhbmNlb2YgQnVmZmVyO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc0J1ZmZlck9yU3RyaW5nV2l0aE5hbWUoZGF0YSkge1xuICByZXR1cm4gISEoZGF0YSAmJiBkYXRhLm5hbWUgJiYgZGF0YS5kYXRhICYmIHR5cGVvZiBkYXRhLm5hbWUgPT09IFwic3RyaW5nXCIgJiYgKHR5cGVvZiBkYXRhLmRhdGEgPT09IFwic3RyaW5nXCIgfHwgaXNCdWZmZXJJbnN0YW5jZShkYXRhLmRhdGEpKSk7XG59XG5mdW5jdGlvbiBpc0ZpbGVPckJ1ZmZlcihkYXRhKSB7XG4gIHJldHVybiBpc0ZpbGVJbnN0YW5jZShkYXRhKSB8fCBpc0J1ZmZlckluc3RhbmNlKGRhdGEpIHx8IGlzQnVmZmVyT3JTdHJpbmdXaXRoTmFtZShkYXRhKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNGaWxlQnVmZmVyT3JTdHJpbmdFcXVhbChpbnB1dDEsIGlucHV0Mikge1xuICBpZiAoaXNGaWxlSW5zdGFuY2UoaW5wdXQxKSAmJiBpc0ZpbGVJbnN0YW5jZShpbnB1dDIpKSB7XG4gICAgLy8gaWYgYm90aCBhcmUgRmlsZSB0eXBlcywgY29tcGFyZSB0aGUgbmFtZSwgc2l6ZSwgYW5kIGxhc3QgbW9kaWZpZWQgZGF0ZSAoYmVzdCBndWVzcyB0aGF0IHRoZXNlIGFyZSB0aGUgc2FtZSBmaWxlcylcbiAgICBpZiAoaW5wdXQxLm5hbWUgPT09IGlucHV0Mi5uYW1lICYmIGlucHV0MS5sYXN0TW9kaWZpZWQgPT09IGlucHV0Mi5sYXN0TW9kaWZpZWQgJiYgaW5wdXQxLnNpemUgPT09IGlucHV0Mi5zaXplKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNCdWZmZXJJbnN0YW5jZShpbnB1dDEpICYmIGlzQnVmZmVySW5zdGFuY2UoaW5wdXQyKSkge1xuICAgIC8vIGJ1ZmZlciBnaXZlcyB1cyBhbiBlYXN5IHdheSB0byBjb21wYXJlIHRoZSBjb250ZW50cyFcblxuICAgIHJldHVybiBpbnB1dDEuZXF1YWxzKGlucHV0Mik7XG4gIH0gZWxzZSBpZiAoaXNCdWZmZXJPclN0cmluZ1dpdGhOYW1lKGlucHV0MSkgJiYgaXNCdWZmZXJPclN0cmluZ1dpdGhOYW1lKGlucHV0MikpIHtcbiAgICAvLyBmaXJzdCBjaGVjayB0aGUgbmFtZXNcbiAgICBpZiAoaW5wdXQxLm5hbWUgPT09IGlucHV0Mi5uYW1lKSB7XG4gICAgICAvLyBpZiB0aGUgZGF0YSBmb3IgYm90aCBpcyBhIHN0cmluZywgY29tcGFyZSB0aGUgc3RyaW5nc1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dDEuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgaW5wdXQyLmRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0MS5kYXRhID09PSBpbnB1dDIuZGF0YTtcbiAgICAgIH0gZWxzZSBpZiAoaXNCdWZmZXJJbnN0YW5jZShpbnB1dDEuZGF0YSkgJiYgaXNCdWZmZXJJbnN0YW5jZShpbnB1dDIuZGF0YSkpIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGtub3cgaXQncyBidWZmZXJzLCBzbyBjb21wYXJlIHRoZSBidWZmZXJzXG4gICAgICAgIHJldHVybiBpbnB1dDEuZGF0YS5lcXVhbHMoaW5wdXQyLmRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBvdGhlcndpc2UgaWYgd2UgaGF2ZSBub3QgZm91bmQgYSBtYXRjaCwgcmV0dXJuIGZhbHNlXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcGFyc2VDaWRBbmRQYXRoKGdhdGV3YXlVcmwsIHVyaSkge1xuICBjb25zdCByZWdleFN0cmluZyA9IGdhdGV3YXlVcmwucmVwbGFjZShcIntjaWR9XCIsIFwiKD88aGFzaD5bXi9dKylcIikucmVwbGFjZShcIntwYXRofVwiLCBcIig/PHBhdGg+W14/I10rKVwiKTtcbiAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4U3RyaW5nKTtcbiAgY29uc3QgbWF0Y2ggPSB1cmkubWF0Y2gocmVnZXgpO1xuICBpZiAobWF0Y2gpIHtcbiAgICBjb25zdCBoYXNoID0gbWF0Y2guZ3JvdXBzPy5oYXNoO1xuICAgIGNvbnN0IHBhdGggPSBtYXRjaC5ncm91cHM/LnBhdGg7XG4gICAgY29uc3QgcXVlcnlTdHJpbmcgPSB1cmkuaW5jbHVkZXMoXCI/XCIpID8gdXJpLnN1YnN0cmluZyh1cmkuaW5kZXhPZihcIj9cIikgKyAxKSA6IFwiXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc2gsXG4gICAgICBwYXRoLFxuICAgICAgcXVlcnk6IHF1ZXJ5U3RyaW5nXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiByZXBsYWNlR2F0ZXdheVVybFdpdGhTY2hlbWUodXJpLCBnYXRld2F5VXJscykge1xuICBmb3IgKGNvbnN0IHNjaGVtZSBvZiBPYmplY3Qua2V5cyhnYXRld2F5VXJscykpIHtcbiAgICBmb3IgKGNvbnN0IGdhdGV3YXlVcmwgb2YgZ2F0ZXdheVVybHNbc2NoZW1lXSkge1xuICAgICAgLy8gSWYgdGhlIHVybCBpcyBhIHRva2VuaXplZCB1cmwsIHdlIG5lZWQgdG8gY29udmVydCBpdCB0byBhIGNhbm9uaWNhbCB1cmxcbiAgICAgIC8vIE90aGVyd2lzZSwgd2UganVzdCBuZWVkIHRvIGNoZWNrIGlmIHRoZSB1cmwgaXMgYSBwcmVmaXggb2YgdGhlIHVyaVxuICAgICAgaWYgKGdhdGV3YXlVcmwuaW5jbHVkZXMoXCJ7Y2lkfVwiKSkge1xuICAgICAgICAvLyBHaXZlbiB0aGUgdXJsIGlzIGEgdG9rZW5pemVkIHVybCwgd2UgbmVlZCB0byBsaWZ0IHRoZSBjaWQgYW5kIHRoZSBwYXRoIGZyb20gdGhlIHVyaVxuICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUNpZEFuZFBhdGgoZ2F0ZXdheVVybCwgdXJpKTtcbiAgICAgICAgaWYgKHBhcnNlZD8uaGFzaCAmJiBwYXJzZWQ/LnBhdGgpIHtcbiAgICAgICAgICBjb25zdCBxdWVyeVN0cmluZyA9IHBhcnNlZD8ucXVlcnkgPyBgPyR7cGFyc2VkPy5xdWVyeX1gIDogXCJcIjtcbiAgICAgICAgICByZXR1cm4gYCR7c2NoZW1lfSR7cGFyc2VkPy5oYXNofS8ke3BhcnNlZD8ucGF0aH0ke3F1ZXJ5U3RyaW5nfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgd2UgY2FuJ3QgbGlmdCB0aGUgY2lkIGFuZCBwYXRoIGZyb20gdGhlIHVyaSwgd2UgY2FuJ3QgcmVwbGFjZSB0aGUgZ2F0ZXdheSB1cmwsIHJldHVybiB0aGUgb3JpZyBzdHJpbmdcbiAgICAgICAgICByZXR1cm4gdXJpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHVyaS5zdGFydHNXaXRoKGdhdGV3YXlVcmwpKSB7XG4gICAgICAgIHJldHVybiB1cmkucmVwbGFjZShnYXRld2F5VXJsLCBzY2hlbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXJpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiByZXBsYWNlU2NoZW1lV2l0aEdhdGV3YXlVcmwodXJpLCBnYXRld2F5VXJscykge1xuICBsZXQgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gIGxldCBjbGllbnRJZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICBjb25zdCBzY2hlbWUgPSBPYmplY3Qua2V5cyhnYXRld2F5VXJscykuZmluZChzID0+IHVyaS5zdGFydHNXaXRoKHMpKTtcbiAgY29uc3Qgc2NoZW1lR2F0ZXdheVVybHMgPSBzY2hlbWUgPyBnYXRld2F5VXJsc1tzY2hlbWVdIDogW107XG4gIGlmICghc2NoZW1lICYmIGluZGV4ID4gMCB8fCBzY2hlbWUgJiYgaW5kZXggPj0gc2NoZW1lR2F0ZXdheVVybHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoIXNjaGVtZSkge1xuICAgIHJldHVybiB1cmk7XG4gIH1cbiAgY29uc3QgcGF0aCA9IHVyaS5yZXBsYWNlKHNjaGVtZSwgXCJcIik7XG4gIHRyeSB7XG4gICAgY29uc3QgZ2F0ZXdheVVybCA9IGdldEdhdGV3YXlVcmxGb3JDaWQoc2NoZW1lR2F0ZXdheVVybHNbaW5kZXhdLCBwYXRoLCBjbGllbnRJZCk7XG4gICAgcmV0dXJuIGdhdGV3YXlVcmw7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUud2FybihgVGhlIElQRlMgdXJpOiAke3BhdGh9IGlzIG5vdCB2YWxpZC5gKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2VPYmplY3RHYXRld2F5VXJsc1dpdGhTY2hlbWVzKGRhdGEsIGdhdGV3YXlVcmxzKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiByZXBsYWNlR2F0ZXdheVVybFdpdGhTY2hlbWUoZGF0YSwgZ2F0ZXdheVVybHMpO1xuICB9XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmIChpc0ZpbGVPckJ1ZmZlcihkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5tYXAoZW50cnkgPT4gcmVwbGFjZU9iamVjdEdhdGV3YXlVcmxzV2l0aFNjaGVtZXMoZW50cnksIGdhdGV3YXlVcmxzKSk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZGF0YSkubWFwKF9yZWYgPT4ge1xuICAgICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWY7XG4gICAgICByZXR1cm4gW2tleSwgcmVwbGFjZU9iamVjdEdhdGV3YXlVcmxzV2l0aFNjaGVtZXModmFsdWUsIGdhdGV3YXlVcmxzKV07XG4gICAgfSkpO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiByZXBsYWNlT2JqZWN0U2NoZW1lc1dpdGhHYXRld2F5VXJscyhkYXRhLCBnYXRld2F5VXJscywgY2xpZW50SWQpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VTY2hlbWVXaXRoR2F0ZXdheVVybChkYXRhLCBnYXRld2F5VXJscywgMCwgY2xpZW50SWQpO1xuICB9XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmIChpc0ZpbGVPckJ1ZmZlcihkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5tYXAoZW50cnkgPT4gcmVwbGFjZU9iamVjdFNjaGVtZXNXaXRoR2F0ZXdheVVybHMoZW50cnksIGdhdGV3YXlVcmxzLCBjbGllbnRJZCkpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGRhdGEpLm1hcChfcmVmMiA9PiB7XG4gICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjI7XG4gICAgICByZXR1cm4gW2tleSwgcmVwbGFjZU9iamVjdFNjaGVtZXNXaXRoR2F0ZXdheVVybHModmFsdWUsIGdhdGV3YXlVcmxzLCBjbGllbnRJZCldO1xuICAgIH0pKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdE9iamVjdEZpbGVzKGRhdGEpIHtcbiAgbGV0IGZpbGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgLy8gSWYgaXRlbSBpcyBhIEZpbGVPckJ1ZmZlciBhZGQgaXQgdG8gb3VyIGxpc3Qgb2YgZmlsZXNcbiAgaWYgKGlzRmlsZU9yQnVmZmVyKGRhdGEpKSB7XG4gICAgZmlsZXMucHVzaChkYXRhKTtcbiAgICByZXR1cm4gZmlsZXM7XG4gIH1cbiAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gZmlsZXM7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBkYXRhLmZvckVhY2goZW50cnkgPT4gZXh0cmFjdE9iamVjdEZpbGVzKGVudHJ5LCBmaWxlcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3Qua2V5cyhkYXRhKS5tYXAoa2V5ID0+IGV4dHJhY3RPYmplY3RGaWxlcyhkYXRhW2tleV0sIGZpbGVzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWxlcztcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcmVwbGFjZU9iamVjdEZpbGVzV2l0aFVyaXMoZGF0YSwgdXJpcykge1xuICBpZiAoaXNGaWxlT3JCdWZmZXIoZGF0YSkpIHtcbiAgICBpZiAodXJpcy5sZW5ndGgpIHtcbiAgICAgIGRhdGEgPSB1cmlzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiTm90IGVub3VnaCBVUklzIHRvIHJlcGxhY2UgYWxsIGZpbGVzIGluIG9iamVjdC5cIik7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5tYXAoZW50cnkgPT4gcmVwbGFjZU9iamVjdEZpbGVzV2l0aFVyaXMoZW50cnksIHVyaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhkYXRhKS5tYXAoX3JlZjMgPT4ge1xuICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjM7XG4gICAgICAgIHJldHVybiBba2V5LCByZXBsYWNlT2JqZWN0RmlsZXNXaXRoVXJpcyh2YWx1ZSwgdXJpcyldO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxudmFyIHBrZyA9IHtcblx0bmFtZTogXCJAdGhpcmR3ZWItZGV2L3N0b3JhZ2VcIixcblx0dmVyc2lvbjogXCIyLjAuOFwiLFxuXHRtYWluOiBcImRpc3QvdGhpcmR3ZWItZGV2LXN0b3JhZ2UuY2pzLmpzXCIsXG5cdG1vZHVsZTogXCJkaXN0L3RoaXJkd2ViLWRldi1zdG9yYWdlLmVzbS5qc1wiLFxuXHRleHBvcnRzOiB7XG5cdFx0XCIuXCI6IHtcblx0XHRcdG1vZHVsZTogXCIuL2Rpc3QvdGhpcmR3ZWItZGV2LXN0b3JhZ2UuZXNtLmpzXCIsXG5cdFx0XHRcImRlZmF1bHRcIjogXCIuL2Rpc3QvdGhpcmR3ZWItZGV2LXN0b3JhZ2UuY2pzLmpzXCJcblx0XHR9LFxuXHRcdFwiLi9wYWNrYWdlLmpzb25cIjogXCIuL3BhY2thZ2UuanNvblwiXG5cdH0sXG5cdHJlcG9zaXRvcnk6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RoaXJkd2ViLWRldi9qcy90cmVlL21haW4vcGFja2FnZXMvc3RvcmFnZVwiLFxuXHRhdXRob3I6IFwidGhpcmR3ZWIgZW5nIDxlbmdAdGhpcmR3ZWIuY29tPlwiLFxuXHRsaWNlbnNlOiBcIkFwYWNoZS0yLjBcIixcblx0c2lkZUVmZmVjdHM6IGZhbHNlLFxuXHRzY3JpcHRzOiB7XG5cdFx0Zm9ybWF0OiBcInByZXR0aWVyIC0td3JpdGUgJ3NyYy8qKi8qJ1wiLFxuXHRcdGxpbnQ6IFwiZXNsaW50IHNyYy8gJiYgYnVueCBwdWJsaW50IC0tc3RyaWN0IC0tbGV2ZWwgd2FybmluZ1wiLFxuXHRcdGZpeDogXCJlc2xpbnQgc3JjLyAtLWZpeFwiLFxuXHRcdFwiZ2VuZXJhdGUtZG9jc1wiOiBcImFwaS1leHRyYWN0b3IgcnVuIC0tbG9jYWwgJiYgYXBpLWRvY3VtZW50ZXIgbWFya2Rvd24gLWkgLi90ZW1wIC1vIC4vZG9jc1wiLFxuXHRcdGNsZWFuOiBcInJtIC1yZiBkaXN0L1wiLFxuXHRcdGJ1aWxkOiBcInRzYyAmJiBwcmVjb25zdHJ1Y3QgYnVpbGRcIixcblx0XHRcInRlc3Q6YWxsXCI6IFwiTk9ERV9FTlY9dGVzdCBTV0NfTk9ERV9QUk9KRUNUPS4vdHNjb25maWcudGVzdC5qc29uIG1vY2hhIC0tdGltZW91dCAzMDAwMCAtLXBhcmFsbGVsICcuL3Rlc3QvKiovKi50ZXN0LnRzJ1wiLFxuXHRcdHRlc3Q6IFwicG5wbSB0ZXN0OmFsbFwiLFxuXHRcdFwidGVzdDpzaW5nbGVcIjogXCJOT0RFX0VOVj10ZXN0IFNXQ19OT0RFX1BST0pFQ1Q9Li90c2NvbmZpZy50ZXN0Lmpzb24gbW9jaGEgLS10aW1lb3V0IDMwMDAwXCIsXG5cdFx0cHVzaDogXCJ5YWxjIHB1c2hcIixcblx0XHR0eXBlZG9jOiBcIm5vZGUgc2NyaXB0cy90eXBlZG9jLm1qc1wiXG5cdH0sXG5cdGZpbGVzOiBbXG5cdFx0XCJkaXN0L1wiXG5cdF0sXG5cdHByZWNvbnN0cnVjdDoge1xuXHRcdGV4cG9ydHM6IHRydWVcblx0fSxcblx0ZGV2RGVwZW5kZW5jaWVzOiB7XG5cdFx0XCJAYmFiZWwvcHJlc2V0LWVudlwiOiBcIl43LjIyLjlcIixcblx0XHRcIkBiYWJlbC9wcmVzZXQtdHlwZXNjcmlwdFwiOiBcIl43LjIyLjVcIixcblx0XHRcIkBtaWNyb3NvZnQvYXBpLWRvY3VtZW50ZXJcIjogXCJeNy4yMi4zMFwiLFxuXHRcdFwiQG1pY3Jvc29mdC9hcGktZXh0cmFjdG9yXCI6IFwiXjcuMzYuM1wiLFxuXHRcdFwiQG1pY3Jvc29mdC90c2RvY1wiOiBcIl4wLjE0LjFcIixcblx0XHRcIkBwcmVjb25zdHJ1Y3QvY2xpXCI6IFwiMi43LjBcIixcblx0XHRcIkBzd2Mtbm9kZS9yZWdpc3RlclwiOiBcIl4xLjYuNlwiLFxuXHRcdFwiQHRoaXJkd2ViLWRldi90c2NvbmZpZ1wiOiBcIndvcmtzcGFjZToqXCIsXG5cdFx0XCJAdHlwZXMvY2hhaVwiOiBcIl40LjMuNVwiLFxuXHRcdFwiQHR5cGVzL21vY2hhXCI6IFwiXjEwLjAuMFwiLFxuXHRcdFwiQHR5cGVzL3V1aWRcIjogXCJeOS4wLjVcIixcblx0XHRcIkB0eXBlc2NyaXB0LWVzbGludC9lc2xpbnQtcGx1Z2luXCI6IFwiXjYuMi4wXCIsXG5cdFx0XCJAdHlwZXNjcmlwdC1lc2xpbnQvcGFyc2VyXCI6IFwiXjYuMi4wXCIsXG5cdFx0Y2hhaTogXCJeNC4zLjZcIixcblx0XHRlc2xpbnQ6IFwiXjguNDUuMFwiLFxuXHRcdFwiZXNsaW50LWNvbmZpZy10aGlyZHdlYlwiOiBcIndvcmtzcGFjZToqXCIsXG5cdFx0XCJlc2xpbnQtcGx1Z2luLXRzZG9jXCI6IFwiXjAuMi4xNlwiLFxuXHRcdGVzbTogXCJeMy4yLjI1XCIsXG5cdFx0bW9jaGE6IFwiXjEwLjIuMFwiLFxuXHRcdHJpbXJhZjogXCJeMy4wLjJcIixcblx0XHR0eXBlc2NyaXB0OiBcIl41LjEuNlwiLFxuXHRcdFwidHlwZWRvYy1nZW5cIjogXCJ3b3Jrc3BhY2U6KlwiXG5cdH0sXG5cdGRlcGVuZGVuY2llczoge1xuXHRcdFwiY2lkLXRvb2xcIjogXCJeMy4wLjBcIixcblx0XHRcImZvcm0tZGF0YVwiOiBcIl40LjAuMFwiLFxuXHRcdHV1aWQ6IFwiXjkuMC4xXCIsXG5cdFx0XCJAdGhpcmR3ZWItZGV2L2NyeXB0b1wiOiBcIndvcmtzcGFjZToqXCJcblx0fSxcblx0ZW5naW5lczoge1xuXHRcdG5vZGU6IFwiPj0xOFwiXG5cdH1cbn07XG5cbi8qKlxuICogRGVmYXVsdCBkb3dubG9hZGVyIHVzZWQgLSBoYW5kbGVzIGRvd25sb2FkaW5nIGZyb20gYWxsIHNjaGVtZXMgc3BlY2lmaWVkIGluIHRoZSBnYXRld2F5IFVSTHMgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiAvLyBDYW4gaW5zdGFudGlhdGUgdGhlIGRvd25sb2FkZXIgd2l0aCB0aGUgZGVmYXVsdCBnYXRld2F5IFVSTHNcbiAqIGNvbnN0IGRvd25sb2FkZXIgPSBuZXcgU3RvcmFnZURvd25sb2FkZXIoKTtcbiAqXG4gKiAvLyBjbGllbnQgaWQgaWYgdXNlZCBpbiBjbGllbnQtc2lkZSBhcHBsaWNhdGlvbnNcbiAqIGNvbnN0IGNsaWVudElkID0gXCJ5b3VyLWNsaWVudC1pZFwiO1xuICogY29uc3Qgc3RvcmFnZSA9IG5ldyBUaGlyZHdlYlN0b3JhZ2UoeyBjbGllbnRJZCwgZG93bmxvYWRlciB9KTtcbiAqXG4gKiAvLyBzZWNyZXQga2V5IGlmIHVzZWQgaW4gc2VydmVyLXNpZGUgYXBwbGljYXRpb25zXG4gKiBjb25zdCBzZWNyZXRLZXkgPSBcInlvdXItc2VjcmV0LWtleVwiO1xuICogY29uc3Qgc3RvcmFnZSA9IG5ldyBUaGlyZHdlYlN0b3JhZ2UoeyBzZWNyZXRLZXksIGRvd25sb2FkZXIgfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFN0b3JhZ2VEb3dubG9hZGVyIHtcbiAgREVGQVVMVF9USU1FT1VUX0lOX1NFQ09ORFMgPSA2MDtcbiAgREVGQVVMVF9NQVhfUkVUUklFUyA9IDM7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnNlY3JldEtleSA9IG9wdGlvbnMuc2VjcmV0S2V5O1xuICAgIHRoaXMuY2xpZW50SWQgPSBvcHRpb25zLmNsaWVudElkO1xuICAgIHRoaXMuZGVmYXVsdFRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXRJblNlY29uZHMgfHwgdGhpcy5ERUZBVUxUX1RJTUVPVVRfSU5fU0VDT05EUztcbiAgfVxuICBhc3luYyBkb3dubG9hZCh1cmksIGdhdGV3YXlVcmxzLCBvcHRpb25zKSB7XG4gICAgbGV0IGF0dGVtcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgIGNvbnN0IG1heFJldHJpZXMgPSBvcHRpb25zPy5tYXhSZXRyaWVzIHx8IHRoaXMuREVGQVVMVF9NQVhfUkVUUklFUztcbiAgICBpZiAoYXR0ZW1wdHMgPiBtYXhSZXRyaWVzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW0ZBSUxFRF9UT19ET1dOTE9BRF9FUlJPUl0gRmFpbGVkIHRvIGRvd25sb2FkIGZyb20gVVJJIC0gdG9vIG1hbnkgYXR0ZW1wdHMgZmFpbGVkLlwiKTtcbiAgICAgIC8vIHJldHVybiBhIDQwNCByZXNwb25zZSB0byBhdm9pZCByZXRyeWluZ1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGVycm9yOiBcIk5vdCBGb3VuZFwiXG4gICAgICB9KSwge1xuICAgICAgICBzdGF0dXM6IDQwNCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJlcGxhY2UgcmVjb2duaXplZCBzY2hlbWUgd2l0aCB0aGUgaGlnaGVzdCBwcmlvcml0eSBnYXRld2F5IFVSTCB0aGF0IGhhc24ndCBhbHJlYWR5IGJlZW4gYXR0ZW1wdGVkXG4gICAgbGV0IHJlc29sdmVkVXJpID0gcmVwbGFjZVNjaGVtZVdpdGhHYXRld2F5VXJsKHVyaSwgZ2F0ZXdheVVybHMsIGF0dGVtcHRzLCB0aGlzLmNsaWVudElkKTtcbiAgICAvLyBJZiBldmVyeSBnYXRld2F5IFVSTCB3ZSBrbm93IGFib3V0IGZvciB0aGUgZGVzaWduYXRlZCBzY2hlbWUgaGFzIGJlZW4gdHJpZWQgKHZpYSByZWN1cnNpb24pIGFuZCBmYWlsZWQsIHRocm93IGFuIGVycm9yXG4gICAgaWYgKCFyZXNvbHZlZFVyaSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIltGQUlMRURfVE9fRE9XTkxPQURfRVJST1JdIFVuYWJsZSB0byBkb3dubG9hZCBmcm9tIFVSSSAtIGFsbCBnYXRld2F5IFVSTHMgZmFpbGVkIHRvIHJlc3BvbmQuXCIpO1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGVycm9yOiBcIk5vdCBGb3VuZFwiXG4gICAgICB9KSwge1xuICAgICAgICBzdGF0dXM6IDQwNCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoYXR0ZW1wdHMgPiAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFJldHJ5aW5nIGRvd25sb2FkIHdpdGggYmFja3VwIGdhdGV3YXkgVVJMOiAke3Jlc29sdmVkVXJpfWApO1xuICAgIH1cbiAgICBsZXQgaGVhZGVycyA9IHt9O1xuICAgIGlmIChpc1R3R2F0ZXdheVVybChyZXNvbHZlZFVyaSkpIHtcbiAgICAgIGNvbnN0IGJ1bmRsZUlkID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJBUFBfQlVORExFX0lEXCIgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuQVBQX0JVTkRMRV9JRCA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0aGlzLnNlY3JldEtleSkge1xuICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgIFwieC1zZWNyZXQta2V5XCI6IHRoaXMuc2VjcmV0S2V5XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY2xpZW50SWQpIHtcbiAgICAgICAgaWYgKCFyZXNvbHZlZFVyaS5pbmNsdWRlcyhcImJ1bmRsZUlkXCIpKSB7XG4gICAgICAgICAgcmVzb2x2ZWRVcmkgPSByZXNvbHZlZFVyaSArIChidW5kbGVJZCA/IGA/YnVuZGxlSWQ9JHtidW5kbGVJZH1gIDogXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVyc1tcIngtY2xpZW50LUlkXCJdID0gdGhpcy5jbGllbnRJZDtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlIGhhdmUgYSBhdXRob3JpemF0aW9uIHRva2VuIG9uIGdsb2JhbCBjb250ZXh0IHRoZW4gYWRkIHRoYXQgdG8gdGhlIGhlYWRlcnNcbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIlRXX0FVVEhfVE9LRU5cIiBpbiBnbG9iYWxUaGlzICYmIHR5cGVvZiBnbG9iYWxUaGlzLlRXX0FVVEhfVE9LRU4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgIGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtnbG9iYWxUaGlzLlRXX0FVVEhfVE9LRU59YFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiICYmIFwiVFdfQ0xJX0FVVEhfVE9LRU5cIiBpbiBnbG9iYWxUaGlzICYmIHR5cGVvZiBnbG9iYWxUaGlzLlRXX0NMSV9BVVRIX1RPS0VOID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7Z2xvYmFsVGhpcy5UV19DTElfQVVUSF9UT0tFTn1gXG4gICAgICAgIH07XG4gICAgICAgIGhlYWRlcnNbXCJ4LWF1dGhvcml6ZS13YWxsZXRcIl0gPSBcInRydWVcIjtcbiAgICAgIH1cbiAgICAgIGhlYWRlcnNbXCJ4LXNkay12ZXJzaW9uXCJdID0gcGtnLnZlcnNpb247XG4gICAgICBoZWFkZXJzW1wieC1zZGstbmFtZVwiXSA9IHBrZy5uYW1lO1xuICAgICAgaGVhZGVyc1tcIngtc2RrLXBsYXRmb3JtXCJdID0gYnVuZGxlSWQgPyBcInJlYWN0LW5hdGl2ZVwiIDogaXNCcm93c2VyKCkgPyB3aW5kb3cuYnJpZGdlICE9PSB1bmRlZmluZWQgPyBcIndlYkdMXCIgOiBcImJyb3dzZXJcIiA6IFwibm9kZVwiO1xuICAgIH1cbiAgICBpZiAoaXNUb29NYW55UmVxdWVzdHMocmVzb2x2ZWRVcmkpKSB7XG4gICAgICAvLyBza2lwIHRoZSByZXF1ZXN0IGlmIHdlJ3JlIGdldHRpbmcgdG9vIG1hbnkgcmVxdWVzdCBlcnJvciBmcm9tIHRoZSBnYXRld2F5XG4gICAgICByZXR1cm4gdGhpcy5kb3dubG9hZCh1cmksIGdhdGV3YXlVcmxzLCBvcHRpb25zLCBhdHRlbXB0cyArIDEpO1xuICAgIH1cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHRpbWVvdXRJblNlY29uZHMgPSBvcHRpb25zPy50aW1lb3V0SW5TZWNvbmRzIHx8IHRoaXMuZGVmYXVsdFRpbWVvdXQ7XG4gICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0SW5TZWNvbmRzICogMTAwMCk7XG4gICAgY29uc3QgcmVzT3JFcnIgPSBhd2FpdCBmZXRjaChyZXNvbHZlZFVyaSwge1xuICAgICAgaGVhZGVycyxcbiAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICB9KS5jYXRjaChlcnIgPT4gZXJyKTtcbiAgICAvLyBpZiB3ZSBnZXQgaGVyZSBjbGVhciB0aGUgdGltZW91dFxuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgfVxuICAgIGlmICghKFwic3RhdHVzXCIgaW4gcmVzT3JFcnIpKSB7XG4gICAgICAvLyBlYXJseSBleGl0IGlmIHdlIGRvbid0IGhhdmUgYSBzdGF0dXMgY29kZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXF1ZXN0IHRpbWVkIG91dCBhZnRlciAke3RpbWVvdXRJblNlY29uZHN9IHNlY29uZHMuICR7aXNUd0dhdGV3YXlVcmwocmVzb2x2ZWRVcmkpID8gXCJZb3UgY2FuIHVwZGF0ZSB0aGUgdGltZW91dEluU2Vjb25kcyBvcHRpb24gdG8gaW5jcmVhc2UgdGhlIHRpbWVvdXQuXCIgOiBcIllvdSdyZSB1c2luZyBhIHB1YmxpYyBJUEZTIGdhdGV3YXksIHBhc3MgaW4gYSBjbGllbnRJZCBvciBzZWNyZXRLZXkgZm9yIGEgcmVsaWFibGUgSVBGUyBnYXRld2F5LlwifWApO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSByZXF1ZXN0IGlzIGdvb2Qgd2UgY2FuIHNraXAgZXZlcnl0aGluZyBlbHNlXG4gICAgaWYgKHJlc09yRXJyLm9rKSB7XG4gICAgICByZXR1cm4gcmVzT3JFcnI7XG4gICAgfVxuICAgIGlmIChyZXNPckVyci5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgLy8gdHJhY2sgdGhhdCB3ZSBnb3QgYSB0b28gbWFueSByZXF1ZXN0cyBlcnJvclxuICAgICAgdG9vTWFueVJlcXVlc3RzQmFja09mZihyZXNvbHZlZFVyaSwgcmVzT3JFcnIpO1xuICAgICAgLy8gU2luY2UgdGhlIGN1cnJlbnQgZ2F0ZXdheSBmYWlsZWQsIHJlY3Vyc2l2ZWx5IHRyeSB0aGUgbmV4dCBvbmUgd2Uga25vdyBhYm91dFxuICAgICAgcmV0dXJuIHRoaXMuZG93bmxvYWQodXJpLCBnYXRld2F5VXJscywgb3B0aW9ucywgYXR0ZW1wdHMgKyAxKTtcbiAgICB9XG4gICAgaWYgKHJlc09yRXJyLnN0YXR1cyA9PT0gNDEwKSB7XG4gICAgICAvLyBEb24ndCByZXRyeSBpZiB0aGUgY29udGVudCBpcyBibG9ja2xpc3RlZFxuICAgICAgY29uc29sZS5lcnJvcihgUmVxdWVzdCB0byAke3Jlc29sdmVkVXJpfSBmYWlsZWQgYmVjYXVzZSB0aGlzIGNvbnRlbnQgc2VlbXMgdG8gYmUgYmxvY2tsaXN0ZWQuIFNlYXJjaCBWaXJ1c1RvdGFsIGZvciB0aGlzIFVSTCB0byBjb25maXJtOiAke3Jlc29sdmVkVXJpfSBgKTtcbiAgICAgIHJldHVybiByZXNPckVycjtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKGBSZXF1ZXN0IHRvICR7cmVzb2x2ZWRVcml9IGZhaWxlZCB3aXRoIHN0YXR1cyAke3Jlc09yRXJyLnN0YXR1c30gLSAke3Jlc09yRXJyLnN0YXR1c1RleHR9YCk7XG5cbiAgICAvLyBpZiB0aGUgc3RhdHVzIGlzIDQwNCBhbmQgd2UncmUgdXNpbmcgYSB0aGlyZHdlYiBnYXRld2F5IHVybCwgcmV0dXJuIHRoZSByZXNwb25zZSBhcyBpc1xuICAgIGlmIChyZXNPckVyci5zdGF0dXMgPT09IDQwNCAmJiBpc1R3R2F0ZXdheVVybChyZXNvbHZlZFVyaSkpIHtcbiAgICAgIHJldHVybiByZXNPckVycjtcbiAgICB9XG5cbiAgICAvLyB0aGVzZSBhcmUgdGhlIG9ubHkgZXJyb3JzIHRoYXQgd2Ugd2FudCB0byByZXRyeSwgZXZlcnl0aGluZyBlbHNlIHdlIHNob3VsZCBqdXN0IHJldHVybiB0aGUgZXJyb3IgYXMgaXNcbiAgICAvLyA0MDggLSBSZXF1ZXN0IFRpbWVvdXRcbiAgICAvLyA0MjkgLSBUb28gTWFueSBSZXF1ZXN0c1xuICAgIC8vIDV4eCAtIFNlcnZlciBFcnJvcnNcbiAgICBpZiAocmVzT3JFcnIuc3RhdHVzICE9PSA0MDggJiYgcmVzT3JFcnIuc3RhdHVzICE9PSA0MjkgJiYgcmVzT3JFcnIuc3RhdHVzIDwgNTAwKSB7XG4gICAgICByZXR1cm4gcmVzT3JFcnI7XG4gICAgfVxuXG4gICAgLy8gU2luY2UgdGhlIGN1cnJlbnQgZ2F0ZXdheSBmYWlsZWQsIHJlY3Vyc2l2ZWx5IHRyeSB0aGUgbmV4dCBvbmUgd2Uga25vdyBhYm91dFxuICAgIHJldHVybiB0aGlzLmRvd25sb2FkKHVyaSwgZ2F0ZXdheVVybHMsIG9wdGlvbnMsIGF0dGVtcHRzICsgMSk7XG4gIH1cbn1cbmNvbnN0IFRPT19NQU5ZX1JFUVVFU1RTX1RSQUNLRVIgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBpc1Rvb01hbnlSZXF1ZXN0cyhnYXRld2F5VXJsKSB7XG4gIHJldHVybiBUT09fTUFOWV9SRVFVRVNUU19UUkFDS0VSLmhhcyhnYXRld2F5VXJsKTtcbn1cbmNvbnN0IFRJTUVPVVRfTUFQID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gdG9vTWFueVJlcXVlc3RzQmFja09mZihnYXRld2F5VXJsLCByZXNwb25zZSkge1xuICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSB0aW1lb3V0IGZvciB0aGlzIGdhdGV3YXkgdXJsLCBjbGVhciBpdFxuICBpZiAoVElNRU9VVF9NQVAuaGFzKGdhdGV3YXlVcmwpKSB7XG4gICAgY2xlYXJUaW1lb3V0KFRJTUVPVVRfTUFQLmdldChnYXRld2F5VXJsKSk7XG4gIH1cbiAgY29uc3QgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiUmV0cnktQWZ0ZXJcIik7XG4gIGxldCBiYWNrT2ZmID0gNTAwMDtcbiAgaWYgKHJldHJ5QWZ0ZXIpIHtcbiAgICBjb25zdCByZXRyeUFmdGVyU2Vjb25kcyA9IHBhcnNlSW50KHJldHJ5QWZ0ZXIpO1xuICAgIGlmICghaXNOYU4ocmV0cnlBZnRlclNlY29uZHMpKSB7XG4gICAgICBiYWNrT2ZmID0gcmV0cnlBZnRlclNlY29uZHMgKiAxMDAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRyYWNrIHRoYXQgd2UgZ290IGEgdG9vIG1hbnkgcmVxdWVzdHMgZXJyb3JcbiAgVE9PX01BTllfUkVRVUVTVFNfVFJBQ0tFUi5zZXQoZ2F0ZXdheVVybCwgdHJ1ZSk7XG4gIFRJTUVPVVRfTUFQLnNldChnYXRld2F5VXJsLCBzZXRUaW1lb3V0KCgpID0+IFRPT19NQU5ZX1JFUVVFU1RTX1RSQUNLRVIuZGVsZXRlKGdhdGV3YXlVcmwpLCBiYWNrT2ZmKSk7XG59XG5cbi8qKlxuICogRGVmYXVsdCB1cGxvYWRlciB1c2VkIC0gaGFuZGxlcyB1cGxvYWRpbmcgYXJiaXRyYXJ5IGRhdGEgdG8gSVBGU1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqIC8vIENhbiBpbnN0YW50aWF0ZSB0aGUgdXBsb2FkZXIgd2l0aCBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gYW5kIHlvdXIgY2xpZW50IElEIHdoZW4gdXNlZCBpbiBjbGllbnQtc2lkZSBhcHBsaWNhdGlvbnNcbiAqIGNvbnN0IHVwbG9hZGVyID0gbmV3IFN0b3JhZ2VVcGxvYWRlcigpO1xuICogY29uc3QgY2xpZW50SWQgPSBcInlvdXItY2xpZW50LWlkXCI7XG4gKiBjb25zdCBzdG9yYWdlID0gbmV3IFRoaXJkd2ViU3RvcmFnZSh7IGNsaWVudElkLCB1cGxvYWRlciB9KTtcbiAqXG4gKiAvLyBDYW4gaW5zdGFudGlhdGUgdGhlIHVwbG9hZGVyIHdpdGggZGVmYXVsdCBjb25maWd1cmF0aW9uIGFuZCB5b3VyIHNlY3JldCBrZXkgd2hlbiB1c2VkIGluIHNlcnZlci1zaWRlIGFwcGxpY2F0aW9uc1xuICogY29uc3QgdXBsb2FkZXIgPSBuZXcgU3RvcmFnZVVwbG9hZGVyKCk7XG4gKiBjb25zdCBzZWNyZXRLZXkgPSBcInlvdXItc2VjcmV0LWtleVwiO1xuICogY29uc3Qgc3RvcmFnZSA9IG5ldyBUaGlyZHdlYlN0b3JhZ2UoeyBzZWNyZXRLZXksIHVwbG9hZGVyIH0pO1xuICpcbiAqIC8vIE9yIG9wdGlvbmFsbHksIGNhbiBwYXNzIGNvbmZpZ3VyYXRpb25cbiAqIGNvbnN0IG9wdGlvbnMgPSB7XG4gKiAgIC8vIFVwbG9hZCBvYmplY3RzIHdpdGggcmVzb2x2YWJsZSBVUkxzXG4gKiAgIHVwbG9hZFdpdGhHYXRld2F5VXJsOiB0cnVlLFxuICogfVxuICogY29uc3QgdXBsb2FkZXIgPSBuZXcgU3RvcmFnZVVwbG9hZGVyKG9wdGlvbnMpO1xuICogY29uc3QgY2xpZW50SWQgPSBcInlvdXItY2xpZW50LWlkXCI7XG4gKiBjb25zdCBzdG9yYWdlID0gbmV3IFRoaXJkd2ViU3RvcmFnZSh7IGNsaWVudElkLCB1cGxvYWRlciB9KTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgSXBmc1VwbG9hZGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudXBsb2FkV2l0aEdhdGV3YXlVcmwgPSBvcHRpb25zPy51cGxvYWRXaXRoR2F0ZXdheVVybCB8fCBmYWxzZTtcbiAgICB0aGlzLnVwbG9hZFNlcnZlclVybCA9IG9wdGlvbnM/LnVwbG9hZFNlcnZlclVybCB8fCBUV19VUExPQURfU0VSVkVSX1VSTDtcbiAgICB0aGlzLmNsaWVudElkID0gb3B0aW9ucz8uY2xpZW50SWQ7XG4gICAgdGhpcy5zZWNyZXRLZXkgPSBvcHRpb25zPy5zZWNyZXRLZXk7XG4gIH1cbiAgYXN5bmMgdXBsb2FkQmF0Y2goZGF0YSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zPy51cGxvYWRXaXRob3V0RGlyZWN0b3J5ICYmIGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1VQTE9BRF9XSVRIT1VUX0RJUkVDVE9SWV9FUlJPUl0gQ2Fubm90IHVwbG9hZCBtb3JlIHRoYW4gb25lIGZpbGUgb3Igb2JqZWN0IHdpdGhvdXQgZGlyZWN0b3J5IVwiKTtcbiAgICB9XG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBjb25zdCB7XG4gICAgICBmb3JtLFxuICAgICAgZmlsZU5hbWVzXG4gICAgfSA9IHRoaXMuYnVpbGRGb3JtRGF0YShmb3JtRGF0YSwgZGF0YSwgb3B0aW9ucyk7XG4gICAgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgICByZXR1cm4gdGhpcy51cGxvYWRCYXRjaEJyb3dzZXIoZm9ybSwgZmlsZU5hbWVzLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudXBsb2FkQmF0Y2hOb2RlKGZvcm0sIGZpbGVOYW1lcywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGJ1aWxkRm9ybURhdGEoZm9ybSwgZmlsZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaWxlTmFtZVRvRmlsZU1hcCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBmaWxlTmFtZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmaWxlID0gZmlsZXNbaV07XG4gICAgICBsZXQgZmlsZU5hbWUgPSBcIlwiO1xuICAgICAgbGV0IGZpbGVEYXRhID0gZmlsZTtcbiAgICAgIGlmIChpc0ZpbGVJbnN0YW5jZShmaWxlKSkge1xuICAgICAgICBpZiAob3B0aW9ucz8ucmV3cml0ZUZpbGVOYW1lcykge1xuICAgICAgICAgIGxldCBleHRlbnNpb25zID0gXCJcIjtcbiAgICAgICAgICBpZiAoZmlsZS5uYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBleHRlbnNpb25TdGFydEluZGV4ID0gZmlsZS5uYW1lLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICAgICAgICAgIGlmIChleHRlbnNpb25TdGFydEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgZXh0ZW5zaW9ucyA9IGZpbGUubmFtZS5zdWJzdHJpbmcoZXh0ZW5zaW9uU3RhcnRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbGVOYW1lID0gYCR7aSArIG9wdGlvbnMucmV3cml0ZUZpbGVOYW1lcy5maWxlU3RhcnROdW1iZXJ9JHtleHRlbnNpb25zfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsZU5hbWUgPSBgJHtmaWxlLm5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0J1ZmZlck9yU3RyaW5nV2l0aE5hbWUoZmlsZSkpIHtcbiAgICAgICAgZmlsZURhdGEgPSBmaWxlLmRhdGE7XG4gICAgICAgIGlmIChvcHRpb25zPy5yZXdyaXRlRmlsZU5hbWVzKSB7XG4gICAgICAgICAgZmlsZU5hbWUgPSBgJHtpICsgb3B0aW9ucy5yZXdyaXRlRmlsZU5hbWVzLmZpbGVTdGFydE51bWJlcn1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbGVOYW1lID0gYCR7ZmlsZS5uYW1lfWA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRpb25zPy5yZXdyaXRlRmlsZU5hbWVzKSB7XG4gICAgICAgICAgZmlsZU5hbWUgPSBgJHtpICsgb3B0aW9ucy5yZXdyaXRlRmlsZU5hbWVzLmZpbGVTdGFydE51bWJlcn1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbGVOYW1lID0gYCR7aX1gO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGRvbid0IHdhbnQgdG8gd3JhcCB3aXRoIGRpcmVjdG9yeSwgYWRqdXN0IHRoZSBmaWxlcGF0aFxuICAgICAgY29uc3QgZmlsZXBhdGggPSBvcHRpb25zPy51cGxvYWRXaXRob3V0RGlyZWN0b3J5ID8gYGZpbGVzYCA6IGBmaWxlcy8ke2ZpbGVOYW1lfWA7XG4gICAgICBpZiAoZmlsZU5hbWVUb0ZpbGVNYXAuaGFzKGZpbGVOYW1lKSkge1xuICAgICAgICAvLyBpZiB0aGUgZmlsZSBpbiB0aGUgbWFwIGlzIHRoZSBzYW1lIGFzIHRoZSBmaWxlIHdlIGFyZSBhbHJlYWR5IGxvb2tpbmcgYXQgdGhlbiBqdXN0IHNraXAgYW5kIGNvbnRpbnVlXG4gICAgICAgIGlmIChpc0ZpbGVCdWZmZXJPclN0cmluZ0VxdWFsKGZpbGVOYW1lVG9GaWxlTWFwLmdldChmaWxlTmFtZSksIGZpbGUpKSB7XG4gICAgICAgICAgLy8gd2UgYWRkIGl0IHRvIHRoZSBmaWxlbmFtZXMgYXJyYXkgc28gdGhhdCB3ZSBjYW4gcmV0dXJuIHRoZSBjb3JyZWN0IG51bWJlciBvZiB1cmxzLFxuICAgICAgICAgIGZpbGVOYW1lcy5wdXNoKGZpbGVOYW1lKTtcbiAgICAgICAgICAvLyBidXQgdGhlbiB3ZSBza2lwIGJlY2F1c2Ugd2UgZG9uJ3QgbmVlZCB0byB1cGxvYWQgaXQgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UgaWYgZmlsZSBuYW1lcyBhcmUgdGhlIHNhbWUgYnV0IHRoZXkgYXJlIG5vdCB0aGUgc2FtZSBmaWxlIHRoZW4gd2Ugc2hvdWxkIHRocm93IGFuIGVycm9yICh0cnlpbmcgdG8gdXBsb2FkIHRvIGRpZmZlcm50IGZpbGVzIGJ1dCB3aXRoIHRoZSBzYW1lIG5hbWVzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtEVVBMSUNBVEVfRklMRV9OQU1FX0VSUk9SXSBGaWxlIG5hbWUgJHtmaWxlTmFtZX0gd2FzIHBhc3NlZCBmb3IgbW9yZSB0aGFuIG9uZSBkaWZmZXJlbnQgZmlsZS5gKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGl0IHRvIHRoZSBtYXAgc28gdGhhdCB3ZSBjYW4gY2hlY2sgZm9yIGR1cGxpY2F0ZXNcbiAgICAgIGZpbGVOYW1lVG9GaWxlTWFwLnNldChmaWxlTmFtZSwgZmlsZSk7XG4gICAgICAvLyBhZGQgaXQgdG8gdGhlIGZpbGVuYW1lcyBhcnJheSBzbyB0aGF0IHdlIGNhbiByZXR1cm4gdGhlIGNvcnJlY3QgbnVtYmVyIG9mIHVybHNcbiAgICAgIGZpbGVOYW1lcy5wdXNoKGZpbGVOYW1lKTtcbiAgICAgIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICAgICAgZm9ybS5hcHBlbmQoXCJmaWxlXCIsIGZpbGVEYXRhLCB7XG4gICAgICAgICAgZmlsZXBhdGhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBicm93c2VyIGRvZXMgYmxvYiB0aGluZ3MsIGZpbGVwYXRoIGlzIHBhcnNlZCBkaWZmZXJlbnRseSBvbiBicm93c2VyIHZzIG5vZGUuXG4gICAgICAgIC8vIHBscyBwaW5hdGE/XG4gICAgICAgIGZvcm0uYXBwZW5kKFwiZmlsZVwiLCBuZXcgQmxvYihbZmlsZURhdGFdKSwgZmlsZXBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgIG5hbWU6IGBTdG9yYWdlIFNES2AsXG4gICAgICBrZXl2YWx1ZXM6IHtcbiAgICAgICAgLi4ub3B0aW9ucz8ubWV0YWRhdGFcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvcm0uYXBwZW5kKFwicGluYXRhTWV0YWRhdGFcIiwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICBpZiAob3B0aW9ucz8udXBsb2FkV2l0aG91dERpcmVjdG9yeSkge1xuICAgICAgZm9ybS5hcHBlbmQoXCJwaW5hdGFPcHRpb25zXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgd3JhcFdpdGhEaXJlY3Rvcnk6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmb3JtLFxuICAgICAgLy8gZW5jb2RlIHRoZSBmaWxlIG5hbWVzIG9uIHRoZSB3YXkgb3V0ICh3aGljaCBpcyB3aGF0IHRoZSB1cGxvYWQgYmFja2VuZCBleHBlY3RzKVxuICAgICAgZmlsZU5hbWVzOiBmaWxlTmFtZXMubWFwKGZOYW1lID0+IGVuY29kZVVSSUNvbXBvbmVudChmTmFtZSkpXG4gICAgfTtcbiAgfVxuICBhc3luYyB1cGxvYWRCYXRjaEJyb3dzZXIoZm9ybSwgZmlsZU5hbWVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgbGV0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKFwiUmVxdWVzdCB0byB1cGxvYWQgdGltZWQgb3V0ISBObyB1cGxvYWQgcHJvZ3Jlc3MgcmVjZWl2ZWQgaW4gMzBzXCIpKTtcbiAgICAgIH0sIDMwMDAwKTtcbiAgICAgIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRzdGFydFwiLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbJHtEYXRlLm5vdygpfV0gW0lQRlNdIFN0YXJ0ZWRgKTtcbiAgICAgIH0pO1xuICAgICAgeGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0lQRlNdIFByb2dyZXNzIEV2ZW50ICR7ZXZlbnQubG9hZGVkfS8ke2V2ZW50LnRvdGFsfWApO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICBpZiAoZXZlbnQubG9hZGVkIDwgZXZlbnQudG90YWwpIHtcbiAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiUmVxdWVzdCB0byB1cGxvYWQgdGltZWQgb3V0ISBObyB1cGxvYWQgcHJvZ3Jlc3MgcmVjZWl2ZWQgaW4gMzBzXCIpKTtcbiAgICAgICAgICB9LCAzMDAwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFske0RhdGUubm93KCl9XSBbSVBGU10gVXBsb2FkZWQgZmlsZXMuIFdhaXRpbmcgZm9yIHJlc3BvbnNlLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5sZW5ndGhDb21wdXRhYmxlICYmIG9wdGlvbnM/Lm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBvcHRpb25zPy5vblByb2dyZXNzKHtcbiAgICAgICAgICAgIHByb2dyZXNzOiBldmVudC5sb2FkZWQsXG4gICAgICAgICAgICB0b3RhbDogZXZlbnQudG90YWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhgWyR7RGF0ZS5ub3coKX1dIFtJUEZTXSBMb2FkYCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgSlNPTiBmcm9tIHVwbG9hZCByZXNwb25zZVwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNpZCA9IGJvZHkuSXBmc0hhc2g7XG4gICAgICAgICAgaWYgKCFjaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgSVBGUyBoYXNoIGZyb20gdXBsb2FkIHJlc3BvbnNlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucz8udXBsb2FkV2l0aG91dERpcmVjdG9yeSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoW2BpcGZzOi8vJHtjaWR9YF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmaWxlTmFtZXMubWFwKG4gPT4gYGlwZnM6Ly8ke2NpZH0vJHtufWApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYFVwbG9hZCBmYWlsZWQgd2l0aCBzdGF0dXMgJHt4aHIuc3RhdHVzfSAtICR7eGhyLnJlc3BvbnNlVGV4dH1gKSk7XG4gICAgICB9KTtcbiAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltJUEZTXSBMb2FkXCIpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDAgJiYgeGhyLnJlYWR5U3RhdGUgIT09IDQgfHwgeGhyLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKFwiVXBsb2FkIGZhaWxlZCBkdWUgdG8gYSBuZXR3b3JrIGVycm9yLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJVbmtub3duIHVwbG9hZCBlcnJvciBvY2N1cmVkXCIpKTtcbiAgICAgIH0pO1xuICAgICAgeGhyLm9wZW4oXCJQT1NUXCIsIGAke3RoaXMudXBsb2FkU2VydmVyVXJsfS9pcGZzL3VwbG9hZGApO1xuICAgICAgaWYgKHRoaXMuc2VjcmV0S2V5KSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwieC1zZWNyZXQta2V5XCIsIHRoaXMuc2VjcmV0S2V5KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jbGllbnRJZCkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIngtY2xpZW50LWlkXCIsIHRoaXMuY2xpZW50SWQpO1xuICAgICAgfVxuICAgICAgY29uc3QgYnVuZGxlSWQgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIkFQUF9CVU5ETEVfSURcIiBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5BUFBfQlVORExFX0lEIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGJ1bmRsZUlkKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwieC1idW5kbGUtaWRcIiwgYnVuZGxlSWQpO1xuICAgICAgfVxuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJ4LXNkay12ZXJzaW9uXCIsIHBrZy52ZXJzaW9uKTtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwieC1zZGstbmFtZVwiLCBwa2cubmFtZSk7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIngtc2RrLXBsYXRmb3JtXCIsIGJ1bmRsZUlkID8gXCJyZWFjdC1uYXRpdmVcIiA6IGlzQnJvd3NlcigpID8gd2luZG93LmJyaWRnZSAhPT0gdW5kZWZpbmVkID8gXCJ3ZWJHTFwiIDogXCJicm93c2VyXCIgOiBcIm5vZGVcIik7XG5cbiAgICAgIC8vIGlmIHdlIGhhdmUgYSBhdXRob3JpemF0aW9uIHRva2VuIG9uIGdsb2JhbCBjb250ZXh0IHRoZW4gYWRkIHRoYXQgdG8gdGhlIGhlYWRlcnMsIHRoaXMgaXMgZm9yIHRoZSBkYXNoYm9hcmQuXG4gICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJUV19BVVRIX1RPS0VOXCIgaW4gZ2xvYmFsVGhpcyAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5UV19BVVRIX1RPS0VOID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiYXV0aG9yaXphdGlvblwiLCBgQmVhcmVyICR7Z2xvYmFsVGhpcy5UV19BVVRIX1RPS0VOfWApO1xuICAgICAgfVxuXG4gICAgICAvLyBDTEkgYXV0aCB0b2tlblxuICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiICYmIFwiVFdfQ0xJX0FVVEhfVE9LRU5cIiBpbiBnbG9iYWxUaGlzICYmIHR5cGVvZiBnbG9iYWxUaGlzLlRXX0NMSV9BVVRIX1RPS0VOID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiYXV0aG9yaXphdGlvblwiLCBgQmVhcmVyICR7Z2xvYmFsVGhpcy5UV19DTElfQVVUSF9UT0tFTn1gKTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJ4LWF1dGhvcml6ZS13YWxsZXRcIiwgYHRydWVgKTtcbiAgICAgIH1cbiAgICAgIHhoci5zZW5kKGZvcm0pO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHVwbG9hZEJhdGNoTm9kZShmb3JtLCBmaWxlTmFtZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucz8ub25Qcm9ncmVzcykge1xuICAgICAgY29uc29sZS53YXJuKFwiVGhlIG9uUHJvZ3Jlc3Mgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGluIHRoZSBicm93c2VyXCIpO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgaWYgKHRoaXMuc2VjcmV0S2V5KSB7XG4gICAgICBoZWFkZXJzW1wieC1zZWNyZXQta2V5XCJdID0gdGhpcy5zZWNyZXRLZXk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNsaWVudElkKSB7XG4gICAgICBoZWFkZXJzW1wieC1jbGllbnQtaWRcIl0gPSB0aGlzLmNsaWVudElkO1xuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgYSBidW5kbGUgaWQgb24gZ2xvYmFsIGNvbnRleHQgdGhlbiBhZGQgdGhhdCB0byB0aGUgaGVhZGVyc1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIkFQUF9CVU5ETEVfSURcIiBpbiBnbG9iYWxUaGlzKSB7XG4gICAgICBoZWFkZXJzW1wieC1idW5kbGUtaWRcIl0gPSBnbG9iYWxUaGlzLkFQUF9CVU5ETEVfSUQ7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBhIGF1dGhvcml6YXRpb24gdG9rZW4gb24gZ2xvYmFsIGNvbnRleHQgdGhlbiBhZGQgdGhhdCB0byB0aGUgaGVhZGVycywgdGhpcyBpcyBmb3IgdGhlIGRhc2hib2FyZC5cbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJUV19BVVRIX1RPS0VOXCIgaW4gZ2xvYmFsVGhpcyAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5UV19BVVRIX1RPS0VOID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBoZWFkZXJzW1wiYXV0aG9yaXphdGlvblwiXSA9IGBCZWFyZXIgJHtnbG9iYWxUaGlzLlRXX0FVVEhfVE9LRU59YDtcbiAgICB9XG5cbiAgICAvLyBDTEkgYXV0aCB0b2tlblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIlRXX0NMSV9BVVRIX1RPS0VOXCIgaW4gZ2xvYmFsVGhpcyAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5UV19DTElfQVVUSF9UT0tFTiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSBgQmVhcmVyICR7Z2xvYmFsVGhpcy5UV19DTElfQVVUSF9UT0tFTn1gO1xuICAgICAgaGVhZGVyc1tcIngtYXV0aG9yaXplLXdhbGxldFwiXSA9IFwidHJ1ZVwiO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHt0aGlzLnVwbG9hZFNlcnZlclVybH0vaXBmcy91cGxvYWRgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAuLi5mb3JtLmdldEhlYWRlcnMoKVxuICAgICAgfSxcbiAgICAgIGJvZHk6IGZvcm0uZ2V0QnVmZmVyKClcbiAgICB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmF1dGhvcml6ZWQgLSBZb3UgZG9uJ3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHVzZSB0aGlzIHNlcnZpY2UuXCIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdXBsb2FkIGZpbGVzIHRvIElQRlMgLSAke3Jlcy5zdGF0dXN9IC0gJHtyZXMuc3RhdHVzVGV4dH0gLSAke2F3YWl0IHJlcy50ZXh0KCl9YCk7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IGNpZCA9IGJvZHkuSXBmc0hhc2g7XG4gICAgaWYgKCFjaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byB1cGxvYWQgZmlsZXMgdG8gSVBGUyAtIEJhZCBDSURcIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zPy51cGxvYWRXaXRob3V0RGlyZWN0b3J5KSB7XG4gICAgICByZXR1cm4gW2BpcGZzOi8vJHtjaWR9YF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmaWxlTmFtZXMubWFwKG5hbWUgPT4gYGlwZnM6Ly8ke2NpZH0vJHtuYW1lfWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFVwbG9hZCBhbmQgZG93bmxvYWQgZmlsZXMgZnJvbSBkZWNlbnRyYWxpemVkIHN0b3JhZ2Ugc3lzdGVtcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiAvLyBDcmVhdGUgYSBkZWZhdWx0IHN0b3JhZ2UgY2xhc3Mgd2l0aCBhIGNsaWVudCBJRCB3aGVuIHVzZWQgaW4gY2xpZW50LXNpZGUgYXBwbGljYXRpb25zXG4gKiBjb25zdCBzdG9yYWdlID0gbmV3IFRoaXJkd2ViU3RvcmFnZSh7IGNsaWVudElkOiBcInlvdXItY2xpZW50LWlkXCIgfSk7XG4gKlxuICogLy8gQ3JlYXRlIGEgZGVmYXVsdCBzdG9yYWdlIGNsYXNzIHdpdGggYSBzZWNyZXQga2V5IHdoZW4gdXNlZCBpbiBzZXJ2ZXItc2lkZSBhcHBsaWNhdGlvbnNcbiAqIGNvbnN0IHN0b3JhZ2UgPSBuZXcgVGhpcmR3ZWJTdG9yYWdlKHsgc2VjcmV0S2V5OiBcInlvdXItc2VjcmV0LWtleVwiIH0pO1xuICpcbiAqIFlvdSBjYW4gZ2V0IGEgY2xpZW50SWQgYW5kIHNlY3JldEtleSBmcm9tIGh0dHBzOi8vdGhpcmR3ZWIuY29tL2NyZWF0ZS1hcGkta2V5XG4gKlxuICogLy8gVXBsb2FkIGFueSBmaWxlIG9yIEpTT04gb2JqZWN0XG4gKiBjb25zdCB1cmkgPSBhd2FpdCBzdG9yYWdlLnVwbG9hZChkYXRhKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0b3JhZ2UuZG93bmxvYWQodXJpKTtcbiAqXG4gKiAvLyBPciBjb25maWd1cmUgYSBjdXN0b20gdXBsb2FkZXIsIGRvd25sb2FkZXIsIGFuZCBnYXRld2F5IFVSTHNcbiAqIGNvbnN0IGdhdGV3YXlVcmxzID0ge1xuICogICAvLyBXZSBkZWZpbmUgYSBtYXBwaW5nIG9mIHNjaGVtZXMgdG8gZ2F0ZXdheSBVUkxzXG4gKiAgIFwiaXBmczovL1wiOiBbXG4gKiAgICAgXCJodHRwczovL2lwZnMudGhpcmR3ZWJjZG4uY29tL2lwZnMvXCIsXG4gKiAgICAgXCJodHRwczovL2Nsb3VkZmxhcmUtaXBmcy5jb20vaXBmcy9cIixcbiAqICAgICBcImh0dHBzOi8vaXBmcy5pby9pcGZzL1wiLFxuICogICBdLFxuICogfTtcbiAqIGNvbnN0IGRvd25sb2FkZXIgPSBuZXcgU3RvcmFnZURvd25sb2FkZXIoKTtcbiAqIGNvbnN0IHVwbG9hZGVyID0gbmV3IElwZnNVcGxvYWRlcigpO1xuICogY29uc3QgY2xpZW50SWQgPSBcInlvdXItY2xpZW50LWlkXCI7XG4gKiBjb25zdCBzdG9yYWdlID0gbmV3IFRoaXJkd2ViU3RvcmFnZSh7IGNsaWVudElkLCB1cGxvYWRlciwgZG93bmxvYWRlciwgZ2F0ZXdheVVybHMgfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFRoaXJkd2ViU3RvcmFnZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnVwbG9hZGVyID0gb3B0aW9ucz8udXBsb2FkZXIgfHwgbmV3IElwZnNVcGxvYWRlcih7XG4gICAgICBjbGllbnRJZDogb3B0aW9ucz8uY2xpZW50SWQsXG4gICAgICBzZWNyZXRLZXk6IG9wdGlvbnM/LnNlY3JldEtleSxcbiAgICAgIHVwbG9hZFNlcnZlclVybDogb3B0aW9ucz8udXBsb2FkU2VydmVyVXJsXG4gICAgfSk7XG4gICAgdGhpcy5kb3dubG9hZGVyID0gb3B0aW9ucz8uZG93bmxvYWRlciB8fCBuZXcgU3RvcmFnZURvd25sb2FkZXIoe1xuICAgICAgc2VjcmV0S2V5OiBvcHRpb25zPy5zZWNyZXRLZXksXG4gICAgICBjbGllbnRJZDogb3B0aW9ucz8uY2xpZW50SWRcbiAgICB9KTtcbiAgICB0aGlzLmdhdGV3YXlVcmxzID0gcHJlcGFyZUdhdGV3YXlVcmxzKHBhcnNlR2F0ZXdheVVybHMob3B0aW9ucz8uZ2F0ZXdheVVybHMpLCBvcHRpb25zPy5jbGllbnRJZCwgb3B0aW9ucz8uc2VjcmV0S2V5KTtcbiAgICB0aGlzLmNsaWVudElkID0gb3B0aW9ucz8uY2xpZW50SWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSBhbnkgc2NoZW1lIG9uIGEgVVJMIHRvIGdldCBhIHJldHJpZXZhYmxlIFVSTCBmb3IgdGhlIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gcmVzb2x2ZSB0aGUgc2NoZW1lIG9mXG4gICAqIEByZXR1cm5zIFRoZSBVUkwgd2l0aCBpdHMgc2NoZW1lIHJlc29sdmVkXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzeFxuICAgKiBjb25zdCB1cmkgPSBcImlwZnM6Ly9leGFtcGxlXCI7XG4gICAqIGNvbnN0IHVybCA9IHN0b3JhZ2UucmVzb2x2ZVNjaGVtZSh1cmkpO1xuICAgKiBjb25zb2xlLmxvZyh1cmwpO1xuICAgKiBgYGBcbiAgICovXG4gIHJlc29sdmVTY2hlbWUodXJsKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VTY2hlbWVXaXRoR2F0ZXdheVVybCh1cmwsIHRoaXMuZ2F0ZXdheVVybHMsIDAsIHRoaXMuY2xpZW50SWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERvd25sb2FkcyBhcmJpdHJhcnkgZGF0YSBmcm9tIGFueSBVUkwgc2NoZW1lLlxuICAgKlxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBvZiB0aGUgZGF0YSB0byBkb3dubG9hZFxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2Ugb2JqZWN0IGZldGNoZWQgZnJvbSB0aGUgcmVzb2x2ZWQgVVJMXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzeFxuICAgKiBjb25zdCB1cmkgPSBcImlwZnM6Ly9leGFtcGxlXCI7XG4gICAqIGNvbnN0IGRhdGEgPSBhd2FpdCBzdG9yYWdlLmRvd25sb2FkKHVyaSk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZG93bmxvYWQodXJsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZG93bmxvYWRlci5kb3dubG9hZCh1cmwsIHRoaXMuZ2F0ZXdheVVybHMsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERvd25sb2FkcyBKU09OIGRhdGEgZnJvbSBhbnkgVVJMIHNjaGVtZS5cbiAgICogUmVzb2x2ZXMgYW55IFVSTHMgd2l0aCBzY2hlbWVzIHRvIHJldHJpZXZhYmxlIGdhdGV3YXkgVVJMcy5cbiAgICpcbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgb2YgdGhlIEpTT04gZGF0YSB0byBkb3dubG9hZFxuICAgKiBAcmV0dXJucyBUaGUgSlNPTiBkYXRhIGZldGNoZWQgZnJvbSB0aGUgcmVzb2x2ZWQgVVJMXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzeFxuICAgKiBjb25zdCB1cmkgPSBcImlwZnM6Ly9leGFtcGxlXCI7XG4gICAqIGNvbnN0IGpzb24gPSBhd2FpdCBzdG9yYWdlLmRvd25sb2FkSlNPTih1cmkpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGRvd25sb2FkSlNPTih1cmwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmRvd25sb2FkKHVybCwgb3B0aW9ucyk7XG5cbiAgICAvLyBJZiB3ZSBnZXQgYSBKU09OIG9iamVjdCwgcmVjdXJzaXZlbHkgcmVwbGFjZSBhbnkgc2NoZW1lcyB3aXRoIGdhdGV3YXlVcmxzXG4gICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIHJlcGxhY2VPYmplY3RTY2hlbWVzV2l0aEdhdGV3YXlVcmxzKGpzb24sIHRoaXMuZ2F0ZXdheVVybHMsIHRoaXMuY2xpZW50SWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwbG9hZCBhcmJpdHJhcnkgZmlsZSBvciBKU09OIGRhdGEgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgZGVjZW50cmFsaXplZCBzdG9yYWdlIHN5c3RlbS5cbiAgICogQXV0b21hdGljYWxseSB1cGxvYWRzIGFueSBmaWxlIGRhdGEgd2l0aGluIEpTT04gb2JqZWN0cyBhbmQgcmVwbGFjZXMgdGhlbSB3aXRoIGhhc2hlcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBBcmJpdHJhcnkgZmlsZSBvciBKU09OIGRhdGEgdG8gdXBsb2FkXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBwYXNzIHRocm91Z2ggdG8gdGhlIHN0b3JhZ2UgdXBsb2FkZXIgY2xhc3NcbiAgICogQHJldHVybnMgIFRoZSBVUkkgb2YgdGhlIHVwbG9hZGVkIGRhdGFcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganN4XG4gICAqIC8vIFVwbG9hZCBmaWxlIGRhdGFcbiAgICogY29uc3QgZmlsZSA9IHJlYWRGaWxlU3luYyhcIi4uL2ZpbGUuanBnXCIpO1xuICAgKiBjb25zdCBmaWxlVXJpID0gYXdhaXQgc3RvcmFnZS51cGxvYWQoZmlsZSk7XG4gICAqXG4gICAqIC8vIE9yIHVwbG9hZCBhIEpTT04gb2JqZWN0XG4gICAqIGNvbnN0IGpzb24gPSB7IG5hbWU6IFwiSlNPTlwiLCBpbWFnZTogZmlsZSB9O1xuICAgKiBjb25zdCBqc29uVXJpID0gYXdhaXQgc3RvcmFnZS51cGxvYWQoanNvbik7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgdXBsb2FkKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBbdXJpXSA9IGF3YWl0IHRoaXMudXBsb2FkQmF0Y2goW2RhdGFdLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdXJpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhdGNoIHVwbG9hZCBhcmJpdHJhcnkgZmlsZSBvciBKU09OIGRhdGEgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgZGVjZW50cmFsaXplZCBzdG9yYWdlIHN5c3RlbS5cbiAgICogQXV0b21hdGljYWxseSB1cGxvYWRzIGFueSBmaWxlIGRhdGEgd2l0aGluIEpTT04gb2JqZWN0cyBhbmQgcmVwbGFjZXMgdGhlbSB3aXRoIGhhc2hlcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBBcnJheSBvZiBhcmJpdHJhcnkgZmlsZSBvciBKU09OIGRhdGEgdG8gdXBsb2FkXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBwYXNzIHRocm91Z2ggdG8gdGhlIHN0b3JhZ2UgdXBsb2FkZXIgY2xhc3NcbiAgICogQHJldHVybnMgIFRoZSBVUklzIG9mIHRoZSB1cGxvYWRlZCBkYXRhXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzeFxuICAgKiAvLyBVcGxvYWQgYW4gYXJyYXkgb2YgZmlsZSBkYXRhXG4gICAqIGNvbnN0IGZpbGVzID0gW1xuICAgKiAgcmVhZEZpbGVTeW5jKFwiLi4vZmlsZTEuanBnXCIpLFxuICAgKiAgcmVhZEZpbGVTeW5jKFwiLi4vZmlsZTIuanBnXCIpLFxuICAgKiBdO1xuICAgKiBjb25zdCBmaWxlVXJpcyA9IGF3YWl0IHN0b3JhZ2UudXBsb2FkQmF0Y2goZmlsZXMpO1xuICAgKlxuICAgKiAvLyBVcGxvYWQgYW4gYXJyYXkgb2YgSlNPTiBvYmplY3RzXG4gICAqIGNvbnN0IG9iamVjdHMgPSBbXG4gICAqICB7IG5hbWU6IFwiSlNPTiAxXCIsIGltYWdlOiBmaWxlc1swXSB9LFxuICAgKiAgeyBuYW1lOiBcIkpTT04gMlwiLCBpbWFnZTogZmlsZXNbMV0gfSxcbiAgICogXTtcbiAgICogY29uc3QganNvblVyaXMgPSBhd2FpdCBzdG9yYWdlLnVwbG9hZEJhdGNoKG9iamVjdHMpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHVwbG9hZEJhdGNoKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBkYXRhID0gZGF0YS5maWx0ZXIoaXRlbSA9PiBpdGVtICE9PSB1bmRlZmluZWQpO1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgaXNGaWxlQXJyYXkgPSBkYXRhLm1hcChpdGVtID0+IGlzRmlsZU9yQnVmZmVyKGl0ZW0pIHx8IHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKS5ldmVyeShpdGVtID0+ICEhaXRlbSk7XG4gICAgbGV0IHVyaXMgPSBbXTtcblxuICAgIC8vIElmIGRhdGEgaXMgYW4gYXJyYXkgb2YgZmlsZXMsIHBhc3MgaXQgdGhyb3VnaCB0byB1cGxvYWQgZGlyZWN0bHlcbiAgICBpZiAoaXNGaWxlQXJyYXkpIHtcbiAgICAgIHVyaXMgPSBhd2FpdCB0aGlzLnVwbG9hZGVyLnVwbG9hZEJhdGNoKGRhdGEsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgaXQgaXMgYW4gYXJyYXkgb2YgSlNPTiBvYmplY3RzLCBzbyB3ZSBoYXZlIHRvIHByZXBhcmUgaXQgZmlyc3RcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gKGF3YWl0IHRoaXMudXBsb2FkQW5kUmVwbGFjZUZpbGVzV2l0aEhhc2hlcyhkYXRhLCBvcHRpb25zKSkubWFwKGl0ZW0gPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaXRlbSk7XG4gICAgICB9KTtcbiAgICAgIHVyaXMgPSBhd2FpdCB0aGlzLnVwbG9hZGVyLnVwbG9hZEJhdGNoKG1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LnVwbG9hZFdpdGhHYXRld2F5VXJsIHx8IHRoaXMudXBsb2FkZXIudXBsb2FkV2l0aEdhdGV3YXlVcmwpIHtcbiAgICAgIHJldHVybiB1cmlzLm1hcCh1cmkgPT4gdGhpcy5yZXNvbHZlU2NoZW1lKHVyaSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdXJpcztcbiAgICB9XG4gIH1cbiAgZ2V0R2F0ZXdheVVybHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2F0ZXdheVVybHM7XG4gIH1cbiAgYXN5bmMgdXBsb2FkQW5kUmVwbGFjZUZpbGVzV2l0aEhhc2hlcyhkYXRhLCBvcHRpb25zKSB7XG4gICAgbGV0IGNsZWFuZWQgPSBkYXRhO1xuICAgIC8vIFJlcGxhY2UgYW55IGdhdGV3YXkgVVJMcyB3aXRoIHRoZWlyIGhhc2hlc1xuICAgIGNsZWFuZWQgPSByZXBsYWNlT2JqZWN0R2F0ZXdheVVybHNXaXRoU2NoZW1lcyhjbGVhbmVkLCB0aGlzLmdhdGV3YXlVcmxzKTtcblxuICAgIC8vIFJlY3Vyc2UgdGhyb3VnaCBkYXRhIGFuZCBleHRyYWN0IGZpbGVzIHRvIHVwbG9hZFxuICAgIGNvbnN0IGZpbGVzID0gZXh0cmFjdE9iamVjdEZpbGVzKGNsZWFuZWQpO1xuICAgIGlmIChmaWxlcy5sZW5ndGgpIHtcbiAgICAgIC8vIFVwbG9hZCBhbGwgZmlsZXMgdGhhdCBjYW1lIGZyb20gdGhlIG9iamVjdFxuICAgICAgY29uc3QgdXJpcyA9IGF3YWl0IHRoaXMudXBsb2FkZXIudXBsb2FkQmF0Y2goZmlsZXMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBSZWN1cnNlIHRocm91Z2ggZGF0YSBhbmQgcmVwbGFjZSBmaWxlcyB3aXRoIGhhc2hlc1xuICAgICAgY2xlYW5lZCA9IHJlcGxhY2VPYmplY3RGaWxlc1dpdGhVcmlzKGNsZWFuZWQsIHVyaXMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucz8udXBsb2FkV2l0aEdhdGV3YXlVcmwgfHwgdGhpcy51cGxvYWRlci51cGxvYWRXaXRoR2F0ZXdheVVybCkge1xuICAgICAgLy8gSWYgZmxhZyBpcyBzZXQsIHJlcGxhY2UgYWxsIHNjaGVtZXMgd2l0aCB0aGVpciBwcmVmZXJyZWQgZ2F0ZXdheSBVUkxcbiAgICAgIC8vIEV4OiB1c2VkIGZvciBTb2xhbmEsIHdoZXJlIHNlcnZpY2VzIGRvbid0IHJlc29sdmUgc2NoZW1lcyBmb3IgeW91LCBzbyBVUkxzIG11c3QgYmUgdXNhYmxlIGJ5IGRlZmF1bHRcbiAgICAgIGNsZWFuZWQgPSByZXBsYWNlT2JqZWN0U2NoZW1lc1dpdGhHYXRld2F5VXJscyhjbGVhbmVkLCB0aGlzLmdhdGV3YXlVcmxzLCB0aGlzLmNsaWVudElkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsZWFuZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgTW9ja0Rvd25sb2FkZXIge1xuICBnYXRld2F5VXJscyA9IERFRkFVTFRfR0FURVdBWV9VUkxTO1xuICBjb25zdHJ1Y3RvcihzdG9yYWdlKSB7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgfVxuICBhc3luYyBkb3dubG9hZCh1cmwpIHtcbiAgICBjb25zdCBbY2lkLCBuYW1lXSA9IHVybC5pbmNsdWRlcyhcIm1vY2s6Ly9cIikgPyB1cmwucmVwbGFjZShcIm1vY2s6Ly9cIiwgXCJcIikuc3BsaXQoXCIvXCIpIDogdXJsLnJlcGxhY2UoXCJpcGZzOi8vXCIsIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICBjb25zdCBkYXRhID0gbmFtZSA/IHRoaXMuc3RvcmFnZVtjaWRdW25hbWVdIDogdGhpcy5zdG9yYWdlW2NpZF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIGpzb24oKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoSlNPTi5wYXJzZShkYXRhKSk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgdGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIE1vY2tVcGxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0b3JhZ2UpIHtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICB9XG4gIGFzeW5jIHVwbG9hZEJhdGNoKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjaWQgPSB2NCgpO1xuICAgIGNvbnN0IHVyaXMgPSBbXTtcbiAgICB0aGlzLnN0b3JhZ2VbY2lkXSA9IHt9O1xuICAgIGxldCBpbmRleCA9IG9wdGlvbnM/LnJld3JpdGVGaWxlTmFtZXM/LmZpbGVTdGFydE51bWJlciB8fCAwO1xuICAgIGZvciAoY29uc3QgZmlsZSBvZiBkYXRhKSB7XG4gICAgICBsZXQgY29udGVudHM7XG4gICAgICBpZiAoaXNGaWxlSW5zdGFuY2UoZmlsZSkpIHtcbiAgICAgICAgY29udGVudHMgPSBhd2FpdCBmaWxlLnRleHQoKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNCdWZmZXJJbnN0YW5jZShmaWxlKSkge1xuICAgICAgICBjb250ZW50cyA9IGZpbGUudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpbGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29udGVudHMgPSBmaWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudHMgPSBpc0J1ZmZlckluc3RhbmNlKGZpbGUuZGF0YSkgPyBmaWxlLmRhdGEudG9TdHJpbmcoKSA6IGZpbGUuZGF0YTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZpbGUubmFtZSA/IGZpbGUubmFtZSA6IGBmaWxlXyR7aW5kZXh9YDtcbiAgICAgICAgdGhpcy5zdG9yYWdlW2NpZF1bbmFtZV0gPSBjb250ZW50cztcbiAgICAgICAgdXJpcy5wdXNoKGBtb2NrOi8vJHtjaWR9LyR7bmFtZX1gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLnN0b3JhZ2VbY2lkXVtpbmRleC50b1N0cmluZygpXSA9IGNvbnRlbnRzO1xuICAgICAgdXJpcy5wdXNoKGBtb2NrOi8vJHtjaWR9LyR7aW5kZXh9YCk7XG4gICAgICBpbmRleCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdXJpcztcbiAgfVxufVxuXG5leHBvcnQgeyBERUZBVUxUX0dBVEVXQVlfVVJMUywgSXBmc1VwbG9hZGVyLCBNb2NrRG93bmxvYWRlciwgTW9ja1VwbG9hZGVyLCBQSU5BVEFfSVBGU19VUkwsIFN0b3JhZ2VEb3dubG9hZGVyLCBUV19VUExPQURfU0VSVkVSX1VSTCwgVGhpcmR3ZWJTdG9yYWdlLCBjb252ZXJ0Q2lkVG9WMSwgZXh0cmFjdE9iamVjdEZpbGVzLCBnZXRHYXRld2F5VXJsRm9yQ2lkLCBpc0Jyb3dzZXIsIGlzQnVmZmVySW5zdGFuY2UsIGlzQnVmZmVyT3JTdHJpbmdXaXRoTmFtZSwgaXNGaWxlQnVmZmVyT3JTdHJpbmdFcXVhbCwgaXNGaWxlSW5zdGFuY2UsIGlzRmlsZU9yQnVmZmVyLCBpc1R3R2F0ZXdheVVybCwgcGFyc2VHYXRld2F5VXJscywgcHJlcGFyZUdhdGV3YXlVcmxzLCByZXBsYWNlR2F0ZXdheVVybFdpdGhTY2hlbWUsIHJlcGxhY2VPYmplY3RGaWxlc1dpdGhVcmlzLCByZXBsYWNlT2JqZWN0R2F0ZXdheVVybHNXaXRoU2NoZW1lcywgcmVwbGFjZU9iamVjdFNjaGVtZXNXaXRoR2F0ZXdheVVybHMsIHJlcGxhY2VTY2hlbWVXaXRoR2F0ZXdheVVybCB9O1xuIl0sIm5hbWVzIjpbIkNJRFRvb2wiLCJzaGEyNTZIZXhTeW5jIiwiRm9ybURhdGEiLCJ2NCIsImdldFByb2Nlc3NFbnYiLCJrZXkiLCJkZWZhdWx0VmFsdWUiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJwcm9jZXNzIiwiZW52IiwiVFdfSE9TVE5BTUVfU1VGRklYIiwiVFdfU1RBR0lOR0hPU1ROQU1FX1NVRkZJWCIsIlRXX0dBVEVXQVlfVVJMUyIsImlzVHdHYXRld2F5VXJsIiwidXJsIiwiaG9zdG5hbWUiLCJVUkwiLCJpc1Byb2QiLCJlbmRzV2l0aCIsIlBVQkxJQ19HQVRFV0FZX1VSTFMiLCJERUZBVUxUX0dBVEVXQVlfVVJMUyIsIlRXX1VQTE9BRF9TRVJWRVJfVVJMIiwiUElOQVRBX0lQRlNfVVJMIiwicGFyc2VHYXRld2F5VXJscyIsImdhdGV3YXlVcmxzIiwiQXJyYXkiLCJpc0FycmF5IiwiZ2V0R2F0ZXdheVVybEZvckNpZCIsImdhdGV3YXlVcmwiLCJjaWQiLCJjbGllbnRJZCIsInBhcnRzIiwic3BsaXQiLCJoYXNoIiwiY29udmVydENpZFRvVjEiLCJmaWxlUGF0aCIsInNsaWNlIiwiam9pbiIsImluY2x1ZGVzIiwicmVwbGFjZSIsIkVycm9yIiwicHJlcGFyZUdhdGV3YXlVcmxzIiwic2VjcmV0S2V5IiwiYWxsR2F0ZXdheVVybHMiLCJPYmplY3QiLCJrZXlzIiwiY2xlYW5lZEdhdGV3YXlVcmxzIiwibWFwIiwiaGFzaGVkU2VjcmV0S2V5IiwiZGVyaXZlZENsaWVudElkIiwiZmlsdGVyIiwibm9ybWFsaXplZCIsImJhc2UzMiIsImUiLCJpc0Jyb3dzZXIiLCJpc0ZpbGVJbnN0YW5jZSIsImRhdGEiLCJnbG9iYWwiLCJGaWxlIiwiaXNCdWZmZXJJbnN0YW5jZSIsIkJ1ZmZlciIsImlzQnVmZmVyT3JTdHJpbmdXaXRoTmFtZSIsIm5hbWUiLCJpc0ZpbGVPckJ1ZmZlciIsImlzRmlsZUJ1ZmZlck9yU3RyaW5nRXF1YWwiLCJpbnB1dDEiLCJpbnB1dDIiLCJsYXN0TW9kaWZpZWQiLCJzaXplIiwiZXF1YWxzIiwicGFyc2VDaWRBbmRQYXRoIiwidXJpIiwicmVnZXhTdHJpbmciLCJyZWdleCIsIlJlZ0V4cCIsIm1hdGNoIiwiZ3JvdXBzIiwicGF0aCIsInF1ZXJ5U3RyaW5nIiwic3Vic3RyaW5nIiwiaW5kZXhPZiIsInF1ZXJ5IiwicmVwbGFjZUdhdGV3YXlVcmxXaXRoU2NoZW1lIiwic2NoZW1lIiwicGFyc2VkIiwic3RhcnRzV2l0aCIsInJlcGxhY2VTY2hlbWVXaXRoR2F0ZXdheVVybCIsImluZGV4IiwiZmluZCIsInMiLCJzY2hlbWVHYXRld2F5VXJscyIsImVyciIsImNvbnNvbGUiLCJ3YXJuIiwicmVwbGFjZU9iamVjdEdhdGV3YXlVcmxzV2l0aFNjaGVtZXMiLCJlbnRyeSIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsIl9yZWYiLCJ2YWx1ZSIsInJlcGxhY2VPYmplY3RTY2hlbWVzV2l0aEdhdGV3YXlVcmxzIiwiX3JlZjIiLCJleHRyYWN0T2JqZWN0RmlsZXMiLCJmaWxlcyIsInB1c2giLCJmb3JFYWNoIiwicmVwbGFjZU9iamVjdEZpbGVzV2l0aFVyaXMiLCJ1cmlzIiwic2hpZnQiLCJfcmVmMyIsInBrZyIsInZlcnNpb24iLCJtYWluIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcG9zaXRvcnkiLCJhdXRob3IiLCJsaWNlbnNlIiwic2lkZUVmZmVjdHMiLCJzY3JpcHRzIiwiZm9ybWF0IiwibGludCIsImZpeCIsImNsZWFuIiwiYnVpbGQiLCJ0ZXN0IiwidHlwZWRvYyIsInByZWNvbnN0cnVjdCIsImRldkRlcGVuZGVuY2llcyIsImNoYWkiLCJlc2xpbnQiLCJlc20iLCJtb2NoYSIsInJpbXJhZiIsInR5cGVzY3JpcHQiLCJkZXBlbmRlbmNpZXMiLCJ1dWlkIiwiZW5naW5lcyIsIm5vZGUiLCJTdG9yYWdlRG93bmxvYWRlciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsIkRFRkFVTFRfVElNRU9VVF9JTl9TRUNPTkRTIiwiREVGQVVMVF9NQVhfUkVUUklFUyIsImRlZmF1bHRUaW1lb3V0IiwidGltZW91dEluU2Vjb25kcyIsImRvd25sb2FkIiwiYXR0ZW1wdHMiLCJtYXhSZXRyaWVzIiwiZXJyb3IiLCJSZXNwb25zZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdGF0dXMiLCJoZWFkZXJzIiwicmVzb2x2ZWRVcmkiLCJidW5kbGVJZCIsImdsb2JhbFRoaXMiLCJBUFBfQlVORExFX0lEIiwiVFdfQVVUSF9UT0tFTiIsImF1dGhvcml6YXRpb24iLCJUV19DTElfQVVUSF9UT0tFTiIsIndpbmRvdyIsImJyaWRnZSIsImlzVG9vTWFueVJlcXVlc3RzIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJyZXNPckVyciIsImZldGNoIiwic2lnbmFsIiwiY2F0Y2giLCJjbGVhclRpbWVvdXQiLCJvayIsInRvb01hbnlSZXF1ZXN0c0JhY2tPZmYiLCJzdGF0dXNUZXh0IiwiVE9PX01BTllfUkVRVUVTVFNfVFJBQ0tFUiIsIk1hcCIsImhhcyIsIlRJTUVPVVRfTUFQIiwicmVzcG9uc2UiLCJnZXQiLCJyZXRyeUFmdGVyIiwiYmFja09mZiIsInJldHJ5QWZ0ZXJTZWNvbmRzIiwicGFyc2VJbnQiLCJpc05hTiIsInNldCIsImRlbGV0ZSIsIklwZnNVcGxvYWRlciIsInVwbG9hZFdpdGhHYXRld2F5VXJsIiwidXBsb2FkU2VydmVyVXJsIiwidXBsb2FkQmF0Y2giLCJ1cGxvYWRXaXRob3V0RGlyZWN0b3J5IiwiZm9ybURhdGEiLCJmb3JtIiwiZmlsZU5hbWVzIiwiYnVpbGRGb3JtRGF0YSIsInVwbG9hZEJhdGNoQnJvd3NlciIsInVwbG9hZEJhdGNoTm9kZSIsImZpbGVOYW1lVG9GaWxlTWFwIiwiaSIsImZpbGUiLCJmaWxlTmFtZSIsImZpbGVEYXRhIiwicmV3cml0ZUZpbGVOYW1lcyIsImV4dGVuc2lvbnMiLCJleHRlbnNpb25TdGFydEluZGV4IiwibGFzdEluZGV4T2YiLCJmaWxlU3RhcnROdW1iZXIiLCJmaWxlcGF0aCIsImFwcGVuZCIsIkJsb2IiLCJtZXRhZGF0YSIsImtleXZhbHVlcyIsIndyYXBXaXRoRGlyZWN0b3J5IiwiZk5hbWUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInhociIsIlhNTEh0dHBSZXF1ZXN0IiwidGltZXIiLCJ1cGxvYWQiLCJhZGRFdmVudExpc3RlbmVyIiwibG9nIiwiRGF0ZSIsIm5vdyIsImV2ZW50IiwibG9hZGVkIiwidG90YWwiLCJsZW5ndGhDb21wdXRhYmxlIiwib25Qcm9ncmVzcyIsInByb2dyZXNzIiwiYm9keSIsInBhcnNlIiwicmVzcG9uc2VUZXh0IiwiSXBmc0hhc2giLCJuIiwicmVhZHlTdGF0ZSIsIm9wZW4iLCJzZXRSZXF1ZXN0SGVhZGVyIiwic2VuZCIsInJlcyIsIm1ldGhvZCIsImdldEhlYWRlcnMiLCJnZXRCdWZmZXIiLCJ0ZXh0IiwianNvbiIsIlRoaXJkd2ViU3RvcmFnZSIsInVwbG9hZGVyIiwiZG93bmxvYWRlciIsInJlc29sdmVTY2hlbWUiLCJkb3dubG9hZEpTT04iLCJpdGVtIiwiaXNGaWxlQXJyYXkiLCJldmVyeSIsInVwbG9hZEFuZFJlcGxhY2VGaWxlc1dpdGhIYXNoZXMiLCJnZXRHYXRld2F5VXJscyIsImNsZWFuZWQiLCJNb2NrRG93bmxvYWRlciIsInN0b3JhZ2UiLCJNb2NrVXBsb2FkZXIiLCJjb250ZW50cyIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@thirdweb-dev+storage@2.0.8/node_modules/@thirdweb-dev/storage/dist/thirdweb-dev-storage.esm.js\n");

/***/ })

};
;