"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@thirdweb-dev+merkletree@0.2.0";
exports.ids = ["vendor-chunks/@thirdweb-dev+merkletree@0.2.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@thirdweb-dev+merkletree@0.2.0/node_modules/@thirdweb-dev/merkletree/dist/thirdweb-dev-merkletree.esm.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@thirdweb-dev+merkletree@0.2.0/node_modules/@thirdweb-dev/merkletree/dist/thirdweb-dev-merkletree.esm.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MerkleTree: () => (/* binding */ MerkleTree)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var buffer_reverse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! buffer-reverse */ \"(ssr)/./node_modules/.pnpm/buffer-reverse@1.0.1/node_modules/buffer-reverse/index.js\");\n/* harmony import */ var buffer_reverse__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(buffer_reverse__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var treeify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! treeify */ \"(ssr)/./node_modules/.pnpm/treeify@1.1.0/node_modules/treeify/treeify.js\");\n/* harmony import */ var treeify__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(treeify__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n// ADAPTED FROM https://github.com/merkletreejs/merkletreejs\nclass Base {\n    /**\n   * print\n   * @desc Prints out a visual representation of the merkle tree.\n   * @example\n   *```js\n   *tree.print()\n   *```\n   */ print() {\n        Base.print(this);\n    }\n    /**\n   * bufferIndexOf\n   * @desc Returns the first index of which given buffer is found in array.\n   * @param {Buffer[]} haystack - Array of buffers.\n   * @param {Buffer} needle - Buffer to find.\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = tree.bufferIndexOf(haystack, needle)\n   *```\n   */ bufferIndexOf(array, element) {\n        let isSorted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        if (isSorted) {\n            return this.binarySearch(array, element, buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.compare);\n        }\n        const eqChecker = (buffer1, buffer2)=>buffer1.equals(buffer2);\n        return this.linearSearch(array, element, eqChecker);\n    }\n    /**\n   * binarySearch\n   * @desc Returns the first index of which given item is found in array using binary search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} compareFunction\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = MerkleTree.binarySearch(array, element, Buffer.compare)\n   *```\n   */ static binarySearch(array, element, compareFunction) {\n        let start = 0;\n        let end = array.length - 1;\n        // Iterate while start not meets end\n        while(start <= end){\n            // Find the mid index\n            const mid = Math.floor((start + end) / 2);\n            // Check if the mid value is greater than, equal to, or less than search element.\n            const ordering = compareFunction(array[mid], element);\n            // If element is present at mid, start iterating for searching first appearance.\n            if (ordering === 0) {\n                // Linear reverse iteration until the first matching item index is found.\n                for(let i = mid - 1; i >= 0; i--){\n                    if (compareFunction(array[i], element) === 0) {\n                        continue;\n                    }\n                    return i + 1;\n                }\n                return 0;\n            } else if (ordering < 0) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return -1;\n    }\n    /**\n   * binarySearch\n   * @desc Returns the first index of which given item is found in array using binary search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} compareFunction\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = tree.binarySearch(array, element, Buffer.compare)\n   *```\n   */ binarySearch(array, element, compareFunction) {\n        return Base.binarySearch(array, element, compareFunction);\n    }\n    /**\n   * linearSearch\n   * @desc Returns the first index of which given item is found in array using linear search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} eqChecker\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = MerkleTree.linearSearch(array, element, (a, b) => a === b)\n   *```\n   */ static linearSearch(array, element, eqChecker) {\n        for(let i = 0; i < array.length; i++){\n            if (eqChecker(array[i], element)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n   * linearSearch\n   * @desc Returns the first index of which given item is found in array using linear search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} eqChecker\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = tree.linearSearch(array, element, (a, b) => a === b)\n   *```\n   */ linearSearch(array, element, eqChecker) {\n        return Base.linearSearch(array, element, eqChecker);\n    }\n    /**\n   * bufferify\n   * @desc Returns a buffer type for the given value.\n   * @param {String|Number|Object|Buffer|ArrayBuffer} value\n   * @return {Buffer}\n   *\n   * @example\n   * ```js\n   *const buf = MerkleTree.bufferify('0x1234')\n   *```\n   */ static bufferify(value) {\n        if (!buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(value)) {\n            // crypto-js support\n            if (typeof value === \"object\" && value.words) {\n                return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value.toString(convertWordsToBuffer), \"hex\");\n            } else if (Base.isHexString(value)) {\n                return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value.replace(/^0x/, \"\"), \"hex\");\n            } else if (typeof value === \"string\") {\n                return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value);\n            } else if (typeof value === \"bigint\") {\n                return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value.toString(16), \"hex\");\n            } else if (value instanceof Uint8Array) {\n                return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value.buffer);\n            } else if (typeof value === \"number\") {\n                let s = value.toString();\n                if (s.length % 2) {\n                    s = `0${s}`;\n                }\n                return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(s, \"hex\");\n            } else if (ArrayBuffer.isView(value)) {\n                return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value.buffer, value.byteOffset, value.byteLength);\n            }\n        }\n        return value;\n    }\n    bigNumberify(value) {\n        return Base.bigNumberify(value);\n    }\n    static bigNumberify(value) {\n        if (typeof value === \"bigint\") {\n            return value;\n        }\n        if (typeof value === \"string\") {\n            if (value.startsWith(\"0x\") && Base.isHexString(value)) {\n                return BigInt(\"0x\" + value.replace(\"0x\", \"\").toString());\n            }\n            return BigInt(value);\n        }\n        if (buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(value)) {\n            return BigInt(\"0x\" + value.toString(\"hex\"));\n        }\n        if (value instanceof Uint8Array) {\n            return uint8ArrayToBigInt(value);\n        }\n        if (typeof value === \"number\") {\n            return BigInt(value);\n        }\n        throw new Error(\"cannot bigNumberify\");\n    }\n    /**\n   * isHexString\n   * @desc Returns true if value is a hex string.\n   * @param {String} value\n   * @return {Boolean}\n   *\n   * @example\n   * ```js\n   *console.log(MerkleTree.isHexString('0x1234'))\n   *```\n   */ static isHexString(v) {\n        return typeof v === \"string\" && /^(0x)?[0-9A-Fa-f]*$/.test(v);\n    }\n    /**\n   * print\n   * @desc Prints out a visual representation of the given merkle tree.\n   * @param {Object} tree - Merkle tree instance.\n   * @return {String}\n   * @example\n   *```js\n   *MerkleTree.print(tree)\n   *```\n   */ static print(tree) {\n        console.log(tree.toString());\n    }\n    /**\n   * bufferToHex\n   * @desc Returns a hex string with 0x prefix for given buffer.\n   * @param {Buffer} value\n   * @return {String}\n   * @example\n   *```js\n   *const hexStr = tree.bufferToHex(Buffer.from('A'))\n   *```\n   */ bufferToHex(value) {\n        let withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return Base.bufferToHex(value, withPrefix);\n    }\n    /**\n   * bufferToHex\n   * @desc Returns a hex string with 0x prefix for given buffer.\n   * @param {Buffer} value\n   * @return {String}\n   * @example\n   *```js\n   *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))\n   *```\n   */ static bufferToHex(value) {\n        let withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return `${withPrefix ? \"0x\" : \"\"}${(value || buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0)).toString(\"hex\")}`;\n    }\n    /**\n   * bufferify\n   * @desc Returns a buffer type for the given value.\n   * @param {String|Number|Object|Buffer} value\n   * @return {Buffer}\n   *\n   * @example\n   * ```js\n   *const buf = tree.bufferify('0x1234')\n   *```\n   */ bufferify(value) {\n        return Base.bufferify(value);\n    }\n    /**\n   * bufferifyFn\n   * @desc Returns a function that will bufferify the return value.\n   * @param {Function}\n   * @return {Function}\n   *\n   * @example\n   * ```js\n   *const fn = tree.bufferifyFn((value) => sha256(value))\n   *```\n   */ bufferifyFn(f) {\n        return (value)=>{\n            const v = f(value);\n            if (buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(v)) {\n                return v;\n            }\n            if (this.isHexString(v)) {\n                return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(v.replace(\"0x\", \"\"), \"hex\");\n            }\n            if (typeof v === \"string\") {\n                return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(v);\n            }\n            if (typeof v === \"bigint\") {\n                return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value.toString(16), \"hex\");\n            }\n            if (ArrayBuffer.isView(v)) {\n                return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(v.buffer, v.byteOffset, v.byteLength);\n            }\n            // crypto-js support\n            const arrayBuffer = hexStringToArrayBuffer(value.toString(\"hex\"));\n            // Assuming f now works with ArrayBuffers\n            const processedBuffer = f(arrayBuffer);\n            const hexResult = arrayBufferToHexString(processedBuffer);\n            return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(hexResult, \"hex\");\n        };\n    }\n    /**\n   * isHexString\n   * @desc Returns true if value is a hex string.\n   * @param {String} value\n   * @return {Boolean}\n   *\n   * @example\n   * ```js\n   *console.log(MerkleTree.isHexString('0x1234'))\n   *```\n   */ isHexString(value) {\n        return Base.isHexString(value);\n    }\n    /**\n   * log2\n   * @desc Returns the log2 of number.\n   * @param {Number} value\n   * @return {Number}\n   */ log2(n) {\n        return n === 1 ? 0 : 1 + this.log2(n / 2 | 0);\n    }\n    /**\n   * zip\n   * @desc Returns true if value is a hex string.\n   * @param {String[]|Number[]|Buffer[]} a - first array\n   * @param {String[]|Number[]|Buffer[]} b -  second array\n   * @return {String[][]|Number[][]|Buffer[][]}\n   *\n   * @example\n   * ```js\n   *const zipped = tree.zip(['a', 'b'],['A', 'B'])\n   *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]\n   *```\n   */ zip(a, b) {\n        return a.map((e, i)=>[\n                e,\n                b[i]\n            ]);\n    }\n    static hexZeroPad(hexStr, length) {\n        return \"0x\" + hexStr.replace(\"0x\", \"\").padStart(length, \"0\");\n    }\n}\nvar Base$1 = Base;\n// UTILS\n// replaces CryptoJS.enc.Hex\nfunction convertWordsToBuffer(value) {\n    const wordArray = value.words;\n    const arrayBuffer = new ArrayBuffer(wordArray.length * 4); // 4 bytes per word\n    const uint8View = new Uint8Array(arrayBuffer);\n    for(let i = 0; i < wordArray.length; i++){\n        uint8View[i * 4] = wordArray[i] >> 24 & 0xff;\n        uint8View[i * 4 + 1] = wordArray[i] >> 16 & 0xff;\n        uint8View[i * 4 + 2] = wordArray[i] >> 8 & 0xff;\n        uint8View[i * 4 + 3] = wordArray[i] & 0xff;\n    }\n    return arrayBuffer;\n}\nfunction hexStringToArrayBuffer(hexString) {\n    const buffer = new Uint8Array(hexString.length / 2);\n    for(let i = 0; i < hexString.length; i += 2){\n        buffer[i / 2] = parseInt(hexString.substring(i, i + 2), 16);\n    }\n    return buffer.buffer;\n}\nfunction arrayBufferToHexString(arrayBuffer) {\n    const uint8View = new Uint8Array(arrayBuffer);\n    return Array.from(uint8View).map((byte)=>byte.toString(16).padStart(2, \"0\")).join(\"\");\n}\nfunction uint8ArrayToBigInt(u8a) {\n    const hex = Array.from(u8a).map((byte)=>byte.toString(16).padStart(2, \"0\")).join(\"\");\n    return BigInt(`0x${hex}`);\n}\n// ADAPTED FROM https://github.com/merkletreejs/merkletreejs\n// TODO: Clean up and DRY up code\n// Disclaimer: The multiproof code is unaudited and may possibly contain serious issues. It's in a hacky state as is and needs to be rewritten.\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */ class MerkleTree extends Base$1 {\n    /**\n   * @desc Constructs a Merkle Tree.\n   * All nodes and leaves are stored as Buffers.\n   * Lonely leaf nodes are promoted to the next level up without being hashed again.\n   * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n   * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n   * @param {Object} options - Additional options\n   * @example\n   *```js\n   *const MerkleTree = require('merkletreejs')\n   *const crypto = require('crypto')\n   *\n   *function sha256(data) {\n   *  // returns Buffer\n   *  return crypto.createHash('sha256').update(data).digest()\n   *}\n   *\n   *const leaves = ['a', 'b', 'c'].map(value => keccak(value))\n   *\n   *const tree = new MerkleTree(leaves, sha256)\n   *```\n   */ constructor(leaves, hashFn){\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        super();\n        this.duplicateOdd = false;\n        this.concatenator = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat;\n        this.hashLeaves = false;\n        this.isBitcoinTree = false;\n        this.leaves = [];\n        this.layers = [];\n        this.sortLeaves = false;\n        this.sortPairs = false;\n        this.sort = false;\n        this.fillDefaultHash = null;\n        this.complete = false;\n        if (options.complete) {\n            if (options.isBitcoinTree) {\n                throw new Error('option \"complete\" is incompatible with \"isBitcoinTree\"');\n            }\n            if (options.duplicateOdd) {\n                throw new Error('option \"complete\" is incompatible with \"duplicateOdd\"');\n            }\n        }\n        this.isBitcoinTree = !!options.isBitcoinTree;\n        this.hashLeaves = !!options.hashLeaves;\n        this.sortLeaves = !!options.sortLeaves;\n        this.sortPairs = !!options.sortPairs;\n        this.complete = !!options.complete;\n        if (options.fillDefaultHash) {\n            if (typeof options.fillDefaultHash === \"function\") {\n                this.fillDefaultHash = options.fillDefaultHash;\n            } else if (buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === \"string\") {\n                this.fillDefaultHash = (idx, hashFn)=>options.fillDefaultHash;\n            } else {\n                throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n            }\n        }\n        this.sort = !!options.sort;\n        if (this.sort) {\n            this.sortLeaves = true;\n            this.sortPairs = true;\n        }\n        this.duplicateOdd = !!options.duplicateOdd;\n        if (options.concatenator) {\n            this.concatenator = options.concatenator;\n        }\n        this.hashFn = this.bufferifyFn(hashFn);\n        this.processLeaves(leaves);\n    }\n    getOptions() {\n        return {\n            complete: this.complete,\n            isBitcoinTree: this.isBitcoinTree,\n            hashLeaves: this.hashLeaves,\n            sortLeaves: this.sortLeaves,\n            sortPairs: this.sortPairs,\n            sort: this.sort,\n            fillDefaultHash: this.fillDefaultHash?.toString() ?? null,\n            duplicateOdd: this.duplicateOdd\n        };\n    }\n    processLeaves(leaves) {\n        if (this.hashLeaves) {\n            leaves = leaves.map(this.hashFn);\n        }\n        this.leaves = leaves.map(this.bufferify);\n        if (this.sortLeaves) {\n            this.leaves = this.leaves.sort(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.compare);\n        }\n        if (this.fillDefaultHash) {\n            for(let i = this.leaves.length; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++){\n                this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n            }\n        }\n        this.createHashes(this.leaves);\n    }\n    createHashes(nodes) {\n        this.layers = [\n            nodes\n        ];\n        while(nodes.length > 1){\n            const layerIndex = this.layers.length;\n            this.layers.push([]);\n            const layerLimit = this.complete && layerIndex === 1 && !Number.isInteger(Math.log2(nodes.length)) ? 2 * nodes.length - 2 ** Math.ceil(Math.log2(nodes.length)) : nodes.length;\n            for(let i = 0; i < nodes.length; i += 2){\n                if (i >= layerLimit) {\n                    this.layers[layerIndex].push(...nodes.slice(layerLimit));\n                    break;\n                } else if (i + 1 === nodes.length) {\n                    if (nodes.length % 2 === 1) {\n                        const data = nodes[nodes.length - 1];\n                        let hash = data;\n                        // is bitcoin tree\n                        if (this.isBitcoinTree) {\n                            // Bitcoin method of duplicating the odd ending nodes\n                            hash = this.hashFn(this.concatenator([\n                                buffer_reverse__WEBPACK_IMPORTED_MODULE_1___default()(data),\n                                buffer_reverse__WEBPACK_IMPORTED_MODULE_1___default()(data)\n                            ]));\n                            hash = buffer_reverse__WEBPACK_IMPORTED_MODULE_1___default()(this.hashFn(hash));\n                            this.layers[layerIndex].push(hash);\n                            continue;\n                        } else {\n                            if (this.duplicateOdd) ;\n                            else {\n                                // push copy of hash and continue iteration\n                                this.layers[layerIndex].push(nodes[i]);\n                                continue;\n                            }\n                        }\n                    }\n                }\n                const left = nodes[i];\n                const right = i + 1 === nodes.length ? left : nodes[i + 1];\n                let combined = null;\n                if (this.isBitcoinTree) {\n                    combined = [\n                        buffer_reverse__WEBPACK_IMPORTED_MODULE_1___default()(left),\n                        buffer_reverse__WEBPACK_IMPORTED_MODULE_1___default()(right)\n                    ];\n                } else {\n                    combined = [\n                        left,\n                        right\n                    ];\n                }\n                if (this.sortPairs) {\n                    combined.sort(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.compare);\n                }\n                let hash = this.hashFn(this.concatenator(combined));\n                // double hash if bitcoin tree\n                if (this.isBitcoinTree) {\n                    hash = buffer_reverse__WEBPACK_IMPORTED_MODULE_1___default()(this.hashFn(hash));\n                }\n                this.layers[layerIndex].push(hash);\n            }\n            nodes = this.layers[layerIndex];\n        }\n    }\n    /**\n   * addLeaf\n   * @desc Adds a leaf to the tree and re-calculates layers.\n   * @param {String|Buffer} - Leaf\n   * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.\n   * @example\n   *```js\n   *tree.addLeaf(newLeaf)\n   *```\n   */ addLeaf(leaf) {\n        let shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (shouldHash) {\n            leaf = this.hashFn(leaf);\n        }\n        this.processLeaves(this.leaves.concat(leaf));\n    }\n    /**\n   * addLeaves\n   * @desc Adds multiple leaves to the tree and re-calculates layers.\n   * @param {String[]|Buffer[]} - Array of leaves\n   * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.\n   * @example\n   *```js\n   *tree.addLeaves(newLeaves)\n   *```\n   */ addLeaves(leaves) {\n        let shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (shouldHash) {\n            leaves = leaves.map(this.hashFn);\n        }\n        this.processLeaves(this.leaves.concat(leaves));\n    }\n    /**\n   * getLeaves\n   * @desc Returns array of leaves of Merkle Tree.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const leaves = tree.getLeaves()\n   *```\n   */ getLeaves(values) {\n        if (Array.isArray(values)) {\n            if (this.hashLeaves) {\n                values = values.map(this.hashFn);\n                if (this.sortLeaves) {\n                    values = values.sort(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.compare);\n                }\n            }\n            return this.leaves.filter(// @ts-expect-error - issue from original code\n            (leaf)=>this.bufferIndexOf(values, leaf, this.sortLeaves) !== -1);\n        }\n        return this.leaves;\n    }\n    /**\n   * getLeaf\n   * @desc Returns the leaf at the given index.\n   * @param {Number} - Index number\n   * @return {Buffer}\n   * @example\n   *```js\n   *const leaf = tree.getLeaf(1)\n   *```\n   */ getLeaf(index) {\n        if (index < 0 || index > this.leaves.length - 1) {\n            return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([]);\n        }\n        return this.leaves[index];\n    }\n    /**\n   * getLeafIndex\n   * @desc Returns the index of the given leaf, or -1 if the leaf is not found.\n   * @param {String|Buffer} - Target leaf\n   * @return {number}\n   * @example\n   *```js\n   *const leaf = Buffer.from('abc')\n   *const index = tree.getLeafIndex(leaf)\n   *```\n   */ getLeafIndex(target) {\n        target = this.bufferify(target);\n        const leaves = this.getLeaves();\n        for(let i = 0; i < leaves.length; i++){\n            const leaf = leaves[i];\n            if (leaf.equals(target)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n   * getLeafCount\n   * @desc Returns the total number of leaves.\n   * @return {number}\n   * @example\n   *```js\n   *const count = tree.getLeafCount()\n   *```\n   */ getLeafCount() {\n        return this.leaves.length;\n    }\n    /**\n   * getHexLeaves\n   * @desc Returns array of leaves of Merkle Tree as hex strings.\n   * @return {String[]}\n   * @example\n   *```js\n   *const leaves = tree.getHexLeaves()\n   *```\n   */ getHexLeaves() {\n        return this.leaves.map((leaf)=>this.bufferToHex(leaf));\n    }\n    /**\n   * marshalLeaves\n   * @desc Returns array of leaves of Merkle Tree as a JSON string.\n   * @param {String[]|Buffer[]} - Merkle tree leaves\n   * @return {String} - List of leaves as JSON string\n   * @example\n   *```js\n   *const jsonStr = MerkleTree.marshalLeaves(leaves)\n   *```\n   */ static marshalLeaves(leaves) {\n        return JSON.stringify(leaves.map((leaf)=>MerkleTree.bufferToHex(leaf)), null, 2);\n    }\n    /**\n   * unmarshalLeaves\n   * @desc Returns array of leaves of Merkle Tree as a Buffers.\n   * @param {String|Object} - JSON stringified leaves\n   * @return {Buffer[]} - Unmarshalled list of leaves\n   * @example\n   *```js\n   *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n   *```\n   */ static unmarshalLeaves(jsonStr) {\n        let parsed = null;\n        if (typeof jsonStr === \"string\") {\n            parsed = JSON.parse(jsonStr);\n        } else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        } else {\n            throw new Error(\"Expected type of string or object\");\n        }\n        if (!parsed) {\n            return [];\n        }\n        if (!Array.isArray(parsed)) {\n            throw new Error(\"Expected JSON string to be array\");\n        }\n        return parsed.map(MerkleTree.bufferify);\n    }\n    /**\n   * getLayers\n   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n   * @return {Buffer[][]}\n   * @example\n   *```js\n   *const layers = tree.getLayers()\n   *```\n   */ getLayers() {\n        return this.layers;\n    }\n    /**\n   * getHexLayers\n   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n   * @return {String[][]}\n   * @example\n   *```js\n   *const layers = tree.getHexLayers()\n   *```\n   */ getHexLayers() {\n        return this.layers.reduce((acc, item)=>{\n            if (Array.isArray(item)) {\n                acc.push(item.map((layer)=>this.bufferToHex(layer)));\n            } else {\n                acc.push(item);\n            }\n            return acc;\n        }, []);\n    }\n    /**\n   * getLayersFlat\n   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const layers = tree.getLayersFlat()\n   *```\n   */ getLayersFlat() {\n        const layers = this.layers.reduce((acc, item)=>{\n            if (Array.isArray(item)) {\n                acc.unshift(...item);\n            } else {\n                acc.unshift(item);\n            }\n            return acc;\n        }, []);\n        layers.unshift(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n            0\n        ]));\n        return layers;\n    }\n    /**\n   * getHexLayersFlat\n   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n   * @return {String[]}\n   * @example\n   *```js\n   *const layers = tree.getHexLayersFlat()\n   *```\n   */ getHexLayersFlat() {\n        return this.getLayersFlat().map((layer)=>this.bufferToHex(layer));\n    }\n    /**\n   * getLayerCount\n   * @desc Returns the total number of layers.\n   * @return {number}\n   * @example\n   *```js\n   *const count = tree.getLayerCount()\n   *```\n   */ getLayerCount() {\n        return this.getLayers().length;\n    }\n    /**\n   * getRoot\n   * @desc Returns the Merkle root hash as a Buffer.\n   * @return {Buffer}\n   * @example\n   *```js\n   *const root = tree.getRoot()\n   *```\n   */ getRoot() {\n        if (this.layers.length === 0) {\n            return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([]);\n        }\n        return this.layers[this.layers.length - 1][0] || buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([]);\n    }\n    /**\n   * getHexRoot\n   * @desc Returns the Merkle root hash as a hex string.\n   * @return {String}\n   * @example\n   *```js\n   *const root = tree.getHexRoot()\n   *```\n   */ getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n   * getProof\n   * @desc Returns the proof for a target leaf.\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {Object[]} - Array of objects containing a position property of type string\n   * with values of 'left' or 'right' and a data property of type Buffer.\n   * @example\n   * ```js\n   *const proof = tree.getProof(leaves[2])\n   *```\n   *\n   * @example\n   *```js\n   *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n   *const tree = new MerkleTree(leaves, keccak)\n   *const proof = tree.getProof(leaves[2], 2)\n   *```\n   */ getProof(leaf, index) {\n        if (typeof leaf === \"undefined\") {\n            throw new Error(\"leaf is required\");\n        }\n        leaf = this.bufferify(leaf);\n        const proof = [];\n        if (!Number.isInteger(index)) {\n            index = -1;\n            for(let i = 0; i < this.leaves.length; i++){\n                if (buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.compare(leaf, this.leaves[i]) === 0) {\n                    index = i;\n                }\n            }\n        }\n        // @ts-expect-error - issue from original code\n        if (index <= -1) {\n            return [];\n        }\n        for(let i = 0; i < this.layers.length; i++){\n            const layer = this.layers[i];\n            // @ts-expect-error - issue from original code\n            const isRightNode = index % 2;\n            const pairIndex = isRightNode ? // @ts-expect-error - issue from original code\n            index - 1 : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1 ? // Proof Generation for Bitcoin Trees\n            index : // Proof Generation for Non-Bitcoin Trees\n            // @ts-expect-error - issue from original code\n            index + 1;\n            if (pairIndex < layer.length) {\n                proof.push({\n                    position: isRightNode ? \"left\" : \"right\",\n                    data: layer[pairIndex]\n                });\n            }\n            // set index to parent index\n            // @ts-expect-error - issue from original code\n            index = index / 2 | 0;\n        }\n        // @ts-expect-error - issue from original code\n        return proof;\n    }\n    /**\n   * getHexProof\n   * @desc Returns the proof for a target leaf as hex strings.\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {String[]} - Proof array as hex strings.\n   * @example\n   * ```js\n   *const proof = tree.getHexProof(leaves[2])\n   *```\n   */ getHexProof(leaf, index) {\n        return this.getProof(leaf, index).map((item)=>this.bufferToHex(item.data));\n    }\n    /**\n   * getProofs\n   * @desc Returns the proofs for all leaves.\n   * @return {Object[]} - Array of objects containing a position property of type string\n   * with values of 'left' or 'right' and a data property of type Buffer for all leaves.\n   * @example\n   * ```js\n   *const proofs = tree.getProofs()\n   *```\n   *\n   * @example\n   *```js\n   *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n   *const tree = new MerkleTree(leaves, keccak)\n   *const proofs = tree.getProofs()\n   *```\n   */ getProofs() {\n        // @ts-expect-error - issue from original code\n        const proof = [];\n        // @ts-expect-error - issue from original code\n        const proofs = [];\n        // @ts-expect-error - issue from original code\n        this.getProofsDFS(this.layers.length - 1, 0, proof, proofs);\n        // @ts-expect-error - issue from original code\n        return proofs;\n    }\n    /**\n   * getProofsDFS\n   * @desc Get all proofs through single traverse\n   * @param {Number} currentLayer - Current layer index in traverse.\n   * @param {Number} index - Current tarvese node index in traverse.\n   * @param {Object[]} proof - Proof chain for single leaf.\n   * @param {Object[]} proofs - Proofs for all leaves\n   * @example\n   * ```js\n   *const layers = tree.getLayers()\n   *const index = 0;\n   *let proof = [];\n   *let proofs = [];\n   *const proof = tree.getProofsDFS(layers, index, proof, proofs)\n   *```\n   */ // @ts-expect-error - issue from original code\n    getProofsDFS(currentLayer, index, proof, proofs) {\n        const isRightNode = index % 2;\n        if (currentLayer === -1) {\n            if (!isRightNode) {\n                proofs.push([\n                    ...proof\n                ].reverse());\n            }\n            // @ts-expect-error - issue from original code\n            return;\n        }\n        if (index >= this.layers[currentLayer].length) {\n            // @ts-expect-error - issue from original code\n            return;\n        }\n        const layer = this.layers[currentLayer];\n        const pairIndex = isRightNode ? index - 1 : index + 1;\n        let pushed = false;\n        if (pairIndex < layer.length) {\n            pushed = true;\n            proof.push({\n                position: isRightNode ? \"left\" : \"right\",\n                data: layer[pairIndex]\n            });\n        }\n        const leftchildIndex = index * 2;\n        const rightchildIndex = index * 2 + 1;\n        this.getProofsDFS(currentLayer - 1, leftchildIndex, proof, proofs);\n        this.getProofsDFS(currentLayer - 1, rightchildIndex, proof, proofs);\n        if (pushed) {\n            proof.splice(proof.length - 1, 1);\n        }\n    }\n    /**\n   * getHexProofs\n   * @desc Returns the proofs for all leaves as hex strings.\n   * @return {String[]} - Proofs array as hex strings.\n   * @example\n   * ```js\n   *const proofs = tree.getHexProofs()\n   *```\n   */ getHexProofs() {\n        return this.getProofs().map((item)=>this.bufferToHex(item.data));\n    }\n    /**\n   * getPositionalHexProof\n   * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n   * @example\n   * ```js\n   *const proof = tree.getPositionalHexProof(leaves[2])\n   *```\n   */ getPositionalHexProof(leaf, index) {\n        return this.getProof(leaf, index).map((item)=>{\n            return [\n                item.position === \"left\" ? 0 : 1,\n                this.bufferToHex(item.data)\n            ];\n        });\n    }\n    /**\n   * getProofIndices\n   * @desc Returns the proof indices for given tree indices.\n   * @param {Number[]} treeIndices - Tree indices\n   * @param {Number} depth - Tree depth; number of layers.\n   * @return {Number[]} - Proof indices\n   * @example\n   * ```js\n   *const proofIndices = tree.getProofIndices([2,5,6], 4)\n   *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n   *```\n   */ getProofIndices(treeIndices, depth) {\n        const leafCount = 2 ** depth;\n        let maximalIndices = new Set();\n        for (const index of treeIndices){\n            let x = leafCount + index;\n            while(x > 1){\n                maximalIndices.add(x ^ 1);\n                x = x / 2 | 0;\n            }\n        }\n        const a = treeIndices.map((index)=>leafCount + index);\n        const b = Array.from(maximalIndices).sort((x, y)=>x - y).reverse();\n        maximalIndices = a.concat(b);\n        const redundantIndices = new Set();\n        const proof = [];\n        for (let index of maximalIndices){\n            if (!redundantIndices.has(index)) {\n                proof.push(index);\n                while(index > 1){\n                    redundantIndices.add(index);\n                    if (!redundantIndices.has(index ^ 1)) {\n                        break;\n                    }\n                    index = index / 2 | 0;\n                }\n            }\n        }\n        return proof.filter((index)=>{\n            return !treeIndices.includes(index - leafCount);\n        });\n    }\n    getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {\n        const depth = Math.ceil(Math.log2(leavesCount));\n        const unevenLayers = [];\n        for(let index = 0; index < depth; index++){\n            const unevenLayer = leavesCount % 2 !== 0;\n            if (unevenLayer) {\n                unevenLayers.push({\n                    index,\n                    leavesCount\n                });\n            }\n            leavesCount = Math.ceil(leavesCount / 2);\n        }\n        const proofIndices = [];\n        let layerNodes = sortedLeafIndices;\n        for(let layerIndex = 0; layerIndex < depth; layerIndex++){\n            const siblingIndices = layerNodes.map((index)=>{\n                if (index % 2 === 0) {\n                    return index + 1;\n                }\n                return index - 1;\n            });\n            let proofNodeIndices = siblingIndices.filter((index)=>!layerNodes.includes(index));\n            const unevenLayer = unevenLayers.find((_ref)=>{\n                let { index } = _ref;\n                return index === layerIndex;\n            });\n            if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {\n                proofNodeIndices = proofNodeIndices.slice(0, -1);\n            }\n            proofIndices.push(proofNodeIndices);\n            layerNodes = [\n                ...new Set(layerNodes.map((index)=>{\n                    if (index % 2 === 0) {\n                        return index / 2;\n                    }\n                    if (index % 2 === 0) {\n                        return (index + 1) / 2;\n                    }\n                    return (index - 1) / 2;\n                }))\n            ];\n        }\n        return proofIndices;\n    }\n    /**\n   * getMultiProof\n   * @desc Returns the multiproof for given tree indices.\n   * @param {Number[]} indices - Tree indices.\n   * @return {Buffer[]} - Multiproofs\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getMultiProof(indices)\n   *```\n   */ getMultiProof(tree, indices) {\n        if (!this.complete) {\n            console.warn(\"Warning: For correct multiProofs it's strongly recommended to set complete: true\");\n        }\n        if (!indices) {\n            indices = tree;\n            tree = this.getLayersFlat();\n        }\n        const isUneven = this.isUnevenTree();\n        if (isUneven) {\n            // @ts-expect-error - issue from original code\n            if (indices.every(Number.isInteger)) {\n                return this.getMultiProofForUnevenTree(indices);\n            }\n        }\n        // @ts-expect-error - issue from original code\n        if (!indices.every(Number.isInteger)) {\n            let els = indices;\n            if (this.sortPairs) {\n                // @ts-expect-error - issue from original code\n                els = els.sort(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.compare);\n            }\n            // @ts-expect-error - issue from original code\n            let ids = els.map((el)=>this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b)=>a === b ? 0 : a > b ? 1 : -1);\n            if (!ids.every((idx)=>idx !== -1)) {\n                throw new Error(\"Element does not exist in Merkle tree\");\n            }\n            // @ts-expect-error - issue from original code\n            const hashes = [];\n            const proof = [];\n            let nextIds = [];\n            for(let i = 0; i < this.layers.length; i++){\n                const layer = this.layers[i];\n                for(let j = 0; j < ids.length; j++){\n                    const idx = ids[j];\n                    const pairElement = this.getPairNode(layer, idx);\n                    hashes.push(layer[idx]);\n                    if (pairElement) {\n                        proof.push(pairElement);\n                    }\n                    nextIds.push(idx / 2 | 0);\n                }\n                ids = nextIds.filter((value, j, self)=>self.indexOf(value) === j);\n                nextIds = [];\n            }\n            // @ts-expect-error - issue from original code\n            return proof.filter((value)=>!hashes.includes(value));\n        }\n        // @ts-expect-error - issue from original code\n        return this.getProofIndices(indices, Math.log2(tree.length / 2 | 0)).map(// @ts-expect-error - issue from original code\n        (index)=>tree[index]);\n    }\n    getMultiProofForUnevenTree(tree, indices) {\n        if (!indices) {\n            indices = tree;\n            tree = this.getLayers();\n        }\n        let proofHashes = [];\n        // @ts-expect-error - issue from original code\n        let currentLayerIndices = indices;\n        // @ts-expect-error - issue from original code\n        for (const treeLayer of tree){\n            const siblings = [];\n            for (const index of currentLayerIndices){\n                if (index % 2 === 0) {\n                    const idx = index + 1;\n                    if (!currentLayerIndices.includes(idx)) {\n                        if (treeLayer[idx]) {\n                            siblings.push(treeLayer[idx]);\n                            continue;\n                        }\n                    }\n                }\n                const idx = index - 1;\n                if (!currentLayerIndices.includes(idx)) {\n                    if (treeLayer[idx]) {\n                        siblings.push(treeLayer[idx]);\n                        continue;\n                    }\n                }\n            }\n            proofHashes = proofHashes.concat(siblings);\n            const uniqueIndices = new Set();\n            for (const index of currentLayerIndices){\n                if (index % 2 === 0) {\n                    uniqueIndices.add(index / 2);\n                    continue;\n                }\n                if (index % 2 === 0) {\n                    uniqueIndices.add((index + 1) / 2);\n                    continue;\n                }\n                uniqueIndices.add((index - 1) / 2);\n            }\n            currentLayerIndices = Array.from(uniqueIndices);\n        }\n        return proofHashes;\n    }\n    /**\n   * getHexMultiProof\n   * @desc Returns the multiproof for given tree indices as hex strings.\n   * @param {Number[]} indices - Tree indices.\n   * @return {String[]} - Multiproofs as hex strings.\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getHexMultiProof(indices)\n   *```\n   */ getHexMultiProof(tree, indices) {\n        return this.getMultiProof(tree, indices).map((x)=>this.bufferToHex(x));\n    }\n    /**\n   * getProofFlags\n   * @desc Returns list of booleans where proofs should be used instead of hashing.\n   * Proof flags are used in the Solidity multiproof verifiers.\n   * @param {Number[]|Buffer[]} leaves\n   * @param {Buffer[]} proofs\n   * @return {Boolean[]} - Boolean flags\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getMultiProof(indices)\n   *const proofFlags = tree.getProofFlags(leaves, proof)\n   *```\n   */ getProofFlags(leaves, proofs) {\n        if (!Array.isArray(leaves) || leaves.length <= 0) {\n            throw new Error(\"Invalid Inputs!\");\n        }\n        let ids;\n        if (leaves.every(Number.isInteger)) {\n            ids = [\n                ...leaves\n            ].sort((a, b)=>a === b ? 0 : a > b ? 1 : -1); // Indices where passed\n        } else {\n            ids = leaves.map((el)=>this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b)=>a === b ? 0 : a > b ? 1 : -1);\n        }\n        if (!ids.every((idx)=>idx !== -1)) {\n            throw new Error(\"Element does not exist in Merkle tree\");\n        }\n        const _proofs = proofs.map((item)=>this.bufferify(item));\n        // @ts-expect-error - issue from original code\n        const tested = [];\n        // @ts-expect-error - issue from original code\n        const flags = [];\n        for(let index = 0; index < this.layers.length; index++){\n            const layer = this.layers[index];\n            ids = ids.reduce((ids_, idx)=>{\n                // @ts-expect-error - issue from original code\n                const skipped = tested.includes(layer[idx]);\n                if (!skipped) {\n                    const pairElement = this.getPairNode(layer, idx);\n                    const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n                    // eslint-disable-next-line no-unused-expressions\n                    pairElement && flags.push(!proofUsed);\n                    tested.push(layer[idx]);\n                    tested.push(pairElement);\n                }\n                // @ts-expect-error - issue from original code\n                ids_.push(idx / 2 | 0);\n                return ids_;\n            }, []);\n        }\n        // @ts-expect-error - issue from original code\n        return flags;\n    }\n    /**\n   * verify\n   * @desc Returns true if the proof path (array of hashes) can connect the target node\n   * to the Merkle root.\n   * @param {Object[]} proof - Array of proof objects that should connect\n   * target node to Merkle root.\n   * @param {Buffer} targetNode - Target node Buffer\n   * @param {Buffer} root - Merkle root Buffer\n   * @return {Boolean}\n   * @example\n   *```js\n   *const root = tree.getRoot()\n   *const proof = tree.getProof(leaves[2])\n   *const verified = tree.verify(proof, leaves[2], root)\n   *```\n   */ verify(proof, targetNode, root) {\n        let hash = this.bufferify(targetNode);\n        root = this.bufferify(root);\n        if (!Array.isArray(proof) || !targetNode || !root) {\n            return false;\n        }\n        for(let i = 0; i < proof.length; i++){\n            const node = proof[i];\n            let data = null;\n            let isLeftNode = null;\n            // case for when proof is hex values only\n            if (typeof node === \"string\") {\n                data = this.bufferify(node);\n                isLeftNode = true;\n            } else if (Array.isArray(node)) {\n                isLeftNode = node[0] === 0;\n                data = this.bufferify(node[1]);\n            } else if (buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(node)) {\n                data = node;\n                isLeftNode = true;\n            } else if (node instanceof Object) {\n                data = this.bufferify(node.data);\n                isLeftNode = node.position === \"left\";\n            } else {\n                throw new Error(\"Expected node to be of type string or object\");\n            }\n            const buffers = [];\n            if (this.isBitcoinTree) {\n                buffers.push(buffer_reverse__WEBPACK_IMPORTED_MODULE_1___default()(hash));\n                buffers[isLeftNode ? \"unshift\" : \"push\"](buffer_reverse__WEBPACK_IMPORTED_MODULE_1___default()(data));\n                hash = this.hashFn(this.concatenator(buffers));\n                hash = buffer_reverse__WEBPACK_IMPORTED_MODULE_1___default()(this.hashFn(hash));\n            } else {\n                if (this.sortPairs) {\n                    if (buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.compare(hash, data) === -1) {\n                        buffers.push(hash, data);\n                        hash = this.hashFn(this.concatenator(buffers));\n                    } else {\n                        buffers.push(data, hash);\n                        hash = this.hashFn(this.concatenator(buffers));\n                    }\n                } else {\n                    buffers.push(hash);\n                    buffers[isLeftNode ? \"unshift\" : \"push\"](data);\n                    hash = this.hashFn(this.concatenator(buffers));\n                }\n            }\n        }\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.compare(hash, root) === 0;\n    }\n    /**\n   * verifyMultiProof\n   * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n   * @param {Buffer} root - Merkle tree root\n   * @param {Number[]} proofIndices - Leave indices for proof\n   * @param {Buffer[]} proofLeaves - Leaf values at indices for proof\n   * @param {Number} leavesCount - Count of original leaves\n   * @param {Buffer[]} proof - Multiproofs given indices\n   * @return {Boolean}\n   * @example\n   *```js\n   *const leaves = tree.getLeaves()\n   *const root = tree.getRoot()\n   *const treeFlat = tree.getLayersFlat()\n   *const leavesCount = leaves.length\n   *const proofIndices = [2, 5, 6]\n   *const proofLeaves = proofIndices.map(i => leaves[i])\n   *const proof = tree.getMultiProof(treeFlat, indices)\n   *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)\n   *```\n   */ verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {\n        const isUneven = this.isUnevenTree();\n        if (isUneven) {\n            // TODO: combine these functions and simplify\n            return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);\n        }\n        const depth = Math.ceil(Math.log2(leavesCount));\n        root = this.bufferify(root);\n        proofLeaves = proofLeaves.map((leaf)=>this.bufferify(leaf));\n        proof = proof.map((leaf)=>this.bufferify(leaf));\n        const tree = {};\n        for (const [index, leaf] of this.zip(proofIndices, proofLeaves)){\n            // @ts-expect-error - issue from original code\n            tree[2 ** depth + index] = leaf;\n        }\n        for (const [index, proofitem] of this.zip(this.getProofIndices(proofIndices, depth), proof)){\n            // @ts-expect-error - issue from original code\n            tree[index] = proofitem;\n        }\n        let indexqueue = Object.keys(tree).map((value)=>Number(value)).sort((a, b)=>a - b);\n        indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n        let i = 0;\n        while(i < indexqueue.length){\n            const index = indexqueue[i];\n            if (index >= 2 && ({}).hasOwnProperty.call(tree, index ^ 1)) {\n                // @ts-expect-error - issue from original code\n                let pair = [\n                    tree[index - index % 2],\n                    tree[index - index % 2 + 1]\n                ];\n                if (this.sortPairs) {\n                    pair = pair.sort(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.compare);\n                }\n                const hash = pair[1] ? this.hashFn(this.concatenator(pair)) : pair[0];\n                // @ts-expect-error - issue from original code\n                tree[index / 2 | 0] = hash;\n                indexqueue.push(index / 2 | 0);\n            }\n            i += 1;\n        }\n        return !proofIndices.length || // @ts-expect-error - issue from original code\n        ({}).hasOwnProperty.call(tree, 1) && tree[1].equals(root);\n    }\n    verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {\n        root = this.bufferify(root);\n        leaves = leaves.map(this.bufferify);\n        proofs = proofs.map(this.bufferify);\n        const leavesLen = leaves.length;\n        const totalHashes = proofFlag.length;\n        const hashes = [];\n        let leafPos = 0;\n        let hashPos = 0;\n        let proofPos = 0;\n        for(let i = 0; i < totalHashes; i++){\n            const bufA = proofFlag[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];\n            const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            const buffers = [\n                bufA,\n                bufB\n            ].sort(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.compare);\n            hashes[i] = this.hashFn(this.concatenator(buffers));\n        }\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.compare(hashes[totalHashes - 1], root) === 0;\n    }\n    verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {\n        root = this.bufferify(root);\n        leaves = leaves.map((leaf)=>this.bufferify(leaf));\n        proof = proof.map((leaf)=>this.bufferify(leaf));\n        const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);\n        return root.equals(computedRoot);\n    }\n    /**\n   * getDepth\n   * @desc Returns the tree depth (number of layers)\n   * @return {Number}\n   * @example\n   *```js\n   *const depth = tree.getDepth()\n   *```\n   */ getDepth() {\n        return this.getLayers().length - 1;\n    }\n    /**\n   * getLayersAsObject\n   * @desc Returns the layers as nested objects instead of an array.\n   * @example\n   *```js\n   *const layersObj = tree.getLayersAsObject()\n   *```\n   */ getLayersAsObject() {\n        const layers = this.getLayers().map((layer)=>layer.map((value)=>this.bufferToHex(value, false)));\n        const objs = [];\n        for(let i = 0; i < layers.length; i++){\n            const arr = [];\n            for(let j = 0; j < layers[i].length; j++){\n                const obj = {\n                    [layers[i][j]]: null\n                };\n                if (objs.length) {\n                    // @ts-expect-error - issue from original code\n                    obj[layers[i][j]] = {};\n                    const a = objs.shift();\n                    // @ts-expect-error - issue from original code\n                    const akey = Object.keys(a)[0];\n                    // @ts-expect-error - issue from original code\n                    obj[layers[i][j]][akey] = a[akey];\n                    if (objs.length) {\n                        const b = objs.shift();\n                        // @ts-expect-error - issue from original code\n                        const bkey = Object.keys(b)[0];\n                        // @ts-expect-error - issue from original code\n                        obj[layers[i][j]][bkey] = b[bkey];\n                    }\n                }\n                arr.push(obj);\n            }\n            objs.push(...arr);\n        }\n        return objs[0];\n    }\n    /**\n   * resetTree\n   * @desc Resets the tree by clearing the leaves and layers.\n   * @example\n   *```js\n   *tree.resetTree()\n   *```\n   */ resetTree() {\n        this.leaves = [];\n        this.layers = [];\n    }\n    /**\n   * getPairNode\n   * @desc Returns the node at the index for given layer.\n   * @param {Buffer[]} layer - Tree layer\n   * @param {Number} index - Index at layer.\n   * @return {Buffer} - Node\n   *\n   *@example\n   * ```js\n   *const node = tree.getPairNode(layer, index)\n   *```\n   */ getPairNode(layer, idx) {\n        const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n        if (pairIdx < layer.length) {\n            return layer[pairIdx];\n        } else {\n            // @ts-expect-error - issue from original code\n            return null;\n        }\n    }\n    /**\n   * toTreeString\n   * @desc Returns a visual representation of the merkle tree as a string.\n   * @return {String}\n   * @example\n   *```js\n   *console.log(tree.toTreeString())\n   *```\n   */ toTreeString() {\n        const obj = this.getLayersAsObject();\n        return (0,treeify__WEBPACK_IMPORTED_MODULE_2__.asTree)(obj, true, false);\n    }\n    /**\n   * toString\n   * @desc Returns a visual representation of the merkle tree as a string.\n   * @example\n   *```js\n   *console.log(tree.toString())\n   *```\n   */ toString() {\n        return this.toTreeString();\n    }\n    isUnevenTree(treeLayers) {\n        const depth = treeLayers?.length || this.getDepth();\n        return !this.isPowOf2(depth);\n    }\n    isPowOf2(v) {\n        return v && !(v & v - 1);\n    }\n    calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {\n        const leafTuples = this.zip(leafIndices, leafHashes).sort((_ref2, _ref3)=>{\n            let [indexA] = _ref2;\n            let [indexB] = _ref3;\n            return indexA - indexB;\n        });\n        const leafTupleIndices = leafTuples.map((_ref4)=>{\n            let [index] = _ref4;\n            return index;\n        });\n        const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);\n        let nextSliceStart = 0;\n        const proofTuplesByLayers = [];\n        for(let i = 0; i < proofIndices.length; i++){\n            const indices = proofIndices[i];\n            const sliceStart = nextSliceStart;\n            nextSliceStart += indices.length;\n            proofTuplesByLayers[i] = this.zip(indices, proofHashes.slice(sliceStart, nextSliceStart));\n        }\n        const tree = [\n            leafTuples\n        ];\n        for(let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++){\n            const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex])// @ts-expect-error - issue from original code\n            .sort((_ref5, _ref6)=>{\n                let [indexA] = _ref5;\n                let [indexB] = _ref6;\n                return indexA - indexB;\n            })// @ts-expect-error - issue from original code\n            .map((_ref7)=>{\n                let [, hash] = _ref7;\n                return hash;\n            });\n            const s = tree[layerIndex].map((_ref8)=>{\n                let [layerIndex_] = _ref8;\n                return layerIndex_;\n            });\n            const parentIndices = [\n                ...new Set(s.map((index)=>{\n                    if (index % 2 === 0) {\n                        return index / 2;\n                    }\n                    if (index % 2 === 0) {\n                        return (index + 1) / 2;\n                    }\n                    return (index - 1) / 2;\n                }))\n            ];\n            const parentLayer = [];\n            for(let i = 0; i < parentIndices.length; i++){\n                const parentNodeTreeIndex = parentIndices[i];\n                const bufA = currentLayer[i * 2];\n                const bufB = currentLayer[i * 2 + 1];\n                const hash = bufB ? this.hashFn(this.concatenator([\n                    bufA,\n                    bufB\n                ])) : bufA;\n                parentLayer.push([\n                    parentNodeTreeIndex,\n                    hash\n                ]);\n            }\n            tree.push(parentLayer);\n        }\n        return tree[tree.length - 1][0][1];\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRoaXJkd2ViLWRldittZXJrbGV0cmVlQDAuMi4wL25vZGVfbW9kdWxlcy9AdGhpcmR3ZWItZGV2L21lcmtsZXRyZWUvZGlzdC90aGlyZHdlYi1kZXYtbWVya2xldHJlZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFnQztBQUNLO0FBQ0o7QUFFakMsNERBQTREO0FBQzVELE1BQU1HO0lBQ0o7Ozs7Ozs7R0FPQyxHQUNEQyxRQUFRO1FBQ05ELEtBQUtDLEtBQUssQ0FBQyxJQUFJO0lBQ2pCO0lBRUE7Ozs7Ozs7Ozs7O0dBV0MsR0FDREMsY0FBY0MsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDNUIsSUFBSUMsV0FBV0MsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDbkYsSUFBSUQsVUFBVTtZQUNaLE9BQU8sSUFBSSxDQUFDSSxZQUFZLENBQUNOLE9BQU9DLFNBQVNQLDBDQUFNQSxDQUFDYSxPQUFPO1FBQ3pEO1FBQ0EsTUFBTUMsWUFBWSxDQUFDQyxTQUFTQyxVQUFZRCxRQUFRRSxNQUFNLENBQUNEO1FBQ3ZELE9BQU8sSUFBSSxDQUFDRSxZQUFZLENBQUNaLE9BQU9DLFNBQVNPO0lBQzNDO0lBRUE7Ozs7Ozs7Ozs7OztHQVlDLEdBQ0QsT0FBT0YsYUFBYU4sS0FBSyxFQUFFQyxPQUFPLEVBQUVZLGVBQWUsRUFBRTtRQUNuRCxJQUFJQyxRQUFRO1FBQ1osSUFBSUMsTUFBTWYsTUFBTUksTUFBTSxHQUFHO1FBRXpCLG9DQUFvQztRQUNwQyxNQUFPVSxTQUFTQyxJQUFLO1lBQ25CLHFCQUFxQjtZQUNyQixNQUFNQyxNQUFNQyxLQUFLQyxLQUFLLENBQUMsQ0FBQ0osUUFBUUMsR0FBRSxJQUFLO1lBRXZDLGlGQUFpRjtZQUNqRixNQUFNSSxXQUFXTixnQkFBZ0JiLEtBQUssQ0FBQ2dCLElBQUksRUFBRWY7WUFFN0MsZ0ZB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QkFDakI7b0JBQ0EsSUFBSUEsUUFBUSxNQUFNLEdBQUc7d0JBQ25CLE9BQU8sQ0FBQ0EsUUFBUSxLQUFLO29CQUN2QjtvQkFDQSxPQUFPLENBQUNBLFFBQVEsS0FBSztnQkFDdkI7YUFBSTtZQUNKLE1BQU13SixjQUFjLEVBQUU7WUFDdEIsSUFBSyxJQUFJN1AsSUFBSSxHQUFHQSxJQUFJNFAsY0FBYzVRLE1BQU0sRUFBRWdCLElBQUs7Z0JBQzdDLE1BQU04UCxzQkFBc0JGLGFBQWEsQ0FBQzVQLEVBQUU7Z0JBQzVDLE1BQU15TixPQUFPbEYsWUFBWSxDQUFDdkksSUFBSSxFQUFFO2dCQUNoQyxNQUFNME4sT0FBT25GLFlBQVksQ0FBQ3ZJLElBQUksSUFBSSxFQUFFO2dCQUNwQyxNQUFNd0YsT0FBT2tJLE9BQU8sSUFBSSxDQUFDN0osTUFBTSxDQUFDLElBQUksQ0FBQ0csWUFBWSxDQUFDO29CQUFDeUo7b0JBQU1DO2lCQUFLLEtBQUtEO2dCQUNuRW9DLFlBQVk5SyxJQUFJLENBQUM7b0JBQUMrSztvQkFBcUJ0SztpQkFBSztZQUM5QztZQUNBaEUsS0FBS3VELElBQUksQ0FBQzhLO1FBQ1o7UUFDQSxPQUFPck8sSUFBSSxDQUFDQSxLQUFLeEMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUNwQztBQUNGO0FBRXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0aGlyZHdlYi1kZXYrbWVya2xldHJlZUAwLjIuMC9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi9tZXJrbGV0cmVlL2Rpc3QvdGhpcmR3ZWItZGV2LW1lcmtsZXRyZWUuZXNtLmpzP2UxM2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCByZXZlcnNlIGZyb20gJ2J1ZmZlci1yZXZlcnNlJztcbmltcG9ydCB7IGFzVHJlZSB9IGZyb20gJ3RyZWVpZnknO1xuXG4vLyBBREFQVEVEIEZST00gaHR0cHM6Ly9naXRodWIuY29tL21lcmtsZXRyZWVqcy9tZXJrbGV0cmVlanNcbmNsYXNzIEJhc2Uge1xuICAvKipcbiAgICogcHJpbnRcbiAgICogQGRlc2MgUHJpbnRzIG91dCBhIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWVya2xlIHRyZWUuXG4gICAqIEBleGFtcGxlXG4gICAqYGBganNcbiAgICp0cmVlLnByaW50KClcbiAgICpgYGBcbiAgICovXG4gIHByaW50KCkge1xuICAgIEJhc2UucHJpbnQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogYnVmZmVySW5kZXhPZlxuICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvZiB3aGljaCBnaXZlbiBidWZmZXIgaXMgZm91bmQgaW4gYXJyYXkuXG4gICAqIEBwYXJhbSB7QnVmZmVyW119IGhheXN0YWNrIC0gQXJyYXkgb2YgYnVmZmVycy5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IG5lZWRsZSAtIEJ1ZmZlciB0byBmaW5kLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gSW5kZXggbnVtYmVyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqY29uc3QgaW5kZXggPSB0cmVlLmJ1ZmZlckluZGV4T2YoaGF5c3RhY2ssIG5lZWRsZSlcbiAgICpgYGBcbiAgICovXG4gIGJ1ZmZlckluZGV4T2YoYXJyYXksIGVsZW1lbnQpIHtcbiAgICBsZXQgaXNTb3J0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5U2VhcmNoKGFycmF5LCBlbGVtZW50LCBCdWZmZXIuY29tcGFyZSk7XG4gICAgfVxuICAgIGNvbnN0IGVxQ2hlY2tlciA9IChidWZmZXIxLCBidWZmZXIyKSA9PiBidWZmZXIxLmVxdWFscyhidWZmZXIyKTtcbiAgICByZXR1cm4gdGhpcy5saW5lYXJTZWFyY2goYXJyYXksIGVsZW1lbnQsIGVxQ2hlY2tlcik7XG4gIH1cblxuICAvKipcbiAgICogYmluYXJ5U2VhcmNoXG4gICAqIEBkZXNjIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9mIHdoaWNoIGdpdmVuIGl0ZW0gaXMgZm91bmQgaW4gYXJyYXkgdXNpbmcgYmluYXJ5IHNlYXJjaC5cbiAgICogQHBhcmFtIHtCdWZmZXJbXX0gYXJyYXkgLSBBcnJheSBvZiBpdGVtcy5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IGVsZW1lbnQgLSBJdGVtIHRvIGZpbmQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVGdW5jdGlvblxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gSW5kZXggbnVtYmVyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqY29uc3QgaW5kZXggPSBNZXJrbGVUcmVlLmJpbmFyeVNlYXJjaChhcnJheSwgZWxlbWVudCwgQnVmZmVyLmNvbXBhcmUpXG4gICAqYGBgXG4gICAqL1xuICBzdGF0aWMgYmluYXJ5U2VhcmNoKGFycmF5LCBlbGVtZW50LCBjb21wYXJlRnVuY3Rpb24pIHtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSBhcnJheS5sZW5ndGggLSAxO1xuXG4gICAgLy8gSXRlcmF0ZSB3aGlsZSBzdGFydCBub3QgbWVldHMgZW5kXG4gICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgICAgLy8gRmluZCB0aGUgbWlkIGluZGV4XG4gICAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChzdGFydCArIGVuZCkgLyAyKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG1pZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4sIGVxdWFsIHRvLCBvciBsZXNzIHRoYW4gc2VhcmNoIGVsZW1lbnQuXG4gICAgICBjb25zdCBvcmRlcmluZyA9IGNvbXBhcmVGdW5jdGlvbihhcnJheVttaWRdLCBlbGVtZW50KTtcblxuICAgICAgLy8gSWYgZWxlbWVudCBpcyBwcmVzZW50IGF0IG1pZCwgc3RhcnQgaXRlcmF0aW5nIGZvciBzZWFyY2hpbmcgZmlyc3QgYXBwZWFyYW5jZS5cbiAgICAgIGlmIChvcmRlcmluZyA9PT0gMCkge1xuICAgICAgICAvLyBMaW5lYXIgcmV2ZXJzZSBpdGVyYXRpb24gdW50aWwgdGhlIGZpcnN0IG1hdGNoaW5nIGl0ZW0gaW5kZXggaXMgZm91bmQuXG4gICAgICAgIGZvciAobGV0IGkgPSBtaWQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChjb21wYXJlRnVuY3Rpb24oYXJyYXlbaV0sIGVsZW1lbnQpID09PSAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSAvKiBFbHNlIGxvb2sgaW4gbGVmdCBvciByaWdodCBoYWxmIGFjY29yZGluZ2x5ICovZWxzZSBpZiAob3JkZXJpbmcgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gbWlkICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IG1pZCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBiaW5hcnlTZWFyY2hcbiAgICogQGRlc2MgUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb2Ygd2hpY2ggZ2l2ZW4gaXRlbSBpcyBmb3VuZCBpbiBhcnJheSB1c2luZyBiaW5hcnkgc2VhcmNoLlxuICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBhcnJheSAtIEFycmF5IG9mIGl0ZW1zLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZWxlbWVudCAtIEl0ZW0gdG8gZmluZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZUZ1bmN0aW9uXG4gICAqIEByZXR1cm4ge051bWJlcn0gLSBJbmRleCBudW1iZXJcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICpjb25zdCBpbmRleCA9IHRyZWUuYmluYXJ5U2VhcmNoKGFycmF5LCBlbGVtZW50LCBCdWZmZXIuY29tcGFyZSlcbiAgICpgYGBcbiAgICovXG4gIGJpbmFyeVNlYXJjaChhcnJheSwgZWxlbWVudCwgY29tcGFyZUZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIEJhc2UuYmluYXJ5U2VhcmNoKGFycmF5LCBlbGVtZW50LCBjb21wYXJlRnVuY3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIGxpbmVhclNlYXJjaFxuICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvZiB3aGljaCBnaXZlbiBpdGVtIGlzIGZvdW5kIGluIGFycmF5IHVzaW5nIGxpbmVhciBzZWFyY2guXG4gICAqIEBwYXJhbSB7QnVmZmVyW119IGFycmF5IC0gQXJyYXkgb2YgaXRlbXMuXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBlbGVtZW50IC0gSXRlbSB0byBmaW5kLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcUNoZWNrZXJcbiAgICogQHJldHVybiB7TnVtYmVyfSAtIEluZGV4IG51bWJlclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKmNvbnN0IGluZGV4ID0gTWVya2xlVHJlZS5saW5lYXJTZWFyY2goYXJyYXksIGVsZW1lbnQsIChhLCBiKSA9PiBhID09PSBiKVxuICAgKmBgYFxuICAgKi9cbiAgc3RhdGljIGxpbmVhclNlYXJjaChhcnJheSwgZWxlbWVudCwgZXFDaGVja2VyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGVxQ2hlY2tlcihhcnJheVtpXSwgZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBsaW5lYXJTZWFyY2hcbiAgICogQGRlc2MgUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb2Ygd2hpY2ggZ2l2ZW4gaXRlbSBpcyBmb3VuZCBpbiBhcnJheSB1c2luZyBsaW5lYXIgc2VhcmNoLlxuICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBhcnJheSAtIEFycmF5IG9mIGl0ZW1zLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZWxlbWVudCAtIEl0ZW0gdG8gZmluZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXFDaGVja2VyXG4gICAqIEByZXR1cm4ge051bWJlcn0gLSBJbmRleCBudW1iZXJcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICpjb25zdCBpbmRleCA9IHRyZWUubGluZWFyU2VhcmNoKGFycmF5LCBlbGVtZW50LCAoYSwgYikgPT4gYSA9PT0gYilcbiAgICpgYGBcbiAgICovXG4gIGxpbmVhclNlYXJjaChhcnJheSwgZWxlbWVudCwgZXFDaGVja2VyKSB7XG4gICAgcmV0dXJuIEJhc2UubGluZWFyU2VhcmNoKGFycmF5LCBlbGVtZW50LCBlcUNoZWNrZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIGJ1ZmZlcmlmeVxuICAgKiBAZGVzYyBSZXR1cm5zIGEgYnVmZmVyIHR5cGUgZm9yIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfE9iamVjdHxCdWZmZXJ8QXJyYXlCdWZmZXJ9IHZhbHVlXG4gICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICpjb25zdCBidWYgPSBNZXJrbGVUcmVlLmJ1ZmZlcmlmeSgnMHgxMjM0JylcbiAgICpgYGBcbiAgICovXG4gIHN0YXRpYyBidWZmZXJpZnkodmFsdWUpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIC8vIGNyeXB0by1qcyBzdXBwb3J0XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlLndvcmRzKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZS50b1N0cmluZyhjb252ZXJ0V29yZHNUb0J1ZmZlciksIFwiaGV4XCIpO1xuICAgICAgfSBlbHNlIGlmIChCYXNlLmlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUucmVwbGFjZSgvXjB4LywgXCJcIiksIFwiaGV4XCIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZS50b1N0cmluZygxNiksIFwiaGV4XCIpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLmJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBsZXQgcyA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChzLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICBzID0gYDAke3N9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ocywgXCJoZXhcIik7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLmJ1ZmZlciwgdmFsdWUuYnl0ZU9mZnNldCwgdmFsdWUuYnl0ZUxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBiaWdOdW1iZXJpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gQmFzZS5iaWdOdW1iZXJpZnkodmFsdWUpO1xuICB9XG4gIHN0YXRpYyBiaWdOdW1iZXJpZnkodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKFwiMHhcIikgJiYgQmFzZS5pc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChcIjB4XCIgKyB2YWx1ZS5yZXBsYWNlKFwiMHhcIiwgXCJcIikudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBCaWdJbnQoXCIweFwiICsgdmFsdWUudG9TdHJpbmcoXCJoZXhcIikpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICByZXR1cm4gdWludDhBcnJheVRvQmlnSW50KHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBiaWdOdW1iZXJpZnlcIik7XG4gIH1cblxuICAvKipcbiAgICogaXNIZXhTdHJpbmdcbiAgICogQGRlc2MgUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgaGV4IHN0cmluZy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqY29uc29sZS5sb2coTWVya2xlVHJlZS5pc0hleFN0cmluZygnMHgxMjM0JykpXG4gICAqYGBgXG4gICAqL1xuICBzdGF0aWMgaXNIZXhTdHJpbmcodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiAmJiAvXigweCk/WzAtOUEtRmEtZl0qJC8udGVzdCh2KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBwcmludFxuICAgKiBAZGVzYyBQcmludHMgb3V0IGEgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBtZXJrbGUgdHJlZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyZWUgLSBNZXJrbGUgdHJlZSBpbnN0YW5jZS5cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKmBgYGpzXG4gICAqTWVya2xlVHJlZS5wcmludCh0cmVlKVxuICAgKmBgYFxuICAgKi9cbiAgc3RhdGljIHByaW50KHRyZWUpIHtcbiAgICBjb25zb2xlLmxvZyh0cmVlLnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIGJ1ZmZlclRvSGV4XG4gICAqIEBkZXNjIFJldHVybnMgYSBoZXggc3RyaW5nIHdpdGggMHggcHJlZml4IGZvciBnaXZlbiBidWZmZXIuXG4gICAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqYGBganNcbiAgICpjb25zdCBoZXhTdHIgPSB0cmVlLmJ1ZmZlclRvSGV4KEJ1ZmZlci5mcm9tKCdBJykpXG4gICAqYGBgXG4gICAqL1xuICBidWZmZXJUb0hleCh2YWx1ZSkge1xuICAgIGxldCB3aXRoUHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIHJldHVybiBCYXNlLmJ1ZmZlclRvSGV4KHZhbHVlLCB3aXRoUHJlZml4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBidWZmZXJUb0hleFxuICAgKiBAZGVzYyBSZXR1cm5zIGEgaGV4IHN0cmluZyB3aXRoIDB4IHByZWZpeCBmb3IgZ2l2ZW4gYnVmZmVyLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gdmFsdWVcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKmBgYGpzXG4gICAqY29uc3QgaGV4U3RyID0gTWVya2xlVHJlZS5idWZmZXJUb0hleChCdWZmZXIuZnJvbSgnQScpKVxuICAgKmBgYFxuICAgKi9cbiAgc3RhdGljIGJ1ZmZlclRvSGV4KHZhbHVlKSB7XG4gICAgbGV0IHdpdGhQcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgcmV0dXJuIGAke3dpdGhQcmVmaXggPyBcIjB4XCIgOiBcIlwifSR7KHZhbHVlIHx8IEJ1ZmZlci5hbGxvYygwKSkudG9TdHJpbmcoXCJoZXhcIil9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBidWZmZXJpZnlcbiAgICogQGRlc2MgUmV0dXJucyBhIGJ1ZmZlciB0eXBlIGZvciB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxPYmplY3R8QnVmZmVyfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqY29uc3QgYnVmID0gdHJlZS5idWZmZXJpZnkoJzB4MTIzNCcpXG4gICAqYGBgXG4gICAqL1xuICBidWZmZXJpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gQmFzZS5idWZmZXJpZnkodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIGJ1ZmZlcmlmeUZuXG4gICAqIEBkZXNjIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYnVmZmVyaWZ5IHRoZSByZXR1cm4gdmFsdWUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259XG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKmNvbnN0IGZuID0gdHJlZS5idWZmZXJpZnlGbigodmFsdWUpID0+IHNoYTI1Nih2YWx1ZSkpXG4gICAqYGBgXG4gICAqL1xuICBidWZmZXJpZnlGbihmKSB7XG4gICAgcmV0dXJuIHZhbHVlID0+IHtcbiAgICAgIGNvbnN0IHYgPSBmKHZhbHVlKTtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0hleFN0cmluZyh2KSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odi5yZXBsYWNlKFwiMHhcIiwgXCJcIiksIFwiaGV4XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUudG9TdHJpbmcoMTYpLCBcImhleFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodikpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYuYnVmZmVyLCB2LmJ5dGVPZmZzZXQsIHYuYnl0ZUxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNyeXB0by1qcyBzdXBwb3J0XG4gICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGhleFN0cmluZ1RvQXJyYXlCdWZmZXIodmFsdWUudG9TdHJpbmcoXCJoZXhcIikpO1xuICAgICAgLy8gQXNzdW1pbmcgZiBub3cgd29ya3Mgd2l0aCBBcnJheUJ1ZmZlcnNcbiAgICAgIGNvbnN0IHByb2Nlc3NlZEJ1ZmZlciA9IGYoYXJyYXlCdWZmZXIpO1xuICAgICAgY29uc3QgaGV4UmVzdWx0ID0gYXJyYXlCdWZmZXJUb0hleFN0cmluZyhwcm9jZXNzZWRCdWZmZXIpO1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhleFJlc3VsdCwgXCJoZXhcIik7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpc0hleFN0cmluZ1xuICAgKiBAZGVzYyBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBoZXggc3RyaW5nLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICpjb25zb2xlLmxvZyhNZXJrbGVUcmVlLmlzSGV4U3RyaW5nKCcweDEyMzQnKSlcbiAgICpgYGBcbiAgICovXG4gIGlzSGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIEJhc2UuaXNIZXhTdHJpbmcodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIGxvZzJcbiAgICogQGRlc2MgUmV0dXJucyB0aGUgbG9nMiBvZiBudW1iZXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBsb2cyKG4pIHtcbiAgICByZXR1cm4gbiA9PT0gMSA/IDAgOiAxICsgdGhpcy5sb2cyKG4gLyAyIHwgMCk7XG4gIH1cblxuICAvKipcbiAgICogemlwXG4gICAqIEBkZXNjIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGhleCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7U3RyaW5nW118TnVtYmVyW118QnVmZmVyW119IGEgLSBmaXJzdCBhcnJheVxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfE51bWJlcltdfEJ1ZmZlcltdfSBiIC0gIHNlY29uZCBhcnJheVxuICAgKiBAcmV0dXJuIHtTdHJpbmdbXVtdfE51bWJlcltdW118QnVmZmVyW11bXX1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICpjb25zdCB6aXBwZWQgPSB0cmVlLnppcChbJ2EnLCAnYiddLFsnQScsICdCJ10pXG4gICAqY29uc29sZS5sb2coemlwcGVkKSAvLyBbIFsgJ2EnLCAnQScgXSwgWyAnYicsICdCJyBdIF1cbiAgICpgYGBcbiAgICovXG4gIHppcChhLCBiKSB7XG4gICAgcmV0dXJuIGEubWFwKChlLCBpKSA9PiBbZSwgYltpXV0pO1xuICB9XG4gIHN0YXRpYyBoZXhaZXJvUGFkKGhleFN0ciwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArIGhleFN0ci5yZXBsYWNlKFwiMHhcIiwgXCJcIikucGFkU3RhcnQobGVuZ3RoLCBcIjBcIik7XG4gIH1cbn1cbnZhciBCYXNlJDEgPSBCYXNlO1xuXG4vLyBVVElMU1xuXG4vLyByZXBsYWNlcyBDcnlwdG9KUy5lbmMuSGV4XG5mdW5jdGlvbiBjb252ZXJ0V29yZHNUb0J1ZmZlcih2YWx1ZSkge1xuICBjb25zdCB3b3JkQXJyYXkgPSB2YWx1ZS53b3JkcztcbiAgY29uc3QgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIod29yZEFycmF5Lmxlbmd0aCAqIDQpOyAvLyA0IGJ5dGVzIHBlciB3b3JkXG4gIGNvbnN0IHVpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICB1aW50OFZpZXdbaSAqIDRdID0gd29yZEFycmF5W2ldID4+IDI0ICYgMHhmZjtcbiAgICB1aW50OFZpZXdbaSAqIDQgKyAxXSA9IHdvcmRBcnJheVtpXSA+PiAxNiAmIDB4ZmY7XG4gICAgdWludDhWaWV3W2kgKiA0ICsgMl0gPSB3b3JkQXJyYXlbaV0gPj4gOCAmIDB4ZmY7XG4gICAgdWludDhWaWV3W2kgKiA0ICsgM10gPSB3b3JkQXJyYXlbaV0gJiAweGZmO1xuICB9XG4gIHJldHVybiBhcnJheUJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIGhleFN0cmluZ1RvQXJyYXlCdWZmZXIoaGV4U3RyaW5nKSB7XG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGhleFN0cmluZy5sZW5ndGggLyAyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZXhTdHJpbmcubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBidWZmZXJbaSAvIDJdID0gcGFyc2VJbnQoaGV4U3RyaW5nLnN1YnN0cmluZyhpLCBpICsgMiksIDE2KTtcbiAgfVxuICByZXR1cm4gYnVmZmVyLmJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIGFycmF5QnVmZmVyVG9IZXhTdHJpbmcoYXJyYXlCdWZmZXIpIHtcbiAgY29uc3QgdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICByZXR1cm4gQXJyYXkuZnJvbSh1aW50OFZpZXcpLm1hcChieXRlID0+IGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHVpbnQ4QXJyYXlUb0JpZ0ludCh1OGEpIHtcbiAgY29uc3QgaGV4ID0gQXJyYXkuZnJvbSh1OGEpLm1hcChieXRlID0+IGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIlwiKTtcbiAgcmV0dXJuIEJpZ0ludChgMHgke2hleH1gKTtcbn1cblxuLy8gQURBUFRFRCBGUk9NIGh0dHBzOi8vZ2l0aHViLmNvbS9tZXJrbGV0cmVlanMvbWVya2xldHJlZWpzXG5cbi8vIFRPRE86IENsZWFuIHVwIGFuZCBEUlkgdXAgY29kZVxuLy8gRGlzY2xhaW1lcjogVGhlIG11bHRpcHJvb2YgY29kZSBpcyB1bmF1ZGl0ZWQgYW5kIG1heSBwb3NzaWJseSBjb250YWluIHNlcmlvdXMgaXNzdWVzLiBJdCdzIGluIGEgaGFja3kgc3RhdGUgYXMgaXMgYW5kIG5lZWRzIHRvIGJlIHJld3JpdHRlbi5cbi8qKlxuICogQ2xhc3MgcmVwcmVuc2VudGluZyBhIE1lcmtsZSBUcmVlXG4gKiBAbmFtZXNwYWNlIE1lcmtsZVRyZWVcbiAqL1xuY2xhc3MgTWVya2xlVHJlZSBleHRlbmRzIEJhc2UkMSB7XG4gIGR1cGxpY2F0ZU9kZCA9IGZhbHNlO1xuICBjb25jYXRlbmF0b3IgPSBCdWZmZXIuY29uY2F0O1xuICBoYXNoTGVhdmVzID0gZmFsc2U7XG4gIGlzQml0Y29pblRyZWUgPSBmYWxzZTtcbiAgbGVhdmVzID0gW107XG4gIGxheWVycyA9IFtdO1xuICBzb3J0TGVhdmVzID0gZmFsc2U7XG4gIHNvcnRQYWlycyA9IGZhbHNlO1xuICBzb3J0ID0gZmFsc2U7XG4gIGZpbGxEZWZhdWx0SGFzaCA9IG51bGw7XG4gIGNvbXBsZXRlID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBkZXNjIENvbnN0cnVjdHMgYSBNZXJrbGUgVHJlZS5cbiAgICogQWxsIG5vZGVzIGFuZCBsZWF2ZXMgYXJlIHN0b3JlZCBhcyBCdWZmZXJzLlxuICAgKiBMb25lbHkgbGVhZiBub2RlcyBhcmUgcHJvbW90ZWQgdG8gdGhlIG5leHQgbGV2ZWwgdXAgd2l0aG91dCBiZWluZyBoYXNoZWQgYWdhaW4uXG4gICAqIEBwYXJhbSB7QnVmZmVyW119IGxlYXZlcyAtIEFycmF5IG9mIGhhc2hlZCBsZWF2ZXMuIEVhY2ggbGVhZiBtdXN0IGJlIGEgQnVmZmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNoRnVuY3Rpb24gLSBIYXNoIGZ1bmN0aW9uIHRvIHVzZSBmb3IgaGFzaGluZyBsZWF2ZXMgYW5kIG5vZGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zXG4gICAqIEBleGFtcGxlXG4gICAqYGBganNcbiAgICpjb25zdCBNZXJrbGVUcmVlID0gcmVxdWlyZSgnbWVya2xldHJlZWpzJylcbiAgICpjb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuICAgKlxuICAgKmZ1bmN0aW9uIHNoYTI1NihkYXRhKSB7XG4gICAqICAvLyByZXR1cm5zIEJ1ZmZlclxuICAgKiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoZGF0YSkuZGlnZXN0KClcbiAgICp9XG4gICAqXG4gICAqY29uc3QgbGVhdmVzID0gWydhJywgJ2InLCAnYyddLm1hcCh2YWx1ZSA9PiBrZWNjYWsodmFsdWUpKVxuICAgKlxuICAgKmNvbnN0IHRyZWUgPSBuZXcgTWVya2xlVHJlZShsZWF2ZXMsIHNoYTI1NilcbiAgICpgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKGxlYXZlcywgaGFzaEZuKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKG9wdGlvbnMuY29tcGxldGUpIHtcbiAgICAgIGlmIChvcHRpb25zLmlzQml0Y29pblRyZWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb24gXCJjb21wbGV0ZVwiIGlzIGluY29tcGF0aWJsZSB3aXRoIFwiaXNCaXRjb2luVHJlZVwiJyk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5kdXBsaWNhdGVPZGQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb24gXCJjb21wbGV0ZVwiIGlzIGluY29tcGF0aWJsZSB3aXRoIFwiZHVwbGljYXRlT2RkXCInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pc0JpdGNvaW5UcmVlID0gISFvcHRpb25zLmlzQml0Y29pblRyZWU7XG4gICAgdGhpcy5oYXNoTGVhdmVzID0gISFvcHRpb25zLmhhc2hMZWF2ZXM7XG4gICAgdGhpcy5zb3J0TGVhdmVzID0gISFvcHRpb25zLnNvcnRMZWF2ZXM7XG4gICAgdGhpcy5zb3J0UGFpcnMgPSAhIW9wdGlvbnMuc29ydFBhaXJzO1xuICAgIHRoaXMuY29tcGxldGUgPSAhIW9wdGlvbnMuY29tcGxldGU7XG4gICAgaWYgKG9wdGlvbnMuZmlsbERlZmF1bHRIYXNoKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmlsbERlZmF1bHRIYXNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5maWxsRGVmYXVsdEhhc2ggPSBvcHRpb25zLmZpbGxEZWZhdWx0SGFzaDtcbiAgICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMuZmlsbERlZmF1bHRIYXNoKSB8fCB0eXBlb2Ygb3B0aW9ucy5maWxsRGVmYXVsdEhhc2ggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhpcy5maWxsRGVmYXVsdEhhc2ggPSAoaWR4LCBoYXNoRm4pID0+IG9wdGlvbnMuZmlsbERlZmF1bHRIYXNoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgXCJmaWxsRGVmYXVsdEhhc2hcIiBtdXN0IGJlIGEgZnVuY3Rpb24sIEJ1ZmZlciwgb3Igc3RyaW5nJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc29ydCA9ICEhb3B0aW9ucy5zb3J0O1xuICAgIGlmICh0aGlzLnNvcnQpIHtcbiAgICAgIHRoaXMuc29ydExlYXZlcyA9IHRydWU7XG4gICAgICB0aGlzLnNvcnRQYWlycyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuZHVwbGljYXRlT2RkID0gISFvcHRpb25zLmR1cGxpY2F0ZU9kZDtcbiAgICBpZiAob3B0aW9ucy5jb25jYXRlbmF0b3IpIHtcbiAgICAgIHRoaXMuY29uY2F0ZW5hdG9yID0gb3B0aW9ucy5jb25jYXRlbmF0b3I7XG4gICAgfVxuICAgIHRoaXMuaGFzaEZuID0gdGhpcy5idWZmZXJpZnlGbihoYXNoRm4pO1xuICAgIHRoaXMucHJvY2Vzc0xlYXZlcyhsZWF2ZXMpO1xuICB9XG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBsZXRlOiB0aGlzLmNvbXBsZXRlLFxuICAgICAgaXNCaXRjb2luVHJlZTogdGhpcy5pc0JpdGNvaW5UcmVlLFxuICAgICAgaGFzaExlYXZlczogdGhpcy5oYXNoTGVhdmVzLFxuICAgICAgc29ydExlYXZlczogdGhpcy5zb3J0TGVhdmVzLFxuICAgICAgc29ydFBhaXJzOiB0aGlzLnNvcnRQYWlycyxcbiAgICAgIHNvcnQ6IHRoaXMuc29ydCxcbiAgICAgIGZpbGxEZWZhdWx0SGFzaDogdGhpcy5maWxsRGVmYXVsdEhhc2g/LnRvU3RyaW5nKCkgPz8gbnVsbCxcbiAgICAgIGR1cGxpY2F0ZU9kZDogdGhpcy5kdXBsaWNhdGVPZGRcbiAgICB9O1xuICB9XG4gIHByb2Nlc3NMZWF2ZXMobGVhdmVzKSB7XG4gICAgaWYgKHRoaXMuaGFzaExlYXZlcykge1xuICAgICAgbGVhdmVzID0gbGVhdmVzLm1hcCh0aGlzLmhhc2hGbik7XG4gICAgfVxuICAgIHRoaXMubGVhdmVzID0gbGVhdmVzLm1hcCh0aGlzLmJ1ZmZlcmlmeSk7XG4gICAgaWYgKHRoaXMuc29ydExlYXZlcykge1xuICAgICAgdGhpcy5sZWF2ZXMgPSB0aGlzLmxlYXZlcy5zb3J0KEJ1ZmZlci5jb21wYXJlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZmlsbERlZmF1bHRIYXNoKSB7XG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5sZWF2ZXMubGVuZ3RoOyBpIDwgTWF0aC5wb3coMiwgTWF0aC5jZWlsKE1hdGgubG9nMih0aGlzLmxlYXZlcy5sZW5ndGgpKSk7IGkrKykge1xuICAgICAgICB0aGlzLmxlYXZlcy5wdXNoKHRoaXMuYnVmZmVyaWZ5KHRoaXMuZmlsbERlZmF1bHRIYXNoKGksIHRoaXMuaGFzaEZuKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNyZWF0ZUhhc2hlcyh0aGlzLmxlYXZlcyk7XG4gIH1cbiAgY3JlYXRlSGFzaGVzKG5vZGVzKSB7XG4gICAgdGhpcy5sYXllcnMgPSBbbm9kZXNdO1xuICAgIHdoaWxlIChub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBsYXllckluZGV4ID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuICAgICAgdGhpcy5sYXllcnMucHVzaChbXSk7XG4gICAgICBjb25zdCBsYXllckxpbWl0ID0gdGhpcy5jb21wbGV0ZSAmJiBsYXllckluZGV4ID09PSAxICYmICFOdW1iZXIuaXNJbnRlZ2VyKE1hdGgubG9nMihub2Rlcy5sZW5ndGgpKSA/IDIgKiBub2Rlcy5sZW5ndGggLSAyICoqIE1hdGguY2VpbChNYXRoLmxvZzIobm9kZXMubGVuZ3RoKSkgOiBub2Rlcy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGlmIChpID49IGxheWVyTGltaXQpIHtcbiAgICAgICAgICB0aGlzLmxheWVyc1tsYXllckluZGV4XS5wdXNoKC4uLm5vZGVzLnNsaWNlKGxheWVyTGltaXQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGxldCBoYXNoID0gZGF0YTtcblxuICAgICAgICAgICAgLy8gaXMgYml0Y29pbiB0cmVlXG4gICAgICAgICAgICBpZiAodGhpcy5pc0JpdGNvaW5UcmVlKSB7XG4gICAgICAgICAgICAgIC8vIEJpdGNvaW4gbWV0aG9kIG9mIGR1cGxpY2F0aW5nIHRoZSBvZGQgZW5kaW5nIG5vZGVzXG4gICAgICAgICAgICAgIGhhc2ggPSB0aGlzLmhhc2hGbih0aGlzLmNvbmNhdGVuYXRvcihbcmV2ZXJzZShkYXRhKSwgcmV2ZXJzZShkYXRhKV0pKTtcbiAgICAgICAgICAgICAgaGFzaCA9IHJldmVyc2UodGhpcy5oYXNoRm4oaGFzaCkpO1xuICAgICAgICAgICAgICB0aGlzLmxheWVyc1tsYXllckluZGV4XS5wdXNoKGhhc2gpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmR1cGxpY2F0ZU9kZCkgOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBwdXNoIGNvcHkgb2YgaGFzaCBhbmQgY29udGludWUgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5sYXllcnNbbGF5ZXJJbmRleF0ucHVzaChub2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVmdCA9IG5vZGVzW2ldO1xuICAgICAgICBjb25zdCByaWdodCA9IGkgKyAxID09PSBub2Rlcy5sZW5ndGggPyBsZWZ0IDogbm9kZXNbaSArIDFdO1xuICAgICAgICBsZXQgY29tYmluZWQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5pc0JpdGNvaW5UcmVlKSB7XG4gICAgICAgICAgY29tYmluZWQgPSBbcmV2ZXJzZShsZWZ0KSwgcmV2ZXJzZShyaWdodCldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbWJpbmVkID0gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zb3J0UGFpcnMpIHtcbiAgICAgICAgICBjb21iaW5lZC5zb3J0KEJ1ZmZlci5jb21wYXJlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGFzaCA9IHRoaXMuaGFzaEZuKHRoaXMuY29uY2F0ZW5hdG9yKGNvbWJpbmVkKSk7XG5cbiAgICAgICAgLy8gZG91YmxlIGhhc2ggaWYgYml0Y29pbiB0cmVlXG4gICAgICAgIGlmICh0aGlzLmlzQml0Y29pblRyZWUpIHtcbiAgICAgICAgICBoYXNoID0gcmV2ZXJzZSh0aGlzLmhhc2hGbihoYXNoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXllcnNbbGF5ZXJJbmRleF0ucHVzaChoYXNoKTtcbiAgICAgIH1cbiAgICAgIG5vZGVzID0gdGhpcy5sYXllcnNbbGF5ZXJJbmRleF07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGFkZExlYWZcbiAgICogQGRlc2MgQWRkcyBhIGxlYWYgdG8gdGhlIHRyZWUgYW5kIHJlLWNhbGN1bGF0ZXMgbGF5ZXJzLlxuICAgKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IC0gTGVhZlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IC0gU2V0IHRvIHRydWUgaWYgdGhlIGxlYWYgc2hvdWxkIGJlIGhhc2hlZCBiZWZvcmUgYmVpbmcgYWRkZWQgdG8gdHJlZS5cbiAgICogQGV4YW1wbGVcbiAgICpgYGBqc1xuICAgKnRyZWUuYWRkTGVhZihuZXdMZWFmKVxuICAgKmBgYFxuICAgKi9cbiAgYWRkTGVhZihsZWFmKSB7XG4gICAgbGV0IHNob3VsZEhhc2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIGlmIChzaG91bGRIYXNoKSB7XG4gICAgICBsZWFmID0gdGhpcy5oYXNoRm4obGVhZik7XG4gICAgfVxuICAgIHRoaXMucHJvY2Vzc0xlYXZlcyh0aGlzLmxlYXZlcy5jb25jYXQobGVhZikpO1xuICB9XG5cbiAgLyoqXG4gICAqIGFkZExlYXZlc1xuICAgKiBAZGVzYyBBZGRzIG11bHRpcGxlIGxlYXZlcyB0byB0aGUgdHJlZSBhbmQgcmUtY2FsY3VsYXRlcyBsYXllcnMuXG4gICAqIEBwYXJhbSB7U3RyaW5nW118QnVmZmVyW119IC0gQXJyYXkgb2YgbGVhdmVzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gLSBTZXQgdG8gdHJ1ZSBpZiB0aGUgbGVhdmVzIHNob3VsZCBiZSBoYXNoZWQgYmVmb3JlIGJlaW5nIGFkZGVkIHRvIHRyZWUuXG4gICAqIEBleGFtcGxlXG4gICAqYGBganNcbiAgICp0cmVlLmFkZExlYXZlcyhuZXdMZWF2ZXMpXG4gICAqYGBgXG4gICAqL1xuICBhZGRMZWF2ZXMobGVhdmVzKSB7XG4gICAgbGV0IHNob3VsZEhhc2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIGlmIChzaG91bGRIYXNoKSB7XG4gICAgICBsZWF2ZXMgPSBsZWF2ZXMubWFwKHRoaXMuaGFzaEZuKTtcbiAgICB9XG4gICAgdGhpcy5wcm9jZXNzTGVhdmVzKHRoaXMubGVhdmVzLmNvbmNhdChsZWF2ZXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXRMZWF2ZXNcbiAgICogQGRlc2MgUmV0dXJucyBhcnJheSBvZiBsZWF2ZXMgb2YgTWVya2xlIFRyZWUuXG4gICAqIEByZXR1cm4ge0J1ZmZlcltdfVxuICAgKiBAZXhhbXBsZVxuICAgKmBgYGpzXG4gICAqY29uc3QgbGVhdmVzID0gdHJlZS5nZXRMZWF2ZXMoKVxuICAgKmBgYFxuICAgKi9cbiAgZ2V0TGVhdmVzKHZhbHVlcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIGlmICh0aGlzLmhhc2hMZWF2ZXMpIHtcbiAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcCh0aGlzLmhhc2hGbik7XG4gICAgICAgIGlmICh0aGlzLnNvcnRMZWF2ZXMpIHtcbiAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuc29ydChCdWZmZXIuY29tcGFyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmxlYXZlcy5maWx0ZXIoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gaXNzdWUgZnJvbSBvcmlnaW5hbCBjb2RlXG4gICAgICBsZWFmID0+IHRoaXMuYnVmZmVySW5kZXhPZih2YWx1ZXMsIGxlYWYsIHRoaXMuc29ydExlYXZlcykgIT09IC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGVhdmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldExlYWZcbiAgICogQGRlc2MgUmV0dXJucyB0aGUgbGVhZiBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAtIEluZGV4IG51bWJlclxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqYGBganNcbiAgICpjb25zdCBsZWFmID0gdHJlZS5nZXRMZWFmKDEpXG4gICAqYGBgXG4gICAqL1xuICBnZXRMZWFmKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMubGVhdmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShbXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxlYXZlc1tpbmRleF07XG4gIH1cblxuICAvKipcbiAgICogZ2V0TGVhZkluZGV4XG4gICAqIEBkZXNjIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBsZWFmLCBvciAtMSBpZiB0aGUgbGVhZiBpcyBub3QgZm91bmQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gLSBUYXJnZXQgbGVhZlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqYGBganNcbiAgICpjb25zdCBsZWFmID0gQnVmZmVyLmZyb20oJ2FiYycpXG4gICAqY29uc3QgaW5kZXggPSB0cmVlLmdldExlYWZJbmRleChsZWFmKVxuICAgKmBgYFxuICAgKi9cbiAgZ2V0TGVhZkluZGV4KHRhcmdldCkge1xuICAgIHRhcmdldCA9IHRoaXMuYnVmZmVyaWZ5KHRhcmdldCk7XG4gICAgY29uc3QgbGVhdmVzID0gdGhpcy5nZXRMZWF2ZXMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlYXZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGVhZiA9IGxlYXZlc1tpXTtcbiAgICAgIGlmIChsZWFmLmVxdWFscyh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogZ2V0TGVhZkNvdW50XG4gICAqIEBkZXNjIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBsZWF2ZXMuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICpgYGBqc1xuICAgKmNvbnN0IGNvdW50ID0gdHJlZS5nZXRMZWFmQ291bnQoKVxuICAgKmBgYFxuICAgKi9cbiAgZ2V0TGVhZkNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmxlYXZlcy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogZ2V0SGV4TGVhdmVzXG4gICAqIEBkZXNjIFJldHVybnMgYXJyYXkgb2YgbGVhdmVzIG9mIE1lcmtsZSBUcmVlIGFzIGhleCBzdHJpbmdzLlxuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAgICogQGV4YW1wbGVcbiAgICpgYGBqc1xuICAgKmNvbnN0IGxlYXZlcyA9IHRyZWUuZ2V0SGV4TGVhdmVzKClcbiAgICpgYGBcbiAgICovXG4gIGdldEhleExlYXZlcygpIHtcbiAgICByZXR1cm4gdGhpcy5sZWF2ZXMubWFwKGxlYWYgPT4gdGhpcy5idWZmZXJUb0hleChsZWFmKSk7XG4gIH1cblxuICAvKipcbiAgICogbWFyc2hhbExlYXZlc1xuICAgKiBAZGVzYyBSZXR1cm5zIGFycmF5IG9mIGxlYXZlcyBvZiBNZXJrbGUgVHJlZSBhcyBhIEpTT04gc3RyaW5nLlxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfEJ1ZmZlcltdfSAtIE1lcmtsZSB0cmVlIGxlYXZlc1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9IC0gTGlzdCBvZiBsZWF2ZXMgYXMgSlNPTiBzdHJpbmdcbiAgICogQGV4YW1wbGVcbiAgICpgYGBqc1xuICAgKmNvbnN0IGpzb25TdHIgPSBNZXJrbGVUcmVlLm1hcnNoYWxMZWF2ZXMobGVhdmVzKVxuICAgKmBgYFxuICAgKi9cbiAgc3RhdGljIG1hcnNoYWxMZWF2ZXMobGVhdmVzKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGxlYXZlcy5tYXAobGVhZiA9PiBNZXJrbGVUcmVlLmJ1ZmZlclRvSGV4KGxlYWYpKSwgbnVsbCwgMik7XG4gIH1cblxuICAvKipcbiAgICogdW5tYXJzaGFsTGVhdmVzXG4gICAqIEBkZXNjIFJldHVybnMgYXJyYXkgb2YgbGVhdmVzIG9mIE1lcmtsZSBUcmVlIGFzIGEgQnVmZmVycy5cbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSAtIEpTT04gc3RyaW5naWZpZWQgbGVhdmVzXG4gICAqIEByZXR1cm4ge0J1ZmZlcltdfSAtIFVubWFyc2hhbGxlZCBsaXN0IG9mIGxlYXZlc1xuICAgKiBAZXhhbXBsZVxuICAgKmBgYGpzXG4gICAqY29uc3QgbGVhdmVzID0gTWVya2xlVHJlZS51bm1hcnNoYWxMZWF2ZXMoanNvblN0cilcbiAgICpgYGBcbiAgICovXG4gIHN0YXRpYyB1bm1hcnNoYWxMZWF2ZXMoanNvblN0cikge1xuICAgIGxldCBwYXJzZWQgPSBudWxsO1xuICAgIGlmICh0eXBlb2YganNvblN0ciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShqc29uU3RyKTtcbiAgICB9IGVsc2UgaWYgKGpzb25TdHIgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIHBhcnNlZCA9IGpzb25TdHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHR5cGUgb2Ygc3RyaW5nIG9yIG9iamVjdFwiKTtcbiAgICB9XG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcnNlZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIEpTT04gc3RyaW5nIHRvIGJlIGFycmF5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkLm1hcChNZXJrbGVUcmVlLmJ1ZmZlcmlmeSk7XG4gIH1cblxuICAvKipcbiAgICogZ2V0TGF5ZXJzXG4gICAqIEBkZXNjIFJldHVybnMgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgb2YgYWxsIGxheWVycyBvZiBNZXJrbGUgVHJlZSwgaW5jbHVkaW5nIGxlYXZlcyBhbmQgcm9vdC5cbiAgICogQHJldHVybiB7QnVmZmVyW11bXX1cbiAgICogQGV4YW1wbGVcbiAgICpgYGBqc1xuICAgKmNvbnN0IGxheWVycyA9IHRyZWUuZ2V0TGF5ZXJzKClcbiAgICpgYGBcbiAgICovXG4gIGdldExheWVycygpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllcnM7XG4gIH1cblxuICAvKipcbiAgICogZ2V0SGV4TGF5ZXJzXG4gICAqIEBkZXNjIFJldHVybnMgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgb2YgYWxsIGxheWVycyBvZiBNZXJrbGUgVHJlZSwgaW5jbHVkaW5nIGxlYXZlcyBhbmQgcm9vdCBhcyBoZXggc3RyaW5ncy5cbiAgICogQHJldHVybiB7U3RyaW5nW11bXX1cbiAgICogQGV4YW1wbGVcbiAgICpgYGBqc1xuICAgKmNvbnN0IGxheWVycyA9IHRyZWUuZ2V0SGV4TGF5ZXJzKClcbiAgICpgYGBcbiAgICovXG4gIGdldEhleExheWVycygpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllcnMucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgIGFjYy5wdXNoKGl0ZW0ubWFwKGxheWVyID0+IHRoaXMuYnVmZmVyVG9IZXgobGF5ZXIpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY2MucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldExheWVyc0ZsYXRcbiAgICogQGRlc2MgUmV0dXJucyBzaW5nbGUgZmxhdCBhcnJheSBvZiBhbGwgbGF5ZXJzIG9mIE1lcmtsZSBUcmVlLCBpbmNsdWRpbmcgbGVhdmVzIGFuZCByb290LlxuICAgKiBAcmV0dXJuIHtCdWZmZXJbXX1cbiAgICogQGV4YW1wbGVcbiAgICpgYGBqc1xuICAgKmNvbnN0IGxheWVycyA9IHRyZWUuZ2V0TGF5ZXJzRmxhdCgpXG4gICAqYGBgXG4gICAqL1xuICBnZXRMYXllcnNGbGF0KCkge1xuICAgIGNvbnN0IGxheWVycyA9IHRoaXMubGF5ZXJzLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICBhY2MudW5zaGlmdCguLi5pdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjYy51bnNoaWZ0KGl0ZW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gICAgbGF5ZXJzLnVuc2hpZnQoQnVmZmVyLmZyb20oWzBdKSk7XG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXRIZXhMYXllcnNGbGF0XG4gICAqIEBkZXNjIFJldHVybnMgc2luZ2xlIGZsYXQgYXJyYXkgb2YgYWxsIGxheWVycyBvZiBNZXJrbGUgVHJlZSwgaW5jbHVkaW5nIGxlYXZlcyBhbmQgcm9vdCBhcyBoZXggc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAgICogQGV4YW1wbGVcbiAgICpgYGBqc1xuICAgKmNvbnN0IGxheWVycyA9IHRyZWUuZ2V0SGV4TGF5ZXJzRmxhdCgpXG4gICAqYGBgXG4gICAqL1xuICBnZXRIZXhMYXllcnNGbGF0KCkge1xuICAgIHJldHVybiB0aGlzLmdldExheWVyc0ZsYXQoKS5tYXAobGF5ZXIgPT4gdGhpcy5idWZmZXJUb0hleChsYXllcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldExheWVyQ291bnRcbiAgICogQGRlc2MgUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGxheWVycy5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKmBgYGpzXG4gICAqY29uc3QgY291bnQgPSB0cmVlLmdldExheWVyQ291bnQoKVxuICAgKmBgYFxuICAgKi9cbiAgZ2V0TGF5ZXJDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXllcnMoKS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogZ2V0Um9vdFxuICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBNZXJrbGUgcm9vdCBoYXNoIGFzIGEgQnVmZmVyLlxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqYGBganNcbiAgICpjb25zdCByb290ID0gdHJlZS5nZXRSb290KClcbiAgICpgYGBcbiAgICovXG4gIGdldFJvb3QoKSB7XG4gICAgaWYgKHRoaXMubGF5ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJzW3RoaXMubGF5ZXJzLmxlbmd0aCAtIDFdWzBdIHx8IEJ1ZmZlci5mcm9tKFtdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXRIZXhSb290XG4gICAqIEBkZXNjIFJldHVybnMgdGhlIE1lcmtsZSByb290IGhhc2ggYXMgYSBoZXggc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqYGBganNcbiAgICpjb25zdCByb290ID0gdHJlZS5nZXRIZXhSb290KClcbiAgICpgYGBcbiAgICovXG4gIGdldEhleFJvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyVG9IZXgodGhpcy5nZXRSb290KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldFByb29mXG4gICAqIEBkZXNjIFJldHVybnMgdGhlIHByb29mIGZvciBhIHRhcmdldCBsZWFmLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gbGVhZiAtIFRhcmdldCBsZWFmXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhdIC0gVGFyZ2V0IGxlYWYgaW5kZXggaW4gbGVhdmVzIGFycmF5LlxuICAgKiBVc2UgaWYgdGhlcmUgYXJlIGxlYXZlcyBjb250YWluaW5nIGR1cGxpY2F0ZSBkYXRhIGluIG9yZGVyIHRvIGRpc3Rpbmd1aXNoIGl0LlxuICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gLSBBcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgYSBwb3NpdGlvbiBwcm9wZXJ0eSBvZiB0eXBlIHN0cmluZ1xuICAgKiB3aXRoIHZhbHVlcyBvZiAnbGVmdCcgb3IgJ3JpZ2h0JyBhbmQgYSBkYXRhIHByb3BlcnR5IG9mIHR5cGUgQnVmZmVyLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKmNvbnN0IHByb29mID0gdHJlZS5nZXRQcm9vZihsZWF2ZXNbMl0pXG4gICAqYGBgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqYGBganNcbiAgICpjb25zdCBsZWF2ZXMgPSBbJ2EnLCAnYicsICdhJ10ubWFwKHZhbHVlID0+IGtlY2Nhayh2YWx1ZSkpXG4gICAqY29uc3QgdHJlZSA9IG5ldyBNZXJrbGVUcmVlKGxlYXZlcywga2VjY2FrKVxuICAgKmNvbnN0IHByb29mID0gdHJlZS5nZXRQcm9vZihsZWF2ZXNbMl0sIDIpXG4gICAqYGBgXG4gICAqL1xuICBnZXRQcm9vZihsZWFmLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgbGVhZiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGVhZiBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgbGVhZiA9IHRoaXMuYnVmZmVyaWZ5KGxlYWYpO1xuICAgIGNvbnN0IHByb29mID0gW107XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGluZGV4KSkge1xuICAgICAgaW5kZXggPSAtMTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZWF2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5jb21wYXJlKGxlYWYsIHRoaXMubGVhdmVzW2ldKSA9PT0gMCkge1xuICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICBpZiAoaW5kZXggPD0gLTEpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmxheWVyc1tpXTtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICAgIGNvbnN0IGlzUmlnaHROb2RlID0gaW5kZXggJSAyO1xuICAgICAgY29uc3QgcGFpckluZGV4ID0gaXNSaWdodE5vZGUgP1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIGlzc3VlIGZyb20gb3JpZ2luYWwgY29kZVxuICAgICAgaW5kZXggLSAxIDogdGhpcy5pc0JpdGNvaW5UcmVlICYmIGluZGV4ID09PSBsYXllci5sZW5ndGggLSAxICYmIGkgPCB0aGlzLmxheWVycy5sZW5ndGggLSAxID9cbiAgICAgIC8vIFByb29mIEdlbmVyYXRpb24gZm9yIEJpdGNvaW4gVHJlZXNcbiAgICAgIGluZGV4IDpcbiAgICAgIC8vIFByb29mIEdlbmVyYXRpb24gZm9yIE5vbi1CaXRjb2luIFRyZWVzXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gaXNzdWUgZnJvbSBvcmlnaW5hbCBjb2RlXG4gICAgICBpbmRleCArIDE7XG4gICAgICBpZiAocGFpckluZGV4IDwgbGF5ZXIubGVuZ3RoKSB7XG4gICAgICAgIHByb29mLnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiBpc1JpZ2h0Tm9kZSA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICAgICAgICAgIGRhdGE6IGxheWVyW3BhaXJJbmRleF1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBpbmRleCB0byBwYXJlbnQgaW5kZXhcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICAgIGluZGV4ID0gaW5kZXggLyAyIHwgMDtcbiAgICB9XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gaXNzdWUgZnJvbSBvcmlnaW5hbCBjb2RlXG4gICAgcmV0dXJuIHByb29mO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldEhleFByb29mXG4gICAqIEBkZXNjIFJldHVybnMgdGhlIHByb29mIGZvciBhIHRhcmdldCBsZWFmIGFzIGhleCBzdHJpbmdzLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gbGVhZiAtIFRhcmdldCBsZWFmXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhdIC0gVGFyZ2V0IGxlYWYgaW5kZXggaW4gbGVhdmVzIGFycmF5LlxuICAgKiBVc2UgaWYgdGhlcmUgYXJlIGxlYXZlcyBjb250YWluaW5nIGR1cGxpY2F0ZSBkYXRhIGluIG9yZGVyIHRvIGRpc3Rpbmd1aXNoIGl0LlxuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX0gLSBQcm9vZiBhcnJheSBhcyBoZXggc3RyaW5ncy5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICpjb25zdCBwcm9vZiA9IHRyZWUuZ2V0SGV4UHJvb2YobGVhdmVzWzJdKVxuICAgKmBgYFxuICAgKi9cbiAgZ2V0SGV4UHJvb2YobGVhZiwgaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcm9vZihsZWFmLCBpbmRleCkubWFwKGl0ZW0gPT4gdGhpcy5idWZmZXJUb0hleChpdGVtLmRhdGEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXRQcm9vZnNcbiAgICogQGRlc2MgUmV0dXJucyB0aGUgcHJvb2ZzIGZvciBhbGwgbGVhdmVzLlxuICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gLSBBcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgYSBwb3NpdGlvbiBwcm9wZXJ0eSBvZiB0eXBlIHN0cmluZ1xuICAgKiB3aXRoIHZhbHVlcyBvZiAnbGVmdCcgb3IgJ3JpZ2h0JyBhbmQgYSBkYXRhIHByb3BlcnR5IG9mIHR5cGUgQnVmZmVyIGZvciBhbGwgbGVhdmVzLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKmNvbnN0IHByb29mcyA9IHRyZWUuZ2V0UHJvb2ZzKClcbiAgICpgYGBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpgYGBqc1xuICAgKmNvbnN0IGxlYXZlcyA9IFsnYScsICdiJywgJ2EnXS5tYXAodmFsdWUgPT4ga2VjY2FrKHZhbHVlKSlcbiAgICpjb25zdCB0cmVlID0gbmV3IE1lcmtsZVRyZWUobGVhdmVzLCBrZWNjYWspXG4gICAqY29uc3QgcHJvb2ZzID0gdHJlZS5nZXRQcm9vZnMoKVxuICAgKmBgYFxuICAgKi9cbiAgZ2V0UHJvb2ZzKCkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICBjb25zdCBwcm9vZiA9IFtdO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICBjb25zdCBwcm9vZnMgPSBbXTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICB0aGlzLmdldFByb29mc0RGUyh0aGlzLmxheWVycy5sZW5ndGggLSAxLCAwLCBwcm9vZiwgcHJvb2ZzKTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICByZXR1cm4gcHJvb2ZzO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldFByb29mc0RGU1xuICAgKiBAZGVzYyBHZXQgYWxsIHByb29mcyB0aHJvdWdoIHNpbmdsZSB0cmF2ZXJzZVxuICAgKiBAcGFyYW0ge051bWJlcn0gY3VycmVudExheWVyIC0gQ3VycmVudCBsYXllciBpbmRleCBpbiB0cmF2ZXJzZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gQ3VycmVudCB0YXJ2ZXNlIG5vZGUgaW5kZXggaW4gdHJhdmVyc2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IHByb29mIC0gUHJvb2YgY2hhaW4gZm9yIHNpbmdsZSBsZWFmLlxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBwcm9vZnMgLSBQcm9vZnMgZm9yIGFsbCBsZWF2ZXNcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICpjb25zdCBsYXllcnMgPSB0cmVlLmdldExheWVycygpXG4gICAqY29uc3QgaW5kZXggPSAwO1xuICAgKmxldCBwcm9vZiA9IFtdO1xuICAgKmxldCBwcm9vZnMgPSBbXTtcbiAgICpjb25zdCBwcm9vZiA9IHRyZWUuZ2V0UHJvb2ZzREZTKGxheWVycywgaW5kZXgsIHByb29mLCBwcm9vZnMpXG4gICAqYGBgXG4gICAqL1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gaXNzdWUgZnJvbSBvcmlnaW5hbCBjb2RlXG4gIGdldFByb29mc0RGUyhjdXJyZW50TGF5ZXIsIGluZGV4LCBwcm9vZiwgcHJvb2ZzKSB7XG4gICAgY29uc3QgaXNSaWdodE5vZGUgPSBpbmRleCAlIDI7XG4gICAgaWYgKGN1cnJlbnRMYXllciA9PT0gLTEpIHtcbiAgICAgIGlmICghaXNSaWdodE5vZGUpIHtcbiAgICAgICAgcHJvb2ZzLnB1c2goWy4uLnByb29mXS5yZXZlcnNlKCkpO1xuICAgICAgfVxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIGlzc3VlIGZyb20gb3JpZ2luYWwgY29kZVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPj0gdGhpcy5sYXllcnNbY3VycmVudExheWVyXS5sZW5ndGgpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmxheWVyc1tjdXJyZW50TGF5ZXJdO1xuICAgIGNvbnN0IHBhaXJJbmRleCA9IGlzUmlnaHROb2RlID8gaW5kZXggLSAxIDogaW5kZXggKyAxO1xuICAgIGxldCBwdXNoZWQgPSBmYWxzZTtcbiAgICBpZiAocGFpckluZGV4IDwgbGF5ZXIubGVuZ3RoKSB7XG4gICAgICBwdXNoZWQgPSB0cnVlO1xuICAgICAgcHJvb2YucHVzaCh7XG4gICAgICAgIHBvc2l0aW9uOiBpc1JpZ2h0Tm9kZSA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICAgICAgICBkYXRhOiBsYXllcltwYWlySW5kZXhdXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbGVmdGNoaWxkSW5kZXggPSBpbmRleCAqIDI7XG4gICAgY29uc3QgcmlnaHRjaGlsZEluZGV4ID0gaW5kZXggKiAyICsgMTtcbiAgICB0aGlzLmdldFByb29mc0RGUyhjdXJyZW50TGF5ZXIgLSAxLCBsZWZ0Y2hpbGRJbmRleCwgcHJvb2YsIHByb29mcyk7XG4gICAgdGhpcy5nZXRQcm9vZnNERlMoY3VycmVudExheWVyIC0gMSwgcmlnaHRjaGlsZEluZGV4LCBwcm9vZiwgcHJvb2ZzKTtcbiAgICBpZiAocHVzaGVkKSB7XG4gICAgICBwcm9vZi5zcGxpY2UocHJvb2YubGVuZ3RoIC0gMSwgMSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldEhleFByb29mc1xuICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBwcm9vZnMgZm9yIGFsbCBsZWF2ZXMgYXMgaGV4IHN0cmluZ3MuXG4gICAqIEByZXR1cm4ge1N0cmluZ1tdfSAtIFByb29mcyBhcnJheSBhcyBoZXggc3RyaW5ncy5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICpjb25zdCBwcm9vZnMgPSB0cmVlLmdldEhleFByb29mcygpXG4gICAqYGBgXG4gICAqL1xuICBnZXRIZXhQcm9vZnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJvb2ZzKCkubWFwKGl0ZW0gPT4gdGhpcy5idWZmZXJUb0hleChpdGVtLmRhdGEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXRQb3NpdGlvbmFsSGV4UHJvb2ZcbiAgICogQGRlc2MgUmV0dXJucyB0aGUgcHJvb2YgZm9yIGEgdGFyZ2V0IGxlYWYgYXMgaGV4IHN0cmluZ3MgYW5kIHRoZSBwb3NpdGlvbiBpbiBiaW5hcnkgKGxlZnQgPT0gMCkuXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBsZWFmIC0gVGFyZ2V0IGxlYWZcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF0gLSBUYXJnZXQgbGVhZiBpbmRleCBpbiBsZWF2ZXMgYXJyYXkuXG4gICAqIFVzZSBpZiB0aGVyZSBhcmUgbGVhdmVzIGNvbnRhaW5pbmcgZHVwbGljYXRlIGRhdGEgaW4gb3JkZXIgdG8gZGlzdGluZ3Vpc2ggaXQuXG4gICAqIEByZXR1cm4geyhzdHJpbmcgfCBudW1iZXIpW11bXX0gLSBQcm9vZiBhcnJheSBhcyBoZXggc3RyaW5ncy4gcG9zaXRpb24gYXQgaW5kZXggMFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKmNvbnN0IHByb29mID0gdHJlZS5nZXRQb3NpdGlvbmFsSGV4UHJvb2YobGVhdmVzWzJdKVxuICAgKmBgYFxuICAgKi9cbiAgZ2V0UG9zaXRpb25hbEhleFByb29mKGxlYWYsIGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJvb2YobGVhZiwgaW5kZXgpLm1hcChpdGVtID0+IHtcbiAgICAgIHJldHVybiBbaXRlbS5wb3NpdGlvbiA9PT0gXCJsZWZ0XCIgPyAwIDogMSwgdGhpcy5idWZmZXJUb0hleChpdGVtLmRhdGEpXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXRQcm9vZkluZGljZXNcbiAgICogQGRlc2MgUmV0dXJucyB0aGUgcHJvb2YgaW5kaWNlcyBmb3IgZ2l2ZW4gdHJlZSBpbmRpY2VzLlxuICAgKiBAcGFyYW0ge051bWJlcltdfSB0cmVlSW5kaWNlcyAtIFRyZWUgaW5kaWNlc1xuICAgKiBAcGFyYW0ge051bWJlcn0gZGVwdGggLSBUcmVlIGRlcHRoOyBudW1iZXIgb2YgbGF5ZXJzLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0gLSBQcm9vZiBpbmRpY2VzXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqY29uc3QgcHJvb2ZJbmRpY2VzID0gdHJlZS5nZXRQcm9vZkluZGljZXMoWzIsNSw2XSwgNClcbiAgICpjb25zb2xlLmxvZyhwcm9vZkluZGljZXMpIC8vIFsgMjMsIDIwLCAxOSwgOCwgMyBdXG4gICAqYGBgXG4gICAqL1xuICBnZXRQcm9vZkluZGljZXModHJlZUluZGljZXMsIGRlcHRoKSB7XG4gICAgY29uc3QgbGVhZkNvdW50ID0gMiAqKiBkZXB0aDtcbiAgICBsZXQgbWF4aW1hbEluZGljZXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiB0cmVlSW5kaWNlcykge1xuICAgICAgbGV0IHggPSBsZWFmQ291bnQgKyBpbmRleDtcbiAgICAgIHdoaWxlICh4ID4gMSkge1xuICAgICAgICBtYXhpbWFsSW5kaWNlcy5hZGQoeCBeIDEpO1xuICAgICAgICB4ID0geCAvIDIgfCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhID0gdHJlZUluZGljZXMubWFwKGluZGV4ID0+IGxlYWZDb3VudCArIGluZGV4KTtcbiAgICBjb25zdCBiID0gQXJyYXkuZnJvbShtYXhpbWFsSW5kaWNlcykuc29ydCgoeCwgeSkgPT4geCAtIHkpLnJldmVyc2UoKTtcbiAgICBtYXhpbWFsSW5kaWNlcyA9IGEuY29uY2F0KGIpO1xuICAgIGNvbnN0IHJlZHVuZGFudEluZGljZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgcHJvb2YgPSBbXTtcbiAgICBmb3IgKGxldCBpbmRleCBvZiBtYXhpbWFsSW5kaWNlcykge1xuICAgICAgaWYgKCFyZWR1bmRhbnRJbmRpY2VzLmhhcyhpbmRleCkpIHtcbiAgICAgICAgcHJvb2YucHVzaChpbmRleCk7XG4gICAgICAgIHdoaWxlIChpbmRleCA+IDEpIHtcbiAgICAgICAgICByZWR1bmRhbnRJbmRpY2VzLmFkZChpbmRleCk7XG4gICAgICAgICAgaWYgKCFyZWR1bmRhbnRJbmRpY2VzLmhhcyhpbmRleCBeIDEpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5kZXggPSBpbmRleCAvIDIgfCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9vZi5maWx0ZXIoaW5kZXggPT4ge1xuICAgICAgcmV0dXJuICF0cmVlSW5kaWNlcy5pbmNsdWRlcyhpbmRleCAtIGxlYWZDb3VudCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0UHJvb2ZJbmRpY2VzRm9yVW5ldmVuVHJlZShzb3J0ZWRMZWFmSW5kaWNlcywgbGVhdmVzQ291bnQpIHtcbiAgICBjb25zdCBkZXB0aCA9IE1hdGguY2VpbChNYXRoLmxvZzIobGVhdmVzQ291bnQpKTtcbiAgICBjb25zdCB1bmV2ZW5MYXllcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZGVwdGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHVuZXZlbkxheWVyID0gbGVhdmVzQ291bnQgJSAyICE9PSAwO1xuICAgICAgaWYgKHVuZXZlbkxheWVyKSB7XG4gICAgICAgIHVuZXZlbkxheWVycy5wdXNoKHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBsZWF2ZXNDb3VudFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxlYXZlc0NvdW50ID0gTWF0aC5jZWlsKGxlYXZlc0NvdW50IC8gMik7XG4gICAgfVxuICAgIGNvbnN0IHByb29mSW5kaWNlcyA9IFtdO1xuICAgIGxldCBsYXllck5vZGVzID0gc29ydGVkTGVhZkluZGljZXM7XG4gICAgZm9yIChsZXQgbGF5ZXJJbmRleCA9IDA7IGxheWVySW5kZXggPCBkZXB0aDsgbGF5ZXJJbmRleCsrKSB7XG4gICAgICBjb25zdCBzaWJsaW5nSW5kaWNlcyA9IGxheWVyTm9kZXMubWFwKGluZGV4ID0+IHtcbiAgICAgICAgaWYgKGluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBpbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4IC0gMTtcbiAgICAgIH0pO1xuICAgICAgbGV0IHByb29mTm9kZUluZGljZXMgPSBzaWJsaW5nSW5kaWNlcy5maWx0ZXIoaW5kZXggPT4gIWxheWVyTm9kZXMuaW5jbHVkZXMoaW5kZXgpKTtcbiAgICAgIGNvbnN0IHVuZXZlbkxheWVyID0gdW5ldmVuTGF5ZXJzLmZpbmQoX3JlZiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgaW5kZXhcbiAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgIHJldHVybiBpbmRleCA9PT0gbGF5ZXJJbmRleDtcbiAgICAgIH0pO1xuICAgICAgaWYgKHVuZXZlbkxheWVyICYmIGxheWVyTm9kZXMuaW5jbHVkZXModW5ldmVuTGF5ZXIubGVhdmVzQ291bnQgLSAxKSkge1xuICAgICAgICBwcm9vZk5vZGVJbmRpY2VzID0gcHJvb2ZOb2RlSW5kaWNlcy5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgICBwcm9vZkluZGljZXMucHVzaChwcm9vZk5vZGVJbmRpY2VzKTtcbiAgICAgIGxheWVyTm9kZXMgPSBbLi4ubmV3IFNldChsYXllck5vZGVzLm1hcChpbmRleCA9PiB7XG4gICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXggLyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gKGluZGV4ICsgMSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaW5kZXggLSAxKSAvIDI7XG4gICAgICB9KSldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvb2ZJbmRpY2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldE11bHRpUHJvb2ZcbiAgICogQGRlc2MgUmV0dXJucyB0aGUgbXVsdGlwcm9vZiBmb3IgZ2l2ZW4gdHJlZSBpbmRpY2VzLlxuICAgKiBAcGFyYW0ge051bWJlcltdfSBpbmRpY2VzIC0gVHJlZSBpbmRpY2VzLlxuICAgKiBAcmV0dXJuIHtCdWZmZXJbXX0gLSBNdWx0aXByb29mc1xuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKmNvbnN0IGluZGljZXMgPSBbMiwgNSwgNl1cbiAgICpjb25zdCBwcm9vZiA9IHRyZWUuZ2V0TXVsdGlQcm9vZihpbmRpY2VzKVxuICAgKmBgYFxuICAgKi9cbiAgZ2V0TXVsdGlQcm9vZih0cmVlLCBpbmRpY2VzKSB7XG4gICAgaWYgKCF0aGlzLmNvbXBsZXRlKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBGb3IgY29ycmVjdCBtdWx0aVByb29mcyBpdCdzIHN0cm9uZ2x5IHJlY29tbWVuZGVkIHRvIHNldCBjb21wbGV0ZTogdHJ1ZVwiKTtcbiAgICB9XG4gICAgaWYgKCFpbmRpY2VzKSB7XG4gICAgICBpbmRpY2VzID0gdHJlZTtcbiAgICAgIHRyZWUgPSB0aGlzLmdldExheWVyc0ZsYXQoKTtcbiAgICB9XG4gICAgY29uc3QgaXNVbmV2ZW4gPSB0aGlzLmlzVW5ldmVuVHJlZSgpO1xuICAgIGlmIChpc1VuZXZlbikge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIGlzc3VlIGZyb20gb3JpZ2luYWwgY29kZVxuICAgICAgaWYgKGluZGljZXMuZXZlcnkoTnVtYmVyLmlzSW50ZWdlcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TXVsdGlQcm9vZkZvclVuZXZlblRyZWUoaW5kaWNlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICBpZiAoIWluZGljZXMuZXZlcnkoTnVtYmVyLmlzSW50ZWdlcikpIHtcbiAgICAgIGxldCBlbHMgPSBpbmRpY2VzO1xuICAgICAgaWYgKHRoaXMuc29ydFBhaXJzKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICAgICAgZWxzID0gZWxzLnNvcnQoQnVmZmVyLmNvbXBhcmUpO1xuICAgICAgfVxuXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gaXNzdWUgZnJvbSBvcmlnaW5hbCBjb2RlXG4gICAgICBsZXQgaWRzID0gZWxzLm1hcChlbCA9PiB0aGlzLmJ1ZmZlckluZGV4T2YodGhpcy5sZWF2ZXMsIGVsLCB0aGlzLnNvcnRMZWF2ZXMpKS5zb3J0KChhLCBiKSA9PiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xKTtcbiAgICAgIGlmICghaWRzLmV2ZXJ5KGlkeCA9PiBpZHggIT09IC0xKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50IGRvZXMgbm90IGV4aXN0IGluIE1lcmtsZSB0cmVlXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gaXNzdWUgZnJvbSBvcmlnaW5hbCBjb2RlXG4gICAgICBjb25zdCBoYXNoZXMgPSBbXTtcbiAgICAgIGNvbnN0IHByb29mID0gW107XG4gICAgICBsZXQgbmV4dElkcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBsYXllciA9IHRoaXMubGF5ZXJzW2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGlkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IGlkeCA9IGlkc1tqXTtcbiAgICAgICAgICBjb25zdCBwYWlyRWxlbWVudCA9IHRoaXMuZ2V0UGFpck5vZGUobGF5ZXIsIGlkeCk7XG4gICAgICAgICAgaGFzaGVzLnB1c2gobGF5ZXJbaWR4XSk7XG4gICAgICAgICAgaWYgKHBhaXJFbGVtZW50KSB7XG4gICAgICAgICAgICBwcm9vZi5wdXNoKHBhaXJFbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dElkcy5wdXNoKGlkeCAvIDIgfCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZHMgPSBuZXh0SWRzLmZpbHRlcigodmFsdWUsIGosIHNlbGYpID0+IHNlbGYuaW5kZXhPZih2YWx1ZSkgPT09IGopO1xuICAgICAgICBuZXh0SWRzID0gW107XG4gICAgICB9XG5cbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICAgIHJldHVybiBwcm9vZi5maWx0ZXIodmFsdWUgPT4gIWhhc2hlcy5pbmNsdWRlcyh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICByZXR1cm4gdGhpcy5nZXRQcm9vZkluZGljZXMoaW5kaWNlcywgTWF0aC5sb2cyKHRyZWUubGVuZ3RoIC8gMiB8IDApKS5tYXAoXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIGlzc3VlIGZyb20gb3JpZ2luYWwgY29kZVxuICAgIGluZGV4ID0+IHRyZWVbaW5kZXhdKTtcbiAgfVxuICBnZXRNdWx0aVByb29mRm9yVW5ldmVuVHJlZSh0cmVlLCBpbmRpY2VzKSB7XG4gICAgaWYgKCFpbmRpY2VzKSB7XG4gICAgICBpbmRpY2VzID0gdHJlZTtcbiAgICAgIHRyZWUgPSB0aGlzLmdldExheWVycygpO1xuICAgIH1cbiAgICBsZXQgcHJvb2ZIYXNoZXMgPSBbXTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gaXNzdWUgZnJvbSBvcmlnaW5hbCBjb2RlXG4gICAgbGV0IGN1cnJlbnRMYXllckluZGljZXMgPSBpbmRpY2VzO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICBmb3IgKGNvbnN0IHRyZWVMYXllciBvZiB0cmVlKSB7XG4gICAgICBjb25zdCBzaWJsaW5ncyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBjdXJyZW50TGF5ZXJJbmRpY2VzKSB7XG4gICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICBjb25zdCBpZHggPSBpbmRleCArIDE7XG4gICAgICAgICAgaWYgKCFjdXJyZW50TGF5ZXJJbmRpY2VzLmluY2x1ZGVzKGlkeCkpIHtcbiAgICAgICAgICAgIGlmICh0cmVlTGF5ZXJbaWR4XSkge1xuICAgICAgICAgICAgICBzaWJsaW5ncy5wdXNoKHRyZWVMYXllcltpZHhdKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkeCA9IGluZGV4IC0gMTtcbiAgICAgICAgaWYgKCFjdXJyZW50TGF5ZXJJbmRpY2VzLmluY2x1ZGVzKGlkeCkpIHtcbiAgICAgICAgICBpZiAodHJlZUxheWVyW2lkeF0pIHtcbiAgICAgICAgICAgIHNpYmxpbmdzLnB1c2godHJlZUxheWVyW2lkeF0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9vZkhhc2hlcyA9IHByb29mSGFzaGVzLmNvbmNhdChzaWJsaW5ncyk7XG4gICAgICBjb25zdCB1bmlxdWVJbmRpY2VzID0gbmV3IFNldCgpO1xuICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBjdXJyZW50TGF5ZXJJbmRpY2VzKSB7XG4gICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICB1bmlxdWVJbmRpY2VzLmFkZChpbmRleCAvIDIpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICB1bmlxdWVJbmRpY2VzLmFkZCgoaW5kZXggKyAxKSAvIDIpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXF1ZUluZGljZXMuYWRkKChpbmRleCAtIDEpIC8gMik7XG4gICAgICB9XG4gICAgICBjdXJyZW50TGF5ZXJJbmRpY2VzID0gQXJyYXkuZnJvbSh1bmlxdWVJbmRpY2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb29mSGFzaGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldEhleE11bHRpUHJvb2ZcbiAgICogQGRlc2MgUmV0dXJucyB0aGUgbXVsdGlwcm9vZiBmb3IgZ2l2ZW4gdHJlZSBpbmRpY2VzIGFzIGhleCBzdHJpbmdzLlxuICAgKiBAcGFyYW0ge051bWJlcltdfSBpbmRpY2VzIC0gVHJlZSBpbmRpY2VzLlxuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX0gLSBNdWx0aXByb29mcyBhcyBoZXggc3RyaW5ncy5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICpjb25zdCBpbmRpY2VzID0gWzIsIDUsIDZdXG4gICAqY29uc3QgcHJvb2YgPSB0cmVlLmdldEhleE11bHRpUHJvb2YoaW5kaWNlcylcbiAgICpgYGBcbiAgICovXG4gIGdldEhleE11bHRpUHJvb2YodHJlZSwgaW5kaWNlcykge1xuICAgIHJldHVybiB0aGlzLmdldE11bHRpUHJvb2YodHJlZSwgaW5kaWNlcykubWFwKHggPT4gdGhpcy5idWZmZXJUb0hleCh4KSk7XG4gIH1cblxuICAvKipcbiAgICogZ2V0UHJvb2ZGbGFnc1xuICAgKiBAZGVzYyBSZXR1cm5zIGxpc3Qgb2YgYm9vbGVhbnMgd2hlcmUgcHJvb2ZzIHNob3VsZCBiZSB1c2VkIGluc3RlYWQgb2YgaGFzaGluZy5cbiAgICogUHJvb2YgZmxhZ3MgYXJlIHVzZWQgaW4gdGhlIFNvbGlkaXR5IG11bHRpcHJvb2YgdmVyaWZpZXJzLlxuICAgKiBAcGFyYW0ge051bWJlcltdfEJ1ZmZlcltdfSBsZWF2ZXNcbiAgICogQHBhcmFtIHtCdWZmZXJbXX0gcHJvb2ZzXG4gICAqIEByZXR1cm4ge0Jvb2xlYW5bXX0gLSBCb29sZWFuIGZsYWdzXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqY29uc3QgaW5kaWNlcyA9IFsyLCA1LCA2XVxuICAgKmNvbnN0IHByb29mID0gdHJlZS5nZXRNdWx0aVByb29mKGluZGljZXMpXG4gICAqY29uc3QgcHJvb2ZGbGFncyA9IHRyZWUuZ2V0UHJvb2ZGbGFncyhsZWF2ZXMsIHByb29mKVxuICAgKmBgYFxuICAgKi9cbiAgZ2V0UHJvb2ZGbGFncyhsZWF2ZXMsIHByb29mcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShsZWF2ZXMpIHx8IGxlYXZlcy5sZW5ndGggPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBJbnB1dHMhXCIpO1xuICAgIH1cbiAgICBsZXQgaWRzO1xuICAgIGlmIChsZWF2ZXMuZXZlcnkoTnVtYmVyLmlzSW50ZWdlcikpIHtcbiAgICAgIGlkcyA9IFsuLi5sZWF2ZXNdLnNvcnQoKGEsIGIpID0+IGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTEpOyAvLyBJbmRpY2VzIHdoZXJlIHBhc3NlZFxuICAgIH0gZWxzZSB7XG4gICAgICBpZHMgPSBsZWF2ZXMubWFwKGVsID0+IHRoaXMuYnVmZmVySW5kZXhPZih0aGlzLmxlYXZlcywgZWwsIHRoaXMuc29ydExlYXZlcykpLnNvcnQoKGEsIGIpID0+IGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTEpO1xuICAgIH1cbiAgICBpZiAoIWlkcy5ldmVyeShpZHggPT4gaWR4ICE9PSAtMSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnQgZG9lcyBub3QgZXhpc3QgaW4gTWVya2xlIHRyZWVcIik7XG4gICAgfVxuICAgIGNvbnN0IF9wcm9vZnMgPSBwcm9vZnMubWFwKGl0ZW0gPT4gdGhpcy5idWZmZXJpZnkoaXRlbSkpO1xuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIGlzc3VlIGZyb20gb3JpZ2luYWwgY29kZVxuICAgIGNvbnN0IHRlc3RlZCA9IFtdO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICBjb25zdCBmbGFncyA9IFtdO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmxheWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5sYXllcnNbaW5kZXhdO1xuICAgICAgaWRzID0gaWRzLnJlZHVjZSgoaWRzXywgaWR4KSA9PiB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICAgICAgY29uc3Qgc2tpcHBlZCA9IHRlc3RlZC5pbmNsdWRlcyhsYXllcltpZHhdKTtcbiAgICAgICAgaWYgKCFza2lwcGVkKSB7XG4gICAgICAgICAgY29uc3QgcGFpckVsZW1lbnQgPSB0aGlzLmdldFBhaXJOb2RlKGxheWVyLCBpZHgpO1xuICAgICAgICAgIGNvbnN0IHByb29mVXNlZCA9IF9wcm9vZnMuaW5jbHVkZXMobGF5ZXJbaWR4XSkgfHwgX3Byb29mcy5pbmNsdWRlcyhwYWlyRWxlbWVudCk7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgICAgIHBhaXJFbGVtZW50ICYmIGZsYWdzLnB1c2goIXByb29mVXNlZCk7XG4gICAgICAgICAgdGVzdGVkLnB1c2gobGF5ZXJbaWR4XSk7XG4gICAgICAgICAgdGVzdGVkLnB1c2gocGFpckVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICAgICAgaWRzXy5wdXNoKGlkeCAvIDIgfCAwKTtcbiAgICAgICAgcmV0dXJuIGlkc187XG4gICAgICB9LCBbXSk7XG4gICAgfVxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIGlzc3VlIGZyb20gb3JpZ2luYWwgY29kZVxuICAgIHJldHVybiBmbGFncztcbiAgfVxuXG4gIC8qKlxuICAgKiB2ZXJpZnlcbiAgICogQGRlc2MgUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9vZiBwYXRoIChhcnJheSBvZiBoYXNoZXMpIGNhbiBjb25uZWN0IHRoZSB0YXJnZXQgbm9kZVxuICAgKiB0byB0aGUgTWVya2xlIHJvb3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IHByb29mIC0gQXJyYXkgb2YgcHJvb2Ygb2JqZWN0cyB0aGF0IHNob3VsZCBjb25uZWN0XG4gICAqIHRhcmdldCBub2RlIHRvIE1lcmtsZSByb290LlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gdGFyZ2V0Tm9kZSAtIFRhcmdldCBub2RlIEJ1ZmZlclxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gcm9vdCAtIE1lcmtsZSByb290IEJ1ZmZlclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAZXhhbXBsZVxuICAgKmBgYGpzXG4gICAqY29uc3Qgcm9vdCA9IHRyZWUuZ2V0Um9vdCgpXG4gICAqY29uc3QgcHJvb2YgPSB0cmVlLmdldFByb29mKGxlYXZlc1syXSlcbiAgICpjb25zdCB2ZXJpZmllZCA9IHRyZWUudmVyaWZ5KHByb29mLCBsZWF2ZXNbMl0sIHJvb3QpXG4gICAqYGBgXG4gICAqL1xuICB2ZXJpZnkocHJvb2YsIHRhcmdldE5vZGUsIHJvb3QpIHtcbiAgICBsZXQgaGFzaCA9IHRoaXMuYnVmZmVyaWZ5KHRhcmdldE5vZGUpO1xuICAgIHJvb3QgPSB0aGlzLmJ1ZmZlcmlmeShyb290KTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvb2YpIHx8ICF0YXJnZXROb2RlIHx8ICFyb290KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvb2YubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBwcm9vZltpXTtcbiAgICAgIGxldCBkYXRhID0gbnVsbDtcbiAgICAgIGxldCBpc0xlZnROb2RlID0gbnVsbDtcblxuICAgICAgLy8gY2FzZSBmb3Igd2hlbiBwcm9vZiBpcyBoZXggdmFsdWVzIG9ubHlcbiAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhID0gdGhpcy5idWZmZXJpZnkobm9kZSk7XG4gICAgICAgIGlzTGVmdE5vZGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICAgIGlzTGVmdE5vZGUgPSBub2RlWzBdID09PSAwO1xuICAgICAgICBkYXRhID0gdGhpcy5idWZmZXJpZnkobm9kZVsxXSk7XG4gICAgICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihub2RlKSkge1xuICAgICAgICBkYXRhID0gbm9kZTtcbiAgICAgICAgaXNMZWZ0Tm9kZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgZGF0YSA9IHRoaXMuYnVmZmVyaWZ5KG5vZGUuZGF0YSk7XG4gICAgICAgIGlzTGVmdE5vZGUgPSBub2RlLnBvc2l0aW9uID09PSBcImxlZnRcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG5vZGUgdG8gYmUgb2YgdHlwZSBzdHJpbmcgb3Igb2JqZWN0XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgICAgaWYgKHRoaXMuaXNCaXRjb2luVHJlZSkge1xuICAgICAgICBidWZmZXJzLnB1c2gocmV2ZXJzZShoYXNoKSk7XG4gICAgICAgIGJ1ZmZlcnNbaXNMZWZ0Tm9kZSA/IFwidW5zaGlmdFwiIDogXCJwdXNoXCJdKHJldmVyc2UoZGF0YSkpO1xuICAgICAgICBoYXNoID0gdGhpcy5oYXNoRm4odGhpcy5jb25jYXRlbmF0b3IoYnVmZmVycykpO1xuICAgICAgICBoYXNoID0gcmV2ZXJzZSh0aGlzLmhhc2hGbihoYXNoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zb3J0UGFpcnMpIHtcbiAgICAgICAgICBpZiAoQnVmZmVyLmNvbXBhcmUoaGFzaCwgZGF0YSkgPT09IC0xKSB7XG4gICAgICAgICAgICBidWZmZXJzLnB1c2goaGFzaCwgZGF0YSk7XG4gICAgICAgICAgICBoYXNoID0gdGhpcy5oYXNoRm4odGhpcy5jb25jYXRlbmF0b3IoYnVmZmVycykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXJzLnB1c2goZGF0YSwgaGFzaCk7XG4gICAgICAgICAgICBoYXNoID0gdGhpcy5oYXNoRm4odGhpcy5jb25jYXRlbmF0b3IoYnVmZmVycykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWZmZXJzLnB1c2goaGFzaCk7XG4gICAgICAgICAgYnVmZmVyc1tpc0xlZnROb2RlID8gXCJ1bnNoaWZ0XCIgOiBcInB1c2hcIl0oZGF0YSk7XG4gICAgICAgICAgaGFzaCA9IHRoaXMuaGFzaEZuKHRoaXMuY29uY2F0ZW5hdG9yKGJ1ZmZlcnMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmNvbXBhcmUoaGFzaCwgcm9vdCkgPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogdmVyaWZ5TXVsdGlQcm9vZlxuICAgKiBAZGVzYyBSZXR1cm5zIHRydWUgaWYgdGhlIG11bHRpcHJvb2ZzIGNhbiBjb25uZWN0IHRoZSBsZWF2ZXMgdG8gdGhlIE1lcmtsZSByb290LlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gcm9vdCAtIE1lcmtsZSB0cmVlIHJvb3RcbiAgICogQHBhcmFtIHtOdW1iZXJbXX0gcHJvb2ZJbmRpY2VzIC0gTGVhdmUgaW5kaWNlcyBmb3IgcHJvb2ZcbiAgICogQHBhcmFtIHtCdWZmZXJbXX0gcHJvb2ZMZWF2ZXMgLSBMZWFmIHZhbHVlcyBhdCBpbmRpY2VzIGZvciBwcm9vZlxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVhdmVzQ291bnQgLSBDb3VudCBvZiBvcmlnaW5hbCBsZWF2ZXNcbiAgICogQHBhcmFtIHtCdWZmZXJbXX0gcHJvb2YgLSBNdWx0aXByb29mcyBnaXZlbiBpbmRpY2VzXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqYGBganNcbiAgICpjb25zdCBsZWF2ZXMgPSB0cmVlLmdldExlYXZlcygpXG4gICAqY29uc3Qgcm9vdCA9IHRyZWUuZ2V0Um9vdCgpXG4gICAqY29uc3QgdHJlZUZsYXQgPSB0cmVlLmdldExheWVyc0ZsYXQoKVxuICAgKmNvbnN0IGxlYXZlc0NvdW50ID0gbGVhdmVzLmxlbmd0aFxuICAgKmNvbnN0IHByb29mSW5kaWNlcyA9IFsyLCA1LCA2XVxuICAgKmNvbnN0IHByb29mTGVhdmVzID0gcHJvb2ZJbmRpY2VzLm1hcChpID0+IGxlYXZlc1tpXSlcbiAgICpjb25zdCBwcm9vZiA9IHRyZWUuZ2V0TXVsdGlQcm9vZih0cmVlRmxhdCwgaW5kaWNlcylcbiAgICpjb25zdCB2ZXJpZmllZCA9IHRyZWUudmVyaWZ5TXVsdGlQcm9vZihyb290LCBwcm9vZkluZGljZXMsIHByb29mTGVhdmVzLCBsZWF2ZXNDb3VudCwgcHJvb2YpXG4gICAqYGBgXG4gICAqL1xuICB2ZXJpZnlNdWx0aVByb29mKHJvb3QsIHByb29mSW5kaWNlcywgcHJvb2ZMZWF2ZXMsIGxlYXZlc0NvdW50LCBwcm9vZikge1xuICAgIGNvbnN0IGlzVW5ldmVuID0gdGhpcy5pc1VuZXZlblRyZWUoKTtcbiAgICBpZiAoaXNVbmV2ZW4pIHtcbiAgICAgIC8vIFRPRE86IGNvbWJpbmUgdGhlc2UgZnVuY3Rpb25zIGFuZCBzaW1wbGlmeVxuICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5TXVsdGlQcm9vZkZvclVuZXZlblRyZWUocm9vdCwgcHJvb2ZJbmRpY2VzLCBwcm9vZkxlYXZlcywgbGVhdmVzQ291bnQsIHByb29mKTtcbiAgICB9XG4gICAgY29uc3QgZGVwdGggPSBNYXRoLmNlaWwoTWF0aC5sb2cyKGxlYXZlc0NvdW50KSk7XG4gICAgcm9vdCA9IHRoaXMuYnVmZmVyaWZ5KHJvb3QpO1xuICAgIHByb29mTGVhdmVzID0gcHJvb2ZMZWF2ZXMubWFwKGxlYWYgPT4gdGhpcy5idWZmZXJpZnkobGVhZikpO1xuICAgIHByb29mID0gcHJvb2YubWFwKGxlYWYgPT4gdGhpcy5idWZmZXJpZnkobGVhZikpO1xuICAgIGNvbnN0IHRyZWUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgbGVhZl0gb2YgdGhpcy56aXAocHJvb2ZJbmRpY2VzLCBwcm9vZkxlYXZlcykpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICAgIHRyZWVbMiAqKiBkZXB0aCArIGluZGV4XSA9IGxlYWY7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2luZGV4LCBwcm9vZml0ZW1dIG9mIHRoaXMuemlwKHRoaXMuZ2V0UHJvb2ZJbmRpY2VzKHByb29mSW5kaWNlcywgZGVwdGgpLCBwcm9vZikpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICAgIHRyZWVbaW5kZXhdID0gcHJvb2ZpdGVtO1xuICAgIH1cbiAgICBsZXQgaW5kZXhxdWV1ZSA9IE9iamVjdC5rZXlzKHRyZWUpLm1hcCh2YWx1ZSA9PiBOdW1iZXIodmFsdWUpKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgaW5kZXhxdWV1ZSA9IGluZGV4cXVldWUuc2xpY2UoMCwgaW5kZXhxdWV1ZS5sZW5ndGggLSAxKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBpbmRleHF1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgaW5kZXggPSBpbmRleHF1ZXVlW2ldO1xuICAgICAgaWYgKGluZGV4ID49IDIgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbCh0cmVlLCBpbmRleCBeIDEpKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICAgICAgbGV0IHBhaXIgPSBbdHJlZVtpbmRleCAtIGluZGV4ICUgMl0sIHRyZWVbaW5kZXggLSBpbmRleCAlIDIgKyAxXV07XG4gICAgICAgIGlmICh0aGlzLnNvcnRQYWlycykge1xuICAgICAgICAgIHBhaXIgPSBwYWlyLnNvcnQoQnVmZmVyLmNvbXBhcmUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc2ggPSBwYWlyWzFdID8gdGhpcy5oYXNoRm4odGhpcy5jb25jYXRlbmF0b3IocGFpcikpIDogcGFpclswXTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIGlzc3VlIGZyb20gb3JpZ2luYWwgY29kZVxuICAgICAgICB0cmVlW2luZGV4IC8gMiB8IDBdID0gaGFzaDtcbiAgICAgICAgaW5kZXhxdWV1ZS5wdXNoKGluZGV4IC8gMiB8IDApO1xuICAgICAgfVxuICAgICAgaSArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gIXByb29mSW5kaWNlcy5sZW5ndGggfHxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gaXNzdWUgZnJvbSBvcmlnaW5hbCBjb2RlXG4gICAge30uaGFzT3duUHJvcGVydHkuY2FsbCh0cmVlLCAxKSAmJiB0cmVlWzFdLmVxdWFscyhyb290KTtcbiAgfVxuICB2ZXJpZnlNdWx0aVByb29mV2l0aEZsYWdzKHJvb3QsIGxlYXZlcywgcHJvb2ZzLCBwcm9vZkZsYWcpIHtcbiAgICByb290ID0gdGhpcy5idWZmZXJpZnkocm9vdCk7XG4gICAgbGVhdmVzID0gbGVhdmVzLm1hcCh0aGlzLmJ1ZmZlcmlmeSk7XG4gICAgcHJvb2ZzID0gcHJvb2ZzLm1hcCh0aGlzLmJ1ZmZlcmlmeSk7XG4gICAgY29uc3QgbGVhdmVzTGVuID0gbGVhdmVzLmxlbmd0aDtcbiAgICBjb25zdCB0b3RhbEhhc2hlcyA9IHByb29mRmxhZy5sZW5ndGg7XG4gICAgY29uc3QgaGFzaGVzID0gW107XG4gICAgbGV0IGxlYWZQb3MgPSAwO1xuICAgIGxldCBoYXNoUG9zID0gMDtcbiAgICBsZXQgcHJvb2ZQb3MgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxIYXNoZXM7IGkrKykge1xuICAgICAgY29uc3QgYnVmQSA9IHByb29mRmxhZ1tpXSA/IGxlYWZQb3MgPCBsZWF2ZXNMZW4gPyBsZWF2ZXNbbGVhZlBvcysrXSA6IGhhc2hlc1toYXNoUG9zKytdIDogcHJvb2ZzW3Byb29mUG9zKytdO1xuICAgICAgY29uc3QgYnVmQiA9IGxlYWZQb3MgPCBsZWF2ZXNMZW4gPyBsZWF2ZXNbbGVhZlBvcysrXSA6IGhhc2hlc1toYXNoUG9zKytdO1xuICAgICAgY29uc3QgYnVmZmVycyA9IFtidWZBLCBidWZCXS5zb3J0KEJ1ZmZlci5jb21wYXJlKTtcbiAgICAgIGhhc2hlc1tpXSA9IHRoaXMuaGFzaEZuKHRoaXMuY29uY2F0ZW5hdG9yKGJ1ZmZlcnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKGhhc2hlc1t0b3RhbEhhc2hlcyAtIDFdLCByb290KSA9PT0gMDtcbiAgfVxuICB2ZXJpZnlNdWx0aVByb29mRm9yVW5ldmVuVHJlZShyb290LCBpbmRpY2VzLCBsZWF2ZXMsIGxlYXZlc0NvdW50LCBwcm9vZikge1xuICAgIHJvb3QgPSB0aGlzLmJ1ZmZlcmlmeShyb290KTtcbiAgICBsZWF2ZXMgPSBsZWF2ZXMubWFwKGxlYWYgPT4gdGhpcy5idWZmZXJpZnkobGVhZikpO1xuICAgIHByb29mID0gcHJvb2YubWFwKGxlYWYgPT4gdGhpcy5idWZmZXJpZnkobGVhZikpO1xuICAgIGNvbnN0IGNvbXB1dGVkUm9vdCA9IHRoaXMuY2FsY3VsYXRlUm9vdEZvclVuZXZlblRyZWUoaW5kaWNlcywgbGVhdmVzLCBsZWF2ZXNDb3VudCwgcHJvb2YpO1xuICAgIHJldHVybiByb290LmVxdWFscyhjb21wdXRlZFJvb3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldERlcHRoXG4gICAqIEBkZXNjIFJldHVybnMgdGhlIHRyZWUgZGVwdGggKG51bWJlciBvZiBsYXllcnMpXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICpgYGBqc1xuICAgKmNvbnN0IGRlcHRoID0gdHJlZS5nZXREZXB0aCgpXG4gICAqYGBgXG4gICAqL1xuICBnZXREZXB0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXllcnMoKS5sZW5ndGggLSAxO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldExheWVyc0FzT2JqZWN0XG4gICAqIEBkZXNjIFJldHVybnMgdGhlIGxheWVycyBhcyBuZXN0ZWQgb2JqZWN0cyBpbnN0ZWFkIG9mIGFuIGFycmF5LlxuICAgKiBAZXhhbXBsZVxuICAgKmBgYGpzXG4gICAqY29uc3QgbGF5ZXJzT2JqID0gdHJlZS5nZXRMYXllcnNBc09iamVjdCgpXG4gICAqYGBgXG4gICAqL1xuICBnZXRMYXllcnNBc09iamVjdCgpIHtcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLmdldExheWVycygpLm1hcChsYXllciA9PiBsYXllci5tYXAodmFsdWUgPT4gdGhpcy5idWZmZXJUb0hleCh2YWx1ZSwgZmFsc2UpKSk7XG4gICAgY29uc3Qgb2JqcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhcnIgPSBbXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGF5ZXJzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAgICBbbGF5ZXJzW2ldW2pdXTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAob2Jqcy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gaXNzdWUgZnJvbSBvcmlnaW5hbCBjb2RlXG4gICAgICAgICAgb2JqW2xheWVyc1tpXVtqXV0gPSB7fTtcbiAgICAgICAgICBjb25zdCBhID0gb2Jqcy5zaGlmdCgpO1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc3N1ZSBmcm9tIG9yaWdpbmFsIGNvZGVcbiAgICAgICAgICBjb25zdCBha2V5ID0gT2JqZWN0LmtleXMoYSlbMF07XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIGlzc3VlIGZyb20gb3JpZ2luYWwgY29kZVxuICAgICAgICAgIG9ialtsYXllcnNbaV1bal1dW2FrZXldID0gYVtha2V5XTtcbiAgICAgICAgICBpZiAob2Jqcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBvYmpzLnNoaWZ0KCk7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gaXNzdWUgZnJvbSBvcmlnaW5hbCBjb2RlXG4gICAgICAgICAgICBjb25zdCBia2V5ID0gT2JqZWN0LmtleXMoYilbMF07XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gaXNzdWUgZnJvbSBvcmlnaW5hbCBjb2RlXG4gICAgICAgICAgICBvYmpbbGF5ZXJzW2ldW2pdXVtia2V5XSA9IGJbYmtleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFyci5wdXNoKG9iaik7XG4gICAgICB9XG4gICAgICBvYmpzLnB1c2goLi4uYXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIG9ianNbMF07XG4gIH1cblxuICAvKipcbiAgICogcmVzZXRUcmVlXG4gICAqIEBkZXNjIFJlc2V0cyB0aGUgdHJlZSBieSBjbGVhcmluZyB0aGUgbGVhdmVzIGFuZCBsYXllcnMuXG4gICAqIEBleGFtcGxlXG4gICAqYGBganNcbiAgICp0cmVlLnJlc2V0VHJlZSgpXG4gICAqYGBgXG4gICAqL1xuICByZXNldFRyZWUoKSB7XG4gICAgdGhpcy5sZWF2ZXMgPSBbXTtcbiAgICB0aGlzLmxheWVycyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldFBhaXJOb2RlXG4gICAqIEBkZXNjIFJldHVybnMgdGhlIG5vZGUgYXQgdGhlIGluZGV4IGZvciBnaXZlbiBsYXllci5cbiAgICogQHBhcmFtIHtCdWZmZXJbXX0gbGF5ZXIgLSBUcmVlIGxheWVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIEluZGV4IGF0IGxheWVyLlxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9IC0gTm9kZVxuICAgKlxuICAgKkBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqY29uc3Qgbm9kZSA9IHRyZWUuZ2V0UGFpck5vZGUobGF5ZXIsIGluZGV4KVxuICAgKmBgYFxuICAgKi9cbiAgZ2V0UGFpck5vZGUobGF5ZXIsIGlkeCkge1xuICAgIGNvbnN0IHBhaXJJZHggPSBpZHggJSAyID09PSAwID8gaWR4ICsgMSA6IGlkeCAtIDE7XG4gICAgaWYgKHBhaXJJZHggPCBsYXllci5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBsYXllcltwYWlySWR4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIGlzc3VlIGZyb20gb3JpZ2luYWwgY29kZVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHRvVHJlZVN0cmluZ1xuICAgKiBAZGVzYyBSZXR1cm5zIGEgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtZXJrbGUgdHJlZSBhcyBhIHN0cmluZy5cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKmBgYGpzXG4gICAqY29uc29sZS5sb2codHJlZS50b1RyZWVTdHJpbmcoKSlcbiAgICpgYGBcbiAgICovXG4gIHRvVHJlZVN0cmluZygpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLmdldExheWVyc0FzT2JqZWN0KCk7XG4gICAgcmV0dXJuIGFzVHJlZShvYmosIHRydWUsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0b1N0cmluZ1xuICAgKiBAZGVzYyBSZXR1cm5zIGEgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtZXJrbGUgdHJlZSBhcyBhIHN0cmluZy5cbiAgICogQGV4YW1wbGVcbiAgICpgYGBqc1xuICAgKmNvbnNvbGUubG9nKHRyZWUudG9TdHJpbmcoKSlcbiAgICpgYGBcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRvVHJlZVN0cmluZygpO1xuICB9XG4gIGlzVW5ldmVuVHJlZSh0cmVlTGF5ZXJzKSB7XG4gICAgY29uc3QgZGVwdGggPSB0cmVlTGF5ZXJzPy5sZW5ndGggfHwgdGhpcy5nZXREZXB0aCgpO1xuICAgIHJldHVybiAhdGhpcy5pc1Bvd09mMihkZXB0aCk7XG4gIH1cbiAgaXNQb3dPZjIodikge1xuICAgIHJldHVybiB2ICYmICEodiAmIHYgLSAxKTtcbiAgfVxuICBjYWxjdWxhdGVSb290Rm9yVW5ldmVuVHJlZShsZWFmSW5kaWNlcywgbGVhZkhhc2hlcywgdG90YWxMZWF2ZXNDb3VudCwgcHJvb2ZIYXNoZXMpIHtcbiAgICBjb25zdCBsZWFmVHVwbGVzID0gdGhpcy56aXAobGVhZkluZGljZXMsIGxlYWZIYXNoZXMpLnNvcnQoKF9yZWYyLCBfcmVmMykgPT4ge1xuICAgICAgbGV0IFtpbmRleEFdID0gX3JlZjI7XG4gICAgICBsZXQgW2luZGV4Ql0gPSBfcmVmMztcbiAgICAgIHJldHVybiBpbmRleEEgLSBpbmRleEI7XG4gICAgfSk7XG4gICAgY29uc3QgbGVhZlR1cGxlSW5kaWNlcyA9IGxlYWZUdXBsZXMubWFwKF9yZWY0ID0+IHtcbiAgICAgIGxldCBbaW5kZXhdID0gX3JlZjQ7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSk7XG4gICAgY29uc3QgcHJvb2ZJbmRpY2VzID0gdGhpcy5nZXRQcm9vZkluZGljZXNGb3JVbmV2ZW5UcmVlKGxlYWZUdXBsZUluZGljZXMsIHRvdGFsTGVhdmVzQ291bnQpO1xuICAgIGxldCBuZXh0U2xpY2VTdGFydCA9IDA7XG4gICAgY29uc3QgcHJvb2ZUdXBsZXNCeUxheWVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvb2ZJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbmRpY2VzID0gcHJvb2ZJbmRpY2VzW2ldO1xuICAgICAgY29uc3Qgc2xpY2VTdGFydCA9IG5leHRTbGljZVN0YXJ0O1xuICAgICAgbmV4dFNsaWNlU3RhcnQgKz0gaW5kaWNlcy5sZW5ndGg7XG4gICAgICBwcm9vZlR1cGxlc0J5TGF5ZXJzW2ldID0gdGhpcy56aXAoaW5kaWNlcywgcHJvb2ZIYXNoZXMuc2xpY2Uoc2xpY2VTdGFydCwgbmV4dFNsaWNlU3RhcnQpKTtcbiAgICB9XG4gICAgY29uc3QgdHJlZSA9IFtsZWFmVHVwbGVzXTtcbiAgICBmb3IgKGxldCBsYXllckluZGV4ID0gMDsgbGF5ZXJJbmRleCA8IHByb29mVHVwbGVzQnlMYXllcnMubGVuZ3RoOyBsYXllckluZGV4KyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRMYXllciA9IHByb29mVHVwbGVzQnlMYXllcnNbbGF5ZXJJbmRleF0uY29uY2F0KHRyZWVbbGF5ZXJJbmRleF0pXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gaXNzdWUgZnJvbSBvcmlnaW5hbCBjb2RlXG4gICAgICAuc29ydCgoX3JlZjUsIF9yZWY2KSA9PiB7XG4gICAgICAgIGxldCBbaW5kZXhBXSA9IF9yZWY1O1xuICAgICAgICBsZXQgW2luZGV4Ql0gPSBfcmVmNjtcbiAgICAgICAgcmV0dXJuIGluZGV4QSAtIGluZGV4QjtcbiAgICAgIH0pXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gaXNzdWUgZnJvbSBvcmlnaW5hbCBjb2RlXG4gICAgICAubWFwKF9yZWY3ID0+IHtcbiAgICAgICAgbGV0IFssIGhhc2hdID0gX3JlZjc7XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBzID0gdHJlZVtsYXllckluZGV4XS5tYXAoX3JlZjggPT4ge1xuICAgICAgICBsZXQgW2xheWVySW5kZXhfXSA9IF9yZWY4O1xuICAgICAgICByZXR1cm4gbGF5ZXJJbmRleF87XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBhcmVudEluZGljZXMgPSBbLi4ubmV3IFNldChzLm1hcChpbmRleCA9PiB7XG4gICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXggLyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gKGluZGV4ICsgMSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaW5kZXggLSAxKSAvIDI7XG4gICAgICB9KSldO1xuICAgICAgY29uc3QgcGFyZW50TGF5ZXIgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50SW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJlbnROb2RlVHJlZUluZGV4ID0gcGFyZW50SW5kaWNlc1tpXTtcbiAgICAgICAgY29uc3QgYnVmQSA9IGN1cnJlbnRMYXllcltpICogMl07XG4gICAgICAgIGNvbnN0IGJ1ZkIgPSBjdXJyZW50TGF5ZXJbaSAqIDIgKyAxXTtcbiAgICAgICAgY29uc3QgaGFzaCA9IGJ1ZkIgPyB0aGlzLmhhc2hGbih0aGlzLmNvbmNhdGVuYXRvcihbYnVmQSwgYnVmQl0pKSA6IGJ1ZkE7XG4gICAgICAgIHBhcmVudExheWVyLnB1c2goW3BhcmVudE5vZGVUcmVlSW5kZXgsIGhhc2hdKTtcbiAgICAgIH1cbiAgICAgIHRyZWUucHVzaChwYXJlbnRMYXllcik7XG4gICAgfVxuICAgIHJldHVybiB0cmVlW3RyZWUubGVuZ3RoIC0gMV1bMF1bMV07XG4gIH1cbn1cblxuZXhwb3J0IHsgTWVya2xlVHJlZSB9O1xuIl0sIm5hbWVzIjpbIkJ1ZmZlciIsInJldmVyc2UiLCJhc1RyZWUiLCJCYXNlIiwicHJpbnQiLCJidWZmZXJJbmRleE9mIiwiYXJyYXkiLCJlbGVtZW50IiwiaXNTb3J0ZWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJiaW5hcnlTZWFyY2giLCJjb21wYXJlIiwiZXFDaGVja2VyIiwiYnVmZmVyMSIsImJ1ZmZlcjIiLCJlcXVhbHMiLCJsaW5lYXJTZWFyY2giLCJjb21wYXJlRnVuY3Rpb24iLCJzdGFydCIsImVuZCIsIm1pZCIsIk1hdGgiLCJmbG9vciIsIm9yZGVyaW5nIiwiaSIsImJ1ZmZlcmlmeSIsInZhbHVlIiwiaXNCdWZmZXIiLCJ3b3JkcyIsImZyb20iLCJ0b1N0cmluZyIsImNvbnZlcnRXb3Jkc1RvQnVmZmVyIiwiaXNIZXhTdHJpbmciLCJyZXBsYWNlIiwiVWludDhBcnJheSIsImJ1ZmZlciIsInMiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiYmlnTnVtYmVyaWZ5Iiwic3RhcnRzV2l0aCIsIkJpZ0ludCIsInVpbnQ4QXJyYXlUb0JpZ0ludCIsIkVycm9yIiwidiIsInRlc3QiLCJ0cmVlIiwiY29uc29sZSIsImxvZyIsImJ1ZmZlclRvSGV4Iiwid2l0aFByZWZpeCIsImFsbG9jIiwiYnVmZmVyaWZ5Rm4iLCJmIiwiYXJyYXlCdWZmZXIiLCJoZXhTdHJpbmdUb0FycmF5QnVmZmVyIiwicHJvY2Vzc2VkQnVmZmVyIiwiaGV4UmVzdWx0IiwiYXJyYXlCdWZmZXJUb0hleFN0cmluZyIsImxvZzIiLCJuIiwiemlwIiwiYSIsImIiLCJtYXAiLCJlIiwiaGV4WmVyb1BhZCIsImhleFN0ciIsInBhZFN0YXJ0IiwiQmFzZSQxIiwid29yZEFycmF5IiwidWludDhWaWV3IiwiaGV4U3RyaW5nIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJBcnJheSIsImJ5dGUiLCJqb2luIiwidThhIiwiaGV4IiwiTWVya2xlVHJlZSIsImNvbnN0cnVjdG9yIiwibGVhdmVzIiwiaGFzaEZuIiwib3B0aW9ucyIsImR1cGxpY2F0ZU9kZCIsImNvbmNhdGVuYXRvciIsImNvbmNhdCIsImhhc2hMZWF2ZXMiLCJpc0JpdGNvaW5UcmVlIiwibGF5ZXJzIiwic29ydExlYXZlcyIsInNvcnRQYWlycyIsInNvcnQiLCJmaWxsRGVmYXVsdEhhc2giLCJjb21wbGV0ZSIsImlkeCIsInByb2Nlc3NMZWF2ZXMiLCJnZXRPcHRpb25zIiwicG93IiwiY2VpbCIsInB1c2giLCJjcmVhdGVIYXNoZXMiLCJub2RlcyIsImxheWVySW5kZXgiLCJsYXllckxpbWl0IiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwic2xpY2UiLCJkYXRhIiwiaGFzaCIsImxlZnQiLCJyaWdodCIsImNvbWJpbmVkIiwiYWRkTGVhZiIsImxlYWYiLCJzaG91bGRIYXNoIiwiYWRkTGVhdmVzIiwiZ2V0TGVhdmVzIiwidmFsdWVzIiwiaXNBcnJheSIsImZpbHRlciIsImdldExlYWYiLCJpbmRleCIsImdldExlYWZJbmRleCIsInRhcmdldCIsImdldExlYWZDb3VudCIsImdldEhleExlYXZlcyIsIm1hcnNoYWxMZWF2ZXMiLCJKU09OIiwic3RyaW5naWZ5IiwidW5tYXJzaGFsTGVhdmVzIiwianNvblN0ciIsInBhcnNlZCIsInBhcnNlIiwiT2JqZWN0IiwiZ2V0TGF5ZXJzIiwiZ2V0SGV4TGF5ZXJzIiwicmVkdWNlIiwiYWNjIiwiaXRlbSIsImxheWVyIiwiZ2V0TGF5ZXJzRmxhdCIsInVuc2hpZnQiLCJnZXRIZXhMYXllcnNGbGF0IiwiZ2V0TGF5ZXJDb3VudCIsImdldFJvb3QiLCJnZXRIZXhSb290IiwiZ2V0UHJvb2YiLCJwcm9vZiIsImlzUmlnaHROb2RlIiwicGFpckluZGV4IiwicG9zaXRpb24iLCJnZXRIZXhQcm9vZiIsImdldFByb29mcyIsInByb29mcyIsImdldFByb29mc0RGUyIsImN1cnJlbnRMYXllciIsInB1c2hlZCIsImxlZnRjaGlsZEluZGV4IiwicmlnaHRjaGlsZEluZGV4Iiwic3BsaWNlIiwiZ2V0SGV4UHJvb2ZzIiwiZ2V0UG9zaXRpb25hbEhleFByb29mIiwiZ2V0UHJvb2ZJbmRpY2VzIiwidHJlZUluZGljZXMiLCJkZXB0aCIsImxlYWZDb3VudCIsIm1heGltYWxJbmRpY2VzIiwiU2V0IiwieCIsImFkZCIsInkiLCJyZWR1bmRhbnRJbmRpY2VzIiwiaGFzIiwiaW5jbHVkZXMiLCJnZXRQcm9vZkluZGljZXNGb3JVbmV2ZW5UcmVlIiwic29ydGVkTGVhZkluZGljZXMiLCJsZWF2ZXNDb3VudCIsInVuZXZlbkxheWVycyIsInVuZXZlbkxheWVyIiwicHJvb2ZJbmRpY2VzIiwibGF5ZXJOb2RlcyIsInNpYmxpbmdJbmRpY2VzIiwicHJvb2ZOb2RlSW5kaWNlcyIsImZpbmQiLCJfcmVmIiwiZ2V0TXVsdGlQcm9vZiIsImluZGljZXMiLCJ3YXJuIiwiaXNVbmV2ZW4iLCJpc1VuZXZlblRyZWUiLCJldmVyeSIsImdldE11bHRpUHJvb2ZGb3JVbmV2ZW5UcmVlIiwiZWxzIiwiaWRzIiwiZWwiLCJoYXNoZXMiLCJuZXh0SWRzIiwiaiIsInBhaXJFbGVtZW50IiwiZ2V0UGFpck5vZGUiLCJzZWxmIiwiaW5kZXhPZiIsInByb29mSGFzaGVzIiwiY3VycmVudExheWVySW5kaWNlcyIsInRyZWVMYXllciIsInNpYmxpbmdzIiwidW5pcXVlSW5kaWNlcyIsImdldEhleE11bHRpUHJvb2YiLCJnZXRQcm9vZkZsYWdzIiwiX3Byb29mcyIsInRlc3RlZCIsImZsYWdzIiwiaWRzXyIsInNraXBwZWQiLCJwcm9vZlVzZWQiLCJ2ZXJpZnkiLCJ0YXJnZXROb2RlIiwicm9vdCIsIm5vZGUiLCJpc0xlZnROb2RlIiwiYnVmZmVycyIsInZlcmlmeU11bHRpUHJvb2YiLCJwcm9vZkxlYXZlcyIsInZlcmlmeU11bHRpUHJvb2ZGb3JVbmV2ZW5UcmVlIiwicHJvb2ZpdGVtIiwiaW5kZXhxdWV1ZSIsImtleXMiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJwYWlyIiwidmVyaWZ5TXVsdGlQcm9vZldpdGhGbGFncyIsInByb29mRmxhZyIsImxlYXZlc0xlbiIsInRvdGFsSGFzaGVzIiwibGVhZlBvcyIsImhhc2hQb3MiLCJwcm9vZlBvcyIsImJ1ZkEiLCJidWZCIiwiY29tcHV0ZWRSb290IiwiY2FsY3VsYXRlUm9vdEZvclVuZXZlblRyZWUiLCJnZXREZXB0aCIsImdldExheWVyc0FzT2JqZWN0Iiwib2JqcyIsImFyciIsIm9iaiIsInNoaWZ0IiwiYWtleSIsImJrZXkiLCJyZXNldFRyZWUiLCJwYWlySWR4IiwidG9UcmVlU3RyaW5nIiwidHJlZUxheWVycyIsImlzUG93T2YyIiwibGVhZkluZGljZXMiLCJsZWFmSGFzaGVzIiwidG90YWxMZWF2ZXNDb3VudCIsImxlYWZUdXBsZXMiLCJfcmVmMiIsIl9yZWYzIiwiaW5kZXhBIiwiaW5kZXhCIiwibGVhZlR1cGxlSW5kaWNlcyIsIl9yZWY0IiwibmV4dFNsaWNlU3RhcnQiLCJwcm9vZlR1cGxlc0J5TGF5ZXJzIiwic2xpY2VTdGFydCIsIl9yZWY1IiwiX3JlZjYiLCJfcmVmNyIsIl9yZWY4IiwibGF5ZXJJbmRleF8iLCJwYXJlbnRJbmRpY2VzIiwicGFyZW50TGF5ZXIiLCJwYXJlbnROb2RlVHJlZUluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@thirdweb-dev+merkletree@0.2.0/node_modules/@thirdweb-dev/merkletree/dist/thirdweb-dev-merkletree.esm.js\n");

/***/ })

};
;