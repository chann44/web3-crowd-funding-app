"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cids@1.1.9";
exports.ids = ["vendor-chunks/cids@1.1.9"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/cids@1.1.9/node_modules/cids/src/cid-util.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/cids@1.1.9/node_modules/cids/src/cid-util.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst mh = __webpack_require__(/*! multihashes */ \"(ssr)/./node_modules/.pnpm/multihashes@4.0.3/node_modules/multihashes/src/index.js\");\nconst CIDUtil = {\n    /**\n   * Test if the given input is a valid CID object.\n   * Returns an error message if it is not.\n   * Returns undefined if it is a valid CID.\n   *\n   * @param {any} other\n   * @returns {string|undefined}\n   */ checkCIDComponents: function(other) {\n        if (other == null) {\n            return \"null values are not valid CIDs\";\n        }\n        if (!(other.version === 0 || other.version === 1)) {\n            return \"Invalid version, must be a number equal to 1 or 0\";\n        }\n        if (typeof other.codec !== \"string\") {\n            return \"codec must be string\";\n        }\n        if (other.version === 0) {\n            if (other.codec !== \"dag-pb\") {\n                return \"codec must be 'dag-pb' for CIDv0\";\n            }\n            if (other.multibaseName !== \"base58btc\") {\n                return \"multibaseName must be 'base58btc' for CIDv0\";\n            }\n        }\n        if (!(other.multihash instanceof Uint8Array)) {\n            return \"multihash must be a Uint8Array\";\n        }\n        try {\n            mh.validate(other.multihash);\n        } catch (err) {\n            let errorMsg = err.message;\n            if (!errorMsg) {\n                errorMsg = \"Multihash validation failed\";\n            }\n            return errorMsg;\n        }\n    }\n};\nmodule.exports = CIDUtil;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY2lkc0AxLjEuOS9ub2RlX21vZHVsZXMvY2lkcy9zcmMvY2lkLXV0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxLQUFLQyxtQkFBT0EsQ0FBQztBQUVuQixNQUFNQyxVQUFVO0lBQ2Q7Ozs7Ozs7R0FPQyxHQUNEQyxvQkFBb0IsU0FBVUMsS0FBSztRQUNqQyxJQUFJQSxTQUFTLE1BQU07WUFDakIsT0FBTztRQUNUO1FBRUEsSUFBSSxDQUFFQSxDQUFBQSxNQUFNQyxPQUFPLEtBQUssS0FBS0QsTUFBTUMsT0FBTyxLQUFLLElBQUk7WUFDakQsT0FBTztRQUNUO1FBRUEsSUFBSSxPQUFPRCxNQUFNRSxLQUFLLEtBQUssVUFBVTtZQUNuQyxPQUFPO1FBQ1Q7UUFFQSxJQUFJRixNQUFNQyxPQUFPLEtBQUssR0FBRztZQUN2QixJQUFJRCxNQUFNRSxLQUFLLEtBQUssVUFBVTtnQkFDNUIsT0FBTztZQUNUO1lBQ0EsSUFBSUYsTUFBTUcsYUFBYSxLQUFLLGFBQWE7Z0JBQ3ZDLE9BQU87WUFDVDtRQUNGO1FBRUEsSUFBSSxDQUFFSCxDQUFBQSxNQUFNSSxTQUFTLFlBQVlDLFVBQVMsR0FBSTtZQUM1QyxPQUFPO1FBQ1Q7UUFFQSxJQUFJO1lBQ0ZULEdBQUdVLFFBQVEsQ0FBQ04sTUFBTUksU0FBUztRQUM3QixFQUFFLE9BQU9HLEtBQUs7WUFDWixJQUFJQyxXQUFXRCxJQUFJRSxPQUFPO1lBQzFCLElBQUksQ0FBQ0QsVUFBVTtnQkFDYkEsV0FBVztZQUNiO1lBQ0EsT0FBT0E7UUFDVDtJQUNGO0FBQ0Y7QUFFQUUsT0FBT0MsT0FBTyxHQUFHYiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy8ucG5wbS9jaWRzQDEuMS45L25vZGVfbW9kdWxlcy9jaWRzL3NyYy9jaWQtdXRpbC5qcz8zZmVhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBtaCA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJylcblxuY29uc3QgQ0lEVXRpbCA9IHtcbiAgLyoqXG4gICAqIFRlc3QgaWYgdGhlIGdpdmVuIGlucHV0IGlzIGEgdmFsaWQgQ0lEIG9iamVjdC5cbiAgICogUmV0dXJucyBhbiBlcnJvciBtZXNzYWdlIGlmIGl0IGlzIG5vdC5cbiAgICogUmV0dXJucyB1bmRlZmluZWQgaWYgaXQgaXMgYSB2YWxpZCBDSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBvdGhlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICovXG4gIGNoZWNrQ0lEQ29tcG9uZW50czogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgaWYgKG90aGVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnbnVsbCB2YWx1ZXMgYXJlIG5vdCB2YWxpZCBDSURzJ1xuICAgIH1cblxuICAgIGlmICghKG90aGVyLnZlcnNpb24gPT09IDAgfHwgb3RoZXIudmVyc2lvbiA9PT0gMSkpIHtcbiAgICAgIHJldHVybiAnSW52YWxpZCB2ZXJzaW9uLCBtdXN0IGJlIGEgbnVtYmVyIGVxdWFsIHRvIDEgb3IgMCdcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG90aGVyLmNvZGVjICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuICdjb2RlYyBtdXN0IGJlIHN0cmluZydcbiAgICB9XG5cbiAgICBpZiAob3RoZXIudmVyc2lvbiA9PT0gMCkge1xuICAgICAgaWYgKG90aGVyLmNvZGVjICE9PSAnZGFnLXBiJykge1xuICAgICAgICByZXR1cm4gXCJjb2RlYyBtdXN0IGJlICdkYWctcGInIGZvciBDSUR2MFwiXG4gICAgICB9XG4gICAgICBpZiAob3RoZXIubXVsdGliYXNlTmFtZSAhPT0gJ2Jhc2U1OGJ0YycpIHtcbiAgICAgICAgcmV0dXJuIFwibXVsdGliYXNlTmFtZSBtdXN0IGJlICdiYXNlNThidGMnIGZvciBDSUR2MFwiXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEob3RoZXIubXVsdGloYXNoIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgIHJldHVybiAnbXVsdGloYXNoIG11c3QgYmUgYSBVaW50OEFycmF5J1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBtaC52YWxpZGF0ZShvdGhlci5tdWx0aWhhc2gpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsZXQgZXJyb3JNc2cgPSBlcnIubWVzc2FnZVxuICAgICAgaWYgKCFlcnJvck1zZykgeyAvLyBKdXN0IGluIGNhc2UgbWgudmFsaWRhdGUoKSB0aHJvd3MgYW4gZXJyb3Igd2l0aCBlbXB0eSBlcnJvciBtZXNzYWdlXG4gICAgICAgIGVycm9yTXNnID0gJ011bHRpaGFzaCB2YWxpZGF0aW9uIGZhaWxlZCdcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvck1zZ1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENJRFV0aWxcbiJdLCJuYW1lcyI6WyJtaCIsInJlcXVpcmUiLCJDSURVdGlsIiwiY2hlY2tDSURDb21wb25lbnRzIiwib3RoZXIiLCJ2ZXJzaW9uIiwiY29kZWMiLCJtdWx0aWJhc2VOYW1lIiwibXVsdGloYXNoIiwiVWludDhBcnJheSIsInZhbGlkYXRlIiwiZXJyIiwiZXJyb3JNc2ciLCJtZXNzYWdlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/cids@1.1.9/node_modules/cids/src/cid-util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/cids@1.1.9/node_modules/cids/src/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/cids@1.1.9/node_modules/cids/src/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst mh = __webpack_require__(/*! multihashes */ \"(ssr)/./node_modules/.pnpm/multihashes@4.0.3/node_modules/multihashes/src/index.js\");\nconst multibase = __webpack_require__(/*! multibase */ \"(ssr)/./node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/index.js\");\nconst multicodec = __webpack_require__(/*! multicodec */ \"(ssr)/./node_modules/.pnpm/multicodec@3.2.1/node_modules/multicodec/src/index.js\");\nconst CIDUtil = __webpack_require__(/*! ./cid-util */ \"(ssr)/./node_modules/.pnpm/cids@1.1.9/node_modules/cids/src/cid-util.js\");\nconst { concat: uint8ArrayConcat } = __webpack_require__(/*! uint8arrays/concat */ \"(ssr)/./node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/concat.js\");\nconst { toString: uint8ArrayToString } = __webpack_require__(/*! uint8arrays/to-string */ \"(ssr)/./node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/to-string.js\");\nconst { equals: uint8ArrayEquals } = __webpack_require__(/*! uint8arrays/equals */ \"(ssr)/./node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/equals.js\");\nconst codecs = multicodec.nameToCode;\nconst codecInts = /** @type {CodecName[]} */ Object.keys(codecs).reduce((p, name)=>{\n    p[codecs[name]] = name;\n    return p;\n}, /** @type {Record<CodecCode, CodecName>} */ {});\nconst symbol = Symbol.for(\"@ipld/js-cid/CID\");\n/**\n * @typedef {Object} SerializedCID\n * @property {string} codec\n * @property {number} version\n * @property {Uint8Array} hash\n */ /**\n * @typedef {0|1} CIDVersion\n * @typedef {import('multibase').BaseNameOrCode} BaseNameOrCode\n * @typedef {import('multicodec').CodecName} CodecName\n * @typedef {import('multicodec').CodecCode} CodecCode\n */ /**\n * Class representing a CID `<mbase><version><mcodec><mhash>`\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\n *\n * @class CID\n */ class CID {\n    /**\n   * Create a new CID.\n   *\n   * The algorithm for argument input is roughly:\n   * ```\n   * if (cid)\n   *   -> create a copy\n   * else if (str)\n   *   if (1st char is on multibase table) -> CID String\n   *   else -> bs58 encoded multihash\n   * else if (Uint8Array)\n   *   if (1st byte is 0 or 1) -> CID\n   *   else -> multihash\n   * else if (Number)\n   *   -> construct CID by parts\n   * ```\n   *\n   * @param {CIDVersion | string | Uint8Array | CID} version\n   * @param {string|number} [codec]\n   * @param {Uint8Array} [multihash]\n   * @param {string} [multibaseName]\n   *\n   * @example\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\n   * new CID(<cidStr>)\n   * new CID(<cid.bytes>)\n   * new CID(<multihash>)\n   * new CID(<bs58 encoded multihash>)\n   * new CID(<cid>)\n   */ constructor(version, codec, multihash, multibaseName){\n        // We have below three blank field accessors only because\n        // otherwise TS will not pick them up if done after assignemnts\n        /**\n     * The version of the CID.\n     *\n     * @type {CIDVersion}\n     */ // eslint-disable-next-line no-unused-expressions\n        this.version;\n        /**\n     * The codec of the CID.\n     *\n     * @deprecated\n     * @type {CodecName}\n     */ // eslint-disable-next-line no-unused-expressions\n        this.codec;\n        /**\n     * The multihash of the CID.\n     *\n     * @type {Uint8Array}\n     */ // eslint-disable-next-line no-unused-expressions\n        this.multihash;\n        Object.defineProperty(this, symbol, {\n            value: true\n        });\n        if (CID.isCID(version)) {\n            // version is an exising CID instance\n            const cid = /** @type {CID} */ version;\n            this.version = cid.version;\n            this.codec = cid.codec;\n            this.multihash = cid.multihash;\n            // Default guard for when a CID < 0.7 is passed with no multibaseName\n            // @ts-ignore\n            this.multibaseName = cid.multibaseName || (cid.version === 0 ? \"base58btc\" : \"base32\");\n            return;\n        }\n        if (typeof version === \"string\") {\n            // e.g. 'base32' or false\n            const baseName = multibase.isEncoded(version);\n            if (baseName) {\n                // version is a CID String encoded with multibase, so v1\n                const cid = multibase.decode(version);\n                this.version = /** @type {CIDVersion} */ parseInt(cid[0].toString(), 16);\n                this.codec = multicodec.getCodec(cid.slice(1));\n                this.multihash = multicodec.rmPrefix(cid.slice(1));\n                this.multibaseName = baseName;\n            } else {\n                // version is a base58btc string multihash, so v0\n                this.version = 0;\n                this.codec = \"dag-pb\";\n                this.multihash = mh.fromB58String(version);\n                this.multibaseName = \"base58btc\";\n            }\n            CID.validateCID(this);\n            Object.defineProperty(this, \"string\", {\n                value: version\n            });\n            return;\n        }\n        if (version instanceof Uint8Array) {\n            const v = parseInt(version[0].toString(), 16);\n            if (v === 1) {\n                // version is a CID Uint8Array\n                const cid = version;\n                this.version = v;\n                this.codec = multicodec.getCodec(cid.slice(1));\n                this.multihash = multicodec.rmPrefix(cid.slice(1));\n                this.multibaseName = \"base32\";\n            } else {\n                // version is a raw multihash Uint8Array, so v0\n                this.version = 0;\n                this.codec = \"dag-pb\";\n                this.multihash = version;\n                this.multibaseName = \"base58btc\";\n            }\n            CID.validateCID(this);\n            return;\n        }\n        // otherwise, assemble the CID from the parameters\n        this.version = version;\n        if (typeof codec === \"number\") {\n            // @ts-ignore\n            codec = codecInts[codec];\n        }\n        this.codec = /** @type {CodecName} */ codec;\n        this.multihash = /** @type {Uint8Array} */ multihash;\n        /**\n     * Multibase name as string.\n     *\n     * @deprecated\n     * @type {string}\n     */ this.multibaseName = multibaseName || (version === 0 ? \"base58btc\" : \"base32\");\n        CID.validateCID(this);\n    }\n    /**\n   * The CID as a `Uint8Array`\n   *\n   * @returns {Uint8Array}\n   *\n   */ get bytes() {\n        // @ts-ignore\n        let bytes = this._bytes;\n        if (!bytes) {\n            if (this.version === 0) {\n                bytes = this.multihash;\n            } else if (this.version === 1) {\n                const codec = multicodec.getCodeVarint(this.codec);\n                bytes = uint8ArrayConcat([\n                    [\n                        1\n                    ],\n                    codec,\n                    this.multihash\n                ], 1 + codec.byteLength + this.multihash.byteLength);\n            } else {\n                throw new Error(\"unsupported version\");\n            }\n            // Cache this Uint8Array so it doesn't have to be recreated\n            Object.defineProperty(this, \"_bytes\", {\n                value: bytes\n            });\n        }\n        return bytes;\n    }\n    /**\n   * The prefix of the CID.\n   *\n   * @returns {Uint8Array}\n   */ get prefix() {\n        const codec = multicodec.getCodeVarint(this.codec);\n        const multihash = mh.prefix(this.multihash);\n        const prefix = uint8ArrayConcat([\n            [\n                this.version\n            ],\n            codec,\n            multihash\n        ], 1 + codec.byteLength + multihash.byteLength);\n        return prefix;\n    }\n    /**\n   * The codec of the CID in its number form.\n   *\n   * @returns {CodecCode}\n   */ get code() {\n        return codecs[this.codec];\n    }\n    /**\n   * Convert to a CID of version `0`.\n   *\n   * @returns {CID}\n   */ toV0() {\n        if (this.codec !== \"dag-pb\") {\n            throw new Error(\"Cannot convert a non dag-pb CID to CIDv0\");\n        }\n        const { name, length } = mh.decode(this.multihash);\n        if (name !== \"sha2-256\") {\n            throw new Error(\"Cannot convert non sha2-256 multihash CID to CIDv0\");\n        }\n        if (length !== 32) {\n            throw new Error(\"Cannot convert non 32 byte multihash CID to CIDv0\");\n        }\n        return new CID(0, this.codec, this.multihash);\n    }\n    /**\n   * Convert to a CID of version `1`.\n   *\n   * @returns {CID}\n   */ toV1() {\n        return new CID(1, this.codec, this.multihash, this.multibaseName);\n    }\n    /**\n   * Encode the CID into a string.\n   *\n   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.\n   * @returns {string}\n   */ toBaseEncodedString(base = this.multibaseName) {\n        // @ts-ignore non enumerable cache property\n        if (this.string && this.string.length !== 0 && base === this.multibaseName) {\n            // @ts-ignore non enumerable cache property\n            return this.string;\n        }\n        let str;\n        if (this.version === 0) {\n            if (base !== \"base58btc\") {\n                throw new Error(\"not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()\");\n            }\n            str = mh.toB58String(this.multihash);\n        } else if (this.version === 1) {\n            str = uint8ArrayToString(multibase.encode(base, this.bytes));\n        } else {\n            throw new Error(\"unsupported version\");\n        }\n        if (base === this.multibaseName) {\n            // cache the string value\n            Object.defineProperty(this, \"string\", {\n                value: str\n            });\n        }\n        return str;\n    }\n    /**\n   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\n   *\n   * @returns {string}\n   */ [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return \"CID(\" + this.toString() + \")\";\n    }\n    /**\n   * Encode the CID into a string.\n   *\n   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.\n   * @returns {string}\n   */ toString(base) {\n        return this.toBaseEncodedString(base);\n    }\n    /**\n   * Serialize to a plain object.\n   *\n   * @returns {SerializedCID}\n   */ toJSON() {\n        return {\n            codec: this.codec,\n            version: this.version,\n            hash: this.multihash\n        };\n    }\n    /**\n   * Compare equality with another CID.\n   *\n   * @param {CID} other\n   * @returns {boolean}\n   */ equals(other) {\n        return this.codec === other.codec && this.version === other.version && uint8ArrayEquals(this.multihash, other.multihash);\n    }\n    /**\n   * Test if the given input is a valid CID object.\n   * Throws if it is not.\n   *\n   * @param {any} other - The other CID.\n   * @returns {void}\n   */ static validateCID(other) {\n        const errorMsg = CIDUtil.checkCIDComponents(other);\n        if (errorMsg) {\n            throw new Error(errorMsg);\n        }\n    }\n    /**\n   * Check if object is a CID instance\n   *\n   * @param {any} value\n   * @returns {value is CID}\n   */ static isCID(value) {\n        return value instanceof CID || Boolean(value && value[symbol]);\n    }\n}\nCID.codecs = codecs;\nmodule.exports = CID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY2lkc0AxLjEuOS9ub2RlX21vZHVsZXMvY2lkcy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxLQUFLQyxtQkFBT0EsQ0FBQztBQUNuQixNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQztBQUMxQixNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQztBQUMzQixNQUFNRyxVQUFVSCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNLEVBQUVJLFFBQVFDLGdCQUFnQixFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBQzdDLE1BQU0sRUFBRU0sVUFBVUMsa0JBQWtCLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFDakQsTUFBTSxFQUFFUSxRQUFRQyxnQkFBZ0IsRUFBRSxHQUFHVCxtQkFBT0EsQ0FBQztBQUU3QyxNQUFNVSxTQUFTUixXQUFXUyxVQUFVO0FBQ3BDLE1BQU1DLFlBQXNDLHdCQUFGLEdBQUdDLE9BQU9DLElBQUksQ0FBQ0osUUFBU0ssTUFBTSxDQUFDLENBQUNDLEdBQUdDO0lBQzNFRCxDQUFDLENBQUNOLE1BQU0sQ0FBQ08sS0FBSyxDQUFDLEdBQUdBO0lBQ2xCLE9BQU9EO0FBQ1QsR0FBRyx5Q0FBeUMsR0FBRyxDQUFDO0FBRWhELE1BQU1FLFNBQVNDLE9BQU9DLEdBQUcsQ0FBQztBQUUxQjs7Ozs7Q0FLQyxHQUNEOzs7OztDQUtDLEdBRUQ7Ozs7O0NBS0MsR0FDRCxNQUFNQztJQUNKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZCQyxHQUNEQyxZQUFhQyxPQUFPLEVBQUVDLEtBQUssRUFBRUMsU0FBUyxFQUFFQyxhQUFhLENBQUU7UUFDckQseURBQXlEO1FBQ3pELCtEQUErRDtRQUUvRDs7OztLQUlDLEdBQ0QsaURBQWlEO1FBQ2pELElBQUksQ0FBQ0gsT0FBTztRQUVaOzs7OztLQUtDLEdBQ0QsaURBQWlEO1FBQ2pELElBQUksQ0FBQ0MsS0FBSztRQUVWOzs7O0tBSUMsR0FDRCxpREFB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Q1YsT0FBTztJQUMvRDtBQUNGO0FBRUFHLElBQUlYLE1BQU0sR0FBR0E7QUFFYnNELE9BQU9DLE9BQU8sR0FBRzVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2NpZHNAMS4xLjkvbm9kZV9tb2R1bGVzL2NpZHMvc3JjL2luZGV4LmpzP2JjOTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG1oID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKVxuY29uc3QgbXVsdGliYXNlID0gcmVxdWlyZSgnbXVsdGliYXNlJylcbmNvbnN0IG11bHRpY29kZWMgPSByZXF1aXJlKCdtdWx0aWNvZGVjJylcbmNvbnN0IENJRFV0aWwgPSByZXF1aXJlKCcuL2NpZC11dGlsJylcbmNvbnN0IHsgY29uY2F0OiB1aW50OEFycmF5Q29uY2F0IH0gPSByZXF1aXJlKCd1aW50OGFycmF5cy9jb25jYXQnKVxuY29uc3QgeyB0b1N0cmluZzogdWludDhBcnJheVRvU3RyaW5nIH0gPSByZXF1aXJlKCd1aW50OGFycmF5cy90by1zdHJpbmcnKVxuY29uc3QgeyBlcXVhbHM6IHVpbnQ4QXJyYXlFcXVhbHMgfSA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2VxdWFscycpXG5cbmNvbnN0IGNvZGVjcyA9IG11bHRpY29kZWMubmFtZVRvQ29kZVxuY29uc3QgY29kZWNJbnRzID0gLyoqIEB0eXBlIHtDb2RlY05hbWVbXX0gKi8oT2JqZWN0LmtleXMoY29kZWNzKSkucmVkdWNlKChwLCBuYW1lKSA9PiB7XG4gIHBbY29kZWNzW25hbWVdXSA9IG5hbWVcbiAgcmV0dXJuIHBcbn0sIC8qKiBAdHlwZSB7UmVjb3JkPENvZGVjQ29kZSwgQ29kZWNOYW1lPn0gKi8oe30pKVxuXG5jb25zdCBzeW1ib2wgPSBTeW1ib2wuZm9yKCdAaXBsZC9qcy1jaWQvQ0lEJylcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTZXJpYWxpemVkQ0lEXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29kZWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2ZXJzaW9uXG4gKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IGhhc2hcbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7MHwxfSBDSURWZXJzaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtdWx0aWJhc2UnKS5CYXNlTmFtZU9yQ29kZX0gQmFzZU5hbWVPckNvZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ211bHRpY29kZWMnKS5Db2RlY05hbWV9IENvZGVjTmFtZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbXVsdGljb2RlYycpLkNvZGVjQ29kZX0gQ29kZWNDb2RlXG4gKi9cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBDSUQgYDxtYmFzZT48dmVyc2lvbj48bWNvZGVjPjxtaGFzaD5gXG4gKiAsIGFzIGRlZmluZWQgaW4gW2lwbGQvY2lkXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL2NpZCkuXG4gKlxuICogQGNsYXNzIENJRFxuICovXG5jbGFzcyBDSUQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IENJRC5cbiAgICpcbiAgICogVGhlIGFsZ29yaXRobSBmb3IgYXJndW1lbnQgaW5wdXQgaXMgcm91Z2hseTpcbiAgICogYGBgXG4gICAqIGlmIChjaWQpXG4gICAqICAgLT4gY3JlYXRlIGEgY29weVxuICAgKiBlbHNlIGlmIChzdHIpXG4gICAqICAgaWYgKDFzdCBjaGFyIGlzIG9uIG11bHRpYmFzZSB0YWJsZSkgLT4gQ0lEIFN0cmluZ1xuICAgKiAgIGVsc2UgLT4gYnM1OCBlbmNvZGVkIG11bHRpaGFzaFxuICAgKiBlbHNlIGlmIChVaW50OEFycmF5KVxuICAgKiAgIGlmICgxc3QgYnl0ZSBpcyAwIG9yIDEpIC0+IENJRFxuICAgKiAgIGVsc2UgLT4gbXVsdGloYXNoXG4gICAqIGVsc2UgaWYgKE51bWJlcilcbiAgICogICAtPiBjb25zdHJ1Y3QgQ0lEIGJ5IHBhcnRzXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge0NJRFZlcnNpb24gfCBzdHJpbmcgfCBVaW50OEFycmF5IHwgQ0lEfSB2ZXJzaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2NvZGVjXVxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFttdWx0aWhhc2hdXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbXVsdGliYXNlTmFtZV1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IENJRCg8dmVyc2lvbj4sIDxjb2RlYz4sIDxtdWx0aWhhc2g+LCA8bXVsdGliYXNlTmFtZT4pXG4gICAqIG5ldyBDSUQoPGNpZFN0cj4pXG4gICAqIG5ldyBDSUQoPGNpZC5ieXRlcz4pXG4gICAqIG5ldyBDSUQoPG11bHRpaGFzaD4pXG4gICAqIG5ldyBDSUQoPGJzNTggZW5jb2RlZCBtdWx0aWhhc2g+KVxuICAgKiBuZXcgQ0lEKDxjaWQ+KVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHZlcnNpb24sIGNvZGVjLCBtdWx0aWhhc2gsIG11bHRpYmFzZU5hbWUpIHtcbiAgICAvLyBXZSBoYXZlIGJlbG93IHRocmVlIGJsYW5rIGZpZWxkIGFjY2Vzc29ycyBvbmx5IGJlY2F1c2VcbiAgICAvLyBvdGhlcndpc2UgVFMgd2lsbCBub3QgcGljayB0aGVtIHVwIGlmIGRvbmUgYWZ0ZXIgYXNzaWduZW1udHNcblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBDSUQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Q0lEVmVyc2lvbn1cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgdGhpcy52ZXJzaW9uXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29kZWMgb2YgdGhlIENJRC5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHR5cGUge0NvZGVjTmFtZX1cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgdGhpcy5jb2RlY1xuXG4gICAgLyoqXG4gICAgICogVGhlIG11bHRpaGFzaCBvZiB0aGUgQ0lELlxuICAgICAqXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgIHRoaXMubXVsdGloYXNoXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgc3ltYm9sLCB7IHZhbHVlOiB0cnVlIH0pXG4gICAgaWYgKENJRC5pc0NJRCh2ZXJzaW9uKSkge1xuICAgICAgLy8gdmVyc2lvbiBpcyBhbiBleGlzaW5nIENJRCBpbnN0YW5jZVxuICAgICAgY29uc3QgY2lkID0gLyoqIEB0eXBlIHtDSUR9ICovKHZlcnNpb24pXG4gICAgICB0aGlzLnZlcnNpb24gPSBjaWQudmVyc2lvblxuICAgICAgdGhpcy5jb2RlYyA9IGNpZC5jb2RlY1xuICAgICAgdGhpcy5tdWx0aWhhc2ggPSBjaWQubXVsdGloYXNoXG4gICAgICAvLyBEZWZhdWx0IGd1YXJkIGZvciB3aGVuIGEgQ0lEIDwgMC43IGlzIHBhc3NlZCB3aXRoIG5vIG11bHRpYmFzZU5hbWVcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMubXVsdGliYXNlTmFtZSA9IGNpZC5tdWx0aWJhc2VOYW1lIHx8IChjaWQudmVyc2lvbiA9PT0gMCA/ICdiYXNlNThidGMnIDogJ2Jhc2UzMicpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlLmcuICdiYXNlMzInIG9yIGZhbHNlXG4gICAgICBjb25zdCBiYXNlTmFtZSA9IG11bHRpYmFzZS5pc0VuY29kZWQodmVyc2lvbilcbiAgICAgIGlmIChiYXNlTmFtZSkge1xuICAgICAgICAvLyB2ZXJzaW9uIGlzIGEgQ0lEIFN0cmluZyBlbmNvZGVkIHdpdGggbXVsdGliYXNlLCBzbyB2MVxuICAgICAgICBjb25zdCBjaWQgPSBtdWx0aWJhc2UuZGVjb2RlKHZlcnNpb24pXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IC8qKiBAdHlwZSB7Q0lEVmVyc2lvbn0gKi8ocGFyc2VJbnQoY2lkWzBdLnRvU3RyaW5nKCksIDE2KSlcbiAgICAgICAgdGhpcy5jb2RlYyA9IG11bHRpY29kZWMuZ2V0Q29kZWMoY2lkLnNsaWNlKDEpKVxuICAgICAgICB0aGlzLm11bHRpaGFzaCA9IG11bHRpY29kZWMucm1QcmVmaXgoY2lkLnNsaWNlKDEpKVxuICAgICAgICB0aGlzLm11bHRpYmFzZU5hbWUgPSBiYXNlTmFtZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdmVyc2lvbiBpcyBhIGJhc2U1OGJ0YyBzdHJpbmcgbXVsdGloYXNoLCBzbyB2MFxuICAgICAgICB0aGlzLnZlcnNpb24gPSAwXG4gICAgICAgIHRoaXMuY29kZWMgPSAnZGFnLXBiJ1xuICAgICAgICB0aGlzLm11bHRpaGFzaCA9IG1oLmZyb21CNThTdHJpbmcodmVyc2lvbilcbiAgICAgICAgdGhpcy5tdWx0aWJhc2VOYW1lID0gJ2Jhc2U1OGJ0YydcbiAgICAgIH1cbiAgICAgIENJRC52YWxpZGF0ZUNJRCh0aGlzKVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdHJpbmcnLCB7IHZhbHVlOiB2ZXJzaW9uIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGNvbnN0IHYgPSBwYXJzZUludCh2ZXJzaW9uWzBdLnRvU3RyaW5nKCksIDE2KVxuICAgICAgaWYgKHYgPT09IDEpIHtcbiAgICAgICAgLy8gdmVyc2lvbiBpcyBhIENJRCBVaW50OEFycmF5XG4gICAgICAgIGNvbnN0IGNpZCA9IHZlcnNpb25cbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdlxuICAgICAgICB0aGlzLmNvZGVjID0gbXVsdGljb2RlYy5nZXRDb2RlYyhjaWQuc2xpY2UoMSkpXG4gICAgICAgIHRoaXMubXVsdGloYXNoID0gbXVsdGljb2RlYy5ybVByZWZpeChjaWQuc2xpY2UoMSkpXG4gICAgICAgIHRoaXMubXVsdGliYXNlTmFtZSA9ICdiYXNlMzInXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB2ZXJzaW9uIGlzIGEgcmF3IG11bHRpaGFzaCBVaW50OEFycmF5LCBzbyB2MFxuICAgICAgICB0aGlzLnZlcnNpb24gPSAwXG4gICAgICAgIHRoaXMuY29kZWMgPSAnZGFnLXBiJ1xuICAgICAgICB0aGlzLm11bHRpaGFzaCA9IHZlcnNpb25cbiAgICAgICAgdGhpcy5tdWx0aWJhc2VOYW1lID0gJ2Jhc2U1OGJ0YydcbiAgICAgIH1cbiAgICAgIENJRC52YWxpZGF0ZUNJRCh0aGlzKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlLCBhc3NlbWJsZSB0aGUgQ0lEIGZyb20gdGhlIHBhcmFtZXRlcnNcblxuICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb25cblxuICAgIGlmICh0eXBlb2YgY29kZWMgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb2RlYyA9IGNvZGVjSW50c1tjb2RlY11cbiAgICB9XG5cbiAgICB0aGlzLmNvZGVjID0gLyoqIEB0eXBlIHtDb2RlY05hbWV9ICovIChjb2RlYylcblxuICAgIHRoaXMubXVsdGloYXNoID0gLyoqIEB0eXBlIHtVaW50OEFycmF5fSAqLyAobXVsdGloYXNoKVxuXG4gICAgLyoqXG4gICAgICogTXVsdGliYXNlIG5hbWUgYXMgc3RyaW5nLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubXVsdGliYXNlTmFtZSA9IG11bHRpYmFzZU5hbWUgfHwgKHZlcnNpb24gPT09IDAgPyAnYmFzZTU4YnRjJyA6ICdiYXNlMzInKVxuXG4gICAgQ0lELnZhbGlkYXRlQ0lEKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogVGhlIENJRCBhcyBhIGBVaW50OEFycmF5YFxuICAgKlxuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICpcbiAgICovXG4gIGdldCBieXRlcyAoKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGxldCBieXRlcyA9IHRoaXMuX2J5dGVzXG5cbiAgICBpZiAoIWJ5dGVzKSB7XG4gICAgICBpZiAodGhpcy52ZXJzaW9uID09PSAwKSB7XG4gICAgICAgIGJ5dGVzID0gdGhpcy5tdWx0aWhhc2hcbiAgICAgIH0gZWxzZSBpZiAodGhpcy52ZXJzaW9uID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGNvZGVjID0gbXVsdGljb2RlYy5nZXRDb2RlVmFyaW50KHRoaXMuY29kZWMpXG4gICAgICAgIGJ5dGVzID0gdWludDhBcnJheUNvbmNhdChbXG4gICAgICAgICAgWzFdLCBjb2RlYywgdGhpcy5tdWx0aWhhc2hcbiAgICAgICAgXSwgMSArIGNvZGVjLmJ5dGVMZW5ndGggKyB0aGlzLm11bHRpaGFzaC5ieXRlTGVuZ3RoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCB2ZXJzaW9uJylcbiAgICAgIH1cblxuICAgICAgLy8gQ2FjaGUgdGhpcyBVaW50OEFycmF5IHNvIGl0IGRvZXNuJ3QgaGF2ZSB0byBiZSByZWNyZWF0ZWRcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2J5dGVzJywgeyB2YWx1ZTogYnl0ZXMgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHJlZml4IG9mIHRoZSBDSUQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgKi9cbiAgZ2V0IHByZWZpeCAoKSB7XG4gICAgY29uc3QgY29kZWMgPSBtdWx0aWNvZGVjLmdldENvZGVWYXJpbnQodGhpcy5jb2RlYylcbiAgICBjb25zdCBtdWx0aWhhc2ggPSBtaC5wcmVmaXgodGhpcy5tdWx0aWhhc2gpXG4gICAgY29uc3QgcHJlZml4ID0gdWludDhBcnJheUNvbmNhdChbXG4gICAgICBbdGhpcy52ZXJzaW9uXSwgY29kZWMsIG11bHRpaGFzaFxuICAgIF0sIDEgKyBjb2RlYy5ieXRlTGVuZ3RoICsgbXVsdGloYXNoLmJ5dGVMZW5ndGgpXG5cbiAgICByZXR1cm4gcHJlZml4XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNvZGVjIG9mIHRoZSBDSUQgaW4gaXRzIG51bWJlciBmb3JtLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29kZWNDb2RlfVxuICAgKi9cbiAgZ2V0IGNvZGUgKCkge1xuICAgIHJldHVybiBjb2RlY3NbdGhpcy5jb2RlY11cbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRvIGEgQ0lEIG9mIHZlcnNpb24gYDBgLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q0lEfVxuICAgKi9cbiAgdG9WMCAoKSB7XG4gICAgaWYgKHRoaXMuY29kZWMgIT09ICdkYWctcGInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgbm9uIGRhZy1wYiBDSUQgdG8gQ0lEdjAnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgbmFtZSwgbGVuZ3RoIH0gPSBtaC5kZWNvZGUodGhpcy5tdWx0aWhhc2gpXG5cbiAgICBpZiAobmFtZSAhPT0gJ3NoYTItMjU2Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBub24gc2hhMi0yNTYgbXVsdGloYXNoIENJRCB0byBDSUR2MCcpXG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aCAhPT0gMzIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgbm9uIDMyIGJ5dGUgbXVsdGloYXNoIENJRCB0byBDSUR2MCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDSUQoMCwgdGhpcy5jb2RlYywgdGhpcy5tdWx0aWhhc2gpXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0byBhIENJRCBvZiB2ZXJzaW9uIGAxYC5cbiAgICpcbiAgICogQHJldHVybnMge0NJRH1cbiAgICovXG4gIHRvVjEgKCkge1xuICAgIHJldHVybiBuZXcgQ0lEKDEsIHRoaXMuY29kZWMsIHRoaXMubXVsdGloYXNoLCB0aGlzLm11bHRpYmFzZU5hbWUpXG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIHRoZSBDSUQgaW50byBhIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtCYXNlTmFtZU9yQ29kZX0gW2Jhc2U9dGhpcy5tdWx0aWJhc2VOYW1lXSAtIEJhc2UgZW5jb2RpbmcgdG8gdXNlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9CYXNlRW5jb2RlZFN0cmluZyAoYmFzZSA9IHRoaXMubXVsdGliYXNlTmFtZSkge1xuICAgIC8vIEB0cy1pZ25vcmUgbm9uIGVudW1lcmFibGUgY2FjaGUgcHJvcGVydHlcbiAgICBpZiAodGhpcy5zdHJpbmcgJiYgdGhpcy5zdHJpbmcubGVuZ3RoICE9PSAwICYmIGJhc2UgPT09IHRoaXMubXVsdGliYXNlTmFtZSkge1xuICAgICAgLy8gQHRzLWlnbm9yZSBub24gZW51bWVyYWJsZSBjYWNoZSBwcm9wZXJ0eVxuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nXG4gICAgfVxuICAgIGxldCBzdHJcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAwKSB7XG4gICAgICBpZiAoYmFzZSAhPT0gJ2Jhc2U1OGJ0YycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3Qgc3VwcG9ydGVkIHdpdGggQ0lEdjAsIHRvIHN1cHBvcnQgZGlmZmVyZW50IGJhc2VzLCBwbGVhc2UgbWlncmF0ZSB0aGUgaW5zdGFuY2UgZG8gQ0lEdjEsIHlvdSBjYW4gZG8gdGhhdCB0aHJvdWdoIGNpZC50b1YxKCknKVxuICAgICAgfVxuICAgICAgc3RyID0gbWgudG9CNThTdHJpbmcodGhpcy5tdWx0aWhhc2gpXG4gICAgfSBlbHNlIGlmICh0aGlzLnZlcnNpb24gPT09IDEpIHtcbiAgICAgIHN0ciA9IHVpbnQ4QXJyYXlUb1N0cmluZyhtdWx0aWJhc2UuZW5jb2RlKGJhc2UsIHRoaXMuYnl0ZXMpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHZlcnNpb24nKVxuICAgIH1cbiAgICBpZiAoYmFzZSA9PT0gdGhpcy5tdWx0aWJhc2VOYW1lKSB7XG4gICAgICAvLyBjYWNoZSB0aGUgc3RyaW5nIHZhbHVlXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0cmluZycsIHsgdmFsdWU6IHN0ciB9KVxuICAgIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICAvKipcbiAgICogQ0lEKFFtZGZUYkJxQlBRN1ZOeFpFWUVqMTRWbVJ1WkJrcUZiaXdSZW9nSmdTMXpSMW4pXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gKCkge1xuICAgIHJldHVybiAnQ0lEKCcgKyB0aGlzLnRvU3RyaW5nKCkgKyAnKSdcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgdGhlIENJRCBpbnRvIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jhc2VOYW1lT3JDb2RlfSBbYmFzZT10aGlzLm11bHRpYmFzZU5hbWVdIC0gQmFzZSBlbmNvZGluZyB0byB1c2UuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZyAoYmFzZSkge1xuICAgIHJldHVybiB0aGlzLnRvQmFzZUVuY29kZWRTdHJpbmcoYmFzZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdG8gYSBwbGFpbiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTZXJpYWxpemVkQ0lEfVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZWM6IHRoaXMuY29kZWMsXG4gICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICBoYXNoOiB0aGlzLm11bHRpaGFzaFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlIGVxdWFsaXR5IHdpdGggYW5vdGhlciBDSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q0lEfSBvdGhlclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyAob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb2RlYyA9PT0gb3RoZXIuY29kZWMgJiZcbiAgICAgIHRoaXMudmVyc2lvbiA9PT0gb3RoZXIudmVyc2lvbiAmJlxuICAgICAgdWludDhBcnJheUVxdWFscyh0aGlzLm11bHRpaGFzaCwgb3RoZXIubXVsdGloYXNoKVxuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgdGhlIGdpdmVuIGlucHV0IGlzIGEgdmFsaWQgQ0lEIG9iamVjdC5cbiAgICogVGhyb3dzIGlmIGl0IGlzIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IG90aGVyIC0gVGhlIG90aGVyIENJRC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVDSUQgKG90aGVyKSB7XG4gICAgY29uc3QgZXJyb3JNc2cgPSBDSURVdGlsLmNoZWNrQ0lEQ29tcG9uZW50cyhvdGhlcilcbiAgICBpZiAoZXJyb3JNc2cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgb2JqZWN0IGlzIGEgQ0lEIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7dmFsdWUgaXMgQ0lEfVxuICAgKi9cbiAgc3RhdGljIGlzQ0lEICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIENJRCB8fCBCb29sZWFuKHZhbHVlICYmIHZhbHVlW3N5bWJvbF0pXG4gIH1cbn1cblxuQ0lELmNvZGVjcyA9IGNvZGVjc1xuXG5tb2R1bGUuZXhwb3J0cyA9IENJRFxuIl0sIm5hbWVzIjpbIm1oIiwicmVxdWlyZSIsIm11bHRpYmFzZSIsIm11bHRpY29kZWMiLCJDSURVdGlsIiwiY29uY2F0IiwidWludDhBcnJheUNvbmNhdCIsInRvU3RyaW5nIiwidWludDhBcnJheVRvU3RyaW5nIiwiZXF1YWxzIiwidWludDhBcnJheUVxdWFscyIsImNvZGVjcyIsIm5hbWVUb0NvZGUiLCJjb2RlY0ludHMiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwicCIsIm5hbWUiLCJzeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJDSUQiLCJjb25zdHJ1Y3RvciIsInZlcnNpb24iLCJjb2RlYyIsIm11bHRpaGFzaCIsIm11bHRpYmFzZU5hbWUiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiaXNDSUQiLCJjaWQiLCJiYXNlTmFtZSIsImlzRW5jb2RlZCIsImRlY29kZSIsInBhcnNlSW50IiwiZ2V0Q29kZWMiLCJzbGljZSIsInJtUHJlZml4IiwiZnJvbUI1OFN0cmluZyIsInZhbGlkYXRlQ0lEIiwiVWludDhBcnJheSIsInYiLCJieXRlcyIsIl9ieXRlcyIsImdldENvZGVWYXJpbnQiLCJieXRlTGVuZ3RoIiwiRXJyb3IiLCJwcmVmaXgiLCJjb2RlIiwidG9WMCIsImxlbmd0aCIsInRvVjEiLCJ0b0Jhc2VFbmNvZGVkU3RyaW5nIiwiYmFzZSIsInN0cmluZyIsInN0ciIsInRvQjU4U3RyaW5nIiwiZW5jb2RlIiwidG9KU09OIiwiaGFzaCIsIm90aGVyIiwiZXJyb3JNc2ciLCJjaGVja0NJRENvbXBvbmVudHMiLCJCb29sZWFuIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/cids@1.1.9/node_modules/cids/src/index.js\n");

/***/ })

};
;