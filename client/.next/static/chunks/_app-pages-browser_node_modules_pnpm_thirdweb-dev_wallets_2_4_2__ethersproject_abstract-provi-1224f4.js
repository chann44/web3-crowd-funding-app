"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_pnpm_thirdweb-dev_wallets_2_4_2__ethersproject_abstract-provi-1224f4"],{

/***/ "(app-pages-browser)/./node_modules/.pnpm/@thirdweb-dev+wallets@2.4.2_@ethersproject+abstract-provider@5.7.0_@ethersproject+abstract-si_q3uhj54vw2tqcdxon24cvgplba/node_modules/@thirdweb-dev/wallets/dist/url-a45219bd.browser.esm.js":
/*!*************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@thirdweb-dev+wallets@2.4.2_@ethersproject+abstract-provider@5.7.0_@ethersproject+abstract-si_q3uhj54vw2tqcdxon24cvgplba/node_modules/@thirdweb-dev/wallets/dist/url-a45219bd.browser.esm.js ***!
  \*************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   g: function() { return /* binding */ getValidPublicRPCUrl; },\n/* harmony export */   i: function() { return /* binding */ isTwUrl; }\n/* harmony export */ });\n/* harmony import */ var _thirdweb_dev_chains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @thirdweb-dev/chains */ \"(app-pages-browser)/./node_modules/.pnpm/@thirdweb-dev+chains@0.1.64/node_modules/@thirdweb-dev/chains/dist/thirdweb-dev-chains.esm.js\");\n\nfunction isTwUrl(url) {\n    const host = new URL(url).hostname;\n    return host.endsWith(\".thirdweb.com\") || host.endsWith(\".thirdweb-dev.com\") || host === \"localhost\" || host === \"0.0.0.0\";\n}\nfunction getValidPublicRPCUrl(chain) {\n    return (0,_thirdweb_dev_chains__WEBPACK_IMPORTED_MODULE_0__.getValidChainRPCs)(chain).map((rpc)=>{\n        try {\n            const url = new URL(rpc);\n            // remove client id from url\n            if (url.hostname.endsWith(\".thirdweb.com\")) {\n                url.pathname = \"\";\n                url.search = \"\";\n            }\n            return url.toString();\n        } catch (e) {\n            return rpc;\n        }\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGhpcmR3ZWItZGV2K3dhbGxldHNAMi40LjJfQGV0aGVyc3Byb2plY3QrYWJzdHJhY3QtcHJvdmlkZXJANS43LjBfQGV0aGVyc3Byb2plY3QrYWJzdHJhY3Qtc2lfcTN1aGo1NHZ3MnRxY2R4b24yNGN2Z3BsYmEvbm9kZV9tb2R1bGVzL0B0aGlyZHdlYi1kZXYvd2FsbGV0cy9kaXN0L3VybC1hNDUyMTliZC5icm93c2VyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUQ7QUFFekQsU0FBU0MsUUFBUUMsR0FBRztJQUNsQixNQUFNQyxPQUFPLElBQUlDLElBQUlGLEtBQUtHLFFBQVE7SUFDbEMsT0FBT0YsS0FBS0csUUFBUSxDQUFDLG9CQUFvQkgsS0FBS0csUUFBUSxDQUFDLHdCQUF3QkgsU0FBUyxlQUFlQSxTQUFTO0FBQ2xIO0FBQ0EsU0FBU0kscUJBQXFCQyxLQUFLO0lBQ2pDLE9BQU9SLHVFQUFpQkEsQ0FBQ1EsT0FBT0MsR0FBRyxDQUFDQyxDQUFBQTtRQUNsQyxJQUFJO1lBQ0YsTUFBTVIsTUFBTSxJQUFJRSxJQUFJTTtZQUNwQiw0QkFBNEI7WUFDNUIsSUFBSVIsSUFBSUcsUUFBUSxDQUFDQyxRQUFRLENBQUMsa0JBQWtCO2dCQUMxQ0osSUFBSVMsUUFBUSxHQUFHO2dCQUNmVCxJQUFJVSxNQUFNLEdBQUc7WUFDZjtZQUNBLE9BQU9WLElBQUlXLFFBQVE7UUFDckIsRUFBRSxPQUFPQyxHQUFHO1lBQ1YsT0FBT0o7UUFDVDtJQUNGO0FBQ0Y7QUFFbUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0aGlyZHdlYi1kZXYrd2FsbGV0c0AyLjQuMl9AZXRoZXJzcHJvamVjdCthYnN0cmFjdC1wcm92aWRlckA1LjcuMF9AZXRoZXJzcHJvamVjdCthYnN0cmFjdC1zaV9xM3VoajU0dncydHFjZHhvbjI0Y3ZncGxiYS9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi93YWxsZXRzL2Rpc3QvdXJsLWE0NTIxOWJkLmJyb3dzZXIuZXNtLmpzP2Y5YjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VmFsaWRDaGFpblJQQ3MgfSBmcm9tICdAdGhpcmR3ZWItZGV2L2NoYWlucyc7XG5cbmZ1bmN0aW9uIGlzVHdVcmwodXJsKSB7XG4gIGNvbnN0IGhvc3QgPSBuZXcgVVJMKHVybCkuaG9zdG5hbWU7XG4gIHJldHVybiBob3N0LmVuZHNXaXRoKFwiLnRoaXJkd2ViLmNvbVwiKSB8fCBob3N0LmVuZHNXaXRoKFwiLnRoaXJkd2ViLWRldi5jb21cIikgfHwgaG9zdCA9PT0gXCJsb2NhbGhvc3RcIiB8fCBob3N0ID09PSBcIjAuMC4wLjBcIjtcbn1cbmZ1bmN0aW9uIGdldFZhbGlkUHVibGljUlBDVXJsKGNoYWluKSB7XG4gIHJldHVybiBnZXRWYWxpZENoYWluUlBDcyhjaGFpbikubWFwKHJwYyA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocnBjKTtcbiAgICAgIC8vIHJlbW92ZSBjbGllbnQgaWQgZnJvbSB1cmxcbiAgICAgIGlmICh1cmwuaG9zdG5hbWUuZW5kc1dpdGgoXCIudGhpcmR3ZWIuY29tXCIpKSB7XG4gICAgICAgIHVybC5wYXRobmFtZSA9IFwiXCI7XG4gICAgICAgIHVybC5zZWFyY2ggPSBcIlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBycGM7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IHsgZ2V0VmFsaWRQdWJsaWNSUENVcmwgYXMgZywgaXNUd1VybCBhcyBpIH07XG4iXSwibmFtZXMiOlsiZ2V0VmFsaWRDaGFpblJQQ3MiLCJpc1R3VXJsIiwidXJsIiwiaG9zdCIsIlVSTCIsImhvc3RuYW1lIiwiZW5kc1dpdGgiLCJnZXRWYWxpZFB1YmxpY1JQQ1VybCIsImNoYWluIiwibWFwIiwicnBjIiwicGF0aG5hbWUiLCJzZWFyY2giLCJ0b1N0cmluZyIsImUiLCJnIiwiaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@thirdweb-dev+wallets@2.4.2_@ethersproject+abstract-provider@5.7.0_@ethersproject+abstract-si_q3uhj54vw2tqcdxon24cvgplba/node_modules/@thirdweb-dev/wallets/dist/url-a45219bd.browser.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@thirdweb-dev+wallets@2.4.2_@ethersproject+abstract-provider@5.7.0_@ethersproject+abstract-si_q3uhj54vw2tqcdxon24cvgplba/node_modules/@thirdweb-dev/wallets/evm/connectors/blocto/dist/thirdweb-dev-wallets-evm-connectors-blocto.browser.esm.js":
/*!*****************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@thirdweb-dev+wallets@2.4.2_@ethersproject+abstract-provider@5.7.0_@ethersproject+abstract-si_q3uhj54vw2tqcdxon24cvgplba/node_modules/@thirdweb-dev/wallets/evm/connectors/blocto/dist/thirdweb-dev-wallets-evm-connectors-blocto.browser.esm.js ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BloctoConnector: function() { return /* binding */ BloctoConnector; }\n/* harmony export */ });\n/* harmony import */ var _dist_classPrivateMethodGet_ea199cc3_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../dist/classPrivateMethodGet-ea199cc3.browser.esm.js */ \"(app-pages-browser)/./node_modules/.pnpm/@thirdweb-dev+wallets@2.4.2_@ethersproject+abstract-provider@5.7.0_@ethersproject+abstract-si_q3uhj54vw2tqcdxon24cvgplba/node_modules/@thirdweb-dev/wallets/dist/classPrivateMethodGet-ea199cc3.browser.esm.js\");\n/* harmony import */ var _dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js */ \"(app-pages-browser)/./node_modules/.pnpm/@thirdweb-dev+wallets@2.4.2_@ethersproject+abstract-provider@5.7.0_@ethersproject+abstract-si_q3uhj54vw2tqcdxon24cvgplba/node_modules/@thirdweb-dev/wallets/dist/classPrivateFieldSet-a5db7c83.browser.esm.js\");\n/* harmony import */ var _dist_defineProperty_d7c057bf_browser_esm_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../../dist/defineProperty-d7c057bf.browser.esm.js */ \"(app-pages-browser)/./node_modules/.pnpm/@thirdweb-dev+wallets@2.4.2_@ethersproject+abstract-provider@5.7.0_@ethersproject+abstract-si_q3uhj54vw2tqcdxon24cvgplba/node_modules/@thirdweb-dev/wallets/dist/defineProperty-d7c057bf.browser.esm.js\");\n/* harmony import */ var _dist_WagmiConnector_2f14002d_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../dist/WagmiConnector-2f14002d.browser.esm.js */ \"(app-pages-browser)/./node_modules/.pnpm/@thirdweb-dev+wallets@2.4.2_@ethersproject+abstract-provider@5.7.0_@ethersproject+abstract-si_q3uhj54vw2tqcdxon24cvgplba/node_modules/@thirdweb-dev/wallets/dist/WagmiConnector-2f14002d.browser.esm.js\");\n/* harmony import */ var _dist_errors_9f6736cb_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../dist/errors-9f6736cb.browser.esm.js */ \"(app-pages-browser)/./node_modules/.pnpm/@thirdweb-dev+wallets@2.4.2_@ethersproject+abstract-provider@5.7.0_@ethersproject+abstract-si_q3uhj54vw2tqcdxon24cvgplba/node_modules/@thirdweb-dev/wallets/dist/errors-9f6736cb.browser.esm.js\");\n/* harmony import */ var _blocto_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @blocto/sdk */ \"(app-pages-browser)/./node_modules/.pnpm/@blocto+sdk@0.5.5/node_modules/@blocto/sdk/dist/blocto-sdk.module.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/.pnpm/@ethersproject+address@5.7.0/node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/.pnpm/@ethersproject+providers@5.7.2/node_modules/@ethersproject/providers/lib.esm/web3-provider.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _dist_walletIds_afeb5af2_browser_esm_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../../dist/walletIds-afeb5af2.browser.esm.js */ \"(app-pages-browser)/./node_modules/.pnpm/@thirdweb-dev+wallets@2.4.2_@ethersproject+abstract-provider@5.7.0_@ethersproject+abstract-si_q3uhj54vw2tqcdxon24cvgplba/node_modules/@thirdweb-dev/wallets/dist/walletIds-afeb5af2.browser.esm.js\");\n/* harmony import */ var _dist_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../../dist/url-a45219bd.browser.esm.js */ \"(app-pages-browser)/./node_modules/.pnpm/@thirdweb-dev+wallets@2.4.2_@ethersproject+abstract-provider@5.7.0_@ethersproject+abstract-si_q3uhj54vw2tqcdxon24cvgplba/node_modules/@thirdweb-dev/wallets/dist/url-a45219bd.browser.esm.js\");\n/* harmony import */ var _dist_normalizeChainId_1fb9aedf_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../dist/normalizeChainId-1fb9aedf.browser.esm.js */ \"(app-pages-browser)/./node_modules/.pnpm/@thirdweb-dev+wallets@2.4.2_@ethersproject+abstract-provider@5.7.0_@ethersproject+abstract-si_q3uhj54vw2tqcdxon24cvgplba/node_modules/@thirdweb-dev/wallets/dist/normalizeChainId-1fb9aedf.browser.esm.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventemitter3 */ \"(app-pages-browser)/./node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\nvar _provider = /*#__PURE__*/ new WeakMap();\nvar _onAccountsChangedBind = /*#__PURE__*/ new WeakMap();\nvar _onChainChangedBind = /*#__PURE__*/ new WeakMap();\nvar _onDisconnectBind = /*#__PURE__*/ new WeakMap();\nvar _isUserRejectedRequestError = /*#__PURE__*/ new WeakSet();\nvar _handleConnectReset = /*#__PURE__*/ new WeakSet();\nclass BloctoConnector extends _dist_WagmiConnector_2f14002d_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.W {\n    async connect(config) {\n        try {\n            const provider = await this.getProvider(config);\n            this.setupListeners();\n            this.emit(\"message\", {\n                type: \"connecting\"\n            });\n            const accounts = await provider.request({\n                method: \"eth_requestAccounts\"\n            });\n            const account = ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress(accounts[0]);\n            const id = await this.getChainId();\n            const unsupported = this.isChainUnsupported(id);\n            return {\n                account,\n                chain: {\n                    id,\n                    unsupported\n                },\n                provider\n            };\n        } catch (error) {\n            (0,_dist_classPrivateMethodGet_ea199cc3_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(this, _handleConnectReset, _handleConnectReset2).call(this);\n            if ((0,_dist_classPrivateMethodGet_ea199cc3_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(this, _isUserRejectedRequestError, _isUserRejectedRequestError2).call(this, error)) {\n                throw new _dist_errors_9f6736cb_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.U(error);\n            }\n            throw error;\n        }\n    }\n    async disconnect() {\n        const provider = await this.getProvider();\n        await provider.request({\n            method: \"wallet_disconnect\"\n        });\n        this.removeListeners();\n        (0,_dist_classPrivateMethodGet_ea199cc3_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(this, _handleConnectReset, _handleConnectReset2).call(this);\n    }\n    async getAccount() {\n        const provider = await this.getProvider();\n        const accounts = await provider.request({\n            method: \"eth_accounts\"\n        });\n        const [address] = accounts || [];\n        if (!address) {\n            throw new Error(\"No accounts found\");\n        }\n        return address;\n    }\n    async getChainId() {\n        const provider = await this.getProvider();\n        const chainId = await provider.request({\n            method: \"eth_chainId\"\n        });\n        return (0,_dist_normalizeChainId_1fb9aedf_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__.n)(chainId);\n    }\n    getProvider() {\n        let { chainId } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!(0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.b)(this, _provider)) {\n            var _this_chains_, _this_chains_find, _this;\n            var _ref, _ref1;\n            const _chainId = (_ref1 = (_ref = chainId !== null && chainId !== void 0 ? chainId : this.options.chainId) !== null && _ref !== void 0 ? _ref : (_this_chains_ = this.chains[0]) === null || _this_chains_ === void 0 ? void 0 : _this_chains_.chainId) !== null && _ref1 !== void 0 ? _ref1 : 1;\n            const _rpc = (_this_chains_find = this.chains.find((x)=>x.chainId === _chainId)) === null || _this_chains_find === void 0 ? void 0 : _this_chains_find.rpc[0];\n            (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.a)(this, _provider, (_this = new _blocto_sdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n                ethereum: {\n                    chainId: _chainId,\n                    rpc: _rpc\n                },\n                appId: this.options.appId\n            })) === null || _this === void 0 ? void 0 : _this.ethereum);\n        }\n        if (!(0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.b)(this, _provider)) {\n            throw new _dist_errors_9f6736cb_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.a();\n        }\n        return Promise.resolve((0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.b)(this, _provider));\n    }\n    async getSigner() {\n        let { chainId } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const [provider, account] = await Promise.all([\n            this.getProvider(),\n            this.getAccount()\n        ]);\n        return new ethers__WEBPACK_IMPORTED_MODULE_8__.Web3Provider(provider, chainId).getSigner(account);\n    }\n    async isAuthorized() {\n        var _classPrivateFieldGet__blocto, _classPrivateFieldGet1;\n        var _ref;\n        return (_ref = !!((_classPrivateFieldGet1 = (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.b)(this, _provider)) === null || _classPrivateFieldGet1 === void 0 ? void 0 : (_classPrivateFieldGet__blocto = _classPrivateFieldGet1._blocto) === null || _classPrivateFieldGet__blocto === void 0 ? void 0 : _classPrivateFieldGet__blocto.sessionKey)) !== null && _ref !== void 0 ? _ref : false;\n    }\n    async switchChain(chainId) {\n        const provider = await this.getProvider();\n        const id = ethers__WEBPACK_IMPORTED_MODULE_9__.hexValue(chainId);\n        const chain = this.chains.find((x)=>x.chainId === chainId);\n        if (!chain) {\n            throw new _dist_errors_9f6736cb_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.S(new Error(\"chain not found on connector.\"));\n        }\n        const isBloctoSupportChain = provider._blocto.supportNetworkList[\"\".concat(chainId)];\n        if (!isBloctoSupportChain) {\n            throw new _dist_errors_9f6736cb_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.S(new Error(\"Blocto unsupported chain: \".concat(id)));\n        }\n        try {\n            await provider.request({\n                method: \"wallet_addEthereumChain\",\n                params: [\n                    {\n                        chainId: id,\n                        rpcUrls: (0,_dist_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_10__.g)(chain) // no client id on purpose here\n                    }\n                ]\n            });\n            await provider.request({\n                method: \"wallet_switchEthereumChain\",\n                params: [\n                    {\n                        chainId: id\n                    }\n                ]\n            });\n            return chain;\n        } catch (error) {\n            if ((0,_dist_classPrivateMethodGet_ea199cc3_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(this, _isUserRejectedRequestError, _isUserRejectedRequestError2).call(this, error)) {\n                throw new _dist_errors_9f6736cb_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.U(error);\n            }\n            throw new _dist_errors_9f6736cb_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.S(error);\n        }\n    }\n    onAccountsChanged() {\n    // not supported yet\n    }\n    async onChainChanged(chain) {\n        const id = (0,_dist_normalizeChainId_1fb9aedf_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__.n)(chain);\n        const unsupported = this.isChainUnsupported(id);\n        const account = await this.getAccount();\n        this.emit(\"change\", {\n            chain: {\n                id,\n                unsupported\n            },\n            account\n        });\n    }\n    onDisconnect() {\n        this.emit(\"disconnect\");\n    }\n    async setupListeners() {\n        const provider = await this.getProvider();\n        provider.on(\"accountsChanged\", (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.b)(this, _onAccountsChangedBind));\n        provider.on(\"chainChanged\", (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.b)(this, _onChainChangedBind));\n        provider.on(\"disconnect\", (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.b)(this, _onDisconnectBind));\n    }\n    async removeListeners() {\n        const provider = await this.getProvider();\n        provider.off(\"accountsChanged\", (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.b)(this, _onAccountsChangedBind));\n        provider.off(\"chainChanged\", (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.b)(this, _onChainChangedBind));\n        provider.off(\"disconnect\", (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.b)(this, _onDisconnectBind));\n    }\n    constructor(_ref){\n        let { chains, options = {} } = _ref;\n        super({\n            chains,\n            options\n        });\n        (0,_dist_classPrivateMethodGet_ea199cc3_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(this, _handleConnectReset);\n        (0,_dist_classPrivateMethodGet_ea199cc3_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(this, _isUserRejectedRequestError);\n        (0,_dist_defineProperty_d7c057bf_browser_esm_js__WEBPACK_IMPORTED_MODULE_11__._)(this, \"id\", _dist_walletIds_afeb5af2_browser_esm_js__WEBPACK_IMPORTED_MODULE_12__.w.blocto);\n        (0,_dist_defineProperty_d7c057bf_browser_esm_js__WEBPACK_IMPORTED_MODULE_11__._)(this, \"name\", \"Blocto\");\n        (0,_dist_defineProperty_d7c057bf_browser_esm_js__WEBPACK_IMPORTED_MODULE_11__._)(this, \"ready\", true);\n        (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(this, _provider, {\n            writable: true,\n            value: void 0\n        });\n        (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(this, _onAccountsChangedBind, {\n            writable: true,\n            value: void 0\n        });\n        (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(this, _onChainChangedBind, {\n            writable: true,\n            value: void 0\n        });\n        (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(this, _onDisconnectBind, {\n            writable: true,\n            value: void 0\n        });\n        (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.a)(this, _onAccountsChangedBind, this.onAccountsChanged.bind(this));\n        (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.a)(this, _onChainChangedBind, this.onChainChanged.bind(this));\n        (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.a)(this, _onDisconnectBind, this.onDisconnect.bind(this));\n    }\n}\nfunction _isUserRejectedRequestError2(error) {\n    return /(user rejected)/i.test(error.message);\n}\nfunction _handleConnectReset2() {\n    (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.a)(this, _provider, undefined);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGhpcmR3ZWItZGV2K3dhbGxldHNAMi40LjJfQGV0aGVyc3Byb2plY3QrYWJzdHJhY3QtcHJvdmlkZXJANS43LjBfQGV0aGVyc3Byb2plY3QrYWJzdHJhY3Qtc2lfcTN1aGo1NHZ3MnRxY2R4b24yNGN2Z3BsYmEvbm9kZV9tb2R1bGVzL0B0aGlyZHdlYi1kZXYvd2FsbGV0cy9ldm0vY29ubmVjdG9ycy9ibG9jdG8vZGlzdC90aGlyZHdlYi1kZXYtd2FsbGV0cy1ldm0tY29ubmVjdG9ycy1ibG9jdG8uYnJvd3Nlci5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0k7QUFDeUI7QUFDekU7QUFDRDtBQUNzRDtBQUNoSDtBQUNNO0FBQzBDO0FBQ0s7QUFDUztBQUNwRTtBQUNQO0FBRXZCLElBQUl5QixZQUFZLFdBQVcsR0FBRSxJQUFJQztBQUNqQyxJQUFJQyx5QkFBeUIsV0FBVyxHQUFFLElBQUlEO0FBQzlDLElBQUlFLHNCQUFzQixXQUFXLEdBQUUsSUFBSUY7QUFDM0MsSUFBSUcsb0JBQW9CLFdBQVcsR0FBRSxJQUFJSDtBQUN6QyxJQUFJSSw4QkFBOEIsV0FBVyxHQUFFLElBQUlDO0FBQ25ELElBQUlDLHNCQUFzQixXQUFXLEdBQUUsSUFBSUQ7QUFDM0MsTUFBTUUsd0JBQXdCdkIsMkVBQWNBO0lBbUMxQyxNQUFNd0IsUUFBUUMsTUFBTSxFQUFFO1FBQ3BCLElBQUk7WUFDRixNQUFNQyxXQUFXLE1BQU0sSUFBSSxDQUFDQyxXQUFXLENBQUNGO1lBQ3hDLElBQUksQ0FBQ0csY0FBYztZQUNuQixJQUFJLENBQUNDLElBQUksQ0FBQyxXQUFXO2dCQUNuQkMsTUFBTTtZQUNSO1lBQ0EsTUFBTUMsV0FBVyxNQUFNTCxTQUFTTSxPQUFPLENBQUM7Z0JBQ3RDQyxRQUFRO1lBQ1Y7WUFDQSxNQUFNQyxVQUFVM0IsOENBQWdCLENBQUN3QixRQUFRLENBQUMsRUFBRTtZQUM1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LGNBQWMsQ0FBQ1MsSUFBSSxDQUFDLElBQUk7UUFDOUU1RixxRkFBcUJBLENBQUMsSUFBSSxFQUFFd0IsbUJBQW1CLElBQUksQ0FBQzRELFlBQVksQ0FBQ1EsSUFBSSxDQUFDLElBQUk7SUFDNUU7QUFxSkY7QUFDQSxTQUFTM0MsNkJBQTZCSCxLQUFLO0lBQ3pDLE9BQU8sbUJBQW1CK0MsSUFBSSxDQUFDL0MsTUFBTWdELE9BQU87QUFDOUM7QUFDQSxTQUFTL0M7SUFDUC9DLHFGQUFxQkEsQ0FBQyxJQUFJLEVBQUVvQixXQUFXc0M7QUFDekM7QUFFMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0aGlyZHdlYi1kZXYrd2FsbGV0c0AyLjQuMl9AZXRoZXJzcHJvamVjdCthYnN0cmFjdC1wcm92aWRlckA1LjcuMF9AZXRoZXJzcHJvamVjdCthYnN0cmFjdC1zaV9xM3VoajU0dncydHFjZHhvbjI0Y3ZncGxiYS9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi93YWxsZXRzL2V2bS9jb25uZWN0b3JzL2Jsb2N0by9kaXN0L3RoaXJkd2ViLWRldi13YWxsZXRzLWV2bS1jb25uZWN0b3JzLWJsb2N0by5icm93c2VyLmVzbS5qcz85OWYzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF8gYXMgX2NsYXNzUHJpdmF0ZU1ldGhvZEluaXRTcGVjLCBhIGFzIF9jbGFzc1ByaXZhdGVNZXRob2RHZXQgfSBmcm9tICcuLi8uLi8uLi8uLi9kaXN0L2NsYXNzUHJpdmF0ZU1ldGhvZEdldC1lYTE5OWNjMy5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgeyBfIGFzIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjLCBhIGFzIF9jbGFzc1ByaXZhdGVGaWVsZFNldCwgYiBhcyBfY2xhc3NQcml2YXRlRmllbGRHZXQgfSBmcm9tICcuLi8uLi8uLi8uLi9kaXN0L2NsYXNzUHJpdmF0ZUZpZWxkU2V0LWE1ZGI3YzgzLmJyb3dzZXIuZXNtLmpzJztcbmltcG9ydCB7IF8gYXMgX2RlZmluZVByb3BlcnR5IH0gZnJvbSAnLi4vLi4vLi4vLi4vZGlzdC9kZWZpbmVQcm9wZXJ0eS1kN2MwNTdiZi5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgeyBXIGFzIFdhZ21pQ29ubmVjdG9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vZGlzdC9XYWdtaUNvbm5lY3Rvci0yZjE0MDAyZC5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgeyBVIGFzIFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvciwgYSBhcyBDb25uZWN0b3JOb3RGb3VuZEVycm9yLCBTIGFzIFN3aXRjaENoYWluRXJyb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9kaXN0L2Vycm9ycy05ZjY3MzZjYi5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgQmxvY3RvU0RLIGZyb20gJ0BibG9jdG8vc2RrJztcbmltcG9ydCB7IHV0aWxzLCBwcm92aWRlcnMgfSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IHsgdyBhcyB3YWxsZXRJZHMgfSBmcm9tICcuLi8uLi8uLi8uLi9kaXN0L3dhbGxldElkcy1hZmViNWFmMi5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldFZhbGlkUHVibGljUlBDVXJsIH0gZnJvbSAnLi4vLi4vLi4vLi4vZGlzdC91cmwtYTQ1MjE5YmQuYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IHsgbiBhcyBub3JtYWxpemVDaGFpbklkIH0gZnJvbSAnLi4vLi4vLi4vLi4vZGlzdC9ub3JtYWxpemVDaGFpbklkLTFmYjlhZWRmLmJyb3dzZXIuZXNtLmpzJztcbmltcG9ydCAnQHRoaXJkd2ViLWRldi9jaGFpbnMnO1xuaW1wb3J0ICdldmVudGVtaXR0ZXIzJztcblxudmFyIF9wcm92aWRlciA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xudmFyIF9vbkFjY291bnRzQ2hhbmdlZEJpbmQgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBfb25DaGFpbkNoYW5nZWRCaW5kID0gLyojX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG52YXIgX29uRGlzY29ubmVjdEJpbmQgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBfaXNVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtTZXQoKTtcbnZhciBfaGFuZGxlQ29ubmVjdFJlc2V0ID0gLyojX19QVVJFX18qL25ldyBXZWFrU2V0KCk7XG5jbGFzcyBCbG9jdG9Db25uZWN0b3IgZXh0ZW5kcyBXYWdtaUNvbm5lY3RvciB7XG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgY2hhaW5zLFxuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfSA9IF9yZWY7XG4gICAgc3VwZXIoe1xuICAgICAgY2hhaW5zLFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xuICAgIF9jbGFzc1ByaXZhdGVNZXRob2RJbml0U3BlYyh0aGlzLCBfaGFuZGxlQ29ubmVjdFJlc2V0KTtcbiAgICBfY2xhc3NQcml2YXRlTWV0aG9kSW5pdFNwZWModGhpcywgX2lzVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB3YWxsZXRJZHMuYmxvY3RvKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIFwiQmxvY3RvXCIpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlYWR5XCIsIHRydWUpO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKHRoaXMsIF9wcm92aWRlciwge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSk7XG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWModGhpcywgX29uQWNjb3VudHNDaGFuZ2VkQmluZCwge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSk7XG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWModGhpcywgX29uQ2hhaW5DaGFuZ2VkQmluZCwge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSk7XG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWModGhpcywgX29uRGlzY29ubmVjdEJpbmQsIHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfb25BY2NvdW50c0NoYW5nZWRCaW5kLCB0aGlzLm9uQWNjb3VudHNDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfb25DaGFpbkNoYW5nZWRCaW5kLCB0aGlzLm9uQ2hhaW5DaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfb25EaXNjb25uZWN0QmluZCwgdGhpcy5vbkRpc2Nvbm5lY3QuYmluZCh0aGlzKSk7XG4gIH1cbiAgYXN5bmMgY29ubmVjdChjb25maWcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKGNvbmZpZyk7XG4gICAgICB0aGlzLnNldHVwTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgdHlwZTogXCJjb25uZWN0aW5nXCJcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBcImV0aF9yZXF1ZXN0QWNjb3VudHNcIlxuICAgICAgfSk7XG4gICAgICBjb25zdCBhY2NvdW50ID0gdXRpbHMuZ2V0QWRkcmVzcyhhY2NvdW50c1swXSk7XG4gICAgICBjb25zdCBpZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgICAgY29uc3QgdW5zdXBwb3J0ZWQgPSB0aGlzLmlzQ2hhaW5VbnN1cHBvcnRlZChpZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY2NvdW50LFxuICAgICAgICBjaGFpbjoge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHVuc3VwcG9ydGVkXG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGVyXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBfY2xhc3NQcml2YXRlTWV0aG9kR2V0KHRoaXMsIF9oYW5kbGVDb25uZWN0UmVzZXQsIF9oYW5kbGVDb25uZWN0UmVzZXQyKS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKF9jbGFzc1ByaXZhdGVNZXRob2RHZXQodGhpcywgX2lzVXNlclJlamVjdGVkUmVxdWVzdEVycm9yLCBfaXNVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IyKS5jYWxsKHRoaXMsIGVycm9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgIGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcIndhbGxldF9kaXNjb25uZWN0XCJcbiAgICB9KTtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVycygpO1xuICAgIF9jbGFzc1ByaXZhdGVNZXRob2RHZXQodGhpcywgX2hhbmRsZUNvbm5lY3RSZXNldCwgX2hhbmRsZUNvbm5lY3RSZXNldDIpLmNhbGwodGhpcyk7XG4gIH1cbiAgYXN5bmMgZ2V0QWNjb3VudCgpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcImV0aF9hY2NvdW50c1wiXG4gICAgfSk7XG4gICAgY29uc3QgW2FkZHJlc3NdID0gYWNjb3VudHMgfHwgW107XG4gICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhY2NvdW50cyBmb3VuZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZHJlc3M7XG4gIH1cbiAgYXN5bmMgZ2V0Q2hhaW5JZCgpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiZXRoX2NoYWluSWRcIlxuICAgIH0pO1xuICAgIHJldHVybiBub3JtYWxpemVDaGFpbklkKGNoYWluSWQpO1xuICB9XG4gIGdldFByb3ZpZGVyKCkge1xuICAgIGxldCB7XG4gICAgICBjaGFpbklkXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgaWYgKCFfY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX3Byb3ZpZGVyKSkge1xuICAgICAgY29uc3QgX2NoYWluSWQgPSBjaGFpbklkID8/IHRoaXMub3B0aW9ucy5jaGFpbklkID8/IHRoaXMuY2hhaW5zWzBdPy5jaGFpbklkID8/IDE7XG4gICAgICBjb25zdCBfcnBjID0gdGhpcy5jaGFpbnMuZmluZCh4ID0+IHguY2hhaW5JZCA9PT0gX2NoYWluSWQpPy5ycGNbMF07XG4gICAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX3Byb3ZpZGVyLCBuZXcgQmxvY3RvU0RLKHtcbiAgICAgICAgZXRoZXJldW06IHtcbiAgICAgICAgICBjaGFpbklkOiBfY2hhaW5JZCxcbiAgICAgICAgICBycGM6IF9ycGNcbiAgICAgICAgfSxcbiAgICAgICAgYXBwSWQ6IHRoaXMub3B0aW9ucy5hcHBJZFxuICAgICAgfSk/LmV0aGVyZXVtKTtcbiAgICB9XG4gICAgaWYgKCFfY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX3Byb3ZpZGVyKSkge1xuICAgICAgdGhyb3cgbmV3IENvbm5lY3Rvck5vdEZvdW5kRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX3Byb3ZpZGVyKSk7XG4gIH1cbiAgYXN5bmMgZ2V0U2lnbmVyKCkge1xuICAgIGxldCB7XG4gICAgICBjaGFpbklkXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3QgW3Byb3ZpZGVyLCBhY2NvdW50XSA9IGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLmdldFByb3ZpZGVyKCksIHRoaXMuZ2V0QWNjb3VudCgpXSk7XG4gICAgcmV0dXJuIG5ldyBwcm92aWRlcnMuV2ViM1Byb3ZpZGVyKHByb3ZpZGVyLCBjaGFpbklkKS5nZXRTaWduZXIoYWNjb3VudCk7XG4gIH1cbiAgYXN5bmMgaXNBdXRob3JpemVkKCkge1xuICAgIHJldHVybiAhIV9jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfcHJvdmlkZXIpPy5fYmxvY3RvPy5zZXNzaW9uS2V5ID8/IGZhbHNlO1xuICB9XG4gIGFzeW5jIHN3aXRjaENoYWluKGNoYWluSWQpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICBjb25zdCBpZCA9IHV0aWxzLmhleFZhbHVlKGNoYWluSWQpO1xuICAgIGNvbnN0IGNoYWluID0gdGhpcy5jaGFpbnMuZmluZCh4ID0+IHguY2hhaW5JZCA9PT0gY2hhaW5JZCk7XG4gICAgaWYgKCFjaGFpbikge1xuICAgICAgdGhyb3cgbmV3IFN3aXRjaENoYWluRXJyb3IobmV3IEVycm9yKFwiY2hhaW4gbm90IGZvdW5kIG9uIGNvbm5lY3Rvci5cIikpO1xuICAgIH1cbiAgICBjb25zdCBpc0Jsb2N0b1N1cHBvcnRDaGFpbiA9IHByb3ZpZGVyLl9ibG9jdG8uc3VwcG9ydE5ldHdvcmtMaXN0W2Ake2NoYWluSWR9YF07XG4gICAgaWYgKCFpc0Jsb2N0b1N1cHBvcnRDaGFpbikge1xuICAgICAgdGhyb3cgbmV3IFN3aXRjaENoYWluRXJyb3IobmV3IEVycm9yKGBCbG9jdG8gdW5zdXBwb3J0ZWQgY2hhaW46ICR7aWR9YCkpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJ3YWxsZXRfYWRkRXRoZXJldW1DaGFpblwiLFxuICAgICAgICBwYXJhbXM6IFt7XG4gICAgICAgICAgY2hhaW5JZDogaWQsXG4gICAgICAgICAgcnBjVXJsczogZ2V0VmFsaWRQdWJsaWNSUENVcmwoY2hhaW4pIC8vIG5vIGNsaWVudCBpZCBvbiBwdXJwb3NlIGhlcmVcbiAgICAgICAgfV1cbiAgICAgIH0pO1xuICAgICAgYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJ3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpblwiLFxuICAgICAgICBwYXJhbXM6IFt7XG4gICAgICAgICAgY2hhaW5JZDogaWRcbiAgICAgICAgfV1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNoYWluO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoX2NsYXNzUHJpdmF0ZU1ldGhvZEdldCh0aGlzLCBfaXNVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IsIF9pc1VzZXJSZWplY3RlZFJlcXVlc3RFcnJvcjIpLmNhbGwodGhpcywgZXJyb3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFN3aXRjaENoYWluRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBvbkFjY291bnRzQ2hhbmdlZCgpIHtcbiAgICAvLyBub3Qgc3VwcG9ydGVkIHlldFxuICB9XG4gIGFzeW5jIG9uQ2hhaW5DaGFuZ2VkKGNoYWluKSB7XG4gICAgY29uc3QgaWQgPSBub3JtYWxpemVDaGFpbklkKGNoYWluKTtcbiAgICBjb25zdCB1bnN1cHBvcnRlZCA9IHRoaXMuaXNDaGFpblVuc3VwcG9ydGVkKGlkKTtcbiAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50KCk7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIsIHtcbiAgICAgIGNoYWluOiB7XG4gICAgICAgIGlkLFxuICAgICAgICB1bnN1cHBvcnRlZFxuICAgICAgfSxcbiAgICAgIGFjY291bnRcbiAgICB9KTtcbiAgfVxuICBvbkRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdFwiKTtcbiAgfVxuICBhc3luYyBzZXR1cExpc3RlbmVycygpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICBwcm92aWRlci5vbihcImFjY291bnRzQ2hhbmdlZFwiLCBfY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX29uQWNjb3VudHNDaGFuZ2VkQmluZCkpO1xuICAgIHByb3ZpZGVyLm9uKFwiY2hhaW5DaGFuZ2VkXCIsIF9jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfb25DaGFpbkNoYW5nZWRCaW5kKSk7XG4gICAgcHJvdmlkZXIub24oXCJkaXNjb25uZWN0XCIsIF9jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfb25EaXNjb25uZWN0QmluZCkpO1xuICB9XG4gIGFzeW5jIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICBwcm92aWRlci5vZmYoXCJhY2NvdW50c0NoYW5nZWRcIiwgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9vbkFjY291bnRzQ2hhbmdlZEJpbmQpKTtcbiAgICBwcm92aWRlci5vZmYoXCJjaGFpbkNoYW5nZWRcIiwgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9vbkNoYWluQ2hhbmdlZEJpbmQpKTtcbiAgICBwcm92aWRlci5vZmYoXCJkaXNjb25uZWN0XCIsIF9jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfb25EaXNjb25uZWN0QmluZCkpO1xuICB9XG59XG5mdW5jdGlvbiBfaXNVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IyKGVycm9yKSB7XG4gIHJldHVybiAvKHVzZXIgcmVqZWN0ZWQpL2kudGVzdChlcnJvci5tZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIF9oYW5kbGVDb25uZWN0UmVzZXQyKCkge1xuICBfY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX3Byb3ZpZGVyLCB1bmRlZmluZWQpO1xufVxuXG5leHBvcnQgeyBCbG9jdG9Db25uZWN0b3IgfTtcbiJdLCJuYW1lcyI6WyJfIiwiX2NsYXNzUHJpdmF0ZU1ldGhvZEluaXRTcGVjIiwiYSIsIl9jbGFzc1ByaXZhdGVNZXRob2RHZXQiLCJfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyIsIl9jbGFzc1ByaXZhdGVGaWVsZFNldCIsImIiLCJfY2xhc3NQcml2YXRlRmllbGRHZXQiLCJfZGVmaW5lUHJvcGVydHkiLCJXIiwiV2FnbWlDb25uZWN0b3IiLCJVIiwiVXNlclJlamVjdGVkUmVxdWVzdEVycm9yIiwiQ29ubmVjdG9yTm90Rm91bmRFcnJvciIsIlMiLCJTd2l0Y2hDaGFpbkVycm9yIiwiQmxvY3RvU0RLIiwidXRpbHMiLCJwcm92aWRlcnMiLCJ3Iiwid2FsbGV0SWRzIiwiZyIsImdldFZhbGlkUHVibGljUlBDVXJsIiwibiIsIm5vcm1hbGl6ZUNoYWluSWQiLCJfcHJvdmlkZXIiLCJXZWFrTWFwIiwiX29uQWNjb3VudHNDaGFuZ2VkQmluZCIsIl9vbkNoYWluQ2hhbmdlZEJpbmQiLCJfb25EaXNjb25uZWN0QmluZCIsIl9pc1VzZXJSZWplY3RlZFJlcXVlc3RFcnJvciIsIldlYWtTZXQiLCJfaGFuZGxlQ29ubmVjdFJlc2V0IiwiQmxvY3RvQ29ubmVjdG9yIiwiY29ubmVjdCIsImNvbmZpZyIsInByb3ZpZGVyIiwiZ2V0UHJvdmlkZXIiLCJzZXR1cExpc3RlbmVycyIsImVtaXQiLCJ0eXBlIiwiYWNjb3VudHMiLCJyZXF1ZXN0IiwibWV0aG9kIiwiYWNjb3VudCIsImdldEFkZHJlc3MiLCJpZCIsImdldENoYWluSWQiLCJ1bnN1cHBvcnRlZCIsImlzQ2hhaW5VbnN1cHBvcnRlZCIsImNoYWluIiwiZXJyb3IiLCJfaGFuZGxlQ29ubmVjdFJlc2V0MiIsImNhbGwiLCJfaXNVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IyIiwiZGlzY29ubmVjdCIsInJlbW92ZUxpc3RlbmVycyIsImdldEFjY291bnQiLCJhZGRyZXNzIiwiRXJyb3IiLCJjaGFpbklkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiX2NoYWluSWQiLCJvcHRpb25zIiwiY2hhaW5zIiwiX3JwYyIsImZpbmQiLCJ4IiwicnBjIiwiZXRoZXJldW0iLCJhcHBJZCIsIlByb21pc2UiLCJyZXNvbHZlIiwiZ2V0U2lnbmVyIiwiYWxsIiwiV2ViM1Byb3ZpZGVyIiwiaXNBdXRob3JpemVkIiwiX2Jsb2N0byIsInNlc3Npb25LZXkiLCJzd2l0Y2hDaGFpbiIsImhleFZhbHVlIiwiaXNCbG9jdG9TdXBwb3J0Q2hhaW4iLCJzdXBwb3J0TmV0d29ya0xpc3QiLCJwYXJhbXMiLCJycGNVcmxzIiwib25BY2NvdW50c0NoYW5nZWQiLCJvbkNoYWluQ2hhbmdlZCIsIm9uRGlzY29ubmVjdCIsIm9uIiwib2ZmIiwiY29uc3RydWN0b3IiLCJfcmVmIiwiYmxvY3RvIiwid3JpdGFibGUiLCJ2YWx1ZSIsImJpbmQiLCJ0ZXN0IiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@thirdweb-dev+wallets@2.4.2_@ethersproject+abstract-provider@5.7.0_@ethersproject+abstract-si_q3uhj54vw2tqcdxon24cvgplba/node_modules/@thirdweb-dev/wallets/evm/connectors/blocto/dist/thirdweb-dev-wallets-evm-connectors-blocto.browser.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@blocto+sdk@0.5.5/node_modules/@blocto/sdk/dist/blocto-sdk.module.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@blocto+sdk@0.5.5/node_modules/@blocto/sdk/dist/blocto-sdk.module.js ***!
  \*************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ BloctoSDK; }\n/* harmony export */ });\n/* Version: 0.5.5 - August 14, 2023 10:23:52 */ /******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n// instead invariant from package, since all error will throw on production\nfunction invariant(condition, format) {\n    if (!condition) {\n        throw new Error(format);\n    }\n}\n// local storage version naming rule: [milestone].[patch]\nvar KEY_SESSION;\n(function(KEY_SESSION) {\n    KEY_SESSION[\"prod\"] = \"BLOCTO_SDK\";\n    KEY_SESSION[\"dev\"] = \"BLOCTO_SDK_DEV\";\n    KEY_SESSION[\"staging\"] = \"BLOCTO_SDK_STAGING\";\n})(KEY_SESSION || (KEY_SESSION = {}));\nvar CHAIN;\n(function(CHAIN) {\n    CHAIN[\"ETHEREUM\"] = \"ethereum\";\n    CHAIN[\"SOLANA\"] = \"solana\";\n    CHAIN[\"APTOS\"] = \"aptos\";\n})(CHAIN || (CHAIN = {}));\nclass MemoryStorage {\n    getItem(key) {\n        return this[key] || null;\n    }\n    setItem(key, value) {\n        this.storage[key] = value;\n    }\n    removeItem(key) {\n        delete this.storage[key];\n    }\n    constructor(){\n        this.storage = {};\n    }\n}\nconst memoryStorage =  true ? window.memoryStorage : 0;\nconst isSupported = ()=>{\n    if (false) {}\n    try {\n        window.sessionStorage.setItem(\"local_storage_supported\", \"1\");\n        const result = window.sessionStorage.getItem(\"local_storage_supported\");\n        window.sessionStorage.removeItem(\"local_storage_supported\");\n        return result === \"1\";\n    } catch (error) {\n        return false;\n    }\n};\nconst storage = isSupported() ? window.sessionStorage : memoryStorage;\nconst getItem = function(key) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    const value = storage.getItem(key);\n    try {\n        return value && JSON.parse(value) || defaultValue;\n    } catch (SyntaxError) {\n        return value || defaultValue;\n    }\n};\nconst setItem = (key, value)=>storage.setItem(key, typeof value === \"string\" ? value : JSON.stringify(value));\nconst removeItem = (key)=>{\n    setItem(key, \"\"); // Due to some versions of browser bug can't removeItem correctly.\n    storage.removeItem(key);\n};\n/**\n * @param {keys.KEY_SESSION} key - key to retrieve the data\n * @returns {ProviderSession | null} ProviderSession | null\n * @description\n * Get ProviderSession from storage.\n * If the data is expired, will remove the data and return null\n */ const getAccountStorage = (key)=>{\n    const rawAccountStorage = getItem(key, null);\n    if (!rawAccountStorage) return null;\n    // compare the expiry time of the item with the current time\n    if (new Date().getTime() > rawAccountStorage.expiry || rawAccountStorage.v !== SDK_VERSION) {\n        removeItem(key);\n        return null;\n    }\n    return rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data;\n};\n/**\n  @param {keys.KEY_SESSION} key - key to store the data\n  @param {ProviderSession} data - Only the part of ProviderSession that needs to be updated\n  {\n    connected?: boolean;\n    code?: string | null;\n    accounts: Record<string, string[] | undefined>;\n  }\n  @param {number} expiry - expiry time of the data\n*/ const setAccountStorage = (key, data, expiry)=>{\n    var _a, _b, _c;\n    const rawAccountStorage = getItem(key);\n    const newAccountStorage = {\n        data: {\n            code: (data === null || data === void 0 ? void 0 : data.code) || ((_a = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _a === void 0 ? void 0 : _a.code),\n            connected: !!((data === null || data === void 0 ? void 0 : data.code) || ((_b = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _b === void 0 ? void 0 : _b.code)),\n            accounts: Object.assign(Object.assign({}, (_c = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _c === void 0 ? void 0 : _c.accounts), data === null || data === void 0 ? void 0 : data.accounts)\n        },\n        expiry: expiry || (rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.expiry) || new Date().getTime() + LOGIN_PERSISTING_TIME,\n        v: SDK_VERSION\n    };\n    setItem(key, newAccountStorage);\n    return;\n};\nconst getChainAddress = (key, chain)=>{\n    var _a, _b;\n    if (!((_a = getAccountStorage(key)) === null || _a === void 0 ? void 0 : _a.code)) {\n        removeItem(key);\n        return null;\n    }\n    return ((_b = getAccountStorage(key)) === null || _b === void 0 ? void 0 : _b.accounts[chain]) || null;\n};\nconst setChainAddress = (key, chain, account)=>{\n    setAccountStorage(key, {\n        accounts: {\n            [chain]: account\n        }\n    });\n    return;\n};\nconst removeChainAddress = (key, chain)=>{\n    setAccountStorage(key, {\n        accounts: {\n            [chain]: undefined\n        }\n    });\n    return;\n};\n/* eth series constants begin */ const ETH_RPC_LIST = {\n    // This is the list of public RPC endpoints that we known to be working\n    // Used to help developers did not set up their own RPC endpoints\n    // BSC mainnet\n    56: \"https://bsc-dataseed1.binance.org\",\n    // BSC testnet\n    97: \"https://data-seed-prebsc-1-s1.binance.org:8545\",\n    // Polygon Mainnet\n    137: \"https://rpc-mainnet.maticvigil.com/\",\n    // Polygon Testnet\n    80001: \"https://rpc-mumbai.matic.today/\",\n    // Avalanche Mainnet\n    43114: \"https://api.avax.network/ext/bc/C/rpc\",\n    // Avalanche Fuji Testnet\n    43113: \"https://api.avax-test.network/ext/bc/C/rpc\",\n    // Arbitrum Mainnet\n    42161: \"https://arb1.arbitrum.io/rpc\",\n    // Arbitrum Testnet\n    421613: \"https://endpoints.omniatech.io/v1/arbitrum/goerli/public\",\n    // Optimism Mainnet\n    10: \"https://mainnet.optimism.io\",\n    // Optimism Goerli Testnet\n    420: \"https://goerli.optimism.io\"\n};\nconst ETH_ENV_WALLET_SERVER_MAPPING = {\n    prod: \"https://wallet-v2.blocto.app\",\n    staging: \"https://wallet-v2-staging.blocto.app\",\n    dev: \"https://wallet-v2-dev.blocto.app\"\n};\nconst ETH_SESSION_KEY_MAPPING = {\n    prod: KEY_SESSION.prod,\n    staging: KEY_SESSION.staging,\n    dev: KEY_SESSION.dev\n};\n/* eth series constants end */ /* sol constants begin */ const SOL_NET = {\n    MainnetBeta: \"mainnet-beta\",\n    Testnet: \"testnet\",\n    Devnet: \"devnet\"\n};\nconst SOL_NET_SERVER_MAPPING = {\n    [SOL_NET.MainnetBeta]: \"https://wallet-v2.blocto.app\",\n    [SOL_NET.Devnet]: \"https://wallet-v2-dev.blocto.app\",\n    [SOL_NET.Testnet]: \"https://wallet-v2-dev.blocto.app\"\n};\nconst SOL_SESSION_KEY_MAPPING = {\n    [SOL_NET.MainnetBeta]: KEY_SESSION.prod,\n    [SOL_NET.Devnet]: KEY_SESSION.dev,\n    [SOL_NET.Testnet]: KEY_SESSION.dev\n};\n/* sol constants end */ /* aptos constants begin */ const APT_SESSION_KEY_MAPPING = {\n    1: KEY_SESSION.prod,\n    2: KEY_SESSION.dev,\n    3: KEY_SESSION.dev,\n    4: KEY_SESSION.dev,\n    5: KEY_SESSION.staging\n};\nconst APT_CHAIN_ID_SERVER_MAPPING = {\n    // MAINNET\n    1: \"https://wallet-v2.blocto.app\",\n    // TESTNET\n    2: \"https://wallet-v2-dev.blocto.app\",\n    // DEVNET\n    3: \"https://wallet-v2-dev.blocto.app\",\n    // TESTING\n    4: \"https://wallet-v2-dev.blocto.app\",\n    // PREMAINNET\n    5: \"https://wallet-v2-staging.blocto.app\"\n};\nvar WalletAdapterNetwork;\n(function(WalletAdapterNetwork) {\n    WalletAdapterNetwork[\"Mainnet\"] = \"mainnet\";\n    WalletAdapterNetwork[\"Testnet\"] = \"testnet\";\n    WalletAdapterNetwork[\"Devnet\"] = \"devnet\";\n    WalletAdapterNetwork[\"Testing\"] = \"testing\";\n    WalletAdapterNetwork[\"Premainnet\"] = \"premainnet\";\n})(WalletAdapterNetwork || (WalletAdapterNetwork = {}));\nconst APT_CHAIN_ID_NAME_MAPPING = {\n    1: WalletAdapterNetwork.Mainnet,\n    2: WalletAdapterNetwork.Testnet,\n    3: WalletAdapterNetwork.Devnet,\n    4: WalletAdapterNetwork.Testing,\n    5: WalletAdapterNetwork.Premainnet\n};\nconst APT_CHAIN_ID_RPC_MAPPING = {\n    1: \"https://fullnode.mainnet.aptoslabs.com/v1\",\n    2: \"https://fullnode.testnet.aptoslabs.com/v1\",\n    3: \"https://fullnode.devnet.aptoslabs.com/v1\",\n    4: \"\",\n    5: \"https://premainnet.aptosdev.com/v1\"\n};\n/* aptos constants end */ const EIP1193_EVENTS = [\n    \"connect\",\n    \"disconnect\",\n    \"message\",\n    \"chainChanged\",\n    \"accountsChanged\"\n];\n// Preserve login for 1 day\nconst LOGIN_PERSISTING_TIME = 86400 * 1000;\nconst DEFAULT_APP_ID = \"00000000-0000-0000-0000-000000000000\";\n// Will inject the version of the SDK by rollup versionInjector during build time\nconst SDK_VERSION = \"0.5.5\";\n// The root class for all providers\nclass BloctoProvider {\n    // implement by children\n    // eslint-disable-next-line\n    request(payload) {\n        return __awaiter(this, void 0, void 0, function*() {});\n    }\n    on(event, listener) {\n        if (!EIP1193_EVENTS.includes(event)) return;\n        this.eventListeners[event].push(listener);\n    }\n    // @todo: implement it\n    // eslint-disable-next-line\n    once() {}\n    removeListener(event, listener) {\n        const listeners = this.eventListeners[event];\n        const index = listeners.findIndex((item)=>item === listener);\n        if (index !== -1) {\n            this.eventListeners[event].splice(index, 1);\n        }\n    }\n    constructor(){\n        this.isBlocto = true;\n        this.isConnecting = false;\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        this.eventListeners = {};\n        // alias removeListener\n        this.off = this.removeListener;\n        // init event listeners\n        EIP1193_EVENTS.forEach((event)=>{\n            this.eventListeners[event] = [];\n        });\n        this.appId = DEFAULT_APP_ID;\n    }\n}\nconst IFRAME_STYLE = \"width:100vw;height:100%;position:fixed;top:0;left:0;z-index:2147483646;border:none;box-sizing:border-box;color-scheme:light;inset:0px;display:block;pointer-events:auto;\";\nfunction createFrame(url) {\n    const frame = document.createElement(\"iframe\");\n    frame.setAttribute(\"src\", url);\n    frame.setAttribute(\"style\", IFRAME_STYLE);\n    return frame;\n}\nfunction attachFrame(frame) {\n    document.body.appendChild(frame);\n}\nfunction detatchFrame(frame) {\n    const parentNode = frame && frame.parentNode;\n    if (parentNode && parentNode.removeChild instanceof Function) {\n        parentNode.removeChild(frame);\n    }\n}\nvar addSelfRemovableHandler = function(eventType, handler) {\n    let target = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : window;\n    function listener(e) {\n        const removeEventListener = ()=>target.removeEventListener(eventType, listener);\n        handler(e, removeEventListener);\n    }\n    target.addEventListener(eventType, listener);\n};\nfunction responseSessionGuard(response, key, disconnectHandler) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (response.status === 403 || response.status === 401) {\n            if (disconnectHandler) {\n                disconnectHandler();\n            }\n            removeItem(key);\n        }\n        if (!response.ok) {\n            const data = yield response.json();\n            const e = new Error((data === null || data === void 0 ? void 0 : data.message) || \"unknown error\");\n            e.error_code = data === null || data === void 0 ? void 0 : data.error_code;\n            throw e;\n        }\n        return response.json();\n    });\n}\nconst isEmail = (value)=>/\\S+@\\S+\\.\\S+/.test(value);\nconst isValidTransaction = (transaction)=>typeof transaction === \"object\" && transaction !== null && \"from\" in transaction;\nconst isValidTransactions = (transactions)=>Array.isArray(transactions) && transactions.every((tx)=>isValidTransaction(tx));\nfunction getEvmSupport() {\n    return __awaiter(this, void 0, void 0, function*() {\n        const { networks } = yield fetch(\"https://api.blocto.app/networks/evm\").then((response)=>response.json());\n        const evmSupportMap = networks.reduce((a, v)=>Object.assign(Object.assign({}, a), {\n                [v.chain_id]: v\n            }), {});\n        return evmSupportMap;\n    });\n}\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar dist = {};\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nfunction _toPrimitive(input, hint) {\n    if (_typeof(input) !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (_typeof(res) !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _assertThisInitialized(self1) {\n    if (self1 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self1;\n}\nfunction _possibleConstructorReturn(self1, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self1);\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _isNativeReflectConstruct$1() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _construct(Parent, args, Class) {\n    if (_isNativeReflectConstruct$1()) {\n        _construct = Reflect.construct.bind();\n    } else {\n        _construct = function _construct(Parent, args, Class) {\n            var a = [\n                null\n            ];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _setPrototypeOf(instance, Class.prototype);\n            return instance;\n        };\n    }\n    return _construct.apply(null, arguments);\n}\nfunction _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n        if (Class === null || !_isNativeFunction(Class)) return Class;\n        if (typeof Class !== \"function\") {\n            throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        if (typeof _cache !== \"undefined\") {\n            if (_cache.has(Class)) return _cache.get(Class);\n            _cache.set(Class, Wrapper);\n        }\n        function Wrapper() {\n            return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n        }\n        Wrapper.prototype = Object.create(Class.prototype, {\n            constructor: {\n                value: Wrapper,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        return _setPrototypeOf(Wrapper, Class);\n    };\n    return _wrapNativeSuper(Class);\n}\nvar classes = {};\nvar fastSafeStringify = stringify;\nstringify[\"default\"] = stringify;\nstringify.stable = deterministicStringify;\nstringify.stableStringify = deterministicStringify;\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = \"[Circular]\";\nvar arr = [];\nvar replacerStack = [];\nfunction defaultOptions() {\n    return {\n        depthLimit: Number.MAX_SAFE_INTEGER,\n        edgesLimit: Number.MAX_SAFE_INTEGER\n    };\n}\n// Regular stringify\nfunction stringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    decirc(obj, \"\", 0, [], undefined, 0, options);\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(obj, replacer, spacer);\n        } else {\n            res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n        }\n    } catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally{\n        while(arr.length !== 0){\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            } else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n        if (propertyDescriptor.configurable) {\n            Object.defineProperty(parent, k, {\n                value: replace\n            });\n            arr.push([\n                parent,\n                k,\n                val,\n                propertyDescriptor\n            ]);\n        } else {\n            replacerStack.push([\n                val,\n                k,\n                replace\n            ]);\n        }\n    } else {\n        parent[k] = replace;\n        arr.push([\n            parent,\n            k,\n            val\n        ]);\n    }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (_typeof(val) === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                decirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            var keys = Object.keys(val);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                decirc(val[key], key, i, stack, val, depth, options);\n            }\n        }\n        stack.pop();\n    }\n}\n// Stable-stringify\nfunction compareFunction(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(tmp, replacer, spacer);\n        } else {\n            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n        }\n    } catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally{\n        // Ensure that we restore the object as it was.\n        while(arr.length !== 0){\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            } else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (_typeof(val) === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        try {\n            if (typeof val.toJSON === \"function\") {\n                return;\n            }\n        } catch (_) {\n            return;\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                deterministicDecirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            // Create a temporary object in the required way\n            var tmp = {};\n            var keys = Object.keys(val).sort(compareFunction);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                deterministicDecirc(val[key], key, i, stack, val, depth, options);\n                tmp[key] = val[key];\n            }\n            if (typeof parent !== \"undefined\") {\n                arr.push([\n                    parent,\n                    k,\n                    val\n                ]);\n                parent[k] = tmp;\n            } else {\n                return tmp;\n            }\n        }\n        stack.pop();\n    }\n}\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n    replacer = typeof replacer !== \"undefined\" ? replacer : function(k, v) {\n        return v;\n    };\n    return function(key, val) {\n        if (replacerStack.length > 0) {\n            for(var i = 0; i < replacerStack.length; i++){\n                var part = replacerStack[i];\n                if (part[1] === key && part[0] === val) {\n                    val = part[2];\n                    replacerStack.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return replacer.call(this, key, val);\n    };\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nObject.defineProperty(classes, \"__esModule\", {\n    value: true\n});\nclasses.EthereumProviderError = classes.EthereumRpcError = void 0;\nvar fast_safe_stringify_1 = fastSafeStringify;\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors\n * per EIP-1474.\n * Permits any integer error code.\n */ var EthereumRpcError = /*#__PURE__*/ function(_Error) {\n    _inherits(EthereumRpcError, _Error);\n    var _super = _createSuper(EthereumRpcError);\n    function EthereumRpcError(code, message, data) {\n        var _this;\n        _classCallCheck(this, EthereumRpcError);\n        if (!Number.isInteger(code)) {\n            throw new Error('\"code\" must be an integer.');\n        }\n        if (!message || typeof message !== \"string\") {\n            throw new Error('\"message\" must be a nonempty string.');\n        }\n        _this = _super.call(this, message);\n        _this.code = code;\n        if (data !== undefined) {\n            _this.data = data;\n        }\n        return _this;\n    }\n    /**\n   * Returns a plain object with all public class properties.\n   */ _createClass(EthereumRpcError, [\n        {\n            key: \"serialize\",\n            value: function serialize() {\n                var serialized = {\n                    code: this.code,\n                    message: this.message\n                };\n                if (this.data !== undefined) {\n                    serialized.data = this.data;\n                }\n                if (this.stack) {\n                    serialized.stack = this.stack;\n                }\n                return serialized;\n            }\n        },\n        {\n            key: \"toString\",\n            value: function toString() {\n                return fast_safe_stringify_1[\"default\"](this.serialize(), stringifyReplacer, 2);\n            }\n        }\n    ]);\n    return EthereumRpcError;\n}(/*#__PURE__*/ _wrapNativeSuper(Error));\nclasses.EthereumRpcError = EthereumRpcError;\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n * Permits integer error codes in the [ 1000 <= 4999 ] range.\n */ var EthereumProviderError = /*#__PURE__*/ function(_EthereumRpcError) {\n    _inherits(EthereumProviderError, _EthereumRpcError);\n    var _super2 = _createSuper(EthereumProviderError);\n    /**\n   * Create an Ethereum Provider JSON-RPC error.\n   * `code` must be an integer in the 1000 <= 4999 range.\n   */ function EthereumProviderError(code, message, data) {\n        _classCallCheck(this, EthereumProviderError);\n        if (!isValidEthProviderCode(code)) {\n            throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n        }\n        return _super2.call(this, code, message, data);\n    }\n    return _createClass(EthereumProviderError);\n}(EthereumRpcError);\nclasses.EthereumProviderError = EthereumProviderError;\n// Internal\nfunction isValidEthProviderCode(code) {\n    return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\nfunction stringifyReplacer(_, value) {\n    if (value === \"[Circular]\") {\n        return undefined;\n    }\n    return value;\n}\nvar utils = {};\nvar errorConstants = {};\nObject.defineProperty(errorConstants, \"__esModule\", {\n    value: true\n});\nerrorConstants.errorValues = errorConstants.errorCodes = void 0;\nerrorConstants.errorCodes = {\n    rpc: {\n        invalidInput: -32000,\n        resourceNotFound: -32001,\n        resourceUnavailable: -32002,\n        transactionRejected: -32003,\n        methodNotSupported: -32004,\n        limitExceeded: -32005,\n        parse: -32700,\n        invalidRequest: -32600,\n        methodNotFound: -32601,\n        invalidParams: -32602,\n        internal: -32603\n    },\n    provider: {\n        userRejectedRequest: 4001,\n        unauthorized: 4100,\n        unsupportedMethod: 4200,\n        disconnected: 4900,\n        chainDisconnected: 4901\n    }\n};\nerrorConstants.errorValues = {\n    \"-32700\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\"\n    },\n    \"-32600\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The JSON sent is not a valid Request object.\"\n    },\n    \"-32601\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The method does not exist / is not available.\"\n    },\n    \"-32602\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid method parameter(s).\"\n    },\n    \"-32603\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Internal JSON-RPC error.\"\n    },\n    \"-32000\": {\n        standard: \"EIP-1474\",\n        message: \"Invalid input.\"\n    },\n    \"-32001\": {\n        standard: \"EIP-1474\",\n        message: \"Resource not found.\"\n    },\n    \"-32002\": {\n        standard: \"EIP-1474\",\n        message: \"Resource unavailable.\"\n    },\n    \"-32003\": {\n        standard: \"EIP-1474\",\n        message: \"Transaction rejected.\"\n    },\n    \"-32004\": {\n        standard: \"EIP-1474\",\n        message: \"Method not supported.\"\n    },\n    \"-32005\": {\n        standard: \"EIP-1474\",\n        message: \"Request limit exceeded.\"\n    },\n    \"4001\": {\n        standard: \"EIP-1193\",\n        message: \"User rejected the request.\"\n    },\n    \"4100\": {\n        standard: \"EIP-1193\",\n        message: \"The requested account and/or method has not been authorized by the user.\"\n    },\n    \"4200\": {\n        standard: \"EIP-1193\",\n        message: \"The requested method is not supported by this Ethereum provider.\"\n    },\n    \"4900\": {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from all chains.\"\n    },\n    \"4901\": {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from the specified chain.\"\n    }\n};\n(function(exports) {\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;\n    var error_constants_1 = errorConstants;\n    var classes_1 = classes;\n    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;\n    var FALLBACK_MESSAGE = \"Unspecified error message. This is a bug, please report it.\";\n    var FALLBACK_ERROR = {\n        code: FALLBACK_ERROR_CODE,\n        message: getMessageFromCode(FALLBACK_ERROR_CODE)\n    };\n    exports.JSON_RPC_SERVER_ERROR_MESSAGE = \"Unspecified server error.\";\n    /**\n   * Gets the message for a given code, or a fallback message if the code has\n   * no corresponding message.\n   */ function getMessageFromCode(code) {\n        var fallbackMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FALLBACK_MESSAGE;\n        if (Number.isInteger(code)) {\n            var codeString = code.toString();\n            if (hasKey(error_constants_1.errorValues, codeString)) {\n                return error_constants_1.errorValues[codeString].message;\n            }\n            if (isJsonRpcServerError(code)) {\n                return exports.JSON_RPC_SERVER_ERROR_MESSAGE;\n            }\n        }\n        return fallbackMessage;\n    }\n    exports.getMessageFromCode = getMessageFromCode;\n    /**\n   * Returns whether the given code is valid.\n   * A code is only valid if it has a message.\n   */ function isValidCode(code) {\n        if (!Number.isInteger(code)) {\n            return false;\n        }\n        var codeString = code.toString();\n        if (error_constants_1.errorValues[codeString]) {\n            return true;\n        }\n        if (isJsonRpcServerError(code)) {\n            return true;\n        }\n        return false;\n    }\n    exports.isValidCode = isValidCode;\n    /**\n   * Serializes the given error to an Ethereum JSON RPC-compatible error object.\n   * Merely copies the given error's values if it is already compatible.\n   * If the given error is not fully compatible, it will be preserved on the\n   * returned object's data.originalError property.\n   */ function serializeError(error) {\n        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$fallbackError = _ref.fallbackError, fallbackError = _ref$fallbackError === void 0 ? FALLBACK_ERROR : _ref$fallbackError, _ref$shouldIncludeSta = _ref.shouldIncludeStack, shouldIncludeStack = _ref$shouldIncludeSta === void 0 ? false : _ref$shouldIncludeSta;\n        var _a, _b;\n        if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== \"string\") {\n            throw new Error(\"Must provide fallback error with integer number code and string message.\");\n        }\n        if (error instanceof classes_1.EthereumRpcError) {\n            return error.serialize();\n        }\n        var serialized = {};\n        if (error && _typeof(error) === \"object\" && !Array.isArray(error) && hasKey(error, \"code\") && isValidCode(error.code)) {\n            var _error = error;\n            serialized.code = _error.code;\n            if (_error.message && typeof _error.message === \"string\") {\n                serialized.message = _error.message;\n                if (hasKey(_error, \"data\")) {\n                    serialized.data = _error.data;\n                }\n            } else {\n                serialized.message = getMessageFromCode(serialized.code);\n                serialized.data = {\n                    originalError: assignOriginalError(error)\n                };\n            }\n        } else {\n            serialized.code = fallbackError.code;\n            var message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;\n            serialized.message = message && typeof message === \"string\" ? message : fallbackError.message;\n            serialized.data = {\n                originalError: assignOriginalError(error)\n            };\n        }\n        var stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;\n        if (shouldIncludeStack && error && stack && typeof stack === \"string\") {\n            serialized.stack = stack;\n        }\n        return serialized;\n    }\n    exports.serializeError = serializeError;\n    // Internal\n    function isJsonRpcServerError(code) {\n        return code >= -32099 && code <= -32000;\n    }\n    function assignOriginalError(error) {\n        if (error && _typeof(error) === \"object\" && !Array.isArray(error)) {\n            return Object.assign({}, error);\n        }\n        return error;\n    }\n    function hasKey(obj, key) {\n        return Object.prototype.hasOwnProperty.call(obj, key);\n    }\n})(utils);\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (null != _i) {\n        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;\n        try {\n            if (_x = (_i = _i.call(arr)).next, 0 === i) {\n                if (Object(_i) !== _i) return;\n                _n = !1;\n            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n        } catch (err) {\n            _d = !0, _e = err;\n        } finally{\n            try {\n                if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n            } finally{\n                if (_d) throw _e;\n            }\n        }\n        return _arr;\n    }\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nvar errors = {};\nObject.defineProperty(errors, \"__esModule\", {\n    value: true\n});\nerrors.ethErrors = void 0;\nvar classes_1 = classes;\nvar utils_1 = utils;\nvar error_constants_1 = errorConstants;\nerrors.ethErrors = {\n    rpc: {\n        /**\n     * Get a JSON RPC 2.0 Parse (-32700) error.\n     */ parse: function parse(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Invalid Request (-32600) error.\n     */ invalidRequest: function invalidRequest(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Invalid Params (-32602) error.\n     */ invalidParams: function invalidParams(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Method Not Found (-32601) error.\n     */ methodNotFound: function methodNotFound(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Internal (-32603) error.\n     */ internal: function internal(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Server error.\n     * Permits integer error codes in the [ -32099 <= -32005 ] range.\n     * Codes -32000 through -32004 are reserved by EIP-1474.\n     */ server: function server(opts) {\n            if (!opts || _typeof(opts) !== \"object\" || Array.isArray(opts)) {\n                throw new Error(\"Ethereum RPC Server errors must provide single object argument.\");\n            }\n            var code = opts.code;\n            if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n                throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\n            }\n            return getEthJsonRpcError(code, opts);\n        },\n        /**\n     * Get an Ethereum JSON RPC Invalid Input (-32000) error.\n     */ invalidInput: function invalidInput(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\n     */ resourceNotFound: function resourceNotFound(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\n     */ resourceUnavailable: function resourceUnavailable(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\n     */ transactionRejected: function transactionRejected(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\n     */ methodNotSupported: function methodNotSupported(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.\n     */ limitExceeded: function limitExceeded(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg);\n        }\n    },\n    provider: {\n        /**\n     * Get an Ethereum Provider User Rejected Request (4001) error.\n     */ userRejectedRequest: function userRejectedRequest(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);\n        },\n        /**\n     * Get an Ethereum Provider Unauthorized (4100) error.\n     */ unauthorized: function unauthorized(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);\n        },\n        /**\n     * Get an Ethereum Provider Unsupported Method (4200) error.\n     */ unsupportedMethod: function unsupportedMethod(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);\n        },\n        /**\n     * Get an Ethereum Provider Not Connected (4900) error.\n     */ disconnected: function disconnected(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);\n        },\n        /**\n     * Get an Ethereum Provider Chain Not Connected (4901) error.\n     */ chainDisconnected: function chainDisconnected(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);\n        },\n        /**\n     * Get a custom Ethereum Provider error.\n     */ custom: function custom(opts) {\n            if (!opts || _typeof(opts) !== \"object\" || Array.isArray(opts)) {\n                throw new Error(\"Ethereum Provider custom errors must provide single object argument.\");\n            }\n            var code = opts.code, message = opts.message, data = opts.data;\n            if (!message || typeof message !== \"string\") {\n                throw new Error('\"message\" must be a nonempty string');\n            }\n            return new classes_1.EthereumProviderError(code, message, data);\n        }\n    }\n};\n// Internal\nfunction getEthJsonRpcError(code, arg) {\n    var _parseOpts = parseOpts(arg), _parseOpts2 = _slicedToArray(_parseOpts, 2), message = _parseOpts2[0], data = _parseOpts2[1];\n    return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);\n}\nfunction getEthProviderError(code, arg) {\n    var _parseOpts3 = parseOpts(arg), _parseOpts4 = _slicedToArray(_parseOpts3, 2), message = _parseOpts4[0], data = _parseOpts4[1];\n    return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);\n}\nfunction parseOpts(arg) {\n    if (arg) {\n        if (typeof arg === \"string\") {\n            return [\n                arg\n            ];\n        } else if (_typeof(arg) === \"object\" && !Array.isArray(arg)) {\n            var message = arg.message, data = arg.data;\n            if (message && typeof message !== \"string\") {\n                throw new Error(\"Must specify string message.\");\n            }\n            return [\n                message || undefined,\n                data\n            ];\n        }\n    }\n    return [];\n}\n(function(exports) {\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;\n    var classes_1 = classes;\n    Object.defineProperty(exports, \"EthereumRpcError\", {\n        enumerable: true,\n        get: function get() {\n            return classes_1.EthereumRpcError;\n        }\n    });\n    Object.defineProperty(exports, \"EthereumProviderError\", {\n        enumerable: true,\n        get: function get() {\n            return classes_1.EthereumProviderError;\n        }\n    });\n    var utils_1 = utils;\n    Object.defineProperty(exports, \"serializeError\", {\n        enumerable: true,\n        get: function get() {\n            return utils_1.serializeError;\n        }\n    });\n    Object.defineProperty(exports, \"getMessageFromCode\", {\n        enumerable: true,\n        get: function get() {\n            return utils_1.getMessageFromCode;\n        }\n    });\n    var errors_1 = errors;\n    Object.defineProperty(exports, \"ethErrors\", {\n        enumerable: true,\n        get: function get() {\n            return errors_1.ethErrors;\n        }\n    });\n    var error_constants_1 = errorConstants;\n    Object.defineProperty(exports, \"errorCodes\", {\n        enumerable: true,\n        get: function get() {\n            return error_constants_1.errorCodes;\n        }\n    });\n})(dist);\nvar global$1 = typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self :  true ? window : 0;\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\nvar inited = false;\nfunction init() {\n    inited = true;\n    var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for(var i = 0, len = code.length; i < len; ++i){\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n    }\n    revLookup[\"-\".charCodeAt(0)] = 62;\n    revLookup[\"_\".charCodeAt(0)] = 63;\n}\nfunction toByteArray(b64) {\n    if (!inited) {\n        init();\n    }\n    var i, j, l, tmp, placeHolders, arr;\n    var len = b64.length;\n    if (len % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    }\n    // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n    placeHolders = b64[len - 2] === \"=\" ? 2 : b64[len - 1] === \"=\" ? 1 : 0;\n    // base64 is 4/3 + up to two characters of the original data\n    arr = new Arr(len * 3 / 4 - placeHolders);\n    // if there are placeholders, only get up to the last complete 4 chars\n    l = placeHolders > 0 ? len - 4 : len;\n    var L = 0;\n    for(i = 0, j = 0; i < l; i += 4, j += 3){\n        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n        arr[L++] = tmp >> 16 & 0xFF;\n        arr[L++] = tmp >> 8 & 0xFF;\n        arr[L++] = tmp & 0xFF;\n    }\n    if (placeHolders === 2) {\n        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[L++] = tmp & 0xFF;\n    } else if (placeHolders === 1) {\n        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[L++] = tmp >> 8 & 0xFF;\n        arr[L++] = tmp & 0xFF;\n    }\n    return arr;\n}\nfunction tripletToBase64(num) {\n    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\nfunction encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for(var i = start; i < end; i += 3){\n        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n        output.push(tripletToBase64(tmp));\n    }\n    return output.join(\"\");\n}\nfunction fromByteArray(uint8) {\n    if (!inited) {\n        init();\n    }\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n    var output = \"\";\n    var parts = [];\n    var maxChunkLength = 16383; // must be multiple of 3\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength){\n        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    }\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        output += lookup[tmp >> 2];\n        output += lookup[tmp << 4 & 0x3F];\n        output += \"==\";\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        output += lookup[tmp >> 10];\n        output += lookup[tmp >> 4 & 0x3F];\n        output += lookup[tmp << 2 & 0x3F];\n        output += \"=\";\n    }\n    parts.push(output);\n    return parts.join(\"\");\n}\nfunction read(buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? nBytes - 1 : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & (1 << -nBits) - 1;\n    s >>= -nBits;\n    nBits += eLen;\n    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8){}\n    m = e & (1 << -nBits) - 1;\n    e >>= -nBits;\n    nBits += mLen;\n    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8){}\n    if (e === 0) {\n        e = 1 - eBias;\n    } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity;\n    } else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n}\nfunction write(buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    var i = isLE ? 0 : nBytes - 1;\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n    value = Math.abs(value);\n    if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n    } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n        }\n        if (e + eBias >= 1) {\n            value += rt / c;\n        } else {\n            value += rt * Math.pow(2, 1 - eBias);\n        }\n        if (value * c >= 2) {\n            e++;\n            c /= 2;\n        }\n        if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n        } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n        } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n        }\n    }\n    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8){}\n    e = e << mLen | m;\n    eLen += mLen;\n    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8){}\n    buffer[offset + i - d] |= s * 128;\n}\nvar toString = {}.toString;\nvar isArray = Array.isArray || function(arr) {\n    return toString.call(arr) == \"[object Array]\";\n};\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */ var INSPECT_MAX_BYTES = 50;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */ Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;\n/*\n * Export kMaxLength after typed array support is determined.\n */ kMaxLength();\nfunction kMaxLength() {\n    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n}\nfunction createBuffer(that, length) {\n    if (kMaxLength() < length) {\n        throw new RangeError(\"Invalid typed array length\");\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = new Uint8Array(length);\n        that.__proto__ = Buffer.prototype;\n    } else {\n        // Fallback: Return an object instance of the Buffer class\n        if (that === null) {\n            that = new Buffer(length);\n        }\n        that.length = length;\n    }\n    return that;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */ function Buffer(arg, encodingOrOffset, length) {\n    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n        return new Buffer(arg, encodingOrOffset, length);\n    }\n    // Common case.\n    if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") {\n            throw new Error(\"If encoding is specified then the first argument must be a string\");\n        }\n        return allocUnsafe(this, arg);\n    }\n    return from(this, arg, encodingOrOffset, length);\n}\n_c = Buffer;\nBuffer.poolSize = 8192; // not used by this implementation\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function(arr) {\n    arr.__proto__ = Buffer.prototype;\n    return arr;\n};\nfunction from(that, value, encodingOrOffset, length) {\n    if (typeof value === \"number\") {\n        throw new TypeError('\"value\" argument must not be a number');\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, encodingOrOffset, length);\n    }\n    if (typeof value === \"string\") {\n        return fromString(that, value, encodingOrOffset);\n    }\n    return fromObject(that, value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/ Buffer.from = function(value, encodingOrOffset, length) {\n    return from(null, value, encodingOrOffset, length);\n};\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n    Buffer.prototype.__proto__ = Uint8Array.prototype;\n    Buffer.__proto__ = Uint8Array;\n    if (typeof Symbol !== \"undefined\" && Symbol.species && Buffer[Symbol.species] === Buffer) ;\n}\nfunction assertSize(size) {\n    if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be a number');\n    } else if (size < 0) {\n        throw new RangeError('\"size\" argument must not be negative');\n    }\n}\nfunction alloc(that, size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n        return createBuffer(that, size);\n    }\n    if (fill !== undefined) {\n        // Only pay attention to encoding if it's a string. This\n        // prevents accidentally sending in a number that would\n        // be interpretted as a start offset.\n        return typeof encoding === \"string\" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n    }\n    return createBuffer(that, size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/ Buffer.alloc = function(size, fill, encoding) {\n    return alloc(null, size, fill, encoding);\n};\nfunction allocUnsafe(that, size) {\n    assertSize(size);\n    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for(var i = 0; i < size; ++i){\n            that[i] = 0;\n        }\n    }\n    return that;\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */ Buffer.allocUnsafe = function(size) {\n    return allocUnsafe(null, size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */ Buffer.allocUnsafeSlow = function(size) {\n    return allocUnsafe(null, size);\n};\nfunction fromString(that, string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n    }\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError('\"encoding\" must be a valid string encoding');\n    }\n    var length = byteLength(string, encoding) | 0;\n    that = createBuffer(that, length);\n    var actual = that.write(string, encoding);\n    if (actual !== length) {\n        // Writing a hex string, for example, that contains invalid characters will\n        // cause everything after the first invalid character to be ignored. (e.g.\n        // 'abxxcd' will be treated as 'ab')\n        that = that.slice(0, actual);\n    }\n    return that;\n}\nfunction fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    that = createBuffer(that, length);\n    for(var i = 0; i < length; i += 1){\n        that[i] = array[i] & 255;\n    }\n    return that;\n}\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n    array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError(\"'offset' is out of bounds\");\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError(\"'length' is out of bounds\");\n    }\n    if (byteOffset === undefined && length === undefined) {\n        array = new Uint8Array(array);\n    } else if (length === undefined) {\n        array = new Uint8Array(array, byteOffset);\n    } else {\n        array = new Uint8Array(array, byteOffset, length);\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = array;\n        that.__proto__ = Buffer.prototype;\n    } else {\n        // Fallback: Return an object instance of the Buffer class\n        that = fromArrayLike(that, array);\n    }\n    return that;\n}\nfunction fromObject(that, obj) {\n    if (internalIsBuffer(obj)) {\n        var len = checked(obj.length) | 0;\n        that = createBuffer(that, len);\n        if (that.length === 0) {\n            return that;\n        }\n        obj.copy(that, 0, 0, len);\n        return that;\n    }\n    if (obj) {\n        if (typeof ArrayBuffer !== \"undefined\" && obj.buffer instanceof ArrayBuffer || \"length\" in obj) {\n            if (typeof obj.length !== \"number\" || isnan(obj.length)) {\n                return createBuffer(that, 0);\n            }\n            return fromArrayLike(that, obj);\n        }\n        if (obj.type === \"Buffer\" && isArray(obj.data)) {\n            return fromArrayLike(that, obj.data);\n        }\n    }\n    throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\");\n}\nfunction checked(length) {\n    // Note: cannot use `length < kMaxLength()` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= kMaxLength()) {\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum \" + \"size: 0x\" + kMaxLength().toString(16) + \" bytes\");\n    }\n    return length | 0;\n}\nBuffer.isBuffer = isBuffer;\nfunction internalIsBuffer(b) {\n    return !!(b != null && b._isBuffer);\n}\nBuffer.compare = function compare(a, b) {\n    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n        throw new TypeError(\"Arguments must be Buffers\");\n    }\n    if (a === b) return 0;\n    var x = a.length;\n    var y = b.length;\n    for(var i = 0, len = Math.min(x, y); i < len; ++i){\n        if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n        }\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\nBuffer.isEncoding = function isEncoding(encoding) {\n    switch(String(encoding).toLowerCase()){\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return true;\n        default:\n            return false;\n    }\n};\nBuffer.concat = function concat(list, length) {\n    if (!isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    if (list.length === 0) {\n        return Buffer.alloc(0);\n    }\n    var i;\n    if (length === undefined) {\n        length = 0;\n        for(i = 0; i < list.length; ++i){\n            length += list[i].length;\n        }\n    }\n    var buffer = Buffer.allocUnsafe(length);\n    var pos = 0;\n    for(i = 0; i < list.length; ++i){\n        var buf = list[i];\n        if (!internalIsBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\nfunction byteLength(string, encoding) {\n    if (internalIsBuffer(string)) {\n        return string.length;\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && typeof ArrayBuffer.isView === \"function\" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n        return string.byteLength;\n    }\n    if (typeof string !== \"string\") {\n        string = \"\" + string;\n    }\n    var len = string.length;\n    if (len === 0) return 0;\n    // Use a for loop to avoid recursion\n    var loweredCase = false;\n    for(;;){\n        switch(encoding){\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n                return len;\n            case \"utf8\":\n            case \"utf-8\":\n            case undefined:\n                return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return len * 2;\n            case \"hex\":\n                return len >>> 1;\n            case \"base64\":\n                return base64ToBytes(string).length;\n            default:\n                if (loweredCase) return utf8ToBytes(string).length // assume utf8\n                ;\n                encoding = (\"\" + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\nBuffer.byteLength = byteLength;\nfunction slowToString(encoding, start, end) {\n    var loweredCase = false;\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) {\n        start = 0;\n    }\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) {\n        return \"\";\n    }\n    if (end === undefined || end > this.length) {\n        end = this.length;\n    }\n    if (end <= 0) {\n        return \"\";\n    }\n    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) {\n        return \"\";\n    }\n    if (!encoding) encoding = \"utf8\";\n    while(true){\n        switch(encoding){\n            case \"hex\":\n                return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n                return utf8Slice(this, start, end);\n            case \"ascii\":\n                return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n                return latin1Slice(this, start, end);\n            case \"base64\":\n                return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return utf16leSlice(this, start, end);\n            default:\n                if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n                encoding = (encoding + \"\").toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\nfunction swap(b, n, m) {\n    var i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n}\nBuffer.prototype.swap16 = function swap16() {\n    var len = this.length;\n    if (len % 2 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    }\n    for(var i = 0; i < len; i += 2){\n        swap(this, i, i + 1);\n    }\n    return this;\n};\nBuffer.prototype.swap32 = function swap32() {\n    var len = this.length;\n    if (len % 4 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    }\n    for(var i = 0; i < len; i += 4){\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n    }\n    return this;\n};\nBuffer.prototype.swap64 = function swap64() {\n    var len = this.length;\n    if (len % 8 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    }\n    for(var i = 0; i < len; i += 8){\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n    }\n    return this;\n};\nBuffer.prototype.toString = function toString() {\n    var length = this.length | 0;\n    if (length === 0) return \"\";\n    if (arguments.length === 0) return utf8Slice(this, 0, length);\n    return slowToString.apply(this, arguments);\n};\nBuffer.prototype.equals = function equals(b) {\n    if (!internalIsBuffer(b)) throw new TypeError(\"Argument must be a Buffer\");\n    if (this === b) return true;\n    return Buffer.compare(this, b) === 0;\n};\nBuffer.prototype.inspect = function inspect() {\n    var str = \"\";\n    var max = INSPECT_MAX_BYTES;\n    if (this.length > 0) {\n        str = this.toString(\"hex\", 0, max).match(/.{2}/g).join(\" \");\n        if (this.length > max) str += \" ... \";\n    }\n    return \"<Buffer \" + str + \">\";\n};\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if (!internalIsBuffer(target)) {\n        throw new TypeError(\"Argument must be a Buffer\");\n    }\n    if (start === undefined) {\n        start = 0;\n    }\n    if (end === undefined) {\n        end = target ? target.length : 0;\n    }\n    if (thisStart === undefined) {\n        thisStart = 0;\n    }\n    if (thisEnd === undefined) {\n        thisEnd = this.length;\n    }\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError(\"out of range index\");\n    }\n    if (thisStart >= thisEnd && start >= end) {\n        return 0;\n    }\n    if (thisStart >= thisEnd) {\n        return -1;\n    }\n    if (start >= end) {\n        return 1;\n    }\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target) return 0;\n    var x = thisEnd - thisStart;\n    var y = end - start;\n    var len = Math.min(x, y);\n    var thisCopy = this.slice(thisStart, thisEnd);\n    var targetCopy = target.slice(start, end);\n    for(var i = 0; i < len; ++i){\n        if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n        }\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1;\n    // Normalize byteOffset\n    if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 0x7fffffff) {\n        byteOffset = 0x7fffffff;\n    } else if (byteOffset < -0x80000000) {\n        byteOffset = -0x80000000;\n    }\n    byteOffset = +byteOffset; // Coerce to Number.\n    if (isNaN(byteOffset)) {\n        // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n        byteOffset = dir ? 0 : buffer.length - 1;\n    }\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1;\n        else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;\n        else return -1;\n    }\n    // Normalize val\n    if (typeof val === \"string\") {\n        val = Buffer.from(val, encoding);\n    }\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if (internalIsBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) {\n            return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n        val = val & 0xFF; // Search for a byte value [0-255]\n        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n        }\n        return arrayIndexOf(buffer, [\n            val\n        ], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n}\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n                return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) {\n            return buf[i];\n        } else {\n            return buf.readUInt16BE(i * indexSize);\n        }\n    }\n    var i;\n    if (dir) {\n        var foundIndex = -1;\n        for(i = byteOffset; i < arrLength; i++){\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1) foundIndex = i;\n                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n            } else {\n                if (foundIndex !== -1) i -= i - foundIndex;\n                foundIndex = -1;\n            }\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for(i = byteOffset; i >= 0; i--){\n            var found = true;\n            for(var j = 0; j < valLength; j++){\n                if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n};\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\nfunction hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n    if (!length) {\n        length = remaining;\n    } else {\n        length = Number(length);\n        if (length > remaining) {\n            length = remaining;\n        }\n    }\n    // must be an even number of digits\n    var strLen = string.length;\n    if (strLen % 2 !== 0) throw new TypeError(\"Invalid hex string\");\n    if (length > strLen / 2) {\n        length = strLen / 2;\n    }\n    for(var i = 0; i < length; ++i){\n        var parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (isNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}\nfunction utf8Write(buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction asciiWrite(buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\nfunction latin1Write(buf, string, offset, length) {\n    return asciiWrite(buf, string, offset, length);\n}\nfunction base64Write(buf, string, offset, length) {\n    return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\nfunction ucs2Write(buf, string, offset, length) {\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n        offset = offset | 0;\n        if (isFinite(length)) {\n            length = length | 0;\n            if (encoding === undefined) encoding = \"utf8\";\n        } else {\n            encoding = length;\n            length = undefined;\n        }\n    // legacy write(string, encoding, offset, length) - remove in v0.13\n    } else {\n        throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    }\n    var remaining = this.length - offset;\n    if (length === undefined || length > remaining) length = remaining;\n    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n    }\n    if (!encoding) encoding = \"utf8\";\n    var loweredCase = false;\n    for(;;){\n        switch(encoding){\n            case \"hex\":\n                return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n                return utf8Write(this, string, offset, length);\n            case \"ascii\":\n                return asciiWrite(this, string, offset, length);\n            case \"latin1\":\n            case \"binary\":\n                return latin1Write(this, string, offset, length);\n            case \"base64\":\n                // Warning: maxLength not taken into account in base64Write\n                return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return ucs2Write(this, string, offset, length);\n            default:\n                if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n                encoding = (\"\" + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n};\nBuffer.prototype.toJSON = function toJSON() {\n    return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n};\nfunction base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) {\n        return fromByteArray(buf);\n    } else {\n        return fromByteArray(buf.slice(start, end));\n    }\n}\nfunction utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    var res = [];\n    var i = start;\n    while(i < end){\n        var firstByte = buf[i];\n        var codePoint = null;\n        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch(bytesPerSequence){\n                case 1:\n                    if (firstByte < 0x80) {\n                        codePoint = firstByte;\n                    }\n                    break;\n                case 2:\n                    secondByte = buf[i + 1];\n                    if ((secondByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                        if (tempCodePoint > 0x7F) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n            }\n        }\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n        } else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n}\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\nfunction decodeCodePointsArray(codePoints) {\n    var len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n        ;\n    }\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    var res = \"\";\n    var i = 0;\n    while(i < len){\n        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n    return res;\n}\nfunction asciiSlice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for(var i = start; i < end; ++i){\n        ret += String.fromCharCode(buf[i] & 0x7F);\n    }\n    return ret;\n}\nfunction latin1Slice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for(var i = start; i < end; ++i){\n        ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n}\nfunction hexSlice(buf, start, end) {\n    var len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    var out = \"\";\n    for(var i = start; i < end; ++i){\n        out += toHex(buf[i]);\n    }\n    return out;\n}\nfunction utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end);\n    var res = \"\";\n    for(var i = 0; i < bytes.length; i += 2){\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n}\nBuffer.prototype.slice = function slice(start, end) {\n    var len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n    } else if (start > len) {\n        start = len;\n    }\n    if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n    } else if (end > len) {\n        end = len;\n    }\n    if (end < start) end = start;\n    var newBuf;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        newBuf = this.subarray(start, end);\n        newBuf.__proto__ = Buffer.prototype;\n    } else {\n        var sliceLen = end - start;\n        newBuf = new Buffer(sliceLen, undefined);\n        for(var i = 0; i < sliceLen; ++i){\n            newBuf[i] = this[i + start];\n        }\n    }\n    return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */ function checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0) throw new RangeError(\"offset is not uint\");\n    if (offset + ext > length) throw new RangeError(\"Trying to access beyond buffer length\");\n}\nBuffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while(++i < byteLength && (mul *= 0x100)){\n        val += this[offset + i] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        checkOffset(offset, byteLength, this.length);\n    }\n    var val = this[offset + --byteLength];\n    var mul = 1;\n    while(byteLength > 0 && (mul *= 0x100)){\n        val += this[offset + --byteLength] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    return this[offset];\n};\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n};\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n};\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while(++i < byteLength && (mul *= 0x100)){\n        val += this[offset + i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var i = byteLength;\n    var mul = 1;\n    var val = this[offset + --i];\n    while(i > 0 && (mul *= 0x100)){\n        val += this[offset + --i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 0x80)) return this[offset];\n    return (0xff - this[offset] + 1) * -1;\n};\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    var val = this[offset] | this[offset + 1] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    var val = this[offset + 1] | this[offset] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return read(this, offset, true, 23, 4);\n};\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return read(this, offset, false, 23, 4);\n};\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return read(this, offset, true, 52, 8);\n};\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return read(this, offset, false, 52, 8);\n};\nfunction checkInt(buf, value, offset, ext, max, min) {\n    if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n}\nBuffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    var mul = 1;\n    var i = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        this[offset + i] = value / mul & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    var i = byteLength - 1;\n    var mul = 1;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        this[offset + i] = value / mul & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffff + value + 1;\n    for(var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i){\n        buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n    }\n}\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n    } else {\n        objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n    } else {\n        objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2;\n};\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffffffff + value + 1;\n    for(var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i){\n        buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n    }\n}\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    var i = 0;\n    var mul = 1;\n    var sub = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    var i = byteLength - 1;\n    var mul = 1;\n    var sub = 0;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n    if (value < 0) value = 0xff + value + 1;\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n    } else {\n        objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n    } else {\n        objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n    } else {\n        objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (value < 0) value = 0xffffffff + value + 1;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4;\n};\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n    if (offset < 0) throw new RangeError(\"Index out of range\");\n}\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4);\n    }\n    write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n}\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, false, noAssert);\n};\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8);\n    }\n    write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n}\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, false, noAssert);\n};\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!start) start = 0;\n    if (!end && end !== 0) end = this.length;\n    if (targetStart >= target.length) targetStart = target.length;\n    if (!targetStart) targetStart = 0;\n    if (end > 0 && end < start) end = start;\n    // Copy 0 bytes; we're done\n    if (end === start) return 0;\n    if (target.length === 0 || this.length === 0) return 0;\n    // Fatal error conditions\n    if (targetStart < 0) {\n        throw new RangeError(\"targetStart out of bounds\");\n    }\n    if (start < 0 || start >= this.length) throw new RangeError(\"sourceStart out of bounds\");\n    if (end < 0) throw new RangeError(\"sourceEnd out of bounds\");\n    // Are we oob?\n    if (end > this.length) end = this.length;\n    if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n    }\n    var len = end - start;\n    var i;\n    if (this === target && start < targetStart && targetStart < end) {\n        // descending copy from end\n        for(i = len - 1; i >= 0; --i){\n            target[i + targetStart] = this[i + start];\n        }\n    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n        // ascending copy from start\n        for(i = 0; i < len; ++i){\n            target[i + targetStart] = this[i + start];\n        }\n    } else {\n        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n    }\n    return len;\n};\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n        } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n        }\n        if (val.length === 1) {\n            var code = val.charCodeAt(0);\n            if (code < 256) {\n                val = code;\n            }\n        }\n        if (encoding !== undefined && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n        }\n        if (typeof encoding === \"string\" && !Buffer.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n    } else if (typeof val === \"number\") {\n        val = val & 255;\n    }\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError(\"Out of range index\");\n    }\n    if (end <= start) {\n        return this;\n    }\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val) val = 0;\n    var i;\n    if (typeof val === \"number\") {\n        for(i = start; i < end; ++i){\n            this[i] = val;\n        }\n    } else {\n        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n        var len = bytes.length;\n        for(i = 0; i < end - start; ++i){\n            this[i + start] = bytes[i % len];\n        }\n    }\n    return this;\n};\n// HELPER FUNCTIONS\n// ================\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\nfunction base64clean(str) {\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = stringtrim(str).replace(INVALID_BASE64_RE, \"\");\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2) return \"\";\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while(str.length % 4 !== 0){\n        str = str + \"=\";\n    }\n    return str;\n}\nfunction stringtrim(str) {\n    if (str.trim) return str.trim();\n    return str.replace(/^\\s+|\\s+$/g, \"\");\n}\nfunction toHex(n) {\n    if (n < 16) return \"0\" + n.toString(16);\n    return n.toString(16);\n}\nfunction utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for(var i = 0; i < length; ++i){\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        } else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else {\n            throw new Error(\"Invalid code point\");\n        }\n    }\n    return bytes;\n}\nfunction asciiToBytes(str) {\n    var byteArray = [];\n    for(var i = 0; i < str.length; ++i){\n        // Node's code seems to be doing this and not & 0x7F..\n        byteArray.push(str.charCodeAt(i) & 0xFF);\n    }\n    return byteArray;\n}\nfunction utf16leToBytes(str, units) {\n    var c, hi, lo;\n    var byteArray = [];\n    for(var i = 0; i < str.length; ++i){\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}\nfunction base64ToBytes(str) {\n    return toByteArray(base64clean(str));\n}\nfunction blitBuffer(src, dst, offset, length) {\n    for(var i = 0; i < length; ++i){\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\nfunction isnan(val) {\n    return val !== val // eslint-disable-line no-self-compare\n    ;\n}\n// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nfunction isBuffer(obj) {\n    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));\n}\nfunction isFastBuffer(obj) {\n    return !!obj.constructor && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n}\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer(obj) {\n    return typeof obj.readFloatLE === \"function\" && typeof obj.slice === \"function\" && isFastBuffer(obj.slice(0, 0));\n}\nconst isHexString = (hex)=>typeof hex === \"string\" && /^0x[0-9A-Fa-f]*$/.test(hex);\nconst utf8ToHex = (str)=>{\n    return Buffer.from(str, \"utf8\").toString(\"hex\");\n};\nvar _EthereumProvider_instances, _EthereumProvider_getBloctoProperties, _EthereumProvider_addToSwitchable, _EthereumProvider_checkNetworkMatched;\nfunction parseChainId(chainId) {\n    if (!chainId) {\n        return 1;\n    }\n    if (typeof chainId === \"number\") {\n        return chainId;\n    } else if (chainId.startsWith(\"0x\")) {\n        return parseInt(chainId, 16);\n    }\n    return parseInt(chainId, 10);\n}\nclass EthereumProvider extends BloctoProvider {\n    // DEPRECATED API: see https://docs.metamask.io/guide/ethereum-provider.html#ethereum-send-deprecated\n    send(methodOrPayload, paramsOrCallback) {\n        return __awaiter(this, void 0, void 0, function*() {\n            switch(true){\n                // signature type 1: arg1 - JSON-RPC payload, arg2 - callback;\n                // ethereum.send(payload: JsonRpcRequest, callback: JsonRpcCallback): void;\n                // This signature is exactly like ethereum.sendAsync()\n                case paramsOrCallback instanceof Function:\n                    return this.sendAsync(methodOrPayload, paramsOrCallback);\n                // signature type 2: arg1 - JSON-RPC method name, arg2 - params array;\n                // ethereum.send(method: string, params?: Array<unknown>): Promise<JsonRpcResponse>;\n                // This signature is like an async ethereum.sendAsync() with method and params as arguments,\n                // instead of a JSON-RPC payload and callback\n                case typeof methodOrPayload === \"string\" && Array.isArray(paramsOrCallback):\n                    return this.sendAsync({\n                        jsonrpc: \"2.0\",\n                        method: methodOrPayload,\n                        params: paramsOrCallback\n                    });\n                // signature type 3: arg1 - JSON-RPC payload(should be synchronous methods)\n                // ethereum.send(payload: JsonRpcRequest): unknown;\n                // This signature enables you to call some type of RPC methods synchronously\n                default:\n                    return this.sendAsync(methodOrPayload);\n            }\n        });\n    }\n    // DEPRECATED API: see https://docs.metamask.io/guide/ethereum-provider.html#legacy-methods implementation\n    // web3 v1.x BatchRequest still depends on it so we need to implement anyway ¯\\_(ツ)_/¯\n    sendAsync(payload, callback) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const handleRequest = new Promise((resolve)=>{\n                // web3 v1.x concat batched JSON-RPC requests to an array, handle it here\n                if (Array.isArray(payload)) {\n                    // collect transactions and send batch with custom method\n                    const transactions = payload.filter((request)=>request.method === \"eth_sendTransaction\").map((request)=>{\n                        var _a;\n                        return (_a = request.params) === null || _a === void 0 ? void 0 : _a[0];\n                    });\n                    const idBase = Math.floor(Math.random() * 10000);\n                    const batchedRequestPayload = {\n                        method: \"blocto_sendBatchTransaction\",\n                        params: transactions\n                    };\n                    const batchResponsePromise = this.request(batchedRequestPayload);\n                    const requests = payload.map((param, index)=>{\n                        let { method, params } = param;\n                        return method === \"eth_sendTransaction\" ? batchResponsePromise : this.request({\n                            id: idBase + index + 1,\n                            jsonrpc: \"2.0\",\n                            method,\n                            params\n                        });\n                    });\n                    // resolve response when all request are executed\n                    Promise.allSettled(requests).then((responses)=>resolve(responses.map((response, index)=>{\n                            return {\n                                id: String(idBase + index + 1),\n                                jsonrpc: \"2.0\",\n                                method: payload[index].method,\n                                result: response.status === \"fulfilled\" ? response.value : undefined,\n                                error: response.status !== \"fulfilled\" ? response.reason : undefined\n                            };\n                        }))).catch((error)=>{\n                        throw dist.ethErrors.rpc.internal(error === null || error === void 0 ? void 0 : error.message);\n                    });\n                } else {\n                    this.request(Object.assign(Object.assign({}, payload), {\n                        id: Number(payload.id)\n                    })).then(resolve);\n                }\n            });\n            // execute callback or return promise, depdends on callback arg given or not\n            if (callback) {\n                handleRequest.then((data)=>callback(null, data)).catch((error)=>callback(error));\n            } else {\n                return handleRequest;\n            }\n        });\n    }\n    /**\n     * Sending userOperation using Blocto SDK.\n     * @param {IUserOperation} userOp - userOperation object\n     * @remarks No need to include nonce, initCode, and signature as parameters when using BloctoSDK to send userOperation.\n     * These parameters will be ignored.\n     * @returns {Promise<string>} - userOperation hash\n     */ sendUserOperation(userOp) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.request({\n                method: \"eth_sendUserOperation\",\n                params: [\n                    userOp\n                ]\n            });\n        });\n    }\n    request(payload) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!(payload === null || payload === void 0 ? void 0 : payload.method)) throw dist.ethErrors.rpc.invalidRequest();\n            const existedSDK = window.ethereum;\n            if (existedSDK && existedSDK.isBlocto) {\n                if (payload.method === \"wallet_switchEthereumChain\") {\n                    if (!((_b = (_a = payload === null || payload === void 0 ? void 0 : payload.params) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams();\n                    }\n                    return existedSDK.request(payload).then(()=>{\n                        var _a, _b, _c;\n                        this.networkVersion = \"\".concat(parseChainId((_a = payload === null || payload === void 0 ? void 0 : payload.params) === null || _a === void 0 ? void 0 : _a[0].chainId));\n                        this.chainId = \"0x\".concat(parseChainId((_b = payload === null || payload === void 0 ? void 0 : payload.params) === null || _b === void 0 ? void 0 : _b[0].chainId).toString(16));\n                        this.rpc = (_c = switchableNetwork === null || switchableNetwork === void 0 ? void 0 : switchableNetwork[this.networkVersion]) === null || _c === void 0 ? void 0 : _c.rpc_url;\n                        return null;\n                    });\n                }\n                return existedSDK.request(payload);\n            }\n            const { blockchainName, switchableNetwork, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            // method that doesn't require user to be connected\n            switch(payload.method){\n                case \"eth_chainId\":\n                    {\n                        return this.chainId;\n                    }\n                case \"net_version\":\n                    {\n                        return this.networkVersion;\n                    }\n                case \"wallet_addEthereumChain\":\n                    {\n                        return this.loadSwitchableNetwork((payload === null || payload === void 0 ? void 0 : payload.params) || []);\n                    }\n                case \"eth_call\":\n                    {\n                        const response = yield this.handleReadRequests(payload);\n                        if (!response || response && !response.result && response.error) {\n                            const errorMessage = ((_c = response === null || response === void 0 ? void 0 : response.error) === null || _c === void 0 ? void 0 : _c.message) ? response.error.message : \"Request failed\";\n                            throw dist.ethErrors.rpc.internal(errorMessage);\n                        }\n                        return response.result;\n                    }\n                case \"wallet_switchEthereumChain\":\n                    {\n                        if (!((_e = (_d = payload === null || payload === void 0 ? void 0 : payload.params) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.chainId)) throw dist.ethErrors.rpc.invalidParams();\n                        const newChainId = payload.params[0].chainId;\n                        if (!getChainAddress(sessionKey, blockchainName)) {\n                            // directly switch network if user is not connected\n                            // TODO: add a confirm switch network dialog\n                            const phasedChainId = parseChainId(newChainId);\n                            if (!switchableNetwork[phasedChainId]) {\n                                throw dist.ethErrors.provider.custom({\n                                    code: 4902,\n                                    message: 'Unrecognized chain ID \"'.concat(newChainId, '\". Try adding the chain using wallet_addEthereumChain first.')\n                                });\n                            }\n                            this.networkVersion = \"\".concat(phasedChainId);\n                            this.chainId = \"0x\".concat(phasedChainId.toString(16));\n                            this.rpc = switchableNetwork[phasedChainId].rpc_url;\n                            this.eventListeners.chainChanged.forEach((listener)=>listener(this.chainId));\n                            return null;\n                        }\n                        break;\n                    }\n            }\n            // Method that requires user to be connected\n            if (!getChainAddress(sessionKey, blockchainName)) {\n                const email = (_f = payload === null || payload === void 0 ? void 0 : payload.params) === null || _f === void 0 ? void 0 : _f[0];\n                if (payload.method === \"eth_requestAccounts\" && isEmail(email)) {\n                    yield this.enable(email);\n                } else {\n                    yield this.enable();\n                }\n            }\n            try {\n                let response = null;\n                let result = null;\n                switch(payload.method){\n                    case \"eth_requestAccounts\":\n                        yield this.fetchAccounts();\n                    // eslint-disable-next-line\n                    case \"eth_accounts\":\n                        result = getChainAddress(sessionKey, blockchainName);\n                        break;\n                    case \"eth_coinbase\":\n                        {\n                            result = (_g = getChainAddress(sessionKey, blockchainName)) === null || _g === void 0 ? void 0 : _g[0];\n                            break;\n                        }\n                    case \"eth_signTypedData_v3\":\n                    case \"eth_signTypedData\":\n                    case \"eth_signTypedData_v4\":\n                    case \"personal_sign\":\n                    case \"eth_sign\":\n                        {\n                            result = yield this.handleSign(payload);\n                            break;\n                        }\n                    case \"wallet_disconnect\":\n                        {\n                            this.handleDisconnect();\n                            result = null;\n                            break;\n                        }\n                    case \"eth_sendTransaction\":\n                        result = yield this.handleSendTransaction(payload);\n                        break;\n                    case \"blocto_sendBatchTransaction\":\n                        result = yield this.handleSendBatchTransaction(payload);\n                        break;\n                    case \"eth_signTransaction\":\n                    case \"eth_sendRawTransaction\":\n                        {\n                            throw dist.ethErrors.rpc.methodNotSupported(\"Method Not Supported: \" + payload.method);\n                        }\n                    case \"eth_sendUserOperation\":\n                        result = yield this.handleSendUserOperation(payload);\n                        break;\n                    case \"wallet_switchEthereumChain\":\n                        {\n                            if (!((_j = (_h = payload === null || payload === void 0 ? void 0 : payload.params) === null || _h === void 0 ? void 0 : _h[0]) === null || _j === void 0 ? void 0 : _j.chainId)) {\n                                throw dist.ethErrors.rpc.invalidParams();\n                            }\n                            const oldAccount = (_k = getChainAddress(sessionKey, blockchainName)) === null || _k === void 0 ? void 0 : _k[0];\n                            const oldChainId = this.chainId;\n                            const newChainId = payload.params[0].chainId;\n                            if (!switchableNetwork[parseChainId(newChainId)]) {\n                                throw dist.ethErrors.provider.custom({\n                                    code: 4902,\n                                    message: 'Unrecognized chain ID \"'.concat(parseChainId(payload.params[0].chainId), '\". Try adding the chain using wallet_addEthereumChain first.')\n                                });\n                            }\n                            this.networkVersion = \"\".concat(parseChainId(newChainId));\n                            this.chainId = \"0x\".concat(parseChainId(newChainId).toString(16));\n                            this.rpc = switchableNetwork[this.networkVersion].rpc_url;\n                            yield this.enable().then((param)=>{\n                                let [newAccount] = param;\n                                var _a;\n                                if (newAccount !== oldAccount) {\n                                    (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.accountsChanged.forEach((listener)=>listener([\n                                            newAccount\n                                        ]));\n                                }\n                                this.eventListeners.chainChanged.forEach((listener)=>listener(this.chainId));\n                                result = null;\n                            }).catch((error)=>{\n                                this.networkVersion = \"\".concat(parseChainId(oldChainId));\n                                this.chainId = \"0x\".concat(parseChainId(oldChainId).toString(16));\n                                this.rpc = switchableNetwork[this.networkVersion].rpc_url;\n                                throw error;\n                            });\n                            break;\n                        }\n                    case \"eth_estimateUserOperationGas\":\n                    case \"eth_getUserOperationByHash\":\n                    case \"eth_getUserOperationReceipt\":\n                    case \"eth_supportedEntryPoints\":\n                        result = yield this.handleBundler(payload);\n                        break;\n                    default:\n                        response = yield this.handleReadRequests(payload);\n                }\n                if (response && !response.result && response.error) {\n                    const errorMessage = response.error.message ? response.error.message : \"Request failed\";\n                    throw dist.ethErrors.rpc.internal(errorMessage);\n                }\n                if (response) return response.result;\n                return result;\n            } catch (error) {\n                throw dist.ethErrors.rpc.internal(error === null || error === void 0 ? void 0 : error.message);\n            }\n        });\n    }\n    bloctoApi(url, options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const { walletServer, blockchainName, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const sessionId = ((_a = getAccountStorage(sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            if (!sessionId) {\n                throw dist.ethErrors.provider.unauthorized();\n            }\n            return fetch(\"\".concat(walletServer, \"/api/\").concat(blockchainName).concat(url), Object.assign({\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Session-Identifier\": sessionId\n                }\n            }, options)).then((response)=>responseSessionGuard(response, sessionKey, ()=>{\n                    var _a;\n                    (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.disconnect.forEach((listener)=>listener(dist.ethErrors.provider.disconnected()));\n                })).catch((e)=>{\n                if ((e === null || e === void 0 ? void 0 : e.error_code) === \"unsupported_method\") {\n                    throw dist.ethErrors.rpc.methodNotSupported(\"Method Not Supported: \" + e.message);\n                } else {\n                    throw dist.ethErrors.rpc.server({\n                        code: -32005,\n                        message: \"Blocto server error: \".concat(e.message)\n                    });\n                }\n            });\n        });\n    }\n    responseListener(frame, objectKey) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { walletServer } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            return new Promise((resolve, reject)=>addSelfRemovableHandler(\"message\", (event, removeEventListener)=>{\n                    const e = event;\n                    if (e.origin === walletServer && e.data.type === \"ETH:FRAME:RESPONSE\") {\n                        if (e.data.status === \"APPROVED\") {\n                            removeEventListener();\n                            detatchFrame(frame);\n                            resolve(e.data[objectKey]);\n                        }\n                        if (e.data.status === \"DECLINED\") {\n                            removeEventListener();\n                            detatchFrame(frame);\n                            if (e.data.errorCode === \"incorrect_session_id\") {\n                                this.handleDisconnect();\n                            }\n                            reject(dist.ethErrors.provider.userRejectedRequest(e.data.errorMessage));\n                        }\n                    }\n                    if (e.data.type === \"ETH:FRAME:CLOSE\") {\n                        removeEventListener();\n                        detatchFrame(frame);\n                        reject(dist.ethErrors.provider.userRejectedRequest(\"User declined the request\"));\n                    }\n                }));\n        });\n    }\n    setIframe(url) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (false) {}\n            const { walletServer, blockchainName } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const frame = createFrame(\"\".concat(walletServer, \"/\").concat(this.appId, \"/\").concat(blockchainName).concat(url));\n            attachFrame(frame);\n            return frame;\n        });\n    }\n    // eip-1102 alias\n    // DEPRECATED API: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1102.md\n    enable(email) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { walletServer, blockchainName, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const existedSDK = window.ethereum;\n            if (existedSDK && existedSDK.isBlocto) {\n                if (existedSDK.chainId !== this.chainId) {\n                    yield existedSDK.request({\n                        method: \"wallet_addEthereumChain\",\n                        params: [\n                            {\n                                chainId: this.chainId\n                            }\n                        ]\n                    });\n                    yield existedSDK.request({\n                        method: \"wallet_switchEthereumChain\",\n                        params: [\n                            {\n                                chainId: this.chainId\n                            }\n                        ]\n                    });\n                    setChainAddress(sessionKey, blockchainName, [\n                        existedSDK.address\n                    ]);\n                }\n                return new Promise((resolve, reject)=>// add a small delay to make sure the network has been switched\n                    setTimeout(()=>existedSDK.enable().then(resolve).catch(reject), 10));\n            }\n            const address = getChainAddress(sessionKey, blockchainName);\n            if (address) {\n                return new Promise((resolve)=>{\n                    resolve(address);\n                });\n            }\n            const params = new URLSearchParams();\n            params.set(\"l6n\", window.location.origin);\n            params.set(\"v\", SDK_VERSION);\n            const emailParam = email && isEmail(email) ? \"/\".concat(email) : \"\";\n            const loginFrame = yield this.setIframe(\"/authn\".concat(emailParam, \"?\").concat(params.toString()));\n            return new Promise((resolve, reject)=>{\n                addSelfRemovableHandler(\"message\", (event, removeListener)=>{\n                    var _a;\n                    const e = event;\n                    if (e.origin === walletServer) {\n                        if (e.data.type === \"ETH:FRAME:RESPONSE\") {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.connect.forEach((listener)=>listener({\n                                    chainId: this.chainId\n                                }));\n                            setAccountStorage(sessionKey, {\n                                code: e.data.code,\n                                connected: true,\n                                accounts: {\n                                    [blockchainName]: [\n                                        e.data.addr\n                                    ]\n                                }\n                            }, e.data.exp);\n                            resolve([\n                                e.data.addr\n                            ]);\n                        }\n                        if (e.data.type === \"ETH:FRAME:CLOSE\") {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            reject(dist.ethErrors.provider.userRejectedRequest());\n                        }\n                    }\n                });\n            });\n        });\n    }\n    fetchAccounts() {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { blockchainName, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const { accounts } = yield this.bloctoApi(\"/accounts\");\n            setChainAddress(sessionKey, blockchainName, accounts);\n            return accounts;\n        });\n    }\n    handleReadRequests(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            return fetch(this.rpc, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(Object.assign({\n                    id: 1,\n                    jsonrpc: \"2.0\"\n                }, payload))\n            }).then((response)=>response.json()).catch((e)=>{\n                throw dist.ethErrors.rpc.internal(e);\n            });\n        });\n    }\n    handleSign(param) {\n        let { method, params } = param;\n        return __awaiter(this, void 0, void 0, function*() {\n            let message = \"\";\n            if (Array.isArray(params)) {\n                if (method === \"eth_sign\") {\n                    message = isHexString(params[1]) ? params[1].slice(2) : utf8ToHex(params[1]);\n                } else if (method === \"personal_sign\") {\n                    message = isHexString(params[0]) ? params[0].slice(2) : utf8ToHex(params[0]);\n                } else if ([\n                    \"eth_signTypedData\",\n                    \"eth_signTypedData_v3\",\n                    \"eth_signTypedData_v4\"\n                ].includes(method)) {\n                    message = params[1];\n                    const { domain } = JSON.parse(message);\n                    if (isHexString(domain.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams('Provided chainId \"'.concat(domain.chainId, '\" must be a number'));\n                    }\n                    if (parseChainId(domain.chainId) !== parseChainId(this.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams('Provided chainId \"'.concat(domain.chainId, '\" must match the active chainId \"').concat(parseChainId(this.chainId), '\"'));\n                    }\n                }\n            }\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { signatureId } = yield this.bloctoApi(\"/user-signature\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    method,\n                    message\n                })\n            });\n            const signFrame = yield this.setIframe(\"/user-signature/\".concat(signatureId));\n            return this.responseListener(signFrame, \"signature\");\n        });\n    }\n    handleSendTransaction(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            if (!isValidTransaction((_a = payload.params) === null || _a === void 0 ? void 0 : _a[0])) {\n                throw dist.ethErrors.rpc.invalidParams();\n            }\n            const { authorizationId } = yield this.bloctoApi(\"/authz\", {\n                method: \"POST\",\n                body: JSON.stringify(payload.params)\n            });\n            const authzFrame = yield this.setIframe(\"/authz/\".concat(authorizationId));\n            return this.responseListener(authzFrame, \"txHash\");\n        });\n    }\n    handleSendBatchTransaction(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const extractParams = (params)=>params.map((param)=>\"params\" in param ? param.params[0] // handle passing web3.eth.sendTransaction.request(...) as a parameter with params\n                     : param);\n            const formatParams = extractParams(payload.params);\n            const copyPayload = Object.assign(Object.assign({}, payload), {\n                params: formatParams\n            });\n            if (!isValidTransactions(copyPayload.params)) {\n                throw dist.ethErrors.rpc.invalidParams();\n            }\n            return this.handleSendTransaction(copyPayload);\n        });\n    }\n    handleSendUserOperation(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { authorizationId } = yield this.bloctoApi(\"/user-operation\", {\n                method: \"POST\",\n                body: JSON.stringify(payload.params)\n            });\n            const userOPFrame = yield this.setIframe(\"/user-operation/\".concat(authorizationId));\n            return this.responseListener(userOPFrame, \"userOpHash\");\n        });\n    }\n    handleBundler(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            return this.bloctoApi(\"/rpc/bundler\", {\n                method: \"POST\",\n                body: JSON.stringify(Object.assign({\n                    id: 1,\n                    jsonrpc: \"2.0\"\n                }, payload))\n            });\n        });\n    }\n    handleDisconnect() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.ethereum;\n            if (existedSDK && existedSDK.isBlocto) {\n                return existedSDK.disconnect();\n            }\n            const { sessionKey, blockchainName } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            removeChainAddress(sessionKey, blockchainName);\n            (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.disconnect.forEach((listener)=>listener(dist.ethErrors.provider.disconnected()));\n        });\n    }\n    loadSwitchableNetwork(networkList) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // setup switchable list if user set networkList\n            if (networkList === null || networkList === void 0 ? void 0 : networkList.length) {\n                const listToAdd = networkList.map((param)=>{\n                    let { chainId, rpcUrls } = param;\n                    if (!chainId) throw dist.ethErrors.rpc.invalidParams(\"Empty chainId\");\n                    if (!(rpcUrls === null || rpcUrls === void 0 ? void 0 : rpcUrls.length)) throw dist.ethErrors.rpc.invalidParams(\"Empty rpcUrls\");\n                    return __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_addToSwitchable).call(this, {\n                        chainId: \"\".concat(parseChainId(chainId)),\n                        rpcUrls\n                    });\n                });\n                return Promise.all(listToAdd).then(()=>null);\n            } else {\n                throw dist.ethErrors.rpc.invalidParams(\"Empty networkList\");\n            }\n        });\n    }\n    constructor({ chainId, rpc, walletServer, appId }){\n        super();\n        _EthereumProvider_instances.add(this);\n        this.networkVersion = \"1\"; // same as chainId but in decimal\n        // setup chainId\n        invariant(chainId, \"'chainId' is required\");\n        this.networkVersion = \"\".concat(parseChainId(chainId));\n        this.chainId = \"0x\".concat(parseChainId(chainId).toString(16));\n        // setup rpc\n        this.rpc = rpc || ETH_RPC_LIST[this.networkVersion];\n        invariant(this.rpc, \"'rpc' is required\");\n        // setup injectedWalletServer\n        this.injectedWalletServer = walletServer;\n        // NOTE: _blocto is not fully initialized yet at this point\n        // Any function should call #getBloctoProperties() to get the full _blocto properties\n        this._blocto = {\n            sessionKey: KEY_SESSION.prod,\n            walletServer: this.injectedWalletServer || \"\",\n            blockchainName: \"\",\n            networkType: \"\",\n            supportNetworkList: {},\n            switchableNetwork: {}\n        };\n        this.appId = appId || DEFAULT_APP_ID;\n    }\n}\n_EthereumProvider_instances = new WeakSet(), _EthereumProvider_getBloctoProperties = function _EthereumProvider_getBloctoProperties() {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (!Object.keys(this._blocto.supportNetworkList).length) {\n            yield getEvmSupport().then((result)=>this._blocto.supportNetworkList = result).catch((e)=>{\n                throw dist.ethErrors.provider.custom({\n                    code: 1001,\n                    message: \"Get blocto server failed: \".concat(e.message)\n                });\n            });\n        }\n        const { chain_id, name, network_type, blocto_service_environment, display_name } = this._blocto.supportNetworkList[this.networkVersion];\n        if (!chain_id) throw dist.ethErrors.provider.unsupportedMethod(\"Get support chain failed: \".concat(this.networkVersion, \" might not be supported yet.\"));\n        this._blocto = Object.assign(Object.assign({}, this._blocto), {\n            sessionKey: ETH_SESSION_KEY_MAPPING[blocto_service_environment],\n            walletServer: this.injectedWalletServer || ETH_ENV_WALLET_SERVER_MAPPING[blocto_service_environment],\n            blockchainName: name,\n            networkType: network_type,\n            switchableNetwork: Object.assign(Object.assign({}, this._blocto.switchableNetwork), {\n                [chain_id]: {\n                    name,\n                    display_name,\n                    network_type,\n                    wallet_web_url: this._blocto.walletServer,\n                    rpc_url: this.rpc\n                }\n            })\n        });\n        return this._blocto;\n    });\n}, _EthereumProvider_addToSwitchable = function _EthereumProvider_addToSwitchable(param) {\n    let { chainId, rpcUrls } = param;\n    return __awaiter(this, void 0, void 0, function*() {\n        const { supportNetworkList } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n        const { chain_id, name, display_name, network_type, blocto_service_environment } = supportNetworkList[chainId];\n        const wallet_web_url = ETH_ENV_WALLET_SERVER_MAPPING[blocto_service_environment];\n        this._blocto.switchableNetwork[chain_id] = {\n            name,\n            display_name,\n            network_type,\n            wallet_web_url,\n            rpc_url: rpcUrls[0]\n        };\n    });\n}, _EthereumProvider_checkNetworkMatched = function _EthereumProvider_checkNetworkMatched() {\n    const existedSDK = window.ethereum;\n    if (existedSDK && existedSDK.isBlocto && parseChainId(existedSDK.chainId) !== parseChainId(this.chainId)) {\n        throw dist.ethErrors.provider.chainDisconnected();\n    }\n};\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base(ALPHABET) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError(\"Alphabet too long\");\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for(var j = 0; j < BASE_MAP.length; j++){\n        BASE_MAP[j] = 255;\n    }\n    for(var i = 0; i < ALPHABET.length; i++){\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + \" is ambiguous\");\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n    function encode(source) {\n        if (source instanceof Uint8Array) ;\n        else if (ArrayBuffer.isView(source)) {\n            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n        } else if (Array.isArray(source)) {\n            source = Uint8Array.from(source);\n        }\n        if (!(source instanceof Uint8Array)) {\n            throw new TypeError(\"Expected Uint8Array\");\n        }\n        if (source.length === 0) {\n            return \"\";\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while(pbegin !== pend && source[pbegin] === 0){\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while(pbegin !== pend){\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){\n                carry += 256 * b58[it1] >>> 0;\n                b58[it1] = carry % BASE >>> 0;\n                carry = carry / BASE >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while(it2 !== size && b58[it2] === 0){\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for(; it2 < size; ++it2){\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    function decodeUnsafe(source) {\n        if (typeof source !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        if (source.length === 0) {\n            return new Uint8Array();\n        }\n        var psz = 0;\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while(source[psz] === LEADER){\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while(source[psz]){\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){\n                carry += BASE * b256[it3] >>> 0;\n                b256[it3] = carry % 256 >>> 0;\n                carry = carry / 256 >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            psz++;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while(it4 !== size && b256[it4] === 0){\n            it4++;\n        }\n        var vch = new Uint8Array(zeroes + (size - it4));\n        var j = zeroes;\n        while(it4 !== size){\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(\"Non-base\" + BASE + \" character\");\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nvar src = base;\nconst basex = src;\nconst ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar bs58 = basex(ALPHABET);\nvar bs58$1 = /*@__PURE__*/ getDefaultExportFromCjs(bs58);\nlet Solana;\ntry {\n    Solana = require(\"@solana/web3.js\");\n} catch (_a) {\n// prevent crash if there is no @solana/web3.js.\n}\nclass SolanaProvider extends BloctoProvider {\n    request(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                return existedSDK.request(payload);\n            }\n            if (!getChainAddress(this.sessionKey, CHAIN.SOLANA)) {\n                yield this.connect();\n            }\n            try {\n                let response = null;\n                let result = null;\n                switch(payload.method){\n                    case \"connect\":\n                        result = yield this.fetchAccounts();\n                        break;\n                    case \"disconnect\":\n                        this.disconnect();\n                        break;\n                    case \"getAccounts\":\n                        result = ((_a = getChainAddress(this.sessionKey, CHAIN.SOLANA)) === null || _a === void 0 ? void 0 : _a.length) ? getChainAddress(this.sessionKey, CHAIN.SOLANA) : yield this.fetchAccounts();\n                        break;\n                    case \"getAccountInfo\":\n                        {\n                            // Format the data as the same format returning from Connection.getAccountInfo from @solana/web3.js\n                            // ref: https://solana-labs.github.io/solana-web3.js/classes/Connection.html#getAccountInfo\n                            const accountInfo = yield this.handleReadRequests(payload);\n                            const [bufferData, encoding] = accountInfo.result.value.data;\n                            result = Object.assign(Object.assign({}, accountInfo.result.value), {\n                                data: Buffer.from(bufferData, encoding),\n                                owner: new Solana.PublicKey(accountInfo.result.value.owner)\n                            });\n                            break;\n                        }\n                    // custom JSON-RPC method\n                    case \"convertToProgramWalletTransaction\":\n                        result = yield this.handleConvertTransaction(payload);\n                        break;\n                    // custom JSON-RPC method\n                    case \"signAndSendTransaction\":\n                        result = yield this.handleSignAndSendTransaction(payload);\n                        break;\n                    // block user from using traditional methods\n                    case \"signTransaction\":\n                    case \"signAllTransactions\":\n                        throw new Error(\"Blocto is program wallet, which doesn't support \".concat(payload.method, \". Use signAndSendTransaction instead.\"));\n                    default:\n                        response = yield this.handleReadRequests(payload);\n                }\n                if (response && !response.result && response.error) {\n                    const errorMessage = response.error.message ? response.error.message : \"Request failed\";\n                    throw new Error(errorMessage);\n                }\n                if (response) return response.result;\n                return result;\n            } catch (error) {\n                console.error(error);\n                throw error;\n            }\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                return new Promise((resolve)=>{\n                    existedSDK.on(\"connect\", ()=>{\n                        setChainAddress(this.sessionKey, CHAIN.SOLANA, [\n                            existedSDK.publicKey.toBase58()\n                        ]);\n                        resolve();\n                    });\n                    existedSDK.connect();\n                });\n            }\n            return new Promise((resolve, reject)=>{\n                if (false) {}\n                if (getChainAddress(this.sessionKey, CHAIN.SOLANA)) {\n                    return resolve();\n                }\n                const location = encodeURIComponent(window.location.origin);\n                const loginFrame = createFrame(\"\".concat(this.server, \"/\").concat(this.appId, \"/solana/authn?l6n=\").concat(location, \"&v=\").concat(SDK_VERSION));\n                attachFrame(loginFrame);\n                addSelfRemovableHandler(\"message\", (event, removeListener)=>{\n                    const e = event;\n                    if (e.origin === this.server) {\n                        if (e.data.type === \"SOL:FRAME:RESPONSE\") {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            this.eventListeners.connect.forEach((listener)=>listener(this.net));\n                            setAccountStorage(this.sessionKey, {\n                                code: e.data.code,\n                                connected: true,\n                                accounts: {\n                                    [CHAIN.SOLANA]: [\n                                        e.data.addr\n                                    ]\n                                }\n                            }, e.data.exp);\n                            resolve();\n                        }\n                        if (e.data.type === \"SOL:FRAME:CLOSE\") {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            reject(new Error(\"User declined the login request\"));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                yield existedSDK.disconnect();\n                return;\n            }\n            this.eventListeners.disconnect.forEach((listener)=>listener(null));\n            removeChainAddress(this.sessionKey, CHAIN.SOLANA);\n        });\n    }\n    fetchAccounts() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            const { accounts } = yield fetch(\"\".concat(this.server, \"/api/solana/accounts\"), {\n                headers: {\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                }\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            setChainAddress(this.sessionKey, CHAIN.SOLANA, accounts);\n            return accounts;\n        });\n    }\n    handleReadRequests(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return fetch(this.rpc, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(Object.assign({\n                    id: 1,\n                    jsonrpc: \"2.0\"\n                }, payload))\n            }).then((response)=>response.json());\n        });\n    }\n    // solana web3 utility\n    convertToProgramWalletTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                return existedSDK.convertToProgramWalletTransaction(transaction);\n            }\n            const message = yield this.request({\n                method: \"convertToProgramWalletTransaction\",\n                params: {\n                    message: transaction.serializeMessage().toString(\"hex\")\n                }\n            });\n            return this.toTransaction(message, []);\n        });\n    }\n    // solana web3 utility\n    signAndSendTransaction(transaction, connection) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                return existedSDK.signAndSendTransaction(transaction);\n            }\n            const extra = {};\n            if (connection) {\n                if (connection.commitment) extra.commitment = connection.commitment;\n                // if the connection object passed-in has different rpc endpoint, reconnect to it\n                // eslint-disable-next-line no-underscore-dangle\n                const rpc = connection ? connection._rpcEndpoint : null;\n                if (rpc && rpc !== this.rpc) {\n                    this.rpc = rpc;\n                    this.disconnect();\n                    yield this.connect();\n                }\n            }\n            return this.request({\n                method: \"signAndSendTransaction\",\n                params: Object.assign({\n                    signatures: yield this.collectSignatures(transaction),\n                    message: transaction.serializeMessage().toString(\"hex\")\n                }, extra)\n            });\n        });\n    }\n    // solana web3 utility\n    // eslint-disable-next-line class-methods-use-this\n    toTransaction(raw, signatures) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const message = Solana.Message.from(Buffer.from(raw, \"hex\"));\n            const transaction = new Solana.Transaction();\n            transaction.recentBlockhash = message.recentBlockhash;\n            if (message.header.numRequiredSignatures > 0) {\n                transaction.feePayer = message.accountKeys[0];\n            }\n            signatures.forEach((signature, index)=>{\n                const sigPubkeyPair = {\n                    signature: signature === Solana.PublicKey.default.toBase58() ? null : bs58$1.decode(signature),\n                    publicKey: message.accountKeys[index]\n                };\n                transaction.signatures.push(sigPubkeyPair);\n            });\n            message.instructions.forEach((instruction)=>{\n                const keys = instruction.accounts.map((account)=>{\n                    const pubkey = message.accountKeys[account];\n                    return {\n                        pubkey,\n                        isSigner: account < message.header.numRequiredSignatures,\n                        isWritable: message.isAccountWritable(account)\n                    };\n                });\n                transaction.instructions.push(new Solana.TransactionInstruction({\n                    keys,\n                    programId: message.accountKeys[instruction.programIdIndex],\n                    data: bs58$1.decode(instruction.data)\n                }));\n            });\n            return transaction;\n        });\n    }\n    // solana web3 utility\n    // eslint-disable-next-line class-methods-use-this\n    collectSignatures(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return transaction.signatures.reduce((acc, cur)=>{\n                if (cur.signature) {\n                    acc[cur.publicKey.toBase58()] = cur.signature.toString(\"hex\");\n                }\n                return acc;\n            }, {});\n        });\n    }\n    handleConvertTransaction(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            return fetch(\"\".concat(this.server, \"/api/solana/convertToWalletTx\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                },\n                body: JSON.stringify(payload.params)\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n        });\n    }\n    handleSignAndSendTransaction(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            const { authorizationId } = yield fetch(\"\".concat(this.server, \"/api/solana/authz\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                },\n                body: JSON.stringify(payload.params)\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            if (false) {}\n            const authzFrame = createFrame(\"\".concat(this.server, \"/\").concat(this.appId, \"/solana/authz/\").concat(authorizationId));\n            attachFrame(authzFrame);\n            return new Promise((resolve, reject)=>addSelfRemovableHandler(\"message\", (event, removeEventListener)=>{\n                    const e = event;\n                    if (e.origin === this.server && e.data.type === \"SOL:FRAME:RESPONSE\") {\n                        if (e.data.status === \"APPROVED\") {\n                            removeEventListener();\n                            detatchFrame(authzFrame);\n                            resolve(e.data.txHash);\n                        }\n                        if (e.data.status === \"DECLINED\") {\n                            removeEventListener();\n                            detatchFrame(authzFrame);\n                            if (e.data.errorCode === \"incorrect_session_id\") {\n                                this.disconnect();\n                            }\n                            reject(new Error(e.data.errorMessage));\n                        }\n                    }\n                }));\n        });\n    }\n    constructor({ net = \"mainnet-beta\", server, appId, rpc }){\n        super();\n        invariant(net, \"'net' is required\");\n        invariant(Object.values(SOL_NET).includes(net), \"unsupported net\");\n        this.net = net;\n        this.rpc = rpc || (net === \"mainnet-beta\" ? \"https://free.rpcpool.com\" : \"https://api.\".concat(net, \".solana.com\"));\n        this.server = server || SOL_NET_SERVER_MAPPING[this.net] || \"\";\n        this.appId = appId || DEFAULT_APP_ID;\n        this.sessionKey = SOL_SESSION_KEY_MAPPING[this.net];\n        if (!Solana) {\n            throw new Error(\"No @solana/web3.js installed. Please install it to interact with Solana.\");\n        }\n    }\n}\nconst checkMessagePayloadFormat = (payload)=>{\n    var _a, _b;\n    const formattedPayload = Object.assign({}, payload);\n    const { message, nonce, address, application, chainId } = payload;\n    if (typeof message !== \"string\") {\n        formattedPayload.message = (_a = String(message)) !== null && _a !== void 0 ? _a : \"\";\n    }\n    if (typeof nonce !== \"string\") {\n        formattedPayload.nonce = (_b = String(nonce)) !== null && _b !== void 0 ? _b : \"\";\n    }\n    if (address && typeof address !== \"boolean\") {\n        formattedPayload.address = !!address;\n    }\n    if (application && typeof application !== \"boolean\") {\n        formattedPayload.application = !!application;\n    }\n    if (chainId && typeof chainId !== \"boolean\") {\n        formattedPayload.chainId = !!chainId;\n    }\n    return formattedPayload;\n};\nclass AptosProvider extends BloctoProvider {\n    get publicAccount() {\n        var _a;\n        return {\n            address: ((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a[0]) || null,\n            publicKey: this.publicKey.length ? this.publicKey : null,\n            // @todo: provide authkey\n            authKey: null,\n            minKeysRequired: 2\n        };\n    }\n    network() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return {\n                name: this.networkName,\n                api: this.api,\n                chainId: this.chainId.toString()\n            };\n        });\n    }\n    isConnected() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return !!((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code);\n        });\n    }\n    signTransaction(transaction) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            if (existedSDK) {\n                return existedSDK.signTransaction(transaction);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error(\"Fail to get account\");\n            }\n            throw new Error(\"signTransaction method not supported.\");\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            if (existedSDK) {\n                yield existedSDK.disconnect();\n                return;\n            }\n            removeChainAddress(this.sessionKey, CHAIN.APTOS);\n        });\n    }\n    signAndSubmitTransaction(transaction) {\n        let txOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            if (existedSDK) {\n                return existedSDK.signAndSubmitTransaction(transaction, txOptions);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error(\"Fail to get account\");\n            }\n            const sessionId = ((_b = getAccountStorage(this.sessionKey)) === null || _b === void 0 ? void 0 : _b.code) || \"\";\n            const { authorizationId } = yield fetch(\"\".concat(this.server, \"/api/aptos/authz\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                },\n                body: JSON.stringify(Object.assign(Object.assign({}, transaction), txOptions))\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            if (false) {}\n            const authzFrame = createFrame(\"\".concat(this.server, \"/\").concat(this.appId, \"/aptos/authz/\").concat(authorizationId));\n            attachFrame(authzFrame);\n            return new Promise((resolve, reject)=>addSelfRemovableHandler(\"message\", (event, removeEventListener)=>{\n                    const e = event;\n                    if (e.origin === this.server && e.data.type === \"APTOS:FRAME:RESPONSE\") {\n                        if (e.data.status === \"APPROVED\") {\n                            removeEventListener();\n                            detatchFrame(authzFrame);\n                            resolve({\n                                hash: e.data.txHash\n                            });\n                        }\n                        if (e.data.status === \"DECLINED\") {\n                            removeEventListener();\n                            detatchFrame(authzFrame);\n                            if (e.data.errorCode === \"incorrect_session_id\") {\n                                this.disconnect();\n                            }\n                            reject(new Error(e.data.errorMessage));\n                        }\n                    }\n                }));\n        });\n    }\n    signMessage(payload) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            const formattedPayload = checkMessagePayloadFormat(payload);\n            if (existedSDK) {\n                return existedSDK.signMessage(formattedPayload);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error(\"Fail to get account\");\n            }\n            if (false) {}\n            const sessionId = ((_b = getAccountStorage(this.sessionKey)) === null || _b === void 0 ? void 0 : _b.code) || \"\";\n            const { signatureId } = yield fetch(\"\".concat(this.server, \"/api/aptos/user-signature\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                },\n                body: JSON.stringify(formattedPayload)\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            const url = \"\".concat(this.server, \"/\").concat(this.appId, \"/aptos/user-signature/\").concat(signatureId);\n            const signFrame = createFrame(url);\n            attachFrame(signFrame);\n            return new Promise((resolve, reject)=>addSelfRemovableHandler(\"message\", (event, removeEventListener)=>{\n                    const e = event;\n                    if (e.origin === this.server && e.data.type === \"APTOS:FRAME:RESPONSE\") {\n                        if (e.data.status === \"APPROVED\") {\n                            removeEventListener();\n                            detatchFrame(signFrame);\n                            resolve(e.data);\n                        }\n                        if (e.data.status === \"DECLINED\") {\n                            removeEventListener();\n                            detatchFrame(signFrame);\n                            if (e.data.errorCode === \"incorrect_session_id\") {\n                                this.disconnect();\n                            }\n                            reject(new Error(e.data.errorMessage));\n                        }\n                    }\n                }));\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            if (existedSDK) {\n                return new Promise((resolve, reject)=>// add a small delay to make sure the network has been switched\n                    setTimeout(()=>existedSDK.connect().then(resolve).catch(reject), 10));\n            }\n            return new Promise((resolve, reject)=>{\n                var _a, _b;\n                if (false) {}\n                if ((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length) {\n                    return resolve({\n                        address: ((_b = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _b === void 0 ? void 0 : _b[0]) || null,\n                        publicKey: this.publicKey,\n                        authKey: null,\n                        minKeysRequired: 2\n                    });\n                }\n                const location = encodeURIComponent(window.location.origin);\n                const loginFrame = createFrame(\"\".concat(this.server, \"/\").concat(this.appId, \"/aptos/authn?l6n=\").concat(location, \"&v=\").concat(SDK_VERSION, \"}\"));\n                attachFrame(loginFrame);\n                addSelfRemovableHandler(\"message\", (event, removeListener)=>__awaiter(this, void 0, void 0, function*() {\n                        var _c, _d, _e;\n                        const e = event;\n                        if (e.origin === this.server) {\n                            if (e.data.type === \"APTOS:FRAME:RESPONSE\") {\n                                removeListener();\n                                detatchFrame(loginFrame);\n                                setAccountStorage(this.sessionKey, {\n                                    code: e.data.code,\n                                    connected: true,\n                                    accounts: {\n                                        [CHAIN.APTOS]: [\n                                            e.data.addr\n                                        ]\n                                    }\n                                }, e.data.exp);\n                                if ((_c = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _c === void 0 ? void 0 : _c.length) {\n                                    try {\n                                        const { public_keys: publicKeys } = yield fetch(\"\".concat(this.server, \"/blocto/aptos/accounts/\").concat((_d = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _d === void 0 ? void 0 : _d[0])).then((response)=>response.json());\n                                        this.publicKey = publicKeys || [];\n                                        resolve({\n                                            address: ((_e = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _e === void 0 ? void 0 : _e[0]) || \"\",\n                                            publicKey: this.publicKey,\n                                            authKey: null,\n                                            minKeysRequired: 2\n                                        });\n                                    } catch (err) {\n                                        return reject(e);\n                                    }\n                                } else {\n                                    // @todo: better error\n                                    return reject();\n                                }\n                            }\n                            if (e.data.type === \"APTOS:FRAME:CLOSE\") {\n                                removeListener();\n                                detatchFrame(loginFrame);\n                                reject(new Error(\"User declined the login request\"));\n                            }\n                        }\n                    }));\n            });\n        });\n    }\n    fetchAddress() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            const { accounts } = yield fetch(\"\".concat(this.server, \"/api/aptos/accounts\"), {\n                headers: {\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                }\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            setChainAddress(this.sessionKey, CHAIN.APTOS, accounts);\n            return (accounts === null || accounts === void 0 ? void 0 : accounts[0]) || \"\";\n        });\n    }\n    constructor({ chainId, server, appId }){\n        super();\n        this.publicKey = [];\n        this.authKey = \"\";\n        invariant(chainId, \"'chainId' is required\");\n        invariant(appId, \"It is necessary to interact with Blocto wallet via your app id. Please visit https://developers.blocto.app for more details.\");\n        this.chainId = chainId;\n        this.networkName = APT_CHAIN_ID_NAME_MAPPING[chainId];\n        this.api = APT_CHAIN_ID_RPC_MAPPING[chainId];\n        this.sessionKey = APT_SESSION_KEY_MAPPING[chainId];\n        const defaultServer = APT_CHAIN_ID_SERVER_MAPPING[chainId];\n        this.appId = appId || DEFAULT_APP_ID;\n        this.server = server || defaultServer || \"\";\n    }\n}\nclass BloctoSDK {\n    constructor({ appId, ethereum, solana, aptos }){\n        if (ethereum) {\n            this.ethereum = new EthereumProvider(Object.assign(Object.assign({}, ethereum), {\n                appId\n            }));\n        }\n        if (solana) {\n            this.solana = new SolanaProvider(Object.assign(Object.assign({}, solana), {\n                appId\n            }));\n        }\n        if (aptos) {\n            this.aptos = new AptosProvider(Object.assign(Object.assign({}, aptos), {\n                appId\n            }));\n        }\n    }\n}\n\nvar _c;\n$RefreshReg$(_c, \"Buffer\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AYmxvY3RvK3Nka0AwLjUuNS9ub2RlX21vZHVsZXMvQGJsb2N0by9zZGsvZGlzdC9ibG9jdG8tc2RrLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsNkNBQTZDLEdBQzdDOzs7Ozs7Ozs7Ozs7OzhFQWE4RSxHQUM5RSxvREFBb0QsR0FHcEQsU0FBU0EsVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNoRCxTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBRUEsU0FBU08sdUJBQXVCQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxDQUFDO0lB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LE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBRytwQixTQUFTO2dCQUFFN21CO1lBQU07UUFDdEY7UUFDQSxJQUFJcXJCLE9BQU87WUFDUCxJQUFJLENBQUNBLEtBQUssR0FBRyxJQUFJckIsY0FBY250QixPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUd1dUIsUUFBUTtnQkFBRXJyQjtZQUFNO1FBQ25GO0lBQ0o7QUFDSjtBQUVnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQGJsb2N0bytzZGtAMC41LjUvbm9kZV9tb2R1bGVzL0BibG9jdG8vc2RrL2Rpc3QvYmxvY3RvLXNkay5tb2R1bGUuanM/M2UyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBWZXJzaW9uOiAwLjUuNSAtIEF1Z3VzdCAxNCwgMjAyMyAxMDoyMzo1MiAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG4vLyBpbnN0ZWFkIGludmFyaWFudCBmcm9tIHBhY2thZ2UsIHNpbmNlIGFsbCBlcnJvciB3aWxsIHRocm93IG9uIHByb2R1Y3Rpb25cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQpO1xuICAgIH1cbn1cblxuLy8gbG9jYWwgc3RvcmFnZSB2ZXJzaW9uIG5hbWluZyBydWxlOiBbbWlsZXN0b25lXS5bcGF0Y2hdXG52YXIgS0VZX1NFU1NJT047XG4oZnVuY3Rpb24gKEtFWV9TRVNTSU9OKSB7XG4gICAgS0VZX1NFU1NJT05bXCJwcm9kXCJdID0gXCJCTE9DVE9fU0RLXCI7XG4gICAgS0VZX1NFU1NJT05bXCJkZXZcIl0gPSBcIkJMT0NUT19TREtfREVWXCI7XG4gICAgS0VZX1NFU1NJT05bXCJzdGFnaW5nXCJdID0gXCJCTE9DVE9fU0RLX1NUQUdJTkdcIjtcbn0pKEtFWV9TRVNTSU9OIHx8IChLRVlfU0VTU0lPTiA9IHt9KSk7XG52YXIgQ0hBSU47XG4oZnVuY3Rpb24gKENIQUlOKSB7XG4gICAgQ0hBSU5bXCJFVEhFUkVVTVwiXSA9IFwiZXRoZXJldW1cIjtcbiAgICBDSEFJTltcIlNPTEFOQVwiXSA9IFwic29sYW5hXCI7XG4gICAgQ0hBSU5bXCJBUFRPU1wiXSA9IFwiYXB0b3NcIjtcbn0pKENIQUlOIHx8IChDSEFJTiA9IHt9KSk7XG5cbmNsYXNzIE1lbW9yeVN0b3JhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSB7fTtcbiAgICB9XG4gICAgZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba2V5XSB8fCBudWxsO1xuICAgIH1cbiAgICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmVtb3ZlSXRlbShrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RvcmFnZVtrZXldO1xuICAgIH1cbn1cbmNvbnN0IG1lbW9yeVN0b3JhZ2UgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5tZW1vcnlTdG9yYWdlIDogbmV3IE1lbW9yeVN0b3JhZ2UoKTtcblxuY29uc3QgaXNTdXBwb3J0ZWQgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ2xvY2FsX3N0b3JhZ2Vfc3VwcG9ydGVkJywgJzEnKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ2xvY2FsX3N0b3JhZ2Vfc3VwcG9ydGVkJyk7XG4gICAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKCdsb2NhbF9zdG9yYWdlX3N1cHBvcnRlZCcpO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSAnMSc7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmNvbnN0IHN0b3JhZ2UgPSBpc1N1cHBvcnRlZCgpID8gd2luZG93LnNlc3Npb25TdG9yYWdlIDogbWVtb3J5U3RvcmFnZTtcbmNvbnN0IGdldEl0ZW0gPSAoa2V5LCBkZWZhdWx0VmFsdWUgPSBudWxsKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBzdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIEpTT04ucGFyc2UodmFsdWUpKSB8fCBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGNhdGNoIChTeW50YXhFcnJvcikge1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgZGVmYXVsdFZhbHVlO1xuICAgIH1cbn07XG5jb25zdCBzZXRJdGVtID0gKGtleSwgdmFsdWUpID0+IHN0b3JhZ2Uuc2V0SXRlbShrZXksIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG5jb25zdCByZW1vdmVJdGVtID0gKGtleSkgPT4ge1xuICAgIHNldEl0ZW0oa2V5LCAnJyk7IC8vIER1ZSB0byBzb21lIHZlcnNpb25zIG9mIGJyb3dzZXIgYnVnIGNhbid0IHJlbW92ZUl0ZW0gY29ycmVjdGx5LlxuICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xufTtcbi8qKlxuICogQHBhcmFtIHtrZXlzLktFWV9TRVNTSU9OfSBrZXkgLSBrZXkgdG8gcmV0cmlldmUgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtQcm92aWRlclNlc3Npb24gfCBudWxsfSBQcm92aWRlclNlc3Npb24gfCBudWxsXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCBQcm92aWRlclNlc3Npb24gZnJvbSBzdG9yYWdlLlxuICogSWYgdGhlIGRhdGEgaXMgZXhwaXJlZCwgd2lsbCByZW1vdmUgdGhlIGRhdGEgYW5kIHJldHVybiBudWxsXG4gKi9cbmNvbnN0IGdldEFjY291bnRTdG9yYWdlID0gKGtleSkgPT4ge1xuICAgIGNvbnN0IHJhd0FjY291bnRTdG9yYWdlID0gZ2V0SXRlbShrZXksIG51bGwpO1xuICAgIGlmICghcmF3QWNjb3VudFN0b3JhZ2UpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIGNvbXBhcmUgdGhlIGV4cGlyeSB0aW1lIG9mIHRoZSBpdGVtIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSA+IHJhd0FjY291bnRTdG9yYWdlLmV4cGlyeSB8fFxuICAgICAgICByYXdBY2NvdW50U3RvcmFnZS52ICE9PSBTREtfVkVSU0lPTikge1xuICAgICAgICByZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmF3QWNjb3VudFN0b3JhZ2UgPT09IG51bGwgfHwgcmF3QWNjb3VudFN0b3JhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd0FjY291bnRTdG9yYWdlLmRhdGE7XG59O1xuLyoqXG4gIEBwYXJhbSB7a2V5cy5LRVlfU0VTU0lPTn0ga2V5IC0ga2V5IHRvIHN0b3JlIHRoZSBkYXRhXG4gIEBwYXJhbSB7UHJvdmlkZXJTZXNzaW9ufSBkYXRhIC0gT25seSB0aGUgcGFydCBvZiBQcm92aWRlclNlc3Npb24gdGhhdCBuZWVkcyB0byBiZSB1cGRhdGVkXG4gIHtcbiAgICBjb25uZWN0ZWQ/OiBib29sZWFuO1xuICAgIGNvZGU/OiBzdHJpbmcgfCBudWxsO1xuICAgIGFjY291bnRzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXSB8IHVuZGVmaW5lZD47XG4gIH1cbiAgQHBhcmFtIHtudW1iZXJ9IGV4cGlyeSAtIGV4cGlyeSB0aW1lIG9mIHRoZSBkYXRhXG4qL1xuY29uc3Qgc2V0QWNjb3VudFN0b3JhZ2UgPSAoa2V5LCBkYXRhLCBleHBpcnkpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCByYXdBY2NvdW50U3RvcmFnZSA9IGdldEl0ZW0oa2V5KTtcbiAgICBjb25zdCBuZXdBY2NvdW50U3RvcmFnZSA9IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgY29kZTogKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5jb2RlKSB8fCAoKF9hID0gcmF3QWNjb3VudFN0b3JhZ2UgPT09IG51bGwgfHwgcmF3QWNjb3VudFN0b3JhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd0FjY291bnRTdG9yYWdlLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSxcbiAgICAgICAgICAgIGNvbm5lY3RlZDogISEoKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5jb2RlKSB8fCAoKF9iID0gcmF3QWNjb3VudFN0b3JhZ2UgPT09IG51bGwgfHwgcmF3QWNjb3VudFN0b3JhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd0FjY291bnRTdG9yYWdlLmRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb2RlKSksXG4gICAgICAgICAgICBhY2NvdW50czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoX2MgPSByYXdBY2NvdW50U3RvcmFnZSA9PT0gbnVsbCB8fCByYXdBY2NvdW50U3RvcmFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmF3QWNjb3VudFN0b3JhZ2UuZGF0YSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFjY291bnRzKSwgZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmFjY291bnRzKSxcbiAgICAgICAgfSxcbiAgICAgICAgZXhwaXJ5OiBleHBpcnkgfHxcbiAgICAgICAgICAgIChyYXdBY2NvdW50U3RvcmFnZSA9PT0gbnVsbCB8fCByYXdBY2NvdW50U3RvcmFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmF3QWNjb3VudFN0b3JhZ2UuZXhwaXJ5KSB8fFxuICAgICAgICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBMT0dJTl9QRVJTSVNUSU5HX1RJTUUsXG4gICAgICAgIHY6IFNES19WRVJTSU9OLFxuICAgIH07XG4gICAgc2V0SXRlbShrZXksIG5ld0FjY291bnRTdG9yYWdlKTtcbiAgICByZXR1cm47XG59O1xuY29uc3QgZ2V0Q2hhaW5BZGRyZXNzID0gKGtleSwgY2hhaW4pID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghKChfYSA9IGdldEFjY291bnRTdG9yYWdlKGtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSkge1xuICAgICAgICByZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKChfYiA9IGdldEFjY291bnRTdG9yYWdlKGtleSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hY2NvdW50c1tjaGFpbl0pIHx8IG51bGw7XG59O1xuY29uc3Qgc2V0Q2hhaW5BZGRyZXNzID0gKGtleSwgY2hhaW4sIGFjY291bnQpID0+IHtcbiAgICBzZXRBY2NvdW50U3RvcmFnZShrZXksIHsgYWNjb3VudHM6IHsgW2NoYWluXTogYWNjb3VudCB9IH0pO1xuICAgIHJldHVybjtcbn07XG5jb25zdCByZW1vdmVDaGFpbkFkZHJlc3MgPSAoa2V5LCBjaGFpbikgPT4ge1xuICAgIHNldEFjY291bnRTdG9yYWdlKGtleSwgeyBhY2NvdW50czogeyBbY2hhaW5dOiB1bmRlZmluZWQgfSB9KTtcbiAgICByZXR1cm47XG59O1xuXG4vKiBldGggc2VyaWVzIGNvbnN0YW50cyBiZWdpbiAqL1xuY29uc3QgRVRIX1JQQ19MSVNUID0ge1xuICAgIC8vIFRoaXMgaXMgdGhlIGxpc3Qgb2YgcHVibGljIFJQQyBlbmRwb2ludHMgdGhhdCB3ZSBrbm93biB0byBiZSB3b3JraW5nXG4gICAgLy8gVXNlZCB0byBoZWxwIGRldmVsb3BlcnMgZGlkIG5vdCBzZXQgdXAgdGhlaXIgb3duIFJQQyBlbmRwb2ludHNcbiAgICAvLyBCU0MgbWFpbm5ldFxuICAgIDU2OiAnaHR0cHM6Ly9ic2MtZGF0YXNlZWQxLmJpbmFuY2Uub3JnJyxcbiAgICAvLyBCU0MgdGVzdG5ldFxuICAgIDk3OiAnaHR0cHM6Ly9kYXRhLXNlZWQtcHJlYnNjLTEtczEuYmluYW5jZS5vcmc6ODU0NScsXG4gICAgLy8gUG9seWdvbiBNYWlubmV0XG4gICAgMTM3OiAnaHR0cHM6Ly9ycGMtbWFpbm5ldC5tYXRpY3ZpZ2lsLmNvbS8nLFxuICAgIC8vIFBvbHlnb24gVGVzdG5ldFxuICAgIDgwMDAxOiAnaHR0cHM6Ly9ycGMtbXVtYmFpLm1hdGljLnRvZGF5LycsXG4gICAgLy8gQXZhbGFuY2hlIE1haW5uZXRcbiAgICA0MzExNDogJ2h0dHBzOi8vYXBpLmF2YXgubmV0d29yay9leHQvYmMvQy9ycGMnLFxuICAgIC8vIEF2YWxhbmNoZSBGdWppIFRlc3RuZXRcbiAgICA0MzExMzogJ2h0dHBzOi8vYXBpLmF2YXgtdGVzdC5uZXR3b3JrL2V4dC9iYy9DL3JwYycsXG4gICAgLy8gQXJiaXRydW0gTWFpbm5ldFxuICAgIDQyMTYxOiAnaHR0cHM6Ly9hcmIxLmFyYml0cnVtLmlvL3JwYycsXG4gICAgLy8gQXJiaXRydW0gVGVzdG5ldFxuICAgIDQyMTYxMzogJ2h0dHBzOi8vZW5kcG9pbnRzLm9tbmlhdGVjaC5pby92MS9hcmJpdHJ1bS9nb2VybGkvcHVibGljJyxcbiAgICAvLyBPcHRpbWlzbSBNYWlubmV0XG4gICAgMTA6ICdodHRwczovL21haW5uZXQub3B0aW1pc20uaW8nLFxuICAgIC8vIE9wdGltaXNtIEdvZXJsaSBUZXN0bmV0XG4gICAgNDIwOiAnaHR0cHM6Ly9nb2VybGkub3B0aW1pc20uaW8nLFxufTtcbmNvbnN0IEVUSF9FTlZfV0FMTEVUX1NFUlZFUl9NQVBQSU5HID0ge1xuICAgIHByb2Q6ICdodHRwczovL3dhbGxldC12Mi5ibG9jdG8uYXBwJyxcbiAgICBzdGFnaW5nOiAnaHR0cHM6Ly93YWxsZXQtdjItc3RhZ2luZy5ibG9jdG8uYXBwJyxcbiAgICBkZXY6ICdodHRwczovL3dhbGxldC12Mi1kZXYuYmxvY3RvLmFwcCcsXG59O1xuY29uc3QgRVRIX1NFU1NJT05fS0VZX01BUFBJTkcgPSB7XG4gICAgcHJvZDogS0VZX1NFU1NJT04ucHJvZCxcbiAgICBzdGFnaW5nOiBLRVlfU0VTU0lPTi5zdGFnaW5nLFxuICAgIGRldjogS0VZX1NFU1NJT04uZGV2LFxufTtcbi8qIGV0aCBzZXJpZXMgY29uc3RhbnRzIGVuZCAqL1xuLyogc29sIGNvbnN0YW50cyBiZWdpbiAqL1xuY29uc3QgU09MX05FVCA9IHtcbiAgICBNYWlubmV0QmV0YTogJ21haW5uZXQtYmV0YScsXG4gICAgVGVzdG5ldDogJ3Rlc3RuZXQnLFxuICAgIERldm5ldDogJ2Rldm5ldCcsXG59O1xuY29uc3QgU09MX05FVF9TRVJWRVJfTUFQUElORyA9IHtcbiAgICBbU09MX05FVC5NYWlubmV0QmV0YV06ICdodHRwczovL3dhbGxldC12Mi5ibG9jdG8uYXBwJyxcbiAgICBbU09MX05FVC5EZXZuZXRdOiAnaHR0cHM6Ly93YWxsZXQtdjItZGV2LmJsb2N0by5hcHAnLFxuICAgIFtTT0xfTkVULlRlc3RuZXRdOiAnaHR0cHM6Ly93YWxsZXQtdjItZGV2LmJsb2N0by5hcHAnLFxufTtcbmNvbnN0IFNPTF9TRVNTSU9OX0tFWV9NQVBQSU5HID0ge1xuICAgIFtTT0xfTkVULk1haW5uZXRCZXRhXTogS0VZX1NFU1NJT04ucHJvZCxcbiAgICBbU09MX05FVC5EZXZuZXRdOiBLRVlfU0VTU0lPTi5kZXYsXG4gICAgW1NPTF9ORVQuVGVzdG5ldF06IEtFWV9TRVNTSU9OLmRldixcbn07XG4vKiBzb2wgY29uc3RhbnRzIGVuZCAqL1xuLyogYXB0b3MgY29uc3RhbnRzIGJlZ2luICovXG5jb25zdCBBUFRfU0VTU0lPTl9LRVlfTUFQUElORyA9IHtcbiAgICAxOiBLRVlfU0VTU0lPTi5wcm9kLFxuICAgIDI6IEtFWV9TRVNTSU9OLmRldixcbiAgICAzOiBLRVlfU0VTU0lPTi5kZXYsXG4gICAgNDogS0VZX1NFU1NJT04uZGV2LFxuICAgIDU6IEtFWV9TRVNTSU9OLnN0YWdpbmcsXG59O1xuY29uc3QgQVBUX0NIQUlOX0lEX1NFUlZFUl9NQVBQSU5HID0ge1xuICAgIC8vIE1BSU5ORVRcbiAgICAxOiAnaHR0cHM6Ly93YWxsZXQtdjIuYmxvY3RvLmFwcCcsXG4gICAgLy8gVEVTVE5FVFxuICAgIDI6ICdodHRwczovL3dhbGxldC12Mi1kZXYuYmxvY3RvLmFwcCcsXG4gICAgLy8gREVWTkVUXG4gICAgMzogJ2h0dHBzOi8vd2FsbGV0LXYyLWRldi5ibG9jdG8uYXBwJyxcbiAgICAvLyBURVNUSU5HXG4gICAgNDogJ2h0dHBzOi8vd2FsbGV0LXYyLWRldi5ibG9jdG8uYXBwJyxcbiAgICAvLyBQUkVNQUlOTkVUXG4gICAgNTogJ2h0dHBzOi8vd2FsbGV0LXYyLXN0YWdpbmcuYmxvY3RvLmFwcCcsXG59O1xudmFyIFdhbGxldEFkYXB0ZXJOZXR3b3JrO1xuKGZ1bmN0aW9uIChXYWxsZXRBZGFwdGVyTmV0d29yaykge1xuICAgIFdhbGxldEFkYXB0ZXJOZXR3b3JrW1wiTWFpbm5ldFwiXSA9IFwibWFpbm5ldFwiO1xuICAgIFdhbGxldEFkYXB0ZXJOZXR3b3JrW1wiVGVzdG5ldFwiXSA9IFwidGVzdG5ldFwiO1xuICAgIFdhbGxldEFkYXB0ZXJOZXR3b3JrW1wiRGV2bmV0XCJdID0gXCJkZXZuZXRcIjtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIlRlc3RpbmdcIl0gPSBcInRlc3RpbmdcIjtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIlByZW1haW5uZXRcIl0gPSBcInByZW1haW5uZXRcIjtcbn0pKFdhbGxldEFkYXB0ZXJOZXR3b3JrIHx8IChXYWxsZXRBZGFwdGVyTmV0d29yayA9IHt9KSk7XG5jb25zdCBBUFRfQ0hBSU5fSURfTkFNRV9NQVBQSU5HID0ge1xuICAgIDE6IFdhbGxldEFkYXB0ZXJOZXR3b3JrLk1haW5uZXQsXG4gICAgMjogV2FsbGV0QWRhcHRlck5ldHdvcmsuVGVzdG5ldCxcbiAgICAzOiBXYWxsZXRBZGFwdGVyTmV0d29yay5EZXZuZXQsXG4gICAgNDogV2FsbGV0QWRhcHRlck5ldHdvcmsuVGVzdGluZyxcbiAgICA1OiBXYWxsZXRBZGFwdGVyTmV0d29yay5QcmVtYWlubmV0LFxufTtcbmNvbnN0IEFQVF9DSEFJTl9JRF9SUENfTUFQUElORyA9IHtcbiAgICAxOiAnaHR0cHM6Ly9mdWxsbm9kZS5tYWlubmV0LmFwdG9zbGFicy5jb20vdjEnLFxuICAgIDI6ICdodHRwczovL2Z1bGxub2RlLnRlc3RuZXQuYXB0b3NsYWJzLmNvbS92MScsXG4gICAgMzogJ2h0dHBzOi8vZnVsbG5vZGUuZGV2bmV0LmFwdG9zbGFicy5jb20vdjEnLFxuICAgIDQ6ICcnLFxuICAgIDU6ICdodHRwczovL3ByZW1haW5uZXQuYXB0b3NkZXYuY29tL3YxJyxcbn07XG4vKiBhcHRvcyBjb25zdGFudHMgZW5kICovXG5jb25zdCBFSVAxMTkzX0VWRU5UUyA9IFtcbiAgICAnY29ubmVjdCcsXG4gICAgJ2Rpc2Nvbm5lY3QnLFxuICAgICdtZXNzYWdlJyxcbiAgICAnY2hhaW5DaGFuZ2VkJyxcbiAgICAnYWNjb3VudHNDaGFuZ2VkJyxcbl07XG4vLyBQcmVzZXJ2ZSBsb2dpbiBmb3IgMSBkYXlcbmNvbnN0IExPR0lOX1BFUlNJU1RJTkdfVElNRSA9IDg2NDAwICogMTAwMDtcbmNvbnN0IERFRkFVTFRfQVBQX0lEID0gJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7XG4vLyBXaWxsIGluamVjdCB0aGUgdmVyc2lvbiBvZiB0aGUgU0RLIGJ5IHJvbGx1cCB2ZXJzaW9uSW5qZWN0b3IgZHVyaW5nIGJ1aWxkIHRpbWVcbmNvbnN0IFNES19WRVJTSU9OID0gJzAuNS41JztcblxuLy8gVGhlIHJvb3QgY2xhc3MgZm9yIGFsbCBwcm92aWRlcnNcbmNsYXNzIEJsb2N0b1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pc0Jsb2N0byA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IHt9O1xuICAgICAgICAvLyBhbGlhcyByZW1vdmVMaXN0ZW5lclxuICAgICAgICB0aGlzLm9mZiA9IHRoaXMucmVtb3ZlTGlzdGVuZXI7XG4gICAgICAgIC8vIGluaXQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIEVJUDExOTNfRVZFTlRTLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcHBJZCA9IERFRkFVTFRfQVBQX0lEO1xuICAgIH1cbiAgICAvLyBpbXBsZW1lbnQgYnkgY2hpbGRyZW5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICByZXF1ZXN0KHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgfSk7XG4gICAgfVxuICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIUVJUDExOTNfRVZFTlRTLmluY2x1ZGVzKGV2ZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyc1tldmVudF0ucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8vIEB0b2RvOiBpbXBsZW1lbnQgaXRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBvbmNlKCkgeyB9XG4gICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0gPT09IGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyc1tldmVudF0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgSUZSQU1FX1NUWUxFID0gJ3dpZHRoOjEwMHZ3O2hlaWdodDoxMDAlO3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDt6LWluZGV4OjIxNDc0ODM2NDY7Ym9yZGVyOm5vbmU7Ym94LXNpemluZzpib3JkZXItYm94O2NvbG9yLXNjaGVtZTpsaWdodDtpbnNldDowcHg7ZGlzcGxheTpibG9jaztwb2ludGVyLWV2ZW50czphdXRvOyc7XG5mdW5jdGlvbiBjcmVhdGVGcmFtZSh1cmwpIHtcbiAgICBjb25zdCBmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGZyYW1lLnNldEF0dHJpYnV0ZSgnc3JjJywgdXJsKTtcbiAgICBmcmFtZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgSUZSQU1FX1NUWUxFKTtcbiAgICByZXR1cm4gZnJhbWU7XG59XG5mdW5jdGlvbiBhdHRhY2hGcmFtZShmcmFtZSkge1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZnJhbWUpO1xufVxuZnVuY3Rpb24gZGV0YXRjaEZyYW1lKGZyYW1lKSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IGZyYW1lICYmIGZyYW1lLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZnJhbWUpO1xuICAgIH1cbn1cblxudmFyIGFkZFNlbGZSZW1vdmFibGVIYW5kbGVyID0gKGV2ZW50VHlwZSwgaGFuZGxlciwgdGFyZ2V0ID0gd2luZG93KSA9PiB7XG4gICAgZnVuY3Rpb24gbGlzdGVuZXIoZSkge1xuICAgICAgICBjb25zdCByZW1vdmVFdmVudExpc3RlbmVyID0gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGhhbmRsZXIoZSwgcmVtb3ZlRXZlbnRMaXN0ZW5lcik7XG4gICAgfVxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xufTtcblxuZnVuY3Rpb24gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIGtleSwgZGlzY29ubmVjdEhhbmRsZXIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDMgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgIGlmIChkaXNjb25uZWN0SGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3RIYW5kbGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5tZXNzYWdlKSB8fCAndW5rbm93biBlcnJvcicpO1xuICAgICAgICAgICAgZS5lcnJvcl9jb2RlID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmVycm9yX2NvZGU7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfSk7XG59XG5cbmNvbnN0IGlzRW1haWwgPSAodmFsdWUpID0+IC9cXFMrQFxcUytcXC5cXFMrLy50ZXN0KHZhbHVlKTtcbmNvbnN0IGlzVmFsaWRUcmFuc2FjdGlvbiA9ICh0cmFuc2FjdGlvbikgPT4gKHR5cGVvZiB0cmFuc2FjdGlvbiA9PT0gJ29iamVjdCcgJiYgdHJhbnNhY3Rpb24gIT09IG51bGwgJiYgJ2Zyb20nIGluIHRyYW5zYWN0aW9uKTtcbmNvbnN0IGlzVmFsaWRUcmFuc2FjdGlvbnMgPSAodHJhbnNhY3Rpb25zKSA9PiAoQXJyYXkuaXNBcnJheSh0cmFuc2FjdGlvbnMpICYmIHRyYW5zYWN0aW9ucy5ldmVyeSh0eCA9PiBpc1ZhbGlkVHJhbnNhY3Rpb24odHgpKSk7XG5cbmZ1bmN0aW9uIGdldEV2bVN1cHBvcnQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrcyB9ID0geWllbGQgZmV0Y2goJ2h0dHBzOi8vYXBpLmJsb2N0by5hcHAvbmV0d29ya3MvZXZtJykudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSk7XG4gICAgICAgIGNvbnN0IGV2bVN1cHBvcnRNYXAgPSBuZXR3b3Jrcy5yZWR1Y2UoKGEsIHYpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGEpLCB7IFt2LmNoYWluX2lkXTogdiB9KSksIHt9KTtcbiAgICAgICAgcmV0dXJuIGV2bVN1cHBvcnRNYXA7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbnZhciBkaXN0ID0ge307XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9LCBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCkpIHtcbiAgICBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3QuYmluZCgpO1xuICB9IGVsc2Uge1xuICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcbiAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICB9O1xuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbnZhciBjbGFzc2VzID0ge307XG5cbnZhciBmYXN0U2FmZVN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbnN0cmluZ2lmeVtcImRlZmF1bHRcIl0gPSBzdHJpbmdpZnk7XG5zdHJpbmdpZnkuc3RhYmxlID0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeTtcbnN0cmluZ2lmeS5zdGFibGVTdHJpbmdpZnkgPSBkZXRlcm1pbmlzdGljU3RyaW5naWZ5O1xudmFyIExJTUlUX1JFUExBQ0VfTk9ERSA9ICdbLi4uXSc7XG52YXIgQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFID0gJ1tDaXJjdWxhcl0nO1xudmFyIGFyciA9IFtdO1xudmFyIHJlcGxhY2VyU3RhY2sgPSBbXTtcbmZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zKCkge1xuICByZXR1cm4ge1xuICAgIGRlcHRoTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgIGVkZ2VzTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gIH07XG59XG5cbi8vIFJlZ3VsYXIgc3RyaW5naWZ5XG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKTtcbiAgfVxuICBkZWNpcmMob2JqLCAnJywgMCwgW10sIHVuZGVmaW5lZCwgMCwgb3B0aW9ucyk7XG4gIHZhciByZXM7XG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpO1xuICAgIH1cbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSgnW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXScpO1xuICB9IGZpbmFsbHkge1xuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKTtcbiAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHNldFJlcGxhY2UocmVwbGFjZSwgdmFsLCBrLCBwYXJlbnQpIHtcbiAgdmFyIHByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBrKTtcbiAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyZW50LCBrLCB7XG4gICAgICAgIHZhbHVlOiByZXBsYWNlXG4gICAgICB9KTtcbiAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbCwgcHJvcGVydHlEZXNjcmlwdG9yXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGxhY2VyU3RhY2sucHVzaChbdmFsLCBrLCByZXBsYWNlXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcmVudFtrXSA9IHJlcGxhY2U7XG4gICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlY2lyYyh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgZGVwdGggKz0gMTtcbiAgdmFyIGk7XG4gIGlmIChfdHlwZW9mKHZhbCkgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXQpIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSAndW5kZWZpbmVkJyAmJiBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGFjay5wdXNoKHZhbCk7XG4gICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWNpcmModmFsW2ldLCBpLCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBkZWNpcmModmFsW2tleV0sIGtleSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKTtcbiAgfVxufVxuXG4vLyBTdGFibGUtc3RyaW5naWZ5XG5mdW5jdGlvbiBjb21wYXJlRnVuY3Rpb24oYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljU3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKCk7XG4gIH1cbiAgdmFyIHRtcCA9IGRldGVybWluaXN0aWNEZWNpcmMob2JqLCAnJywgMCwgW10sIHVuZGVmaW5lZCwgMCwgb3B0aW9ucykgfHwgb2JqO1xuICB2YXIgcmVzO1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlciwgc3BhY2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlR2V0dGVyVmFsdWVzKHJlcGxhY2VyKSwgc3BhY2VyKTtcbiAgICB9XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJ1t1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV0nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXN0b3JlIHRoZSBvYmplY3QgYXMgaXQgd2FzLlxuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKTtcbiAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNEZWNpcmModmFsLCBrLCBlZGdlSW5kZXgsIHN0YWNrLCBwYXJlbnQsIGRlcHRoLCBvcHRpb25zKSB7XG4gIGRlcHRoICs9IDE7XG4gIHZhciBpO1xuICBpZiAoX3R5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgIHNldFJlcGxhY2UoQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXQpIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSAndW5kZWZpbmVkJyAmJiBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGFjay5wdXNoKHZhbCk7XG4gICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtpXSwgaSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkgb2JqZWN0IGluIHRoZSByZXF1aXJlZCB3YXlcbiAgICAgIHZhciB0bXAgPSB7fTtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKS5zb3J0KGNvbXBhcmVGdW5jdGlvbik7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgIHRtcFtrZXldID0gdmFsW2tleV07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhcmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSk7XG4gICAgICAgIHBhcmVudFtrXSA9IHRtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0bXA7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YWNrLnBvcCgpO1xuICB9XG59XG5cbi8vIHdyYXBzIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB2YWx1ZXMgd2UgY291bGRuJ3QgcmVwbGFjZVxuLy8gYW5kIG1hcmsgdGhlbSBhcyByZXBsYWNlZCB2YWx1ZVxuZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlcikge1xuICByZXBsYWNlciA9IHR5cGVvZiByZXBsYWNlciAhPT0gJ3VuZGVmaW5lZCcgPyByZXBsYWNlciA6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGxhY2VyU3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSByZXBsYWNlclN0YWNrW2ldO1xuICAgICAgICBpZiAocGFydFsxXSA9PT0ga2V5ICYmIHBhcnRbMF0gPT09IHZhbCkge1xuICAgICAgICAgIHZhbCA9IHBhcnRbMl07XG4gICAgICAgICAgcmVwbGFjZXJTdGFjay5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NlcywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuY2xhc3Nlcy5FdGhlcmV1bVByb3ZpZGVyRXJyb3IgPSBjbGFzc2VzLkV0aGVyZXVtUnBjRXJyb3IgPSB2b2lkIDA7XG52YXIgZmFzdF9zYWZlX3N0cmluZ2lmeV8xID0gZmFzdFNhZmVTdHJpbmdpZnk7XG4vKipcbiAqIEVycm9yIHN1YmNsYXNzIGltcGxlbWVudGluZyBKU09OIFJQQyAyLjAgZXJyb3JzIGFuZCBFdGhlcmV1bSBSUEMgZXJyb3JzXG4gKiBwZXIgRUlQLTE0NzQuXG4gKiBQZXJtaXRzIGFueSBpbnRlZ2VyIGVycm9yIGNvZGUuXG4gKi9cbnZhciBFdGhlcmV1bVJwY0Vycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKEV0aGVyZXVtUnBjRXJyb3IsIF9FcnJvcik7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRXRoZXJldW1ScGNFcnJvcik7XG4gIGZ1bmN0aW9uIEV0aGVyZXVtUnBjRXJyb3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXRoZXJldW1ScGNFcnJvcik7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9uZW1wdHkgc3RyaW5nLicpO1xuICAgIH1cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwbGFpbiBvYmplY3Qgd2l0aCBhbGwgcHVibGljIGNsYXNzIHByb3BlcnRpZXMuXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoRXRoZXJldW1ScGNFcnJvciwgW3tcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHZhciBzZXJpYWxpemVkID0ge1xuICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXJpYWxpemVkLmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGFjaykge1xuICAgICAgICBzZXJpYWxpemVkLnN0YWNrID0gdGhpcy5zdGFjaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNlcmlhbGl6ZWQgZXJyb3IsIG9taXR0aW5nXG4gICAgICogYW55IGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gZmFzdF9zYWZlX3N0cmluZ2lmeV8xW1wiZGVmYXVsdFwiXSh0aGlzLnNlcmlhbGl6ZSgpLCBzdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBFdGhlcmV1bVJwY0Vycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcbmNsYXNzZXMuRXRoZXJldW1ScGNFcnJvciA9IEV0aGVyZXVtUnBjRXJyb3I7XG4vKipcbiAqIEVycm9yIHN1YmNsYXNzIGltcGxlbWVudGluZyBFdGhlcmV1bSBQcm92aWRlciBlcnJvcnMgcGVyIEVJUC0xMTkzLlxuICogUGVybWl0cyBpbnRlZ2VyIGVycm9yIGNvZGVzIGluIHRoZSBbIDEwMDAgPD0gNDk5OSBdIHJhbmdlLlxuICovXG52YXIgRXRoZXJldW1Qcm92aWRlckVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXRoZXJldW1ScGNFcnJvcikge1xuICBfaW5oZXJpdHMoRXRoZXJldW1Qcm92aWRlckVycm9yLCBfRXRoZXJldW1ScGNFcnJvcik7XG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKEV0aGVyZXVtUHJvdmlkZXJFcnJvcik7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gRXRoZXJldW0gUHJvdmlkZXIgSlNPTi1SUEMgZXJyb3IuXG4gICAqIGBjb2RlYCBtdXN0IGJlIGFuIGludGVnZXIgaW4gdGhlIDEwMDAgPD0gNDk5OSByYW5nZS5cbiAgICovXG4gIGZ1bmN0aW9uIEV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV0aGVyZXVtUHJvdmlkZXJFcnJvcik7XG4gICAgaWYgKCFpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlciBzdWNoIHRoYXQ6IDEwMDAgPD0gY29kZSA8PSA0OTk5Jyk7XG4gICAgfVxuICAgIHJldHVybiBfc3VwZXIyLmNhbGwodGhpcywgY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFdGhlcmV1bVByb3ZpZGVyRXJyb3IpO1xufShFdGhlcmV1bVJwY0Vycm9yKTtcbmNsYXNzZXMuRXRoZXJldW1Qcm92aWRlckVycm9yID0gRXRoZXJldW1Qcm92aWRlckVycm9yO1xuLy8gSW50ZXJuYWxcbmZ1bmN0aW9uIGlzVmFsaWRFdGhQcm92aWRlckNvZGUoY29kZSkge1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihjb2RlKSAmJiBjb2RlID49IDEwMDAgJiYgY29kZSA8PSA0OTk5O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5UmVwbGFjZXIoXywgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSAnW0NpcmN1bGFyXScpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIHV0aWxzID0ge307XG5cbnZhciBlcnJvckNvbnN0YW50cyA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3JDb25zdGFudHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmVycm9yQ29uc3RhbnRzLmVycm9yVmFsdWVzID0gZXJyb3JDb25zdGFudHMuZXJyb3JDb2RlcyA9IHZvaWQgMDtcbmVycm9yQ29uc3RhbnRzLmVycm9yQ29kZXMgPSB7XG4gIHJwYzoge1xuICAgIGludmFsaWRJbnB1dDogLTMyMDAwLFxuICAgIHJlc291cmNlTm90Rm91bmQ6IC0zMjAwMSxcbiAgICByZXNvdXJjZVVuYXZhaWxhYmxlOiAtMzIwMDIsXG4gICAgdHJhbnNhY3Rpb25SZWplY3RlZDogLTMyMDAzLFxuICAgIG1ldGhvZE5vdFN1cHBvcnRlZDogLTMyMDA0LFxuICAgIGxpbWl0RXhjZWVkZWQ6IC0zMjAwNSxcbiAgICBwYXJzZTogLTMyNzAwLFxuICAgIGludmFsaWRSZXF1ZXN0OiAtMzI2MDAsXG4gICAgbWV0aG9kTm90Rm91bmQ6IC0zMjYwMSxcbiAgICBpbnZhbGlkUGFyYW1zOiAtMzI2MDIsXG4gICAgaW50ZXJuYWw6IC0zMjYwM1xuICB9LFxuICBwcm92aWRlcjoge1xuICAgIHVzZXJSZWplY3RlZFJlcXVlc3Q6IDQwMDEsXG4gICAgdW5hdXRob3JpemVkOiA0MTAwLFxuICAgIHVuc3VwcG9ydGVkTWV0aG9kOiA0MjAwLFxuICAgIGRpc2Nvbm5lY3RlZDogNDkwMCxcbiAgICBjaGFpbkRpc2Nvbm5lY3RlZDogNDkwMVxuICB9XG59O1xuZXJyb3JDb25zdGFudHMuZXJyb3JWYWx1ZXMgPSB7XG4gICctMzI3MDAnOiB7XG4gICAgc3RhbmRhcmQ6ICdKU09OIFJQQyAyLjAnLFxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIEpTT04gd2FzIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXIuIEFuIGVycm9yIG9jY3VycmVkIG9uIHRoZSBzZXJ2ZXIgd2hpbGUgcGFyc2luZyB0aGUgSlNPTiB0ZXh0LidcbiAgfSxcbiAgJy0zMjYwMCc6IHtcbiAgICBzdGFuZGFyZDogJ0pTT04gUlBDIDIuMCcsXG4gICAgbWVzc2FnZTogJ1RoZSBKU09OIHNlbnQgaXMgbm90IGEgdmFsaWQgUmVxdWVzdCBvYmplY3QuJ1xuICB9LFxuICAnLTMyNjAxJzoge1xuICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcbiAgICBtZXNzYWdlOiAnVGhlIG1ldGhvZCBkb2VzIG5vdCBleGlzdCAvIGlzIG5vdCBhdmFpbGFibGUuJ1xuICB9LFxuICAnLTMyNjAyJzoge1xuICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBtZXRob2QgcGFyYW1ldGVyKHMpLidcbiAgfSxcbiAgJy0zMjYwMyc6IHtcbiAgICBzdGFuZGFyZDogJ0pTT04gUlBDIDIuMCcsXG4gICAgbWVzc2FnZTogJ0ludGVybmFsIEpTT04tUlBDIGVycm9yLidcbiAgfSxcbiAgJy0zMjAwMCc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBpbnB1dC4nXG4gIH0sXG4gICctMzIwMDEnOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgbWVzc2FnZTogJ1Jlc291cmNlIG5vdCBmb3VuZC4nXG4gIH0sXG4gICctMzIwMDInOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgbWVzc2FnZTogJ1Jlc291cmNlIHVuYXZhaWxhYmxlLidcbiAgfSxcbiAgJy0zMjAwMyc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICBtZXNzYWdlOiAnVHJhbnNhY3Rpb24gcmVqZWN0ZWQuJ1xuICB9LFxuICAnLTMyMDA0Jzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTE0NzQnLFxuICAgIG1lc3NhZ2U6ICdNZXRob2Qgbm90IHN1cHBvcnRlZC4nXG4gIH0sXG4gICctMzIwMDUnOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgbWVzc2FnZTogJ1JlcXVlc3QgbGltaXQgZXhjZWVkZWQuJ1xuICB9LFxuICAnNDAwMSc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICBtZXNzYWdlOiAnVXNlciByZWplY3RlZCB0aGUgcmVxdWVzdC4nXG4gIH0sXG4gICc0MTAwJzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxuICAgIG1lc3NhZ2U6ICdUaGUgcmVxdWVzdGVkIGFjY291bnQgYW5kL29yIG1ldGhvZCBoYXMgbm90IGJlZW4gYXV0aG9yaXplZCBieSB0aGUgdXNlci4nXG4gIH0sXG4gICc0MjAwJzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxuICAgIG1lc3NhZ2U6ICdUaGUgcmVxdWVzdGVkIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgRXRoZXJldW0gcHJvdmlkZXIuJ1xuICB9LFxuICAnNDkwMCc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICBtZXNzYWdlOiAnVGhlIHByb3ZpZGVyIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIGFsbCBjaGFpbnMuJ1xuICB9LFxuICAnNDkwMSc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICBtZXNzYWdlOiAnVGhlIHByb3ZpZGVyIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBzcGVjaWZpZWQgY2hhaW4uJ1xuICB9XG59O1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0cy5zZXJpYWxpemVFcnJvciA9IGV4cG9ydHMuaXNWYWxpZENvZGUgPSBleHBvcnRzLmdldE1lc3NhZ2VGcm9tQ29kZSA9IGV4cG9ydHMuSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0UgPSB2b2lkIDA7XG4gIHZhciBlcnJvcl9jb25zdGFudHNfMSA9IGVycm9yQ29uc3RhbnRzO1xuICB2YXIgY2xhc3Nlc18xID0gY2xhc3NlcztcbiAgdmFyIEZBTExCQUNLX0VSUk9SX0NPREUgPSBlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5pbnRlcm5hbDtcbiAgdmFyIEZBTExCQUNLX01FU1NBR0UgPSAnVW5zcGVjaWZpZWQgZXJyb3IgbWVzc2FnZS4gVGhpcyBpcyBhIGJ1ZywgcGxlYXNlIHJlcG9ydCBpdC4nO1xuICB2YXIgRkFMTEJBQ0tfRVJST1IgPSB7XG4gICAgY29kZTogRkFMTEJBQ0tfRVJST1JfQ09ERSxcbiAgICBtZXNzYWdlOiBnZXRNZXNzYWdlRnJvbUNvZGUoRkFMTEJBQ0tfRVJST1JfQ09ERSlcbiAgfTtcbiAgZXhwb3J0cy5KU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSA9ICdVbnNwZWNpZmllZCBzZXJ2ZXIgZXJyb3IuJztcbiAgLyoqXG4gICAqIEdldHMgdGhlIG1lc3NhZ2UgZm9yIGEgZ2l2ZW4gY29kZSwgb3IgYSBmYWxsYmFjayBtZXNzYWdlIGlmIHRoZSBjb2RlIGhhc1xuICAgKiBubyBjb3JyZXNwb25kaW5nIG1lc3NhZ2UuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRNZXNzYWdlRnJvbUNvZGUoY29kZSkge1xuICAgIHZhciBmYWxsYmFja01lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IEZBTExCQUNLX01FU1NBR0U7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcbiAgICAgIHZhciBjb2RlU3RyaW5nID0gY29kZS50b1N0cmluZygpO1xuICAgICAgaWYgKGhhc0tleShlcnJvcl9jb25zdGFudHNfMS5lcnJvclZhbHVlcywgY29kZVN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yX2NvbnN0YW50c18xLmVycm9yVmFsdWVzW2NvZGVTdHJpbmddLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNKc29uUnBjU2VydmVyRXJyb3IoY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFja01lc3NhZ2U7XG4gIH1cbiAgZXhwb3J0cy5nZXRNZXNzYWdlRnJvbUNvZGUgPSBnZXRNZXNzYWdlRnJvbUNvZGU7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIGNvZGUgaXMgdmFsaWQuXG4gICAqIEEgY29kZSBpcyBvbmx5IHZhbGlkIGlmIGl0IGhhcyBhIG1lc3NhZ2UuXG4gICAqL1xuICBmdW5jdGlvbiBpc1ZhbGlkQ29kZShjb2RlKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjb2RlU3RyaW5nID0gY29kZS50b1N0cmluZygpO1xuICAgIGlmIChlcnJvcl9jb25zdGFudHNfMS5lcnJvclZhbHVlc1tjb2RlU3RyaW5nXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBleHBvcnRzLmlzVmFsaWRDb2RlID0gaXNWYWxpZENvZGU7XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBlcnJvciB0byBhbiBFdGhlcmV1bSBKU09OIFJQQy1jb21wYXRpYmxlIGVycm9yIG9iamVjdC5cbiAgICogTWVyZWx5IGNvcGllcyB0aGUgZ2l2ZW4gZXJyb3IncyB2YWx1ZXMgaWYgaXQgaXMgYWxyZWFkeSBjb21wYXRpYmxlLlxuICAgKiBJZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgbm90IGZ1bGx5IGNvbXBhdGlibGUsIGl0IHdpbGwgYmUgcHJlc2VydmVkIG9uIHRoZVxuICAgKiByZXR1cm5lZCBvYmplY3QncyBkYXRhLm9yaWdpbmFsRXJyb3IgcHJvcGVydHkuXG4gICAqL1xuICBmdW5jdGlvbiBzZXJpYWxpemVFcnJvcihlcnJvcikge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgIF9yZWYkZmFsbGJhY2tFcnJvciA9IF9yZWYuZmFsbGJhY2tFcnJvcixcbiAgICAgIGZhbGxiYWNrRXJyb3IgPSBfcmVmJGZhbGxiYWNrRXJyb3IgPT09IHZvaWQgMCA/IEZBTExCQUNLX0VSUk9SIDogX3JlZiRmYWxsYmFja0Vycm9yLFxuICAgICAgX3JlZiRzaG91bGRJbmNsdWRlU3RhID0gX3JlZi5zaG91bGRJbmNsdWRlU3RhY2ssXG4gICAgICBzaG91bGRJbmNsdWRlU3RhY2sgPSBfcmVmJHNob3VsZEluY2x1ZGVTdGEgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRzaG91bGRJbmNsdWRlU3RhO1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCFmYWxsYmFja0Vycm9yIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGZhbGxiYWNrRXJyb3IuY29kZSkgfHwgdHlwZW9mIGZhbGxiYWNrRXJyb3IubWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGZhbGxiYWNrIGVycm9yIHdpdGggaW50ZWdlciBudW1iZXIgY29kZSBhbmQgc3RyaW5nIG1lc3NhZ2UuJyk7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGNsYXNzZXNfMS5FdGhlcmV1bVJwY0Vycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3Iuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIHZhciBzZXJpYWxpemVkID0ge307XG4gICAgaWYgKGVycm9yICYmIF90eXBlb2YoZXJyb3IpID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShlcnJvcikgJiYgaGFzS2V5KGVycm9yLCAnY29kZScpICYmIGlzVmFsaWRDb2RlKGVycm9yLmNvZGUpKSB7XG4gICAgICB2YXIgX2Vycm9yID0gZXJyb3I7XG4gICAgICBzZXJpYWxpemVkLmNvZGUgPSBfZXJyb3IuY29kZTtcbiAgICAgIGlmIChfZXJyb3IubWVzc2FnZSAmJiB0eXBlb2YgX2Vycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQubWVzc2FnZSA9IF9lcnJvci5tZXNzYWdlO1xuICAgICAgICBpZiAoaGFzS2V5KF9lcnJvciwgJ2RhdGEnKSkge1xuICAgICAgICAgIHNlcmlhbGl6ZWQuZGF0YSA9IF9lcnJvci5kYXRhO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpYWxpemVkLm1lc3NhZ2UgPSBnZXRNZXNzYWdlRnJvbUNvZGUoc2VyaWFsaXplZC5jb2RlKTtcbiAgICAgICAgc2VyaWFsaXplZC5kYXRhID0ge1xuICAgICAgICAgIG9yaWdpbmFsRXJyb3I6IGFzc2lnbk9yaWdpbmFsRXJyb3IoZXJyb3IpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWQuY29kZSA9IGZhbGxiYWNrRXJyb3IuY29kZTtcbiAgICAgIHZhciBtZXNzYWdlID0gKF9hID0gZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlO1xuICAgICAgc2VyaWFsaXplZC5tZXNzYWdlID0gbWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyBtZXNzYWdlIDogZmFsbGJhY2tFcnJvci5tZXNzYWdlO1xuICAgICAgc2VyaWFsaXplZC5kYXRhID0ge1xuICAgICAgICBvcmlnaW5hbEVycm9yOiBhc3NpZ25PcmlnaW5hbEVycm9yKGVycm9yKVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHN0YWNrID0gKF9iID0gZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGFjaztcbiAgICBpZiAoc2hvdWxkSW5jbHVkZVN0YWNrICYmIGVycm9yICYmIHN0YWNrICYmIHR5cGVvZiBzdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNlcmlhbGl6ZWQuc3RhY2sgPSBzdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgZXhwb3J0cy5zZXJpYWxpemVFcnJvciA9IHNlcmlhbGl6ZUVycm9yO1xuICAvLyBJbnRlcm5hbFxuICBmdW5jdGlvbiBpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gLTMyMDk5ICYmIGNvZGUgPD0gLTMyMDAwO1xuICB9XG4gIGZ1bmN0aW9uIGFzc2lnbk9yaWdpbmFsRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgJiYgX3R5cGVvZihlcnJvcikgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGVycm9yKSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0tleShvYmosIGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9XG59KSh1dGlscyk7XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBudWxsID09IGFyciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gX2kpIHtcbiAgICB2YXIgX3MsXG4gICAgICBfZSxcbiAgICAgIF94LFxuICAgICAgX3IsXG4gICAgICBfYXJyID0gW10sXG4gICAgICBfbiA9ICEwLFxuICAgICAgX2QgPSAhMTtcbiAgICB0cnkge1xuICAgICAgaWYgKF94ID0gKF9pID0gX2kuY2FsbChhcnIpKS5uZXh0LCAwID09PSBpKSB7XG4gICAgICAgIGlmIChPYmplY3QoX2kpICE9PSBfaSkgcmV0dXJuO1xuICAgICAgICBfbiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKF9uID0gKF9zID0gX3guY2FsbChfaSkpLmRvbmUpICYmIChfYXJyLnB1c2goX3MudmFsdWUpLCBfYXJyLmxlbmd0aCAhPT0gaSk7IF9uID0gITApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSAhMCwgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgbnVsbCAhPSBfaVtcInJldHVyblwiXSAmJiAoX3IgPSBfaVtcInJldHVyblwiXSgpLCBPYmplY3QoX3IpICE9PSBfcikpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfYXJyO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG52YXIgZXJyb3JzID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvcnMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmVycm9ycy5ldGhFcnJvcnMgPSB2b2lkIDA7XG52YXIgY2xhc3Nlc18xID0gY2xhc3NlcztcbnZhciB1dGlsc18xID0gdXRpbHM7XG52YXIgZXJyb3JfY29uc3RhbnRzXzEgPSBlcnJvckNvbnN0YW50cztcbmVycm9ycy5ldGhFcnJvcnMgPSB7XG4gIHJwYzoge1xuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBQYXJzZSAoLTMyNzAwKSBlcnJvci5cbiAgICAgKi9cbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLnBhcnNlLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludmFsaWQgUmVxdWVzdCAoLTMyNjAwKSBlcnJvci5cbiAgICAgKi9cbiAgICBpbnZhbGlkUmVxdWVzdDogZnVuY3Rpb24gaW52YWxpZFJlcXVlc3QoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludmFsaWRSZXF1ZXN0LCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludmFsaWQgUGFyYW1zICgtMzI2MDIpIGVycm9yLlxuICAgICAqL1xuICAgIGludmFsaWRQYXJhbXM6IGZ1bmN0aW9uIGludmFsaWRQYXJhbXMoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludmFsaWRQYXJhbXMsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgTWV0aG9kIE5vdCBGb3VuZCAoLTMyNjAxKSBlcnJvci5cbiAgICAgKi9cbiAgICBtZXRob2ROb3RGb3VuZDogZnVuY3Rpb24gbWV0aG9kTm90Rm91bmQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLm1ldGhvZE5vdEZvdW5kLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludGVybmFsICgtMzI2MDMpIGVycm9yLlxuICAgICAqL1xuICAgIGludGVybmFsOiBmdW5jdGlvbiBpbnRlcm5hbChhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMuaW50ZXJuYWwsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgU2VydmVyIGVycm9yLlxuICAgICAqIFBlcm1pdHMgaW50ZWdlciBlcnJvciBjb2RlcyBpbiB0aGUgWyAtMzIwOTkgPD0gLTMyMDA1IF0gcmFuZ2UuXG4gICAgICogQ29kZXMgLTMyMDAwIHRocm91Z2ggLTMyMDA0IGFyZSByZXNlcnZlZCBieSBFSVAtMTQ3NC5cbiAgICAgKi9cbiAgICBzZXJ2ZXI6IGZ1bmN0aW9uIHNlcnZlcihvcHRzKSB7XG4gICAgICBpZiAoIW9wdHMgfHwgX3R5cGVvZihvcHRzKSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V0aGVyZXVtIFJQQyBTZXJ2ZXIgZXJyb3JzIG11c3QgcHJvdmlkZSBzaW5nbGUgb2JqZWN0IGFyZ3VtZW50LicpO1xuICAgICAgfVxuICAgICAgdmFyIGNvZGUgPSBvcHRzLmNvZGU7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29kZSkgfHwgY29kZSA+IC0zMjAwNSB8fCBjb2RlIDwgLTMyMDk5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyIHN1Y2ggdGhhdDogLTMyMDk5IDw9IGNvZGUgPD0gLTMyMDA1Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGNvZGUsIG9wdHMpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIEludmFsaWQgSW5wdXQgKC0zMjAwMCkgZXJyb3IuXG4gICAgICovXG4gICAgaW52YWxpZElucHV0OiBmdW5jdGlvbiBpbnZhbGlkSW5wdXQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludmFsaWRJbnB1dCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBSZXNvdXJjZSBOb3QgRm91bmQgKC0zMjAwMSkgZXJyb3IuXG4gICAgICovXG4gICAgcmVzb3VyY2VOb3RGb3VuZDogZnVuY3Rpb24gcmVzb3VyY2VOb3RGb3VuZChhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMucmVzb3VyY2VOb3RGb3VuZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBSZXNvdXJjZSBVbmF2YWlsYWJsZSAoLTMyMDAyKSBlcnJvci5cbiAgICAgKi9cbiAgICByZXNvdXJjZVVuYXZhaWxhYmxlOiBmdW5jdGlvbiByZXNvdXJjZVVuYXZhaWxhYmxlKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5yZXNvdXJjZVVuYXZhaWxhYmxlLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIFRyYW5zYWN0aW9uIFJlamVjdGVkICgtMzIwMDMpIGVycm9yLlxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uUmVqZWN0ZWQ6IGZ1bmN0aW9uIHRyYW5zYWN0aW9uUmVqZWN0ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLnRyYW5zYWN0aW9uUmVqZWN0ZWQsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgTWV0aG9kIE5vdCBTdXBwb3J0ZWQgKC0zMjAwNCkgZXJyb3IuXG4gICAgICovXG4gICAgbWV0aG9kTm90U3VwcG9ydGVkOiBmdW5jdGlvbiBtZXRob2ROb3RTdXBwb3J0ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBMaW1pdCBFeGNlZWRlZCAoLTMyMDA1KSBlcnJvci5cbiAgICAgKi9cbiAgICBsaW1pdEV4Y2VlZGVkOiBmdW5jdGlvbiBsaW1pdEV4Y2VlZGVkKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5saW1pdEV4Y2VlZGVkLCBhcmcpO1xuICAgIH1cbiAgfSxcbiAgcHJvdmlkZXI6IHtcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgVXNlciBSZWplY3RlZCBSZXF1ZXN0ICg0MDAxKSBlcnJvci5cbiAgICAgKi9cbiAgICB1c2VyUmVqZWN0ZWRSZXF1ZXN0OiBmdW5jdGlvbiB1c2VyUmVqZWN0ZWRSZXF1ZXN0KGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0LCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVuYXV0aG9yaXplZCAoNDEwMCkgZXJyb3IuXG4gICAgICovXG4gICAgdW5hdXRob3JpemVkOiBmdW5jdGlvbiB1bmF1dGhvcml6ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBVbnN1cHBvcnRlZCBNZXRob2QgKDQyMDApIGVycm9yLlxuICAgICAqL1xuICAgIHVuc3VwcG9ydGVkTWV0aG9kOiBmdW5jdGlvbiB1bnN1cHBvcnRlZE1ldGhvZChhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucHJvdmlkZXIudW5zdXBwb3J0ZWRNZXRob2QsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgTm90IENvbm5lY3RlZCAoNDkwMCkgZXJyb3IuXG4gICAgICovXG4gICAgZGlzY29ubmVjdGVkOiBmdW5jdGlvbiBkaXNjb25uZWN0ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnByb3ZpZGVyLmRpc2Nvbm5lY3RlZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBDaGFpbiBOb3QgQ29ubmVjdGVkICg0OTAxKSBlcnJvci5cbiAgICAgKi9cbiAgICBjaGFpbkRpc2Nvbm5lY3RlZDogZnVuY3Rpb24gY2hhaW5EaXNjb25uZWN0ZWQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnByb3ZpZGVyLmNoYWluRGlzY29ubmVjdGVkLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgY3VzdG9tIEV0aGVyZXVtIFByb3ZpZGVyIGVycm9yLlxuICAgICAqL1xuICAgIGN1c3RvbTogZnVuY3Rpb24gY3VzdG9tKG9wdHMpIHtcbiAgICAgIGlmICghb3B0cyB8fCBfdHlwZW9mKG9wdHMpICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXRoZXJldW0gUHJvdmlkZXIgY3VzdG9tIGVycm9ycyBtdXN0IHByb3ZpZGUgc2luZ2xlIG9iamVjdCBhcmd1bWVudC4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2RlID0gb3B0cy5jb2RlLFxuICAgICAgICBtZXNzYWdlID0gb3B0cy5tZXNzYWdlLFxuICAgICAgICBkYXRhID0gb3B0cy5kYXRhO1xuICAgICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZVwiIG11c3QgYmUgYSBub25lbXB0eSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgY2xhc3Nlc18xLkV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9XG4gIH1cbn07XG4vLyBJbnRlcm5hbFxuZnVuY3Rpb24gZ2V0RXRoSnNvblJwY0Vycm9yKGNvZGUsIGFyZykge1xuICB2YXIgX3BhcnNlT3B0cyA9IHBhcnNlT3B0cyhhcmcpLFxuICAgIF9wYXJzZU9wdHMyID0gX3NsaWNlZFRvQXJyYXkoX3BhcnNlT3B0cywgMiksXG4gICAgbWVzc2FnZSA9IF9wYXJzZU9wdHMyWzBdLFxuICAgIGRhdGEgPSBfcGFyc2VPcHRzMlsxXTtcbiAgcmV0dXJuIG5ldyBjbGFzc2VzXzEuRXRoZXJldW1ScGNFcnJvcihjb2RlLCBtZXNzYWdlIHx8IHV0aWxzXzEuZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIGdldEV0aFByb3ZpZGVyRXJyb3IoY29kZSwgYXJnKSB7XG4gIHZhciBfcGFyc2VPcHRzMyA9IHBhcnNlT3B0cyhhcmcpLFxuICAgIF9wYXJzZU9wdHM0ID0gX3NsaWNlZFRvQXJyYXkoX3BhcnNlT3B0czMsIDIpLFxuICAgIG1lc3NhZ2UgPSBfcGFyc2VPcHRzNFswXSxcbiAgICBkYXRhID0gX3BhcnNlT3B0czRbMV07XG4gIHJldHVybiBuZXcgY2xhc3Nlc18xLkV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlIHx8IHV0aWxzXzEuZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIHBhcnNlT3B0cyhhcmcpIHtcbiAgaWYgKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFthcmddO1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IGFyZy5tZXNzYWdlLFxuICAgICAgICBkYXRhID0gYXJnLmRhdGE7XG4gICAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgc3RyaW5nIG1lc3NhZ2UuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW21lc3NhZ2UgfHwgdW5kZWZpbmVkLCBkYXRhXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0cy5nZXRNZXNzYWdlRnJvbUNvZGUgPSBleHBvcnRzLnNlcmlhbGl6ZUVycm9yID0gZXhwb3J0cy5FdGhlcmV1bVByb3ZpZGVyRXJyb3IgPSBleHBvcnRzLkV0aGVyZXVtUnBjRXJyb3IgPSBleHBvcnRzLmV0aEVycm9ycyA9IGV4cG9ydHMuZXJyb3JDb2RlcyA9IHZvaWQgMDtcbiAgdmFyIGNsYXNzZXNfMSA9IGNsYXNzZXM7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyZXVtUnBjRXJyb3JcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gY2xhc3Nlc18xLkV0aGVyZXVtUnBjRXJyb3I7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXRoZXJldW1Qcm92aWRlckVycm9yXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGNsYXNzZXNfMS5FdGhlcmV1bVByb3ZpZGVyRXJyb3I7XG4gICAgfVxuICB9KTtcbiAgdmFyIHV0aWxzXzEgPSB1dGlscztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VyaWFsaXplRXJyb3JcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdXRpbHNfMS5zZXJpYWxpemVFcnJvcjtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRNZXNzYWdlRnJvbUNvZGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdXRpbHNfMS5nZXRNZXNzYWdlRnJvbUNvZGU7XG4gICAgfVxuICB9KTtcbiAgdmFyIGVycm9yc18xID0gZXJyb3JzO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJldGhFcnJvcnNcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZXJyb3JzXzEuZXRoRXJyb3JzO1xuICAgIH1cbiAgfSk7XG4gIHZhciBlcnJvcl9jb25zdGFudHNfMSA9IGVycm9yQ29uc3RhbnRzO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlcnJvckNvZGVzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXM7XG4gICAgfVxuICB9KTtcbn0pKGRpc3QpO1xuXG52YXIgZ2xvYmFsJDEgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6XG4gIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSk7XG5cbnZhciBsb29rdXAgPSBbXTtcbnZhciByZXZMb29rdXAgPSBbXTtcbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXk7XG52YXIgaW5pdGVkID0gZmFsc2U7XG5mdW5jdGlvbiBpbml0ICgpIHtcbiAgaW5pdGVkID0gdHJ1ZTtcbiAgdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbG9va3VwW2ldID0gY29kZVtpXTtcbiAgICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gIH1cblxuICByZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjI7XG4gIHJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2Mztcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICBpZiAoIWluaXRlZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFycjtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGg7XG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHBsYWNlSG9sZGVycyA9IGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDA7XG5cbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuO1xuXG4gIHZhciBMID0gMDtcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldO1xuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGO1xuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7XG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGO1xuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpO1xuICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMik7XG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRjtcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcDtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSk7XG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgaWYgKCFpbml0ZWQpIHtcbiAgICBpbml0KCk7XG4gIH1cbiAgdmFyIHRtcDtcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aDtcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzOyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MzsgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSk7XG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl07XG4gICAgb3V0cHV0ICs9ICc9PSc7XG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSk7XG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSAnPSc7XG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dCk7XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIHJlYWQgKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG07XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSAtNztcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMDtcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxO1xuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5mdW5jdGlvbiB3cml0ZSAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGM7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApO1xuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpO1xuICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7XG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn1cblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIElOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsJDEuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsJDEuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHRydWU7XG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmtNYXhMZW5ndGgoKTtcblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MjsgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIHJldHVybiBhcnJcbn07XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufTtcblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGU7XG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5O1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikgO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn07XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59O1xuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufTtcblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7XG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpO1xuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1O1xuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoOyAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKGludGVybmFsSXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMDtcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbik7XG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKTtcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuQnVmZmVyLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5mdW5jdGlvbiBpbnRlcm5hbElzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYSkgfHwgIWludGVybmFsSXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufTtcblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGk7XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gIHZhciBwb3MgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcyk7XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufTtcblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMDtcbiAgc3RhcnQgPj4+PSAwO1xuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZTtcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl07XG4gIGJbbl0gPSBiW21dO1xuICBiW21dID0gaTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpO1xuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNyk7XG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpO1xuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNCk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDA7XG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIG1heCA9IElOU1BFQ1RfTUFYX0JZVEVTO1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJyk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJztcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwO1xuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDA7XG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDA7XG4gIGVuZCA+Pj49IDA7XG4gIHRoaXNTdGFydCA+Pj49IDA7XG4gIHRoaXNFbmQgPj4+PSAwO1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0O1xuICB2YXIgeSA9IGVuZCAtIHN0YXJ0O1xuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSk7XG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpO1xuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV07XG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufTtcblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0O1xuICAgIGJ5dGVPZmZzZXQgPSAwO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmY7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwO1xuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDsgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0O1xuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMDtcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKTtcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRjsgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMTtcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoO1xuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMjtcbiAgICAgIGFyckxlbmd0aCAvPSAyO1xuICAgICAgdmFsTGVuZ3RoIC89IDI7XG4gICAgICBieXRlT2Zmc2V0IC89IDI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpO1xuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4O1xuICAgICAgICBmb3VuZEluZGV4ID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoO1xuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59O1xuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDA7XG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTtcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkO1xuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIG9mZnNldCA9IDA7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgb2Zmc2V0ID0gMDtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMDtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4JztcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nO1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59O1xuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG4gIHZhciByZXMgPSBbXTtcblxuICB2YXIgaSA9IHN0YXJ0O1xuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV07XG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGw7XG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxO1xuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludDtcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM107XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkQ7XG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGO1xuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwO1xuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnO1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3Rik7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJztcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG5cbiAgdmFyIG91dCA9ICcnO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pO1xuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1Nik7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBzdGFydCA9IH5+c3RhcnQ7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmQ7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlbjtcbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlbjtcbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbjtcbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMDtcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW47XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIHZhciBuZXdCdWY7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCk7XG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59O1xuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXTtcbiAgdmFyIG11bCA9IDE7XG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgfVxuICBtdWwgKj0gMHg4MDtcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciBpID0gYnl0ZUxlbmd0aDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV07XG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWw7XG4gIH1cbiAgbXVsICo9IDB4ODA7XG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCk7XG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpO1xuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufTtcblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICB9XG5cbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gIHZhciBtdWwgPSAxO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDg7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDE7XG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMTtcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKTtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQpO1xuICB9XG4gIHdyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCk7XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59O1xuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4KTtcbiAgfVxuICB3cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpO1xuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufTtcblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDA7XG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7XG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMDtcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQ7XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIHZhciBpO1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbGVuXG59O1xuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZDtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1O1xuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwO1xuXG4gIGlmICghdmFsKSB2YWwgPSAwO1xuXG4gIHZhciBpO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBpbnRlcm5hbElzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSk7XG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn07XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nO1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpO1xuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSc7XG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHk7XG4gIHZhciBjb2RlUG9pbnQ7XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG4gIHZhciBieXRlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvO1xuICB2YXIgYnl0ZUFycmF5ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGkgPSBjID4+IDg7XG4gICAgbG8gPSBjICUgMjU2O1xuICAgIGJ5dGVBcnJheS5wdXNoKGxvKTtcbiAgICBieXRlQXJyYXkucHVzaChoaSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiB0b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG4vLyB0aGUgZm9sbG93aW5nIGlzIGZyb20gaXMtYnVmZmVyLCBhbHNvIGJ5IEZlcm9zcyBBYm91a2hhZGlqZWggYW5kIHdpdGggc2FtZSBsaXNlbmNlXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5mdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmICghIW9iai5faXNCdWZmZXIgfHwgaXNGYXN0QnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikpXG59XG5cbmZ1bmN0aW9uIGlzRmFzdEJ1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzRmFzdEJ1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cbmNvbnN0IGlzSGV4U3RyaW5nID0gKGhleCkgPT4gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgJiYgL14weFswLTlBLUZhLWZdKiQvLnRlc3QoaGV4KTtcbmNvbnN0IHV0ZjhUb0hleCA9IChzdHIpID0+IHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCAndXRmOCcpLnRvU3RyaW5nKCdoZXgnKTtcbn07XG5cbnZhciBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMsIF9FdGhlcmV1bVByb3ZpZGVyX2FkZFRvU3dpdGNoYWJsZSwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZDtcbmZ1bmN0aW9uIHBhcnNlQ2hhaW5JZChjaGFpbklkKSB7XG4gICAgaWYgKCFjaGFpbklkKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoYWluSWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBjaGFpbklkO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFpbklkLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGNoYWluSWQsIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KGNoYWluSWQsIDEwKTtcbn1cbmNsYXNzIEV0aGVyZXVtUHJvdmlkZXIgZXh0ZW5kcyBCbG9jdG9Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoeyBjaGFpbklkLCBycGMsIHdhbGxldFNlcnZlciwgYXBwSWQgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gJzEnOyAvLyBzYW1lIGFzIGNoYWluSWQgYnV0IGluIGRlY2ltYWxcbiAgICAgICAgLy8gc2V0dXAgY2hhaW5JZFxuICAgICAgICBpbnZhcmlhbnQoY2hhaW5JZCwgXCInY2hhaW5JZCcgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIHRoaXMubmV0d29ya1ZlcnNpb24gPSBgJHtwYXJzZUNoYWluSWQoY2hhaW5JZCl9YDtcbiAgICAgICAgdGhpcy5jaGFpbklkID0gYDB4JHtwYXJzZUNoYWluSWQoY2hhaW5JZCkudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgIC8vIHNldHVwIHJwY1xuICAgICAgICB0aGlzLnJwYyA9IHJwYyB8fCBFVEhfUlBDX0xJU1RbdGhpcy5uZXR3b3JrVmVyc2lvbl07XG4gICAgICAgIGludmFyaWFudCh0aGlzLnJwYywgXCIncnBjJyBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgLy8gc2V0dXAgaW5qZWN0ZWRXYWxsZXRTZXJ2ZXJcbiAgICAgICAgdGhpcy5pbmplY3RlZFdhbGxldFNlcnZlciA9IHdhbGxldFNlcnZlcjtcbiAgICAgICAgLy8gTk9URTogX2Jsb2N0byBpcyBub3QgZnVsbHkgaW5pdGlhbGl6ZWQgeWV0IGF0IHRoaXMgcG9pbnRcbiAgICAgICAgLy8gQW55IGZ1bmN0aW9uIHNob3VsZCBjYWxsICNnZXRCbG9jdG9Qcm9wZXJ0aWVzKCkgdG8gZ2V0IHRoZSBmdWxsIF9ibG9jdG8gcHJvcGVydGllc1xuICAgICAgICB0aGlzLl9ibG9jdG8gPSB7XG4gICAgICAgICAgICBzZXNzaW9uS2V5OiBLRVlfU0VTU0lPTi5wcm9kLFxuICAgICAgICAgICAgd2FsbGV0U2VydmVyOiB0aGlzLmluamVjdGVkV2FsbGV0U2VydmVyIHx8ICcnLFxuICAgICAgICAgICAgYmxvY2tjaGFpbk5hbWU6ICcnLFxuICAgICAgICAgICAgbmV0d29ya1R5cGU6ICcnLFxuICAgICAgICAgICAgc3VwcG9ydE5ldHdvcmtMaXN0OiB7fSxcbiAgICAgICAgICAgIHN3aXRjaGFibGVOZXR3b3JrOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkIHx8IERFRkFVTFRfQVBQX0lEO1xuICAgIH1cbiAgICAvLyBERVBSRUNBVEVEIEFQSTogc2VlIGh0dHBzOi8vZG9jcy5tZXRhbWFzay5pby9ndWlkZS9ldGhlcmV1bS1wcm92aWRlci5odG1sI2V0aGVyZXVtLXNlbmQtZGVwcmVjYXRlZFxuICAgIHNlbmQobWV0aG9kT3JQYXlsb2FkLCBwYXJhbXNPckNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBzaWduYXR1cmUgdHlwZSAxOiBhcmcxIC0gSlNPTi1SUEMgcGF5bG9hZCwgYXJnMiAtIGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIC8vIGV0aGVyZXVtLnNlbmQocGF5bG9hZDogSnNvblJwY1JlcXVlc3QsIGNhbGxiYWNrOiBKc29uUnBjQ2FsbGJhY2spOiB2b2lkO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2lnbmF0dXJlIGlzIGV4YWN0bHkgbGlrZSBldGhlcmV1bS5zZW5kQXN5bmMoKVxuICAgICAgICAgICAgICAgIGNhc2UgcGFyYW1zT3JDYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kQXN5bmMobWV0aG9kT3JQYXlsb2FkLCBwYXJhbXNPckNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAvLyBzaWduYXR1cmUgdHlwZSAyOiBhcmcxIC0gSlNPTi1SUEMgbWV0aG9kIG5hbWUsIGFyZzIgLSBwYXJhbXMgYXJyYXk7XG4gICAgICAgICAgICAgICAgLy8gZXRoZXJldW0uc2VuZChtZXRob2Q6IHN0cmluZywgcGFyYW1zPzogQXJyYXk8dW5rbm93bj4pOiBQcm9taXNlPEpzb25ScGNSZXNwb25zZT47XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaWduYXR1cmUgaXMgbGlrZSBhbiBhc3luYyBldGhlcmV1bS5zZW5kQXN5bmMoKSB3aXRoIG1ldGhvZCBhbmQgcGFyYW1zIGFzIGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIGEgSlNPTi1SUEMgcGF5bG9hZCBhbmQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVvZiBtZXRob2RPclBheWxvYWQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocGFyYW1zT3JDYWxsYmFjayk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kT3JQYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNPckNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBzaWduYXR1cmUgdHlwZSAzOiBhcmcxIC0gSlNPTi1SUEMgcGF5bG9hZChzaG91bGQgYmUgc3luY2hyb25vdXMgbWV0aG9kcylcbiAgICAgICAgICAgICAgICAvLyBldGhlcmV1bS5zZW5kKHBheWxvYWQ6IEpzb25ScGNSZXF1ZXN0KTogdW5rbm93bjtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNpZ25hdHVyZSBlbmFibGVzIHlvdSB0byBjYWxsIHNvbWUgdHlwZSBvZiBSUEMgbWV0aG9kcyBzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEFzeW5jKG1ldGhvZE9yUGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBERVBSRUNBVEVEIEFQSTogc2VlIGh0dHBzOi8vZG9jcy5tZXRhbWFzay5pby9ndWlkZS9ldGhlcmV1bS1wcm92aWRlci5odG1sI2xlZ2FjeS1tZXRob2RzIGltcGxlbWVudGF0aW9uXG4gICAgLy8gd2ViMyB2MS54IEJhdGNoUmVxdWVzdCBzdGlsbCBkZXBlbmRzIG9uIGl0IHNvIHdlIG5lZWQgdG8gaW1wbGVtZW50IGFueXdheSDCr1xcXyjjg4QpXy/Cr1xuICAgIHNlbmRBc3luYyhwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlUmVxdWVzdCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gd2ViMyB2MS54IGNvbmNhdCBiYXRjaGVkIEpTT04tUlBDIHJlcXVlc3RzIHRvIGFuIGFycmF5LCBoYW5kbGUgaXQgaGVyZVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgdHJhbnNhY3Rpb25zIGFuZCBzZW5kIGJhdGNoIHdpdGggY3VzdG9tIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChyZXF1ZXN0KSA9PiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgocmVxdWVzdCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSByZXF1ZXN0LnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWRCYXNlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXRjaGVkUmVxdWVzdFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdibG9jdG9fc2VuZEJhdGNoVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB0cmFuc2FjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoUmVzcG9uc2VQcm9taXNlID0gdGhpcy5yZXF1ZXN0KGJhdGNoZWRSZXF1ZXN0UGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RzID0gcGF5bG9hZC5tYXAoKHsgbWV0aG9kLCBwYXJhbXMgfSwgaW5kZXgpID0+IG1ldGhvZCA9PT0gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGJhdGNoUmVzcG9uc2VQcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkQmFzZSArIGluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlIHJlc3BvbnNlIHdoZW4gYWxsIHJlcXVlc3QgYXJlIGV4ZWN1dGVkXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsU2V0dGxlZChyZXF1ZXN0cylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChyZXNwb25zZXMpID0+IHJlc29sdmUocmVzcG9uc2VzLm1hcCgocmVzcG9uc2UsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBTdHJpbmcoaWRCYXNlICsgaW5kZXggKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHBheWxvYWRbaW5kZXhdLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3BvbnNlLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogcmVzcG9uc2Uuc3RhdHVzICE9PSAnZnVsZmlsbGVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLnJlYXNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGF5bG9hZCksIHsgaWQ6IE51bWJlcihwYXlsb2FkLmlkKSB9KSkudGhlbihyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgY2FsbGJhY2sgb3IgcmV0dXJuIHByb21pc2UsIGRlcGRlbmRzIG9uIGNhbGxiYWNrIGFyZyBnaXZlbiBvciBub3RcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGhhbmRsZVJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IGNhbGxiYWNrKG51bGwsIGRhdGEpKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiBjYWxsYmFjayhlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlcXVlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kaW5nIHVzZXJPcGVyYXRpb24gdXNpbmcgQmxvY3RvIFNESy5cbiAgICAgKiBAcGFyYW0ge0lVc2VyT3BlcmF0aW9ufSB1c2VyT3AgLSB1c2VyT3BlcmF0aW9uIG9iamVjdFxuICAgICAqIEByZW1hcmtzIE5vIG5lZWQgdG8gaW5jbHVkZSBub25jZSwgaW5pdENvZGUsIGFuZCBzaWduYXR1cmUgYXMgcGFyYW1ldGVycyB3aGVuIHVzaW5nIEJsb2N0b1NESyB0byBzZW5kIHVzZXJPcGVyYXRpb24uXG4gICAgICogVGhlc2UgcGFyYW1ldGVycyB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSB1c2VyT3BlcmF0aW9uIGhhc2hcbiAgICAgKi9cbiAgICBzZW5kVXNlck9wZXJhdGlvbih1c2VyT3ApIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9zZW5kVXNlck9wZXJhdGlvbicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbdXNlck9wXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWVzdChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaztcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghKHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5tZXRob2QpKVxuICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUmVxdWVzdCgpO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5ldGhlcmV1bTtcbiAgICAgICAgICAgIGlmIChleGlzdGVkU0RLICYmIGV4aXN0ZWRTREsuaXNCbG9jdG8pIHtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgPT09ICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoKF9iID0gKF9hID0gcGF5bG9hZCA9PT0gbnVsbCB8fCBwYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsucmVxdWVzdChwYXlsb2FkKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXR3b3JrVmVyc2lvbiA9IGAke3BhcnNlQ2hhaW5JZCgoX2EgPSBwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0uY2hhaW5JZCl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhaW5JZCA9IGAweCR7cGFyc2VDaGFpbklkKChfYiA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5wYXJhbXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlswXS5jaGFpbklkKS50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnBjID0gKF9jID0gc3dpdGNoYWJsZU5ldHdvcmsgPT09IG51bGwgfHwgc3dpdGNoYWJsZU5ldHdvcmsgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN3aXRjaGFibGVOZXR3b3JrW3RoaXMubmV0d29ya1ZlcnNpb25dKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucnBjX3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsucmVxdWVzdChwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgYmxvY2tjaGFpbk5hbWUsIHN3aXRjaGFibGVOZXR3b3JrLCBzZXNzaW9uS2V5IH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvLyBtZXRob2QgdGhhdCBkb2Vzbid0IHJlcXVpcmUgdXNlciB0byBiZSBjb25uZWN0ZWRcbiAgICAgICAgICAgIHN3aXRjaCAocGF5bG9hZC5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdldGhfY2hhaW5JZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhaW5JZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV0X3ZlcnNpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtWZXJzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbic6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZFN3aXRjaGFibGVOZXR3b3JrKChwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQucGFyYW1zKSB8fCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9jYWxsJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuaGFuZGxlUmVhZFJlcXVlc3RzKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlIHx8IChyZXNwb25zZSAmJiAhcmVzcG9uc2UucmVzdWx0ICYmIHJlc3BvbnNlLmVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gKChfYyA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5lcnJvcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZS5lcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnUmVxdWVzdCBmYWlsZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludGVybmFsKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKChfZSA9IChfZCA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5wYXJhbXMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZFswXSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNoYWluSWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q2hhaW5JZCA9IHBheWxvYWQucGFyYW1zWzBdLmNoYWluSWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2V0Q2hhaW5BZGRyZXNzKHNlc3Npb25LZXksIGJsb2NrY2hhaW5OYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlyZWN0bHkgc3dpdGNoIG5ldHdvcmsgaWYgdXNlciBpcyBub3QgY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBhZGQgYSBjb25maXJtIHN3aXRjaCBuZXR3b3JrIGRpYWxvZ1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGhhc2VkQ2hhaW5JZCA9IHBhcnNlQ2hhaW5JZChuZXdDaGFpbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3dpdGNoYWJsZU5ldHdvcmtbcGhhc2VkQ2hhaW5JZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci5jdXN0b20oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiA0OTAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgVW5yZWNvZ25pemVkIGNoYWluIElEIFwiJHtuZXdDaGFpbklkfVwiLiBUcnkgYWRkaW5nIHRoZSBjaGFpbiB1c2luZyB3YWxsZXRfYWRkRXRoZXJldW1DaGFpbiBmaXJzdC5gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXR3b3JrVmVyc2lvbiA9IGAke3BoYXNlZENoYWluSWR9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhaW5JZCA9IGAweCR7cGhhc2VkQ2hhaW5JZC50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnBjID0gc3dpdGNoYWJsZU5ldHdvcmtbcGhhc2VkQ2hhaW5JZF0ucnBjX3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuY2hhaW5DaGFuZ2VkLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcih0aGlzLmNoYWluSWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ldGhvZCB0aGF0IHJlcXVpcmVzIHVzZXIgdG8gYmUgY29ubmVjdGVkXG4gICAgICAgICAgICBpZiAoIWdldENoYWluQWRkcmVzcyhzZXNzaW9uS2V5LCBibG9ja2NoYWluTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWFpbCA9IChfZiA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5wYXJhbXMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZlswXTtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgPT09ICdldGhfcmVxdWVzdEFjY291bnRzJyAmJiBpc0VtYWlsKGVtYWlsKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmVuYWJsZShlbWFpbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9yZXF1ZXN0QWNjb3VudHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5mZXRjaEFjY291bnRzKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfYWNjb3VudHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2V0Q2hhaW5BZGRyZXNzKHNlc3Npb25LZXksIGJsb2NrY2hhaW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfY29pbmJhc2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAoX2cgPSBnZXRDaGFpbkFkZHJlc3Moc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUpKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfc2lnblR5cGVkRGF0YV92Myc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zaWduVHlwZWREYXRhJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ25UeXBlZERhdGFfdjQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdwZXJzb25hbF9zaWduJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ24nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCB0aGlzLmhhbmRsZVNpZ24ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3YWxsZXRfZGlzY29ubmVjdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zZW5kVHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgdGhpcy5oYW5kbGVTZW5kVHJhbnNhY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmxvY3RvX3NlbmRCYXRjaFRyYW5zYWN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuaGFuZGxlU2VuZEJhdGNoVHJhbnNhY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ25UcmFuc2FjdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCdNZXRob2QgTm90IFN1cHBvcnRlZDogJyArIHBheWxvYWQubWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfc2VuZFVzZXJPcGVyYXRpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgdGhpcy5oYW5kbGVTZW5kVXNlck9wZXJhdGlvbihwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKChfaiA9IChfaCA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5wYXJhbXMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaFswXSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmNoYWluSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZEFjY291bnQgPSAoX2sgPSBnZXRDaGFpbkFkZHJlc3Moc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUpKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2tbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRDaGFpbklkID0gdGhpcy5jaGFpbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q2hhaW5JZCA9IHBheWxvYWQucGFyYW1zWzBdLmNoYWluSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN3aXRjaGFibGVOZXR3b3JrW3BhcnNlQ2hhaW5JZChuZXdDaGFpbklkKV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci5jdXN0b20oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiA0OTAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgVW5yZWNvZ25pemVkIGNoYWluIElEIFwiJHtwYXJzZUNoYWluSWQocGF5bG9hZC5wYXJhbXNbMF0uY2hhaW5JZCl9XCIuIFRyeSBhZGRpbmcgdGhlIGNoYWluIHVzaW5nIHdhbGxldF9hZGRFdGhlcmV1bUNoYWluIGZpcnN0LmAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gYCR7cGFyc2VDaGFpbklkKG5ld0NoYWluSWQpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYWluSWQgPSBgMHgke3BhcnNlQ2hhaW5JZChuZXdDaGFpbklkKS50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnBjID0gc3dpdGNoYWJsZU5ldHdvcmtbdGhpcy5uZXR3b3JrVmVyc2lvbl0ucnBjX3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZW5hYmxlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoW25ld0FjY291bnRdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdBY2NvdW50ICE9PSBvbGRBY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2NvdW50c0NoYW5nZWQuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKFtuZXdBY2NvdW50XSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmNoYWluQ2hhbmdlZC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIodGhpcy5jaGFpbklkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV0d29ya1ZlcnNpb24gPSBgJHtwYXJzZUNoYWluSWQob2xkQ2hhaW5JZCl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYWluSWQgPSBgMHgke3BhcnNlQ2hhaW5JZChvbGRDaGFpbklkKS50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJwYyA9IHN3aXRjaGFibGVOZXR3b3JrW3RoaXMubmV0d29ya1ZlcnNpb25dLnJwY191cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9lc3RpbWF0ZVVzZXJPcGVyYXRpb25HYXMnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfZ2V0VXNlck9wZXJhdGlvbkJ5SGFzaCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9nZXRVc2VyT3BlcmF0aW9uUmVjZWlwdCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zdXBwb3J0ZWRFbnRyeVBvaW50cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCB0aGlzLmhhbmRsZUJ1bmRsZXIocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0geWllbGQgdGhpcy5oYW5kbGVSZWFkUmVxdWVzdHMocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiAhcmVzcG9uc2UucmVzdWx0ICYmIHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHJlc3BvbnNlLmVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2UuZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAnUmVxdWVzdCBmYWlsZWQnO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYmxvY3RvQXBpKHVybCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdhbGxldFNlcnZlciwgYmxvY2tjaGFpbk5hbWUsIHNlc3Npb25LZXkgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2EgPSBnZXRBY2NvdW50U3RvcmFnZShzZXNzaW9uS2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpIHx8ICcnO1xuICAgICAgICAgICAgaWYgKCFzZXNzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci51bmF1dGhvcml6ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmZXRjaChgJHt3YWxsZXRTZXJ2ZXJ9L2FwaS8ke2Jsb2NrY2hhaW5OYW1lfSR7dXJsfWAsIE9iamVjdC5hc3NpZ24oeyBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0gfSwgb3B0aW9ucykpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZVNlc3Npb25HdWFyZChyZXNwb25zZSwgc2Vzc2lvbktleSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmV2ZW50TGlzdGVuZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuZGlzY29ubmVjdGVkKCkpKTtcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLmVycm9yX2NvZGUpID09PSAndW5zdXBwb3J0ZWRfbWV0aG9kJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCdNZXRob2QgTm90IFN1cHBvcnRlZDogJyArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuc2VydmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IC0zMjAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBCbG9jdG8gc2VydmVyIGVycm9yOiAke2UubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3BvbnNlTGlzdGVuZXIoZnJhbWUsIG9iamVjdEtleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyB3YWxsZXRTZXJ2ZXIgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlRXZlbnRMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBldmVudDtcbiAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gPT09IHdhbGxldFNlcnZlciAmJlxuICAgICAgICAgICAgICAgICAgICBlLmRhdGEudHlwZSA9PT0gJ0VUSDpGUkFNRTpSRVNQT05TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdBUFBST1ZFRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGUuZGF0YVtvYmplY3RLZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0RFQ0xJTkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuZXJyb3JDb2RlID09PSAnaW5jb3JyZWN0X3Nlc3Npb25faWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdChlLmRhdGEuZXJyb3JNZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnRVRIOkZSQU1FOkNMT1NFJykge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChkaXN0LmV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KCdVc2VyIGRlY2xpbmVkIHRoZSByZXF1ZXN0JykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldElmcmFtZSh1cmwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnByb3ZpZGVyLmN1c3RvbSh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IDEwMDEsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdCbG9jdG8gU0RLIG9ubHkgd29ya3MgaW4gYnJvd3NlciBlbnZpcm9ubWVudCcsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHdhbGxldFNlcnZlciwgYmxvY2tjaGFpbk5hbWUgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lID0gY3JlYXRlRnJhbWUoYCR7d2FsbGV0U2VydmVyfS8ke3RoaXMuYXBwSWR9LyR7YmxvY2tjaGFpbk5hbWV9JHt1cmx9YCk7XG4gICAgICAgICAgICBhdHRhY2hGcmFtZShmcmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlaXAtMTEwMiBhbGlhc1xuICAgIC8vIERFUFJFQ0FURUQgQVBJOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vRUlQcy9ibG9iL21hc3Rlci9FSVBTL2VpcC0xMTAyLm1kXG4gICAgZW5hYmxlKGVtYWlsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdhbGxldFNlcnZlciwgYmxvY2tjaGFpbk5hbWUsIHNlc3Npb25LZXkgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuZXRoZXJldW07XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESyAmJiBleGlzdGVkU0RLLmlzQmxvY3RvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0ZWRTREsuY2hhaW5JZCAhPT0gdGhpcy5jaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGV4aXN0ZWRTREsucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IHRoaXMuY2hhaW5JZCB9XSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGV4aXN0ZWRTREsucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IHRoaXMuY2hhaW5JZCB9XSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNldENoYWluQWRkcmVzcyhzZXNzaW9uS2V5LCBibG9ja2NoYWluTmFtZSwgW2V4aXN0ZWRTREsuYWRkcmVzc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gXG4gICAgICAgICAgICAgICAgLy8gYWRkIGEgc21hbGwgZGVsYXkgdG8gbWFrZSBzdXJlIHRoZSBuZXR3b3JrIGhhcyBiZWVuIHN3aXRjaGVkXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBleGlzdGVkU0RLLmVuYWJsZSgpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KSwgMTApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRDaGFpbkFkZHJlc3Moc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoJ2w2bicsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICAgICAgcGFyYW1zLnNldCgndicsIFNES19WRVJTSU9OKTtcbiAgICAgICAgICAgIGNvbnN0IGVtYWlsUGFyYW0gPSBlbWFpbCAmJiBpc0VtYWlsKGVtYWlsKSA/IGAvJHtlbWFpbH1gIDogJyc7XG4gICAgICAgICAgICBjb25zdCBsb2dpbkZyYW1lID0geWllbGQgdGhpcy5zZXRJZnJhbWUoYC9hdXRobiR7ZW1haWxQYXJhbX0/JHtwYXJhbXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIoJ21lc3NhZ2UnLCAoZXZlbnQsIHJlbW92ZUxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gPT09IHdhbGxldFNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnRVRIOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGxvZ2luRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25uZWN0LmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcih7IGNoYWluSWQ6IHRoaXMuY2hhaW5JZCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QWNjb3VudFN0b3JhZ2Uoc2Vzc2lvbktleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBlLmRhdGEuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Jsb2NrY2hhaW5OYW1lXTogW2UuZGF0YS5hZGRyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBlLmRhdGEuZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtlLmRhdGEuYWRkcl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnRVRIOkZSQU1FOkNMT1NFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGxvZ2luRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChkaXN0LmV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoQWNjb3VudHMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IGJsb2NrY2hhaW5OYW1lLCBzZXNzaW9uS2V5IH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSB5aWVsZCB0aGlzLmJsb2N0b0FwaShgL2FjY291bnRzYCk7XG4gICAgICAgICAgICBzZXRDaGFpbkFkZHJlc3Moc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUsIGFjY291bnRzKTtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVJlYWRSZXF1ZXN0cyhwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2godGhpcy5ycGMsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKHsgaWQ6IDEsIGpzb25ycGM6ICcyLjAnIH0sIHBheWxvYWQpKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludGVybmFsKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVTaWduKHsgbWV0aG9kLCBwYXJhbXMgfSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAnZXRoX3NpZ24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBpc0hleFN0cmluZyhwYXJhbXNbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmFtc1sxXS5zbGljZSgyKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1dGY4VG9IZXgocGFyYW1zWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0aG9kID09PSAncGVyc29uYWxfc2lnbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGlzSGV4U3RyaW5nKHBhcmFtc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyYW1zWzBdLnNsaWNlKDIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHV0ZjhUb0hleChwYXJhbXNbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChbXG4gICAgICAgICAgICAgICAgICAgICdldGhfc2lnblR5cGVkRGF0YScsXG4gICAgICAgICAgICAgICAgICAgICdldGhfc2lnblR5cGVkRGF0YV92MycsXG4gICAgICAgICAgICAgICAgICAgICdldGhfc2lnblR5cGVkRGF0YV92NCcsXG4gICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBwYXJhbXNbMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9tYWluIH0gPSBKU09OLnBhcnNlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoZG9tYWluLmNoYWluSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhgUHJvdmlkZWQgY2hhaW5JZCBcIiR7ZG9tYWluLmNoYWluSWR9XCIgbXVzdCBiZSBhIG51bWJlcmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUNoYWluSWQoZG9tYWluLmNoYWluSWQpICE9PSBwYXJzZUNoYWluSWQodGhpcy5jaGFpbklkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoYFByb3ZpZGVkIGNoYWluSWQgXCIke2RvbWFpbi5jaGFpbklkfVwiIG11c3QgbWF0Y2ggdGhlIGFjdGl2ZSBjaGFpbklkIFwiJHtwYXJzZUNoYWluSWQodGhpcy5jaGFpbklkKX1cImApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9jaGVja05ldHdvcmtNYXRjaGVkKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgeyBzaWduYXR1cmVJZCB9ID0geWllbGQgdGhpcy5ibG9jdG9BcGkoYC91c2VyLXNpZ25hdHVyZWAsIHsgbWV0aG9kOiAnUE9TVCcsIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgbWV0aG9kLCBtZXNzYWdlIH0pIH0pO1xuICAgICAgICAgICAgY29uc3Qgc2lnbkZyYW1lID0geWllbGQgdGhpcy5zZXRJZnJhbWUoYC91c2VyLXNpZ25hdHVyZS8ke3NpZ25hdHVyZUlkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VMaXN0ZW5lcihzaWduRnJhbWUsICdzaWduYXR1cmUnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVNlbmRUcmFuc2FjdGlvbihwYXlsb2FkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZFRyYW5zYWN0aW9uKChfYSA9IHBheWxvYWQucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgYXV0aG9yaXphdGlvbklkIH0gPSB5aWVsZCB0aGlzLmJsb2N0b0FwaShgL2F1dGh6YCwgeyBtZXRob2Q6ICdQT1NUJywgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZC5wYXJhbXMpIH0pO1xuICAgICAgICAgICAgY29uc3QgYXV0aHpGcmFtZSA9IHlpZWxkIHRoaXMuc2V0SWZyYW1lKGAvYXV0aHovJHthdXRob3JpemF0aW9uSWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZUxpc3RlbmVyKGF1dGh6RnJhbWUsICd0eEhhc2gnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVNlbmRCYXRjaFRyYW5zYWN0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhY3RQYXJhbXMgPSAocGFyYW1zKSA9PiBwYXJhbXMubWFwKChwYXJhbSkgPT4gJ3BhcmFtcycgaW4gcGFyYW1cbiAgICAgICAgICAgICAgICA/IHBhcmFtLnBhcmFtc1swXSAvLyBoYW5kbGUgcGFzc2luZyB3ZWIzLmV0aC5zZW5kVHJhbnNhY3Rpb24ucmVxdWVzdCguLi4pIGFzIGEgcGFyYW1ldGVyIHdpdGggcGFyYW1zXG4gICAgICAgICAgICAgICAgOiBwYXJhbSk7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXRQYXJhbXMgPSBleHRyYWN0UGFyYW1zKHBheWxvYWQucGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnN0IGNvcHlQYXlsb2FkID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXlsb2FkKSwgeyBwYXJhbXM6IGZvcm1hdFBhcmFtcyB9KTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZFRyYW5zYWN0aW9ucyhjb3B5UGF5bG9hZC5wYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbmRUcmFuc2FjdGlvbihjb3B5UGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVTZW5kVXNlck9wZXJhdGlvbihwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhvcml6YXRpb25JZCB9ID0geWllbGQgdGhpcy5ibG9jdG9BcGkoYC91c2VyLW9wZXJhdGlvbmAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkLnBhcmFtcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJPUEZyYW1lID0geWllbGQgdGhpcy5zZXRJZnJhbWUoYC91c2VyLW9wZXJhdGlvbi8ke2F1dGhvcml6YXRpb25JZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlTGlzdGVuZXIodXNlck9QRnJhbWUsICd1c2VyT3BIYXNoJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVCdW5kbGVyKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsb2N0b0FwaShgL3JwYy9idW5kbGVyYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oeyBpZDogMSwganNvbnJwYzogJzIuMCcgfSwgcGF5bG9hZCkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVEaXNjb25uZWN0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGVkU0RLID0gd2luZG93LmV0aGVyZXVtO1xuICAgICAgICAgICAgaWYgKGV4aXN0ZWRTREsgJiYgZXhpc3RlZFNESy5pc0Jsb2N0bykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGVkU0RLLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUgfSA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHJlbW92ZUNoYWluQWRkcmVzcyhzZXNzaW9uS2V5LCBibG9ja2NoYWluTmFtZSk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmV2ZW50TGlzdGVuZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuZGlzY29ubmVjdGVkKCkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxvYWRTd2l0Y2hhYmxlTmV0d29yayhuZXR3b3JrTGlzdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gc2V0dXAgc3dpdGNoYWJsZSBsaXN0IGlmIHVzZXIgc2V0IG5ldHdvcmtMaXN0XG4gICAgICAgICAgICBpZiAobmV0d29ya0xpc3QgPT09IG51bGwgfHwgbmV0d29ya0xpc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5ldHdvcmtMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RUb0FkZCA9IG5ldHdvcmtMaXN0Lm1hcCgoeyBjaGFpbklkLCBycGNVcmxzIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGFpbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoJ0VtcHR5IGNoYWluSWQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocnBjVXJscyA9PT0gbnVsbCB8fCBycGNVcmxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBycGNVcmxzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcygnRW1wdHkgcnBjVXJscycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9hZGRUb1N3aXRjaGFibGUpLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogYCR7cGFyc2VDaGFpbklkKGNoYWluSWQpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBycGNVcmxzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobGlzdFRvQWRkKS50aGVuKCgpID0+IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoJ0VtcHR5IG5ldHdvcmtMaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbl9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMgPSBmdW5jdGlvbiBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5fYmxvY3RvLnN1cHBvcnROZXR3b3JrTGlzdCkubGVuZ3RoKSB7XG4gICAgICAgICAgICB5aWVsZCBnZXRFdm1TdXBwb3J0KClcbiAgICAgICAgICAgICAgICAudGhlbigocmVzdWx0KSA9PiAodGhpcy5fYmxvY3RvLnN1cHBvcnROZXR3b3JrTGlzdCA9IHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogMTAwMSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEdldCBibG9jdG8gc2VydmVyIGZhaWxlZDogJHtlLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2hhaW5faWQsIG5hbWUsIG5ldHdvcmtfdHlwZSwgYmxvY3RvX3NlcnZpY2VfZW52aXJvbm1lbnQsIGRpc3BsYXlfbmFtZSwgfSA9IHRoaXMuX2Jsb2N0by5zdXBwb3J0TmV0d29ya0xpc3RbdGhpcy5uZXR3b3JrVmVyc2lvbl07XG4gICAgICAgIGlmICghY2hhaW5faWQpXG4gICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci51bnN1cHBvcnRlZE1ldGhvZChgR2V0IHN1cHBvcnQgY2hhaW4gZmFpbGVkOiAke3RoaXMubmV0d29ya1ZlcnNpb259IG1pZ2h0IG5vdCBiZSBzdXBwb3J0ZWQgeWV0LmApO1xuICAgICAgICB0aGlzLl9ibG9jdG8gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2Jsb2N0byksIHsgc2Vzc2lvbktleTogRVRIX1NFU1NJT05fS0VZX01BUFBJTkdbYmxvY3RvX3NlcnZpY2VfZW52aXJvbm1lbnRdLCB3YWxsZXRTZXJ2ZXI6IHRoaXMuaW5qZWN0ZWRXYWxsZXRTZXJ2ZXIgfHxcbiAgICAgICAgICAgICAgICBFVEhfRU5WX1dBTExFVF9TRVJWRVJfTUFQUElOR1tibG9jdG9fc2VydmljZV9lbnZpcm9ubWVudF0sIGJsb2NrY2hhaW5OYW1lOiBuYW1lLCBuZXR3b3JrVHlwZTogbmV0d29ya190eXBlLCBzd2l0Y2hhYmxlTmV0d29yazogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9ibG9jdG8uc3dpdGNoYWJsZU5ldHdvcmspLCB7IFtjaGFpbl9pZF06IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9uYW1lLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHdhbGxldF93ZWJfdXJsOiB0aGlzLl9ibG9jdG8ud2FsbGV0U2VydmVyLFxuICAgICAgICAgICAgICAgICAgICBycGNfdXJsOiB0aGlzLnJwYyxcbiAgICAgICAgICAgICAgICB9IH0pIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxvY3RvO1xuICAgIH0pO1xufSwgX0V0aGVyZXVtUHJvdmlkZXJfYWRkVG9Td2l0Y2hhYmxlID0gZnVuY3Rpb24gX0V0aGVyZXVtUHJvdmlkZXJfYWRkVG9Td2l0Y2hhYmxlKHsgY2hhaW5JZCwgcnBjVXJscywgfSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHsgc3VwcG9ydE5ldHdvcmtMaXN0IH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5faWQsIG5hbWUsIGRpc3BsYXlfbmFtZSwgbmV0d29ya190eXBlLCBibG9jdG9fc2VydmljZV9lbnZpcm9ubWVudCwgfSA9IHN1cHBvcnROZXR3b3JrTGlzdFtjaGFpbklkXTtcbiAgICAgICAgY29uc3Qgd2FsbGV0X3dlYl91cmwgPSBFVEhfRU5WX1dBTExFVF9TRVJWRVJfTUFQUElOR1tibG9jdG9fc2VydmljZV9lbnZpcm9ubWVudF07XG4gICAgICAgIHRoaXMuX2Jsb2N0by5zd2l0Y2hhYmxlTmV0d29ya1tjaGFpbl9pZF0gPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGlzcGxheV9uYW1lLFxuICAgICAgICAgICAgbmV0d29ya190eXBlLFxuICAgICAgICAgICAgd2FsbGV0X3dlYl91cmwsXG4gICAgICAgICAgICBycGNfdXJsOiBycGNVcmxzWzBdLFxuICAgICAgICB9O1xuICAgIH0pO1xufSwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCA9IGZ1bmN0aW9uIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQoKSB7XG4gICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5ldGhlcmV1bTtcbiAgICBpZiAoZXhpc3RlZFNESyAmJlxuICAgICAgICBleGlzdGVkU0RLLmlzQmxvY3RvICYmXG4gICAgICAgIHBhcnNlQ2hhaW5JZChleGlzdGVkU0RLLmNoYWluSWQpICE9PSBwYXJzZUNoYWluSWQodGhpcy5jaGFpbklkKSkge1xuICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci5jaGFpbkRpc2Nvbm5lY3RlZCgpO1xuICAgIH1cbn07XG5cbi8vIGJhc2UteCBlbmNvZGluZyAvIGRlY29kaW5nXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTggYmFzZS14IGNvbnRyaWJ1dG9yc1xuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTggVGhlIEJpdGNvaW4gQ29yZSBkZXZlbG9wZXJzIChiYXNlNTguY3BwKVxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBMSUNFTlNFIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuZnVuY3Rpb24gYmFzZSAoQUxQSEFCRVQpIHtcbiAgaWYgKEFMUEhBQkVULmxlbmd0aCA+PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxwaGFiZXQgdG9vIGxvbmcnKSB9XG4gIHZhciBCQVNFX01BUCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgQkFTRV9NQVAubGVuZ3RoOyBqKyspIHtcbiAgICBCQVNFX01BUFtqXSA9IDI1NTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHggPSBBTFBIQUJFVC5jaGFyQXQoaSk7XG4gICAgdmFyIHhjID0geC5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChCQVNFX01BUFt4Y10gIT09IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpIH1cbiAgICBCQVNFX01BUFt4Y10gPSBpO1xuICB9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoO1xuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApO1xuICB2YXIgRkFDVE9SID0gTWF0aC5sb2coQkFTRSkgLyBNYXRoLmxvZygyNTYpOyAvLyBsb2coQkFTRSkgLyBsb2coMjU2KSwgcm91bmRlZCB1cFxuICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKTsgLy8gbG9nKDI1NikgLyBsb2coQkFTRSksIHJvdW5kZWQgdXBcbiAgZnVuY3Rpb24gZW5jb2RlIChzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkgOyBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc291cmNlKSkge1xuICAgICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlLmJ1ZmZlciwgc291cmNlLmJ5dGVPZmZzZXQsIHNvdXJjZS5ieXRlTGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgc291cmNlID0gVWludDhBcnJheS5mcm9tKHNvdXJjZSk7XG4gICAgfVxuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnIH1cbiAgICAgICAgLy8gU2tpcCAmIGNvdW50IGxlYWRpbmcgemVyb2VzLlxuICAgIHZhciB6ZXJvZXMgPSAwO1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHZhciBwYmVnaW4gPSAwO1xuICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aDtcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICBwYmVnaW4rKztcbiAgICAgIHplcm9lcysrO1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTU4IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxKSA+Pj4gMDtcbiAgICB2YXIgYjU4ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGJ5dGVzLlxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQpIHtcbiAgICAgIHZhciBjYXJyeSA9IHNvdXJjZVtwYmVnaW5dO1xuICAgICAgICAgICAgLy8gQXBwbHkgXCJiNTggPSBiNTggKiAyNTYgKyBjaFwiLlxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yICh2YXIgaXQxID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQxICE9PSAtMSk7IGl0MS0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKDI1NiAqIGI1OFtpdDFdKSA+Pj4gMDtcbiAgICAgICAgYjU4W2l0MV0gPSAoY2FycnkgJSBCQVNFKSA+Pj4gMDtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSA+Pj4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaTtcbiAgICAgIHBiZWdpbisrO1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiYXNlNTggcmVzdWx0LlxuICAgIHZhciBpdDIgPSBzaXplIC0gbGVuZ3RoO1xuICAgIHdoaWxlIChpdDIgIT09IHNpemUgJiYgYjU4W2l0Ml0gPT09IDApIHtcbiAgICAgIGl0MisrO1xuICAgIH1cbiAgICAgICAgLy8gVHJhbnNsYXRlIHRoZSByZXN1bHQgaW50byBhIHN0cmluZy5cbiAgICB2YXIgc3RyID0gTEVBREVSLnJlcGVhdCh6ZXJvZXMpO1xuICAgIGZvciAoOyBpdDIgPCBzaXplOyArK2l0MikgeyBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdKTsgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUgKHNvdXJjZSkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBTdHJpbmcnKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KCkgfVxuICAgIHZhciBwc3ogPSAwO1xuICAgICAgICAvLyBTa2lwIGFuZCBjb3VudCBsZWFkaW5nICcxJ3MuXG4gICAgdmFyIHplcm9lcyA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdID09PSBMRUFERVIpIHtcbiAgICAgIHplcm9lcysrO1xuICAgICAgcHN6Kys7XG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlMjU2IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKCgoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IpICsgMSkgPj4+IDA7IC8vIGxvZyg1OCkgLyBsb2coMjU2KSwgcm91bmRlZCB1cC5cbiAgICB2YXIgYjI1NiA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSBjaGFyYWN0ZXJzLlxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSkge1xuICAgICAgICAgICAgLy8gRGVjb2RlIGNoYXJhY3RlclxuICAgICAgdmFyIGNhcnJ5ID0gQkFTRV9NQVBbc291cmNlLmNoYXJDb2RlQXQocHN6KV07XG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNoYXJhY3RlclxuICAgICAgaWYgKGNhcnJ5ID09PSAyNTUpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MyAhPT0gLTEpOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IChCQVNFICogYjI1NltpdDNdKSA+Pj4gMDtcbiAgICAgICAgYjI1NltpdDNdID0gKGNhcnJ5ICUgMjU2KSA+Pj4gMDtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyAyNTYpID4+PiAwO1xuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpO1xuICAgICAgcHN6Kys7XG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGIyNTYuXG4gICAgdmFyIGl0NCA9IHNpemUgLSBsZW5ndGg7XG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrO1xuICAgIH1cbiAgICB2YXIgdmNoID0gbmV3IFVpbnQ4QXJyYXkoemVyb2VzICsgKHNpemUgLSBpdDQpKTtcbiAgICB2YXIgaiA9IHplcm9lcztcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdO1xuICAgIH1cbiAgICByZXR1cm4gdmNoXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gZGVjb2RlVW5zYWZlKHN0cmluZyk7XG4gICAgaWYgKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1iYXNlJyArIEJBU0UgKyAnIGNoYXJhY3RlcicpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9XG59XG52YXIgc3JjID0gYmFzZTtcblxuY29uc3QgYmFzZXggPSBzcmM7XG5jb25zdCBBTFBIQUJFVCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6JztcblxudmFyIGJzNTggPSBiYXNleChBTFBIQUJFVCk7XG5cbnZhciBiczU4JDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYnM1OCk7XG5cbmxldCBTb2xhbmE7XG50cnkge1xuICAgIFNvbGFuYSA9IHJlcXVpcmUoJ0Bzb2xhbmEvd2ViMy5qcycpO1xufVxuY2F0Y2ggKF9hKSB7XG4gICAgLy8gcHJldmVudCBjcmFzaCBpZiB0aGVyZSBpcyBubyBAc29sYW5hL3dlYjMuanMuXG59XG5jbGFzcyBTb2xhbmFQcm92aWRlciBleHRlbmRzIEJsb2N0b1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG5ldCA9ICdtYWlubmV0LWJldGEnLCBzZXJ2ZXIsIGFwcElkLCBycGMsIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaW52YXJpYW50KG5ldCwgXCInbmV0JyBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgaW52YXJpYW50KE9iamVjdC52YWx1ZXMoU09MX05FVCkuaW5jbHVkZXMobmV0KSwgJ3Vuc3VwcG9ydGVkIG5ldCcpO1xuICAgICAgICB0aGlzLm5ldCA9IG5ldDtcbiAgICAgICAgdGhpcy5ycGMgPVxuICAgICAgICAgICAgcnBjIHx8XG4gICAgICAgICAgICAgICAgKG5ldCA9PT0gJ21haW5uZXQtYmV0YSdcbiAgICAgICAgICAgICAgICAgICAgPyAnaHR0cHM6Ly9mcmVlLnJwY3Bvb2wuY29tJ1xuICAgICAgICAgICAgICAgICAgICA6IGBodHRwczovL2FwaS4ke25ldH0uc29sYW5hLmNvbWApO1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlciB8fCBTT0xfTkVUX1NFUlZFUl9NQVBQSU5HW3RoaXMubmV0XSB8fCAnJztcbiAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkIHx8IERFRkFVTFRfQVBQX0lEO1xuICAgICAgICB0aGlzLnNlc3Npb25LZXkgPSBTT0xfU0VTU0lPTl9LRVlfTUFQUElOR1t0aGlzLm5ldF07XG4gICAgICAgIGlmICghU29sYW5hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEBzb2xhbmEvd2ViMy5qcyBpbnN0YWxsZWQuIFBsZWFzZSBpbnN0YWxsIGl0IHRvIGludGVyYWN0IHdpdGggU29sYW5hLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3QocGF5bG9hZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGVkU0RLID0gd2luZG93LnNvbGFuYTtcbiAgICAgICAgICAgIGlmIChleGlzdGVkU0RLICYmIGV4aXN0ZWRTREsuaXNCbG9jdG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RlZFNESy5yZXF1ZXN0KHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5TT0xBTkEpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwYXlsb2FkLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuZmV0Y2hBY2NvdW50cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ2V0QWNjb3VudHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKChfYSA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLlNPTEFOQSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5TT0xBTkEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB5aWVsZCB0aGlzLmZldGNoQWNjb3VudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXRBY2NvdW50SW5mbyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCB0aGUgZGF0YSBhcyB0aGUgc2FtZSBmb3JtYXQgcmV0dXJuaW5nIGZyb20gQ29ubmVjdGlvbi5nZXRBY2NvdW50SW5mbyBmcm9tIEBzb2xhbmEvd2ViMy5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVmOiBodHRwczovL3NvbGFuYS1sYWJzLmdpdGh1Yi5pby9zb2xhbmEtd2ViMy5qcy9jbGFzc2VzL0Nvbm5lY3Rpb24uaHRtbCNnZXRBY2NvdW50SW5mb1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudEluZm8gPSB5aWVsZCB0aGlzLmhhbmRsZVJlYWRSZXF1ZXN0cyhwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtidWZmZXJEYXRhLCBlbmNvZGluZ10gPSBhY2NvdW50SW5mby5yZXN1bHQudmFsdWUuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjb3VudEluZm8ucmVzdWx0LnZhbHVlKSwgeyBkYXRhOiBCdWZmZXIuZnJvbShidWZmZXJEYXRhLCBlbmNvZGluZyksIG93bmVyOiBuZXcgU29sYW5hLlB1YmxpY0tleShhY2NvdW50SW5mby5yZXN1bHQudmFsdWUub3duZXIpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY3VzdG9tIEpTT04tUlBDIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb252ZXJ0VG9Qcm9ncmFtV2FsbGV0VHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgdGhpcy5oYW5kbGVDb252ZXJ0VHJhbnNhY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VzdG9tIEpTT04tUlBDIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduQW5kU2VuZFRyYW5zYWN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuaGFuZGxlU2lnbkFuZFNlbmRUcmFuc2FjdGlvbihwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBibG9jayB1c2VyIGZyb20gdXNpbmcgdHJhZGl0aW9uYWwgbWV0aG9kc1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduVHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduQWxsVHJhbnNhY3Rpb25zJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmxvY3RvIGlzIHByb2dyYW0gd2FsbGV0LCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgJHtwYXlsb2FkLm1ldGhvZH0uIFVzZSBzaWduQW5kU2VuZFRyYW5zYWN0aW9uIGluc3RlYWQuYCk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkIHRoaXMuaGFuZGxlUmVhZFJlcXVlc3RzKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgIXJlc3BvbnNlLnJlc3VsdCAmJiByZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSByZXNwb25zZS5lcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLmVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ1JlcXVlc3QgZmFpbGVkJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5zb2xhbmE7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESyAmJiBleGlzdGVkU0RLLmlzQmxvY3RvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0ZWRTREsub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5TT0xBTkEsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGVkU0RLLnB1YmxpY0tleS50b0Jhc2U1OCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBleGlzdGVkU0RLLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoJ0N1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBpbiBicm93c2VyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5TT0xBTkEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gZW5jb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ2luRnJhbWUgPSBjcmVhdGVGcmFtZShgJHt0aGlzLnNlcnZlcn0vJHt0aGlzLmFwcElkfS9zb2xhbmEvYXV0aG4/bDZuPSR7bG9jYXRpb259JnY9JHtTREtfVkVSU0lPTn1gKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hGcmFtZShsb2dpbkZyYW1lKTtcbiAgICAgICAgICAgICAgICBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlTGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gPT09IHRoaXMuc2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnR5cGUgPT09ICdTT0w6RlJBTUU6UkVTUE9OU0UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhdGNoRnJhbWUobG9naW5GcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5jb25uZWN0LmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcih0aGlzLm5ldCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFjY291bnRTdG9yYWdlKHRoaXMuc2Vzc2lvbktleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBlLmRhdGEuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0NIQUlOLlNPTEFOQV06IFtlLmRhdGEuYWRkcl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZS5kYXRhLmV4cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnU09MOkZSQU1FOkNMT1NFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGxvZ2luRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1VzZXIgZGVjbGluZWQgdGhlIGxvZ2luIHJlcXVlc3QnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuc29sYW5hO1xuICAgICAgICAgICAgaWYgKGV4aXN0ZWRTREsgJiYgZXhpc3RlZFNESy5pc0Jsb2N0bykge1xuICAgICAgICAgICAgICAgIHlpZWxkIGV4aXN0ZWRTREsuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuZGlzY29ubmVjdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIobnVsbCkpO1xuICAgICAgICAgICAgcmVtb3ZlQ2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uU09MQU5BKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoQWNjb3VudHMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2EgPSBnZXRBY2NvdW50U3RvcmFnZSh0aGlzLnNlc3Npb25LZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSB5aWVsZCBmZXRjaChgJHt0aGlzLnNlcnZlcn0vYXBpL3NvbGFuYS9hY2NvdW50c2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgY2hlY2sgdGhlIGV4aXN0ZW5jZSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1BcHBsaWNhdGlvbi1JZGVudGlmaWVyJzogdGhpcy5hcHBJZCxcbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1TZXNzaW9uLUlkZW50aWZpZXInOiBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZVNlc3Npb25HdWFyZChyZXNwb25zZSwgdGhpcy5zZXNzaW9uS2V5KSk7XG4gICAgICAgICAgICBzZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5TT0xBTkEsIGFjY291bnRzKTtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVJlYWRSZXF1ZXN0cyhwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2godGhpcy5ycGMsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKHsgaWQ6IDEsIGpzb25ycGM6ICcyLjAnIH0sIHBheWxvYWQpKSxcbiAgICAgICAgICAgIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gc29sYW5hIHdlYjMgdXRpbGl0eVxuICAgIGNvbnZlcnRUb1Byb2dyYW1XYWxsZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5zb2xhbmE7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESyAmJiBleGlzdGVkU0RLLmlzQmxvY3RvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsuY29udmVydFRvUHJvZ3JhbVdhbGxldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2NvbnZlcnRUb1Byb2dyYW1XYWxsZXRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZU1lc3NhZ2UoKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9UcmFuc2FjdGlvbihtZXNzYWdlLCBbXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBzb2xhbmEgd2ViMyB1dGlsaXR5XG4gICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5zb2xhbmE7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESyAmJiBleGlzdGVkU0RLLmlzQmxvY3RvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleHRyYSA9IHt9O1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5jb21taXRtZW50KVxuICAgICAgICAgICAgICAgICAgICBleHRyYS5jb21taXRtZW50ID0gY29ubmVjdGlvbi5jb21taXRtZW50O1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjb25uZWN0aW9uIG9iamVjdCBwYXNzZWQtaW4gaGFzIGRpZmZlcmVudCBycGMgZW5kcG9pbnQsIHJlY29ubmVjdCB0byBpdFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHJwYyA9IGNvbm5lY3Rpb24gPyBjb25uZWN0aW9uLl9ycGNFbmRwb2ludCA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJwYyAmJiBycGMgIT09IHRoaXMucnBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnBjID0gcnBjO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnc2lnbkFuZFNlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHsgc2lnbmF0dXJlczogeWllbGQgdGhpcy5jb2xsZWN0U2lnbmF0dXJlcyh0cmFuc2FjdGlvbiksIG1lc3NhZ2U6IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZU1lc3NhZ2UoKS50b1N0cmluZygnaGV4JykgfSwgZXh0cmEpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBzb2xhbmEgd2ViMyB1dGlsaXR5XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICB0b1RyYW5zYWN0aW9uKHJhdywgc2lnbmF0dXJlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFNvbGFuYS5NZXNzYWdlLmZyb20oQnVmZmVyLmZyb20ocmF3LCAnaGV4JykpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgU29sYW5hLlRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBtZXNzYWdlLnJlY2VudEJsb2NraGFzaDtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBtZXNzYWdlLmFjY291bnRLZXlzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2lnbmF0dXJlcy5mb3JFYWNoKChzaWduYXR1cmUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnUHVia2V5UGFpciA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUgPT09IFNvbGFuYS5QdWJsaWNLZXkuZGVmYXVsdC50b0Jhc2U1OCgpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYnM1OCQxLmRlY29kZShzaWduYXR1cmUpLFxuICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IG1lc3NhZ2UuYWNjb3VudEtleXNbaW5kZXhdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uc2lnbmF0dXJlcy5wdXNoKHNpZ1B1YmtleVBhaXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtZXNzYWdlLmluc3RydWN0aW9ucy5mb3JFYWNoKChpbnN0cnVjdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBpbnN0cnVjdGlvbi5hY2NvdW50cy5tYXAoKGFjY291bnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHVia2V5ID0gbWVzc2FnZS5hY2NvdW50S2V5c1thY2NvdW50XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2lnbmVyOiBhY2NvdW50IDwgbWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNXcml0YWJsZTogbWVzc2FnZS5pc0FjY291bnRXcml0YWJsZShhY2NvdW50KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5pbnN0cnVjdGlvbnMucHVzaChuZXcgU29sYW5hLlRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtSWQ6IG1lc3NhZ2UuYWNjb3VudEtleXNbaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBiczU4JDEuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gc29sYW5hIHdlYjMgdXRpbGl0eVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgY29sbGVjdFNpZ25hdHVyZXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbi5zaWduYXR1cmVzLnJlZHVjZSgoYWNjLCBjdXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLnNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NbY3VyLnB1YmxpY0tleS50b0Jhc2U1OCgpXSA9IGN1ci5zaWduYXR1cmUudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlQ29udmVydFRyYW5zYWN0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gKChfYSA9IGdldEFjY291bnRTdG9yYWdlKHRoaXMuc2Vzc2lvbktleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBmZXRjaChgJHt0aGlzLnNlcnZlcn0vYXBpL3NvbGFuYS9jb252ZXJ0VG9XYWxsZXRUeGAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgY2hlY2sgdGhlIGV4aXN0ZW5jZSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1BcHBsaWNhdGlvbi1JZGVudGlmaWVyJzogdGhpcy5hcHBJZCxcbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1TZXNzaW9uLUlkZW50aWZpZXInOiBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkLnBhcmFtcyksXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIHRoaXMuc2Vzc2lvbktleSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlU2lnbkFuZFNlbmRUcmFuc2FjdGlvbihwYXlsb2FkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2EgPSBnZXRBY2NvdW50U3RvcmFnZSh0aGlzLnNlc3Npb25LZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhvcml6YXRpb25JZCB9ID0geWllbGQgZmV0Y2goYCR7dGhpcy5zZXJ2ZXJ9L2FwaS9zb2xhbmEvYXV0aHpgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGNoZWNrIHRoZSBleGlzdGVuY2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZC5wYXJhbXMpLFxuICAgICAgICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlU2Vzc2lvbkd1YXJkKHJlc3BvbnNlLCB0aGlzLnNlc3Npb25LZXkpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF1dGh6RnJhbWUgPSBjcmVhdGVGcmFtZShgJHt0aGlzLnNlcnZlcn0vJHt0aGlzLmFwcElkfS9zb2xhbmEvYXV0aHovJHthdXRob3JpemF0aW9uSWR9YCk7XG4gICAgICAgICAgICBhdHRhY2hGcmFtZShhdXRoekZyYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlRXZlbnRMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBldmVudDtcbiAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gPT09IHRoaXMuc2VydmVyICYmXG4gICAgICAgICAgICAgICAgICAgIGUuZGF0YS50eXBlID09PSAnU09MOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0FQUFJPVkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGF1dGh6RnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlLmRhdGEudHhIYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0RFQ0xJTkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGF1dGh6RnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5lcnJvckNvZGUgPT09ICdpbmNvcnJlY3Rfc2Vzc2lvbl9pZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZS5kYXRhLmVycm9yTWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IGNoZWNrTWVzc2FnZVBheWxvYWRGb3JtYXQgPSAocGF5bG9hZCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZm9ybWF0dGVkUGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oe30sIHBheWxvYWQpO1xuICAgIGNvbnN0IHsgbWVzc2FnZSwgbm9uY2UsIGFkZHJlc3MsIGFwcGxpY2F0aW9uLCBjaGFpbklkIH0gPSBwYXlsb2FkO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9ybWF0dGVkUGF5bG9hZC5tZXNzYWdlID0gKF9hID0gU3RyaW5nKG1lc3NhZ2UpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBub25jZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9ybWF0dGVkUGF5bG9hZC5ub25jZSA9IChfYiA9IFN0cmluZyhub25jZSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICAgIH1cbiAgICBpZiAoYWRkcmVzcyAmJiB0eXBlb2YgYWRkcmVzcyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGZvcm1hdHRlZFBheWxvYWQuYWRkcmVzcyA9ICEhYWRkcmVzcztcbiAgICB9XG4gICAgaWYgKGFwcGxpY2F0aW9uICYmIHR5cGVvZiBhcHBsaWNhdGlvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGZvcm1hdHRlZFBheWxvYWQuYXBwbGljYXRpb24gPSAhIWFwcGxpY2F0aW9uO1xuICAgIH1cbiAgICBpZiAoY2hhaW5JZCAmJiB0eXBlb2YgY2hhaW5JZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGZvcm1hdHRlZFBheWxvYWQuY2hhaW5JZCA9ICEhY2hhaW5JZDtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlZFBheWxvYWQ7XG59O1xuY2xhc3MgQXB0b3NQcm92aWRlciBleHRlbmRzIEJsb2N0b1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNoYWluSWQsIHNlcnZlciwgYXBwSWQgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnB1YmxpY0tleSA9IFtdO1xuICAgICAgICB0aGlzLmF1dGhLZXkgPSAnJztcbiAgICAgICAgaW52YXJpYW50KGNoYWluSWQsIFwiJ2NoYWluSWQnIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICBpbnZhcmlhbnQoYXBwSWQsICdJdCBpcyBuZWNlc3NhcnkgdG8gaW50ZXJhY3Qgd2l0aCBCbG9jdG8gd2FsbGV0IHZpYSB5b3VyIGFwcCBpZC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZGV2ZWxvcGVycy5ibG9jdG8uYXBwIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIHRoaXMubmV0d29ya05hbWUgPSBBUFRfQ0hBSU5fSURfTkFNRV9NQVBQSU5HW2NoYWluSWRdO1xuICAgICAgICB0aGlzLmFwaSA9IEFQVF9DSEFJTl9JRF9SUENfTUFQUElOR1tjaGFpbklkXTtcbiAgICAgICAgdGhpcy5zZXNzaW9uS2V5ID0gQVBUX1NFU1NJT05fS0VZX01BUFBJTkdbY2hhaW5JZF07XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTZXJ2ZXIgPSBBUFRfQ0hBSU5fSURfU0VSVkVSX01BUFBJTkdbY2hhaW5JZF07XG4gICAgICAgIHRoaXMuYXBwSWQgPSBhcHBJZCB8fCBERUZBVUxUX0FQUF9JRDtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXIgfHwgZGVmYXVsdFNlcnZlciB8fCAnJztcbiAgICB9XG4gICAgZ2V0IHB1YmxpY0FjY291bnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3M6ICgoX2EgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgfHwgbnVsbCxcbiAgICAgICAgICAgIHB1YmxpY0tleTogdGhpcy5wdWJsaWNLZXkubGVuZ3RoID8gdGhpcy5wdWJsaWNLZXkgOiBudWxsLFxuICAgICAgICAgICAgLy8gQHRvZG86IHByb3ZpZGUgYXV0aGtleVxuICAgICAgICAgICAgYXV0aEtleTogbnVsbCxcbiAgICAgICAgICAgIG1pbktleXNSZXF1aXJlZDogMixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uZXR3b3JrTmFtZSxcbiAgICAgICAgICAgICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW5JZC50b1N0cmluZygpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISEoKF9hID0gZ2V0QWNjb3VudFN0b3JhZ2UodGhpcy5zZXNzaW9uS2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuYmxvY3RvQXB0b3M7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGVkU0RLLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYXNDb25uZWN0ZWQgPSB5aWVsZCB0aGlzLmlzQ29ubmVjdGVkKCk7XG4gICAgICAgICAgICBpZiAoIWhhc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoKF9hID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbCB0byBnZXQgYWNjb3VudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduVHJhbnNhY3Rpb24gbWV0aG9kIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5ibG9jdG9BcHRvcztcbiAgICAgICAgICAgIGlmIChleGlzdGVkU0RLKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgZXhpc3RlZFNESy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlQ2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCB0eE9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5ibG9jdG9BcHRvcztcbiAgICAgICAgICAgIGlmIChleGlzdGVkU0RLKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsuc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCB0eE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFzQ29ubmVjdGVkID0geWllbGQgdGhpcy5pc0Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgaWYgKCFoYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKChfYSA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWwgdG8gZ2V0IGFjY291bnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2IgPSBnZXRBY2NvdW50U3RvcmFnZSh0aGlzLnNlc3Npb25LZXkpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29kZSkgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhvcml6YXRpb25JZCB9ID0geWllbGQgZmV0Y2goYCR7dGhpcy5zZXJ2ZXJ9L2FwaS9hcHRvcy9hdXRoemAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgY2hlY2sgdGhlIGV4aXN0ZW5jZSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1BcHBsaWNhdGlvbi1JZGVudGlmaWVyJzogdGhpcy5hcHBJZCxcbiAgICAgICAgICAgICAgICAgICAgJ0Jsb2N0by1TZXNzaW9uLUlkZW50aWZpZXInOiBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zYWN0aW9uKSwgdHhPcHRpb25zKSksXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIHRoaXMuc2Vzc2lvbktleSkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXV0aHpGcmFtZSA9IGNyZWF0ZUZyYW1lKGAke3RoaXMuc2VydmVyfS8ke3RoaXMuYXBwSWR9L2FwdG9zL2F1dGh6LyR7YXV0aG9yaXphdGlvbklkfWApO1xuICAgICAgICAgICAgYXR0YWNoRnJhbWUoYXV0aHpGcmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIoJ21lc3NhZ2UnLCAoZXZlbnQsIHJlbW92ZUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luID09PSB0aGlzLnNlcnZlciAmJlxuICAgICAgICAgICAgICAgICAgICBlLmRhdGEudHlwZSA9PT0gJ0FQVE9TOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0FQUFJPVkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGF1dGh6RnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGhhc2g6IGUuZGF0YS50eEhhc2ggfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdERUNMSU5FRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShhdXRoekZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuZXJyb3JDb2RlID09PSAnaW5jb3JyZWN0X3Nlc3Npb25faWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGUuZGF0YS5lcnJvck1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuYmxvY3RvQXB0b3M7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRQYXlsb2FkID0gY2hlY2tNZXNzYWdlUGF5bG9hZEZvcm1hdChwYXlsb2FkKTtcbiAgICAgICAgICAgIGlmIChleGlzdGVkU0RLKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsuc2lnbk1lc3NhZ2UoZm9ybWF0dGVkUGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYXNDb25uZWN0ZWQgPSB5aWVsZCB0aGlzLmlzQ29ubmVjdGVkKCk7XG4gICAgICAgICAgICBpZiAoIWhhc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoKF9hID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbCB0byBnZXQgYWNjb3VudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gKChfYiA9IGdldEFjY291bnRTdG9yYWdlKHRoaXMuc2Vzc2lvbktleSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb2RlKSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHsgc2lnbmF0dXJlSWQgfSA9IHlpZWxkIGZldGNoKGAke3RoaXMuc2VydmVyfS9hcGkvYXB0b3MvdXNlci1zaWduYXR1cmVgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGNoZWNrIHRoZSBleGlzdGVuY2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZm9ybWF0dGVkUGF5bG9hZCksXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIHRoaXMuc2Vzc2lvbktleSkpO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5zZXJ2ZXJ9LyR7dGhpcy5hcHBJZH0vYXB0b3MvdXNlci1zaWduYXR1cmUvJHtzaWduYXR1cmVJZH1gO1xuICAgICAgICAgICAgY29uc3Qgc2lnbkZyYW1lID0gY3JlYXRlRnJhbWUodXJsKTtcbiAgICAgICAgICAgIGF0dGFjaEZyYW1lKHNpZ25GcmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIoJ21lc3NhZ2UnLCAoZXZlbnQsIHJlbW92ZUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luID09PSB0aGlzLnNlcnZlciAmJlxuICAgICAgICAgICAgICAgICAgICBlLmRhdGEudHlwZSA9PT0gJ0FQVE9TOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnN0YXR1cyA9PT0gJ0FQUFJPVkVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKHNpZ25GcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdERUNMSU5FRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShzaWduRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5lcnJvckNvZGUgPT09ICdpbmNvcnJlY3Rfc2Vzc2lvbl9pZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZS5kYXRhLmVycm9yTWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuYmxvY3RvQXB0b3M7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBcbiAgICAgICAgICAgICAgICAvLyBhZGQgYSBzbWFsbCBkZWxheSB0byBtYWtlIHN1cmUgdGhlIG5ldHdvcmsgaGFzIGJlZW4gc3dpdGNoZWRcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGV4aXN0ZWRTREsuY29ubmVjdCgpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KSwgMTApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgnQ3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChfYSA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiAoKF9iID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF0pIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IHRoaXMucHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aEtleTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbktleXNSZXF1aXJlZDogMixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gZW5jb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ2luRnJhbWUgPSBjcmVhdGVGcmFtZShgJHt0aGlzLnNlcnZlcn0vJHt0aGlzLmFwcElkfS9hcHRvcy9hdXRobj9sNm49JHtsb2NhdGlvbn0mdj0ke1NES19WRVJTSU9OfX1gKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hGcmFtZShsb2dpbkZyYW1lKTtcbiAgICAgICAgICAgICAgICBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlcignbWVzc2FnZScsIChldmVudCwgcmVtb3ZlTGlzdGVuZXIpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luID09PSB0aGlzLnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnQVBUT1M6RlJBTUU6UkVTUE9OU0UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhdGNoRnJhbWUobG9naW5GcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QWNjb3VudFN0b3JhZ2UodGhpcy5zZXNzaW9uS2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGUuZGF0YS5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbQ0hBSU4uQVBUT1NdOiBbZS5kYXRhLmFkZHJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGUuZGF0YS5leHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2MgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcHVibGljX2tleXM6IHB1YmxpY0tleXMgfSA9IHlpZWxkIGZldGNoKGAke3RoaXMuc2VydmVyfS9ibG9jdG8vYXB0b3MvYWNjb3VudHMvJHsoX2QgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZFswXX1gKS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGljS2V5ID0gcHVibGljS2V5cyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6ICgoX2UgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiB0aGlzLnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoS2V5OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbktleXNSZXF1aXJlZDogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvOiBiZXR0ZXIgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEudHlwZSA9PT0gJ0FQVE9TOkZSQU1FOkNMT1NFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGxvZ2luRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1VzZXIgZGVjbGluZWQgdGhlIGxvZ2luIHJlcXVlc3QnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoQWRkcmVzcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gKChfYSA9IGdldEFjY291bnRTdG9yYWdlKHRoaXMuc2Vzc2lvbktleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHsgYWNjb3VudHMgfSA9IHlpZWxkIGZldGNoKGAke3RoaXMuc2VydmVyfS9hcGkvYXB0b3MvYWNjb3VudHNgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGNoZWNrIHRoZSBleGlzdGVuY2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIHRoaXMuc2Vzc2lvbktleSkpO1xuICAgICAgICAgICAgc2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MsIGFjY291bnRzKTtcbiAgICAgICAgICAgIHJldHVybiAoYWNjb3VudHMgPT09IG51bGwgfHwgYWNjb3VudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjY291bnRzWzBdKSB8fCAnJztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBCbG9jdG9TREsge1xuICAgIGNvbnN0cnVjdG9yKHsgYXBwSWQsIGV0aGVyZXVtLCBzb2xhbmEsIGFwdG9zIH0pIHtcbiAgICAgICAgaWYgKGV0aGVyZXVtKSB7XG4gICAgICAgICAgICB0aGlzLmV0aGVyZXVtID0gbmV3IEV0aGVyZXVtUHJvdmlkZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldGhlcmV1bSksIHsgYXBwSWQgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb2xhbmEpIHtcbiAgICAgICAgICAgIHRoaXMuc29sYW5hID0gbmV3IFNvbGFuYVByb3ZpZGVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc29sYW5hKSwgeyBhcHBJZCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFwdG9zKSB7XG4gICAgICAgICAgICB0aGlzLmFwdG9zID0gbmV3IEFwdG9zUHJvdmlkZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhcHRvcyksIHsgYXBwSWQgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBCbG9jdG9TREsgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJyZWNlaXZlciIsInN0YXRlIiwia2luZCIsImYiLCJUeXBlRXJyb3IiLCJoYXMiLCJjYWxsIiwiZ2V0IiwiU3VwcHJlc3NlZEVycm9yIiwiZXJyb3IiLCJzdXBwcmVzc2VkIiwibWVzc2FnZSIsIkVycm9yIiwibmFtZSIsImludmFyaWFudCIsImNvbmRpdGlvbiIsImZvcm1hdCIsIktFWV9TRVNTSU9OIiwiQ0hBSU4iLCJNZW1vcnlTdG9yYWdlIiwiZ2V0SXRlbSIsImtleSIsInNldEl0ZW0iLCJzdG9yYWdlIiwicmVtb3ZlSXRlbSIsImNvbnN0cnVjdG9yIiwibWVtb3J5U3RvcmFnZSIsIndpbmRvdyIsImlzU3VwcG9ydGVkIiwic2Vzc2lvblN0b3JhZ2UiLCJkZWZhdWx0VmFsdWUiLCJKU09OIiwicGFyc2UiLCJTeW50YXhFcnJvciIsInN0cmluZ2lmeSIsImdldEFjY291bnRTdG9yYWdlIiwicmF3QWNjb3VudFN0b3JhZ2UiLCJEYXRlIiwiZ2V0VGltZSIsImV4cGlyeSIsInYiLCJTREtfVkVSU0lPTiIsImRhdGEiLCJzZXRBY2NvdW50U3RvcmFnZSIsIl9hIiwiX2IiLCJfYyIsIm5ld0FjY291bnRTdG9yYWdlIiwiY29kZSIsImNvbm5lY3RlZCIsImFjY291bnRzIiwiT2JqZWN0IiwiYXNzaWduIiwiTE9HSU5fUEVSU0lTVElOR19USU1FIiwiZ2V0Q2hhaW5BZGRyZXNzIiwiY2hhaW4iLCJzZXRDaGFpbkFkZHJlc3MiLCJhY2NvdW50IiwicmVtb3ZlQ2hhaW5BZGRyZXNzIiwidW5kZWZpbmVkIiwiRVRIX1JQQ19MSVNUIiwiRVRIX0VOVl9XQUxMRVRfU0VSVkVSX01BUFBJTkciLCJwcm9kIiwic3RhZ2luZyIsImRldiIsIkVUSF9TRVNTSU9OX0tFWV9NQVBQSU5HIiwiU09MX05FVCIsIk1haW5uZXRCZXRhIiwiVGVzdG5ldCIsIkRldm5ldCIsIlNPTF9ORVRfU0VSVkVSX01BUFBJTkciLCJTT0xfU0VTU0lPTl9LRVlfTUFQUElORyIsIkFQVF9TRVNTSU9OX0tFWV9NQVBQSU5HIiwiQVBUX0NIQUlOX0lEX1NFUlZFUl9NQVBQSU5HIiwiV2FsbGV0QWRhcHRlck5ldHdvcmsiLCJBUFRfQ0hBSU5fSURfTkFNRV9NQVBQSU5HIiwiTWFpbm5ldCIsIlRlc3RpbmciLCJQcmVtYWlubmV0IiwiQVBUX0NIQUlOX0lEX1JQQ19NQVBQSU5HIiwiRUlQMTE5M19FVkVOVFMiLCJERUZBVUxUX0FQUF9JRCIsIkJsb2N0b1Byb3ZpZGVyIiwicmVxdWVzdCIsInBheWxvYWQiLCJvbiIsImV2ZW50IiwibGlzdGVuZXIiLCJpbmNsdWRlcyIsImV2ZW50TGlzdGVuZXJzIiwicHVzaCIsIm9uY2UiLCJyZW1vdmVMaXN0ZW5lciIsImxpc3RlbmVycyIsImluZGV4IiwiZmluZEluZGV4IiwiaXRlbSIsInNwbGljZSIsImlzQmxvY3RvIiwiaXNDb25uZWN0aW5nIiwib2ZmIiwiZm9yRWFjaCIsImFwcElkIiwiSUZSQU1FX1NUWUxFIiwiY3JlYXRlRnJhbWUiLCJ1cmwiLCJmcmFtZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImF0dGFjaEZyYW1lIiwiYm9keSIsImFwcGVuZENoaWxkIiwiZGV0YXRjaEZyYW1lIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiRnVuY3Rpb24iLCJhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlciIsImV2ZW50VHlwZSIsImhhbmRsZXIiLCJ0YXJnZXQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlc3BvbnNlU2Vzc2lvbkd1YXJkIiwicmVzcG9uc2UiLCJkaXNjb25uZWN0SGFuZGxlciIsInN0YXR1cyIsIm9rIiwianNvbiIsImVycm9yX2NvZGUiLCJpc0VtYWlsIiwidGVzdCIsImlzVmFsaWRUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIiwiaXNWYWxpZFRyYW5zYWN0aW9ucyIsInRyYW5zYWN0aW9ucyIsIkFycmF5IiwiaXNBcnJheSIsImV2ZXJ5IiwidHgiLCJnZXRFdm1TdXBwb3J0IiwibmV0d29ya3MiLCJmZXRjaCIsImV2bVN1cHBvcnRNYXAiLCJyZWR1Y2UiLCJhIiwiY2hhaW5faWQiLCJnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyIsIngiLCJfX2VzTW9kdWxlIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJkaXN0IiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl90b1ByaW1pdGl2ZSIsImlucHV0IiwiaGludCIsInByaW0iLCJ0b1ByaW1pdGl2ZSIsInJlcyIsIlN0cmluZyIsIk51bWJlciIsIl90b1Byb3BlcnR5S2V5IiwiYXJnIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfc2V0UHJvdG90eXBlT2YiLCJvIiwicCIsInNldFByb3RvdHlwZU9mIiwiYmluZCIsIl9fcHJvdG9fXyIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9nZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX2lzTmF0aXZlRnVuY3Rpb24iLCJmbiIsInRvU3RyaW5nIiwiaW5kZXhPZiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMSIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzaGFtIiwiUHJveHkiLCJCb29sZWFuIiwidmFsdWVPZiIsIl9jb25zdHJ1Y3QiLCJQYXJlbnQiLCJhcmdzIiwiQ2xhc3MiLCJhcmd1bWVudHMiLCJfd3JhcE5hdGl2ZVN1cGVyIiwiX2NhY2hlIiwiTWFwIiwic2V0IiwiV3JhcHBlciIsImNsYXNzZXMiLCJmYXN0U2FmZVN0cmluZ2lmeSIsInN0YWJsZSIsImRldGVybWluaXN0aWNTdHJpbmdpZnkiLCJzdGFibGVTdHJpbmdpZnkiLCJMSU1JVF9SRVBMQUNFX05PREUiLCJDSVJDVUxBUl9SRVBMQUNFX05PREUiLCJhcnIiLCJyZXBsYWNlclN0YWNrIiwiZGVmYXVsdE9wdGlvbnMiLCJkZXB0aExpbWl0IiwiTUFYX1NBRkVfSU5URUdFUiIsImVkZ2VzTGltaXQiLCJyZXBsYWNlciIsInNwYWNlciIsIm9wdGlvbnMiLCJkZWNpcmMiLCJyZXBsYWNlR2V0dGVyVmFsdWVzIiwiXyIsInBhcnQiLCJwb3AiLCJzZXRSZXBsYWNlIiwicmVwbGFjZSIsInZhbCIsImsiLCJwYXJlbnQiLCJwcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlZGdlSW5kZXgiLCJzdGFjayIsImRlcHRoIiwia2V5cyIsImNvbXBhcmVGdW5jdGlvbiIsImIiLCJ0bXAiLCJkZXRlcm1pbmlzdGljRGVjaXJjIiwidG9KU09OIiwic29ydCIsIl9jcmVhdGVTdXBlciIsIkRlcml2ZWQiLCJoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9jcmVhdGVTdXBlckludGVybmFsIiwiU3VwZXIiLCJOZXdUYXJnZXQiLCJFdGhlcmV1bVByb3ZpZGVyRXJyb3IiLCJFdGhlcmV1bVJwY0Vycm9yIiwiZmFzdF9zYWZlX3N0cmluZ2lmeV8xIiwiX0Vycm9yIiwiX3N1cGVyIiwiX3RoaXMiLCJpc0ludGVnZXIiLCJzZXJpYWxpemUiLCJzZXJpYWxpemVkIiwic3RyaW5naWZ5UmVwbGFjZXIiLCJfRXRoZXJldW1ScGNFcnJvciIsIl9zdXBlcjIiLCJpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlIiwidXRpbHMiLCJlcnJvckNvbnN0YW50cyIsImVycm9yVmFsdWVzIiwiZXJyb3JDb2RlcyIsInJwYyIsImludmFsaWRJbnB1dCIsInJlc291cmNlTm90Rm91bmQiLCJyZXNvdXJjZVVuYXZhaWxhYmxlIiwidHJhbnNhY3Rpb25SZWplY3RlZCIsIm1ldGhvZE5vdFN1cHBvcnRlZCIsImxpbWl0RXhjZWVkZWQiLCJpbnZhbGlkUmVxdWVzdCIsIm1ldGhvZE5vdEZvdW5kIiwiaW52YWxpZFBhcmFtcyIsImludGVybmFsIiwicHJvdmlkZXIiLCJ1c2VyUmVqZWN0ZWRSZXF1ZXN0IiwidW5hdXRob3JpemVkIiwidW5zdXBwb3J0ZWRNZXRob2QiLCJkaXNjb25uZWN0ZWQiLCJjaGFpbkRpc2Nvbm5lY3RlZCIsInN0YW5kYXJkIiwiZXhwb3J0cyIsInNlcmlhbGl6ZUVycm9yIiwiaXNWYWxpZENvZGUiLCJnZXRNZXNzYWdlRnJvbUNvZGUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSIsImVycm9yX2NvbnN0YW50c18xIiwiY2xhc3Nlc18xIiwiRkFMTEJBQ0tfRVJST1JfQ09ERSIsIkZBTExCQUNLX01FU1NBR0UiLCJGQUxMQkFDS19FUlJPUiIsImZhbGxiYWNrTWVzc2FnZSIsImNvZGVTdHJpbmciLCJoYXNLZXkiLCJpc0pzb25ScGNTZXJ2ZXJFcnJvciIsIl9yZWYiLCJfcmVmJGZhbGxiYWNrRXJyb3IiLCJmYWxsYmFja0Vycm9yIiwiX3JlZiRzaG91bGRJbmNsdWRlU3RhIiwic2hvdWxkSW5jbHVkZVN0YWNrIiwiX2Vycm9yIiwib3JpZ2luYWxFcnJvciIsImFzc2lnbk9yaWdpbmFsRXJyb3IiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfaSIsIl9zIiwiX2UiLCJfeCIsIl9yIiwiX2FyciIsIl9uIiwiX2QiLCJlcnIiLCJfYXJyYXlMaWtlVG9BcnJheSIsImxlbiIsImFycjIiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJtaW5MZW4iLCJuIiwic2xpY2UiLCJmcm9tIiwiX25vbkl0ZXJhYmxlUmVzdCIsIl9zbGljZWRUb0FycmF5IiwiZXJyb3JzIiwiZXRoRXJyb3JzIiwidXRpbHNfMSIsImdldEV0aEpzb25ScGNFcnJvciIsInNlcnZlciIsIm9wdHMiLCJnZXRFdGhQcm92aWRlckVycm9yIiwiY3VzdG9tIiwiX3BhcnNlT3B0cyIsInBhcnNlT3B0cyIsIl9wYXJzZU9wdHMyIiwiX3BhcnNlT3B0czMiLCJfcGFyc2VPcHRzNCIsImVycm9yc18xIiwiZ2xvYmFsJDEiLCJnbG9iYWwiLCJsb29rdXAiLCJyZXZMb29rdXAiLCJBcnIiLCJVaW50OEFycmF5IiwiaW5pdGVkIiwiaW5pdCIsImNoYXJDb2RlQXQiLCJ0b0J5dGVBcnJheSIsImI2NCIsImoiLCJsIiwicGxhY2VIb2xkZXJzIiwiTCIsInRyaXBsZXRUb0Jhc2U2NCIsIm51bSIsImVuY29kZUNodW5rIiwidWludDgiLCJzdGFydCIsImVuZCIsIm91dHB1dCIsImpvaW4iLCJmcm9tQnl0ZUFycmF5IiwiZXh0cmFCeXRlcyIsInBhcnRzIiwibWF4Q2h1bmtMZW5ndGgiLCJsZW4yIiwicmVhZCIsImJ1ZmZlciIsIm9mZnNldCIsImlzTEUiLCJtTGVuIiwibkJ5dGVzIiwibSIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsImQiLCJzIiwiTmFOIiwiSW5maW5pdHkiLCJNYXRoIiwicG93Iiwid3JpdGUiLCJjIiwicnQiLCJhYnMiLCJpc05hTiIsImZsb29yIiwibG9nIiwiTE4yIiwiSU5TUEVDVF9NQVhfQllURVMiLCJCdWZmZXIiLCJUWVBFRF9BUlJBWV9TVVBQT1JUIiwia01heExlbmd0aCIsImNyZWF0ZUJ1ZmZlciIsInRoYXQiLCJSYW5nZUVycm9yIiwiZW5jb2RpbmdPck9mZnNldCIsImFsbG9jVW5zYWZlIiwicG9vbFNpemUiLCJfYXVnbWVudCIsIkFycmF5QnVmZmVyIiwiZnJvbUFycmF5QnVmZmVyIiwiZnJvbVN0cmluZyIsImZyb21PYmplY3QiLCJzcGVjaWVzIiwiYXNzZXJ0U2l6ZSIsInNpemUiLCJhbGxvYyIsImZpbGwiLCJlbmNvZGluZyIsImNoZWNrZWQiLCJhbGxvY1Vuc2FmZVNsb3ciLCJzdHJpbmciLCJpc0VuY29kaW5nIiwiYnl0ZUxlbmd0aCIsImFjdHVhbCIsImZyb21BcnJheUxpa2UiLCJhcnJheSIsImJ5dGVPZmZzZXQiLCJpbnRlcm5hbElzQnVmZmVyIiwiY29weSIsImlzbmFuIiwidHlwZSIsImlzQnVmZmVyIiwiX2lzQnVmZmVyIiwiY29tcGFyZSIsInkiLCJtaW4iLCJ0b0xvd2VyQ2FzZSIsImNvbmNhdCIsImxpc3QiLCJwb3MiLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiZXF1YWxzIiwiaW5zcGVjdCIsInN0ciIsIm1heCIsIm1hdGNoIiwidGhpc1N0YXJ0IiwidGhpc0VuZCIsInRoaXNDb3B5IiwidGFyZ2V0Q29weSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwiZGlyIiwiYXJyYXlJbmRleE9mIiwibGFzdEluZGV4T2YiLCJpbmRleFNpemUiLCJhcnJMZW5ndGgiLCJ2YWxMZW5ndGgiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJoZXhXcml0ZSIsInJlbWFpbmluZyIsInN0ckxlbiIsInBhcnNlZCIsInBhcnNlSW50Iiwic3Vic3RyIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJpc0Zpbml0ZSIsImZpcnN0Qnl0ZSIsImNvZGVQb2ludCIsImJ5dGVzUGVyU2VxdWVuY2UiLCJzZWNvbmRCeXRlIiwidGhpcmRCeXRlIiwiZm91cnRoQnl0ZSIsInRlbXBDb2RlUG9pbnQiLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJNQVhfQVJHVU1FTlRTX0xFTkdUSCIsImNvZGVQb2ludHMiLCJmcm9tQ2hhckNvZGUiLCJyZXQiLCJvdXQiLCJ0b0hleCIsImJ5dGVzIiwibmV3QnVmIiwic3ViYXJyYXkiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4Iiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIm9iamVjdFdyaXRlVUludDMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnQzMkJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsIklOVkFMSURfQkFTRTY0X1JFIiwiYmFzZTY0Y2xlYW4iLCJzdHJpbmd0cmltIiwidHJpbSIsInVuaXRzIiwibGVhZFN1cnJvZ2F0ZSIsImJ5dGVBcnJheSIsImhpIiwibG8iLCJzcmMiLCJkc3QiLCJpc0Zhc3RCdWZmZXIiLCJpc1Nsb3dCdWZmZXIiLCJpc0hleFN0cmluZyIsImhleCIsInV0ZjhUb0hleCIsIl9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcyIsIl9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMiLCJfRXRoZXJldW1Qcm92aWRlcl9hZGRUb1N3aXRjaGFibGUiLCJfRXRoZXJldW1Qcm92aWRlcl9jaGVja05ldHdvcmtNYXRjaGVkIiwicGFyc2VDaGFpbklkIiwiY2hhaW5JZCIsInN0YXJ0c1dpdGgiLCJFdGhlcmV1bVByb3ZpZGVyIiwic2VuZCIsIm1ldGhvZE9yUGF5bG9hZCIsInBhcmFtc09yQ2FsbGJhY2siLCJzZW5kQXN5bmMiLCJqc29ucnBjIiwibWV0aG9kIiwicGFyYW1zIiwiY2FsbGJhY2siLCJoYW5kbGVSZXF1ZXN0IiwiZmlsdGVyIiwibWFwIiwiaWRCYXNlIiwicmFuZG9tIiwiYmF0Y2hlZFJlcXVlc3RQYXlsb2FkIiwiYmF0Y2hSZXNwb25zZVByb21pc2UiLCJyZXF1ZXN0cyIsImlkIiwiYWxsU2V0dGxlZCIsInJlc3BvbnNlcyIsInJlYXNvbiIsImNhdGNoIiwic2VuZFVzZXJPcGVyYXRpb24iLCJ1c2VyT3AiLCJfZiIsIl9nIiwiX2giLCJfaiIsIl9rIiwiZXhpc3RlZFNESyIsImV0aGVyZXVtIiwibmV0d29ya1ZlcnNpb24iLCJzd2l0Y2hhYmxlTmV0d29yayIsInJwY191cmwiLCJibG9ja2NoYWluTmFtZSIsInNlc3Npb25LZXkiLCJsb2FkU3dpdGNoYWJsZU5ldHdvcmsiLCJoYW5kbGVSZWFkUmVxdWVzdHMiLCJlcnJvck1lc3NhZ2UiLCJuZXdDaGFpbklkIiwicGhhc2VkQ2hhaW5JZCIsImNoYWluQ2hhbmdlZCIsImVtYWlsIiwiZW5hYmxlIiwiZmV0Y2hBY2NvdW50cyIsImhhbmRsZVNpZ24iLCJoYW5kbGVEaXNjb25uZWN0IiwiaGFuZGxlU2VuZFRyYW5zYWN0aW9uIiwiaGFuZGxlU2VuZEJhdGNoVHJhbnNhY3Rpb24iLCJoYW5kbGVTZW5kVXNlck9wZXJhdGlvbiIsIm9sZEFjY291bnQiLCJvbGRDaGFpbklkIiwibmV3QWNjb3VudCIsImFjY291bnRzQ2hhbmdlZCIsImhhbmRsZUJ1bmRsZXIiLCJibG9jdG9BcGkiLCJ3YWxsZXRTZXJ2ZXIiLCJzZXNzaW9uSWQiLCJoZWFkZXJzIiwiZGlzY29ubmVjdCIsInJlc3BvbnNlTGlzdGVuZXIiLCJvYmplY3RLZXkiLCJvcmlnaW4iLCJlcnJvckNvZGUiLCJzZXRJZnJhbWUiLCJhZGRyZXNzIiwic2V0VGltZW91dCIsIlVSTFNlYXJjaFBhcmFtcyIsImxvY2F0aW9uIiwiZW1haWxQYXJhbSIsImxvZ2luRnJhbWUiLCJjb25uZWN0IiwiYWRkciIsImV4cCIsImRvbWFpbiIsInNpZ25hdHVyZUlkIiwic2lnbkZyYW1lIiwiYXV0aG9yaXphdGlvbklkIiwiYXV0aHpGcmFtZSIsImV4dHJhY3RQYXJhbXMiLCJwYXJhbSIsImZvcm1hdFBhcmFtcyIsImNvcHlQYXlsb2FkIiwidXNlck9QRnJhbWUiLCJuZXR3b3JrTGlzdCIsImxpc3RUb0FkZCIsInJwY1VybHMiLCJhbGwiLCJhZGQiLCJpbmplY3RlZFdhbGxldFNlcnZlciIsIl9ibG9jdG8iLCJuZXR3b3JrVHlwZSIsInN1cHBvcnROZXR3b3JrTGlzdCIsIldlYWtTZXQiLCJuZXR3b3JrX3R5cGUiLCJibG9jdG9fc2VydmljZV9lbnZpcm9ubWVudCIsImRpc3BsYXlfbmFtZSIsIndhbGxldF93ZWJfdXJsIiwiYmFzZSIsIkFMUEhBQkVUIiwiQkFTRV9NQVAiLCJjaGFyQXQiLCJ4YyIsIkJBU0UiLCJMRUFERVIiLCJGQUNUT1IiLCJpRkFDVE9SIiwiZW5jb2RlIiwic291cmNlIiwiemVyb2VzIiwicGJlZ2luIiwicGVuZCIsImI1OCIsImNhcnJ5IiwiaXQxIiwiaXQyIiwicmVwZWF0IiwiZGVjb2RlVW5zYWZlIiwicHN6IiwiYjI1NiIsIml0MyIsIml0NCIsInZjaCIsImRlY29kZSIsImJhc2V4IiwiYnM1OCIsImJzNTgkMSIsIlNvbGFuYSIsInJlcXVpcmUiLCJTb2xhbmFQcm92aWRlciIsInNvbGFuYSIsIlNPTEFOQSIsImFjY291bnRJbmZvIiwiYnVmZmVyRGF0YSIsIm93bmVyIiwiUHVibGljS2V5IiwiaGFuZGxlQ29udmVydFRyYW5zYWN0aW9uIiwiaGFuZGxlU2lnbkFuZFNlbmRUcmFuc2FjdGlvbiIsImNvbnNvbGUiLCJwdWJsaWNLZXkiLCJ0b0Jhc2U1OCIsImVuY29kZVVSSUNvbXBvbmVudCIsIm5ldCIsImNvbnZlcnRUb1Byb2dyYW1XYWxsZXRUcmFuc2FjdGlvbiIsInNlcmlhbGl6ZU1lc3NhZ2UiLCJ0b1RyYW5zYWN0aW9uIiwic2lnbkFuZFNlbmRUcmFuc2FjdGlvbiIsImNvbm5lY3Rpb24iLCJleHRyYSIsImNvbW1pdG1lbnQiLCJfcnBjRW5kcG9pbnQiLCJzaWduYXR1cmVzIiwiY29sbGVjdFNpZ25hdHVyZXMiLCJyYXciLCJNZXNzYWdlIiwiVHJhbnNhY3Rpb24iLCJyZWNlbnRCbG9ja2hhc2giLCJoZWFkZXIiLCJudW1SZXF1aXJlZFNpZ25hdHVyZXMiLCJmZWVQYXllciIsImFjY291bnRLZXlzIiwic2lnbmF0dXJlIiwic2lnUHVia2V5UGFpciIsImRlZmF1bHQiLCJpbnN0cnVjdGlvbnMiLCJpbnN0cnVjdGlvbiIsInB1YmtleSIsImlzU2lnbmVyIiwiaXNXcml0YWJsZSIsImlzQWNjb3VudFdyaXRhYmxlIiwiVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiIsInByb2dyYW1JZCIsInByb2dyYW1JZEluZGV4IiwiYWNjIiwiY3VyIiwidHhIYXNoIiwidmFsdWVzIiwiY2hlY2tNZXNzYWdlUGF5bG9hZEZvcm1hdCIsImZvcm1hdHRlZFBheWxvYWQiLCJub25jZSIsImFwcGxpY2F0aW9uIiwiQXB0b3NQcm92aWRlciIsInB1YmxpY0FjY291bnQiLCJBUFRPUyIsImF1dGhLZXkiLCJtaW5LZXlzUmVxdWlyZWQiLCJuZXR3b3JrIiwibmV0d29ya05hbWUiLCJhcGkiLCJpc0Nvbm5lY3RlZCIsInNpZ25UcmFuc2FjdGlvbiIsImJsb2N0b0FwdG9zIiwiaGFzQ29ubmVjdGVkIiwic2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uIiwidHhPcHRpb25zIiwiaGFzaCIsInNpZ25NZXNzYWdlIiwicHVibGljX2tleXMiLCJwdWJsaWNLZXlzIiwiZmV0Y2hBZGRyZXNzIiwiZGVmYXVsdFNlcnZlciIsIkJsb2N0b1NESyIsImFwdG9zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@blocto+sdk@0.5.5/node_modules/@blocto/sdk/dist/blocto-sdk.module.js\n"));

/***/ })

}]);